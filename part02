Newsgroups: comp.sources.misc
From: allbery@uunet.UU.NET (Brandon S. Allbery - comp.sources.misc)
Subject: v08i036: GnuPlot v1.10A (part 2 of 7)
Reply-To: canoaf@ntvax.UUCP (Augustine Cano)

Posting-number: Volume 8, Issue 36
Submitted-by: canoaf@ntvax.UUCP (Augustine Cano)
Archive-name: gnuplot1.10A/part02

[OOPS!!!  I had to patch these after receiving them -- and managed to lose the
name of the person who submitted them in the process.  Duh.  The name shown
is a "best guess".  Submitter, please correct me.  ++bsa]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  gnuplot.1 graphics.c header.mac help hp26.trm hp75.trm
#   hpljet.trm hrcgraph.asm internal.c iris4d.trm lineproc.mac
#   link.com link.opt link.otc
# Wrapped by allbery@uunet on Sat Sep  9 13:47:19 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'gnuplot.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot.1'\"
else
echo shar: Extracting \"'gnuplot.1'\" \(1896 characters\)
sed "s/^X//" >'gnuplot.1' <<'END_OF_FILE'
X.\" dummy line
X.TH GNUPLOT 1 "28 January 1987"
X.UC 4
X.SH NAME
Xgnuplot \- an interactive plotting program
X.SH SYNOPSIS
X.B gnuplot
X.br
X.SH DESCRIPTION
X.I Gnuplot 
Xis a command-driven interactive function plotting program.
XHere are some of its features:
X.PP
XPlots any number of functions, built up of C operators, C library
Xfunctions, and some things C doesn't have like **, sgn(), etc.  Also
Xsupport for plotting data files, to compare actual
Xdata to theoretical curves.
X.PP
XUser-defined X and Y ranges (optional Y auto-ranging), smart Y scaling,
Xsmart tic marks.
X.PP
XUser-defined constants and functions.
X.PP
XSupport through a generalized graphics driver for
XAED 767,
XBBN BitGraph,
XHP2623,
XHP75xx,
XPOSTSCRIPT,
XQMS QUIC
XReGis (VT125 and VT2xx),
XSelanar,
XTek 401x,
XVectrix 384,
Xand unixplot.  The PC version
Xsupports IBM CGA & EGA, Hercules, ATT 6300,
Xand Corona 325 graphics.  Other devices can be added
Xsimply, but will require recompiling.
X.PP
XShell escapes and command line substitution.
X.PP
XLoad and save capability.
X.PP
XOutput redirection.
X.PP
XAll computations performed in the complex domain.  Just the real part is
Xplotted by default, but functions like imag() and abs() and arg() are
Xavailable to override this.
X.SH AUTHORS
XThomas Williams and Colin Kelley, Villanova University.
X.br
X(vu-vlsi!plot.UUCP)
X.SH BUGS
XThe unixplot library does not provide for sending unixplot output to
Xa file.  As a result, unixplot output cannot be sent to a file with the
X.I Gnuplot
X\&'set output' command; instead, standard output must be redirected
Xto this file from the Unix command line.  For example:
X.IP
X\ \ \ \ \ \ \ 
X.I % gnuplot > unixplot.out
X.br
X\ \ \ \ \ \ \ \ gnuplot>
X.I set term unxiplot
X.br
X\ \ \ \ \ \ \ \ gnuplot>
X.I plot sin(x)
X.PP
XThe atan() function does not work correctly for complex arguments.
X.SH SEE ALSO
XSee the printed manual or the on-line help for details on specific commands.
END_OF_FILE
if test 1896 -ne `wc -c <'gnuplot.1'`; then
    echo shar: \"'gnuplot.1'\" unpacked with wrong size!
fi
# end of 'gnuplot.1'
fi
if test -f 'graphics.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'graphics.c'\"
else
echo shar: Extracting \"'graphics.c'\" \(9002 characters\)
sed "s/^X//" >'graphics.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  graphics.c
X *
X *  Copyright (C) 1986, 1987  Thomas Williams, Colin Kelley
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "plot.h"
X
Xchar *strcpy(),*strncpy(),*strcat();
X
Xextern BOOLEAN polar;
Xextern BOOLEAN autoscale;
Xextern FILE *outfile;
Xextern BOOLEAN log_x, log_y;
Xextern int term;
X
Xextern BOOLEAN screen_ok;
Xextern BOOLEAN term_init;
X
Xextern double loff,roff,toff,boff;
Xextern double zero;
X
Xextern struct termentry term_tbl[];
X
X
X#ifndef max		/* Lattice C has max() in math.h, but shouldn't! */
X#define max(a,b) ((a > b) ? a : b)
X#endif
X
X/* maps floating point x (and y) to screen */ 
X#define map_x(x) (int)((x-xmin)*xscale) 
X#define map_y(y) (int)((y-ymin)*yscale)
X
X
Xdouble raise(x,y)
Xdouble x;
Xint y;
X{
Xregister int i;
Xdouble val;
X
X	val = 1.0;
X	for (i=0; i < abs(y); i++)
X		val *= x;
X	if (y < 0 ) return (1.0/val);
X	return(val);
X}
X
X
Xdouble make_tics(tmin,tmax,logscale)
Xdouble tmin,tmax;
XBOOLEAN logscale;
X{
Xregister double xr,xnorm,tics,tic,l10;
X
X	xr = fabs(tmin-tmax);
X	
X	l10 = log10(xr);
X	if (logscale) {
X		tic = raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X		if (tic < 1.0)
X			tic = 1.0;
X	} else {
X		xnorm = pow(10.0,l10-(double)((l10 >= 0.0 ) ? (int)l10 : ((int)l10-1)));
X		if (xnorm <= 2)
X			tics = 0.2;
X		else if (xnorm <= 5)
X			tics = 0.5;
X		else tics = 1.0;	
X		tic = tics * raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X	}
X	return(tic);
X}
X
Xchar *idx(a,b)
Xchar *a,b;
X{
X	do {
X		if (*a == b)
X			return(a);
X	} while (*a++);
X	return(0);
X}
X
X 
Xnum2str(num,str)
Xdouble num;
Xchar str[];
X{
Xstatic char temp[80];
Xregister double d;
Xregister char *a,*b;
X
X 	if ((d = fabs(num)) > 9999.0 || d < 0.001 && d != 0.0) 
X		(void) sprintf(temp,"%-.3e",num);	
X	else
X		(void) sprintf(temp,"%-.3g",num);
X	if (b = idx(temp,'e')) {
X		a = b;
X		while ( *(--a) == '0') /* trailing zeros */
X			;	
X		if ( *a == '.') 
X			a--;
X		(void) strncpy(str,temp,(int)(a-temp)+1);
X		str[(int)(a-temp)+1] = '\0';
X		a = b+1;	/* point to 1 after 'e' */
X		(void) strcat(str,"e");
X		if ( *a == '-') 
X			(void) strcat(str,"-");
X		a++;						 /* advance a past '+' or '-' */
X		while ( *a == '0' && *(a+1) != '\0') /* leading zeroes */
X			a++;
X		(void) strcat(str,a); /* copy rest of string */
X	}
X	else
X		(void) strcpy(str,temp);	
X}
X
X
Xdo_plot(plots, pcount, xmin, xmax, ymin, ymax)
Xstruct curve_points *plots;
Xint pcount;			/* count of plots in linked list */
Xdouble xmin, xmax;
Xdouble ymin, ymax;
X{
Xregister int i, x;
Xregister struct termentry *t = &term_tbl[term];
Xregister BOOLEAN prev_undef;
Xregister int curve, xaxis_y, yaxis_x, dpcount;
Xregister struct curve_points *this_plot;
Xregister enum PLOT_TYPE p_type;
Xregister double xscale, yscale;
Xregister double ytic, xtic, least, most, ticplace;
Xregister int mms,mts;
X			/* only a Pyramid would have this many registers! */
Xstatic char xns[20],xms[20],yns[20],yms[20],xts[20],yts[20];
Xstatic char label[80];
X
X	if (polar)
X		polar_xform (plots, pcount, &xmin, &xmax, &ymin, &ymax);
X
X	if (ymin == HUGE || ymax == -HUGE)
X		int_error("all points undefined!", NO_CARET);
X
X/*	This used be xmax == xmin, but that caused an infinite loop once. */
X	if (fabs(xmax - xmin) < zero)
X		int_error("xmin should not equal xmax!",NO_CARET);
X	if (fabs(ymax - ymin) < zero)
X		int_error("ymin should not equal ymax!",NO_CARET);
X
X/*	Apply the desired viewport offsets. */
X	xmin -= loff;
X	xmax += roff;
X	ymin -= boff;
X	ymax += toff;
X	
X	ytic = make_tics(ymin,ymax,log_y);
X	xtic = make_tics(xmin,xmax,log_x);
X	dpcount = 0;
X	
X	if (ymin < ymax ) {
X		ymin = ytic * floor(ymin/ytic);	
X		ymax = ytic * ceil(ymax/ytic);
X	}
X	else {
X		ymin = ytic * ceil(ymin/ytic);
X		ymax = ytic * floor(ymax/ytic);
X	}
X
X	yscale = (t->ymax - 2)/(ymax - ymin);
X	xscale = (t->xmax - 2)/(xmax - xmin);
X	
X	if (!term_init) {
X		(*t->init)();
X		term_init = TRUE;
X	}
X	screen_ok = FALSE;
X	(*t->graphics)();
X	(*t->linetype)(-2); /* border linetype */
X
X	/* draw plot border */
X	(*t->move)(0,0);	
X	(*t->vector)(t->xmax-1,0);	
X	(*t->vector)(t->xmax-1,t->ymax-1);	
X	(*t->vector)(0,t->ymax-1);	
X	(*t->vector)(0,0);
X
X	least = (ymin < ymax) ? ymin : ymax;
X	most = (ymin < ymax) ? ymax : ymin;
X
X	for (ticplace = ytic + least; ticplace < most ; ticplace += ytic) { 
X		(*t->move)(0,map_y(ticplace));
X		(*t->vector)(t->h_tic,map_y(ticplace));
X		(*t->move)(t->xmax-1,map_y(ticplace));
X       	        (*t->vector)(t->xmax-1-t->h_tic,map_y(ticplace));
X	}
X
X	if (xmin < xmax ) {
X		least = xtic * floor(xmin/xtic);	
X		most = xtic * ceil(xmax/xtic);
X	}
X	else {
X		least = xtic * ceil(xmin/xtic);
X		most = xtic * floor(xmax/xtic);
X	}
X
X	for (ticplace = xtic + least; ticplace < most ; ticplace += xtic) { 
X		(*t->move)(map_x(ticplace),0);
X		(*t->vector)(map_x(ticplace),t->v_tic);
X		(*t->move)(map_x(ticplace),t->ymax-1);
X       	        (*t->vector)(map_x(ticplace),t->ymax-1-t->v_tic);
X	}
X
X	if (log_x) {
X		num2str(pow(10.0,xmin),xns);
X		num2str(pow(10.0,xmax),xms);
X		num2str(pow(10.0,xtic),xts);
X	}
X	else {
X		num2str(xmin,xns);
X		num2str(xmax,xms);
X		num2str(xtic,xts);
X	}
X	if (log_y) {
X		num2str(pow(10.0,ymin),yns);
X		num2str(pow(10.0,ymax),yms);
X		num2str(pow(10.0,ytic),yts);
X	} else {
X		num2str(ymin,yns);
X		num2str(ymax,yms);
X		num2str(ytic,yts);
X	}
X	mms = max(strlen(xms),strlen(yms));
X	mts = max(strlen(xts),strlen(yts));
X
X	(void) sprintf(label,"%s < y < %-*s  inc = %-*s",yns,mms,yms,mts,yts);
X	(*t->lrput_text)(0, label);
X	(void) sprintf(label,"%s < x < %-*s  inc = %-*s",xns,mms,xms,mts,xts);
X	(*t->lrput_text)(1, label);
X
X
X/* DRAW AXES */
X	(*t->linetype)(-1);	/* axis line type */
X	xaxis_y = map_y(0.0);
X	yaxis_x = map_x(0.0); 
X
X	if (xaxis_y < 0)
X		xaxis_y = 0;				/* save for impulse plotting */
X	else if (xaxis_y >= t->ymax)
X		xaxis_y = t->ymax - 1;
X	else if (!log_y) {
X		(*t->move)(0,xaxis_y);
X		(*t->vector)((t->xmax-1),xaxis_y);
X	}
X
X	if (!log_x && yaxis_x >= 0 && yaxis_x < t->xmax) {
X		(*t->move)(yaxis_x,0);
X		(*t->vector)(yaxis_x,(t->ymax-1));
X	}
X
X/* DRAW CURVES */
X	this_plot = plots;
X	for (curve = 0; curve < pcount; this_plot = this_plot->next_cp, curve++) {
X		(*t->linetype)(curve);
X		(*t->ulput_text)(curve, this_plot->title);
X		(*t->linetype)(curve);
X
X		p_type = this_plot->plot_type;
X		switch(this_plot->plot_style) {
X			case IMPULSES:
X				for (i = 0; i < this_plot->p_count; i++) {
X					if (!this_plot->points[i].undefined) {
X						x = map_x(this_plot->points[i].x);
X						(*t->move)(x,xaxis_y);
X						(*t->vector)(x,map_y(this_plot->points[i].y));
X					}
X				}
X				break;
X			case LINES:
X				prev_undef = TRUE;
X				for (i = 0; i < this_plot->p_count; i++) {
X					if (!this_plot->points[i].undefined) {
X						x = map_x(this_plot->points[i].x);
X						if (prev_undef)
X							(*t->move)(x,
X							map_y(this_plot->points[i].y));
X						(*t->vector)(x,
X							map_y(this_plot->points[i].y));
X					}
X					prev_undef = this_plot->points[i].undefined;
X				}
X				break;
X			case POINTS:
X				for (i = 0; i < this_plot->p_count; i++) {
X					if (!this_plot->points[i].undefined) {
X						x = map_x(this_plot->points[i].x);
X						(*t->point)(x,map_y(this_plot->points[i].y),dpcount);
X					}
X				}
X				dpcount++;
X				break;
X		}
X	}
X	(*t->text)();
X	(void) fflush(outfile);
X}
X
X
Xpolar_xform (plots, pcount, xminp, xmaxp, yminp, ymaxp)
Xstruct curve_points *plots;
Xint pcount;			/* count of plots in linked list */
Xdouble *xminp, *xmaxp;
Xdouble *yminp, *ymaxp;
X{
Xregister int i, p_cnt;
Xregister struct termentry *t = &term_tbl[term];
Xregister struct curve_points *this_plot;
Xenum PLOT_TYPE p_type;
Xstruct coordinate *pnts;
Xint curve, xaxis_y, yaxis_x, dpcount;
Xdouble xmin, xmax, ymin, ymax, x, y;
X
X/*
X	Cycle through all the plots converting polar to rectangular and adjust
X	max and mins.
X*/
X	xmin = HUGE;
X	ymin = HUGE;
X	xmax = -HUGE;
X	ymax = -HUGE;
X    
X	this_plot = plots;
X	for (curve = 0; curve < pcount; this_plot = this_plot->next_cp, curve++) {
X		p_cnt = this_plot->p_count;
X        pnts = this_plot->points;
X
X	/*	Convert to cartesian all points in this curve. */
X		for (i = 0; i < p_cnt; i++) {
X			if (!pnts[i].undefined) {
X				x = pnts[i].y*cos(pnts[i].x);
X				y = pnts[i].y*sin(pnts[i].x);
X				pnts[i].x = x;
X				pnts[i].y = y;
X				if (xmin > x) xmin = x;
X				if (xmax < x) xmax = x;
X			/*  Can't worry about autoscale (assume true). */
X				if (ymin > y) ymin = y;
X				if (ymax < y) ymax = y;
X			}
X		}	
X	}
X	if (xmin < xmax) {  /* All points might be undefined... */
X		if (xmax - xmin < zero) {
X		/* This happens at least for the plot of 1/cos(x) (verticle line). */
X			xmin -= 3.14159;
X			xmax += 3.14159;
X		}
X	}
X	if (ymin < ymax) {  /* Only if there were defined points... */
X		if (ymax - ymin < zero) {
X		/* This happens at least for the plot of 1/sin(x) (horizontal line). */
X			ymin -= 1;
X			ymax += 1;
X		}
X	}
X
X/* Return the new maximums and minimums */
X	*xminp = xmin;
X	*xmaxp = xmax;
X	*yminp = ymin;
X	*ymaxp = ymax;
X}
END_OF_FILE
if test 9002 -ne `wc -c <'graphics.c'`; then
    echo shar: \"'graphics.c'\" unpacked with wrong size!
fi
# end of 'graphics.c'
fi
if test -f 'header.mac' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'header.mac'\"
else
echo shar: Extracting \"'header.mac'\" \(920 characters\)
sed "s/^X//" >'header.mac' <<'END_OF_FILE'
Xif1
XCOMPACT	equ 1			; define your memory model here
X
Xifdef	SMALL
X	; default, so do nothing
X	else
X
Xifdef	MEDIUM
X	LARGE_CODE equ 1
X	else
X
Xifdef	COMPACT
X	LARGE_DATA equ 1
X	else
X
Xifdef	LARGE
X	LARGE_DATA equ 1
X	LARGE_CODE equ 1
X
Xelse
X	%out No memory model defined--assuming SMALL
X
Xendif	; LARGE
Xendif	; COMPACT
Xendif	; MEDIUM
Xendif	; SMALL
X
X
Xbeginproc macro procname
X
Xifdef	LARGE_CODE
X	procname proc far
Xelse
X	procname proc near
Xendif	; LARGE_CODE
X
X	endm	; beginproc
X
X
Xendif	; if1
X
X
X_TEXT	SEGMENT	BYTE PUBLIC 'CODE'
X_TEXT	ENDS
X_DATA	SEGMENT WORD PUBLIC 'DATA'
X_DATA	ENDS
XCONST	SEGMENT WORD PUBLIC 'CONST'
XCONST	ENDS
X_BSS	SEGMENT WORD PUBLIC 'BSS'
X_BSS	ENDS
X
XDGROUP	GROUP	CONST, _BSS, _DATA
X	assume cs:_text, ds:dgroup, ss:dgroup, es:dgroup
X
X; define X as the offset of first argument on stack frame
X
Xifdef LARGE_CODE
X	X	equ 6			; return offset and segment + old BP
Xelse
X	X	equ 4			; return offset + old BP
Xendif	; LARGE_CODE
END_OF_FILE
if test 920 -ne `wc -c <'header.mac'`; then
    echo shar: \"'header.mac'\" unpacked with wrong size!
fi
# end of 'header.mac'
fi
if test ! -d 'help' ; then
    echo shar: Creating directory \"'help'\"
    mkdir 'help'
fi
if test -f 'hp26.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hp26.trm'\"
else
echo shar: Extracting \"'hp26.trm'\" \(1692 characters\)
sed "s/^X//" >'hp26.trm' <<'END_OF_FILE'
X/* thanks to hplvlch!ch (Chuck Heller) for the HP2623A driver */
X#define HP26_XMAX 512
X#define HP26_YMAX 390
X
X#define HP26_XLAST (HP26_XMAX - 1)
X#define HP26_YLAST (HP26_XMAX - 1)
X
X/* Assume a character size of 1, or a 7 x 10 grid. */
X#define HP26_VCHAR	10
X#define HP26_HCHAR	7
X#define HP26_VTIC	4
X#define HP26_HTIC	4
X
XHP26_init()
X{
X	/*	The HP2623A needs no initialization. */
X}
X
X
XHP26_graphics()
X{
X	/*	Clear and enable the display */
X
X	fputs("\033*daZ\033*dcZ",outfile);
X}
X
X
XHP26_text()
X{
X	fputs("\033*dT",outfile);	/* back to text mode */
X}
X
X
XHP26_linetype(linetype)
Xint linetype;
X{
X#define	SOLID	1
X#define LINE4	4
X#define LINE5	5
X#define LINE6	6
X#define LINE8	8
X#define	DOTS	7
X#define LINE9	9
X#define LINE10	10
X
Xstatic int map[2+9] = {	SOLID,	/* border */
X						DOTS,	/* axes */
X						SOLID,	/* plot 0 */
X						LINE4,	/* plot 1 */
X						LINE5,	/* plot 2 */
X						LINE6,	/* plot 3 */
X						LINE8,	/* plot 4 */
X						LINE9,	/* plot 5 */
X						LINE10,	/* plot 6 */
X						DOTS,	/* plot 7 */
X						SOLID	/* plot 8 */ };
X
X	if (linetype >= 9)
X		linetype %= 9;
X	fprintf(outfile,"\033*m%dB",map[linetype + 2]);
X}
X
X
XHP26_move(x,y)
Xint x,y;
X{
X	fprintf(outfile,"\033*pa%d,%dZ",x,y);
X}
X
X
XHP26_vector(x,y)
Xint x,y;
X{
X	fprintf(outfile,"\033*pb%d,%dZ",x,y);
X}
X
X
XHP26_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	HP26_move(HP26_XMAX-HP26_HTIC*2,HP26_VTIC*2+HP26_VCHAR*row);
X	fputs("\033*dS",outfile);
X	fprintf(outfile,"\033*m7Q\033*l%s\n",str);
X	fputs("\033*dT",outfile);
X}
X
X
XHP26_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	HP26_move(HP26_HTIC*2,HP26_YMAX-HP26_VTIC*2-HP26_VCHAR*row);
X	fputs("\033*dS",outfile);
X	fprintf(outfile,"\033*m3Q\033*l%s\n",str);
X	fputs("\033*dT",outfile);
X}
X
X
XHP26_reset()
X{
X}
X
X
END_OF_FILE
if test 1692 -ne `wc -c <'hp26.trm'`; then
    echo shar: \"'hp26.trm'\" unpacked with wrong size!
fi
# end of 'hp26.trm'
fi
if test -f 'hp75.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hp75.trm'\"
else
echo shar: Extracting \"'hp75.trm'\" \(1415 characters\)
sed "s/^X//" >'hp75.trm' <<'END_OF_FILE'
X#define HP75_XMAX 6000
X#define HP75_YMAX 6000
X
X#define HP75_XLAST (HP75_XMAX - 1)
X#define HP75_YLAST (HP75_XMAX - 1)
X
X/* HP75_VCHAR, HP75_HCHAR  are not used */
X#define HP75_VCHAR	(HP75_YMAX/20)	
X#define HP75_HCHAR	(HP75_XMAX/20)		
X#define HP75_VTIC	(HP75_YMAX/70)		
X#define HP75_HTIC	(HP75_XMAX/75)		
X
XHP75_init()
X{
X	fprintf(outfile,
X	"IN;\033.P1:SC0,%d,0,%d;\n;IP;SI0.2137,0.2812;\n",
X		HP75_XMAX,HP75_YMAX);
X/*	 1      2  3       4             5    6  7
X	1. turn on eavesdropping
X	2. reset to power-up defaults
X	3. enable XON/XOFF flow control
X	4. set SCaling to 2000 x 2000
X	5. rotate page 90 degrees
X	6. ???
X	7. set some character set stuff
X*/
X}
X
X
XHP75_graphics()
X{
X/*         1
X	fputs("\033.Y",outfile);
X	1. enable eavesdropping
X*/
X}
X
X
XHP75_text()
X{
X	fputs("NR;\033.Z",outfile);
X/*         1  2
X	1. go into 'view' mode
X	2. disable plotter eavesdropping
X*/
X}
X
X
XHP75_linetype(linetype)
Xint linetype;
X{
X	fprintf(outfile,"SP%d;\n",(linetype+3)%8);
X}
X
X
XHP75_move(x,y)
Xint x,y;
X{
X	fprintf(outfile,"PU%d,%d;\n",x,y);
X}
X
X
XHP75_vector(x,y)
Xint x,y;
X{
X	fprintf(outfile,"PD%d,%d;\n",x,y);
X}
X
X
XHP75_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	HP75_move(HP75_XMAX-HP75_HTIC*2,HP75_VTIC*2+HP75_VCHAR*row);
X	fprintf(outfile,"LO17;LB%s\003\n",str);
X}
X
XHP75_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	HP75_move(HP75_HTIC*2,HP75_YMAX-HP75_VTIC*2-HP75_VCHAR*row);
X	fprintf(outfile,"LO13;LB%s\003\n",str);
X}
X
XHP75_reset()
X{
X}
X
X
END_OF_FILE
if test 1415 -ne `wc -c <'hp75.trm'`; then
    echo shar: \"'hp75.trm'\" unpacked with wrong size!
fi
# end of 'hp75.trm'
fi
if test -f 'hpljet.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hpljet.trm'\"
else
echo shar: Extracting \"'hpljet.trm'\" \(6360 characters\)
sed "s/^X//" >'hpljet.trm' <<'END_OF_FILE'
X/*
X** Hewlett-Packard Laserjet
X** Driver written and copyrighted 1987 by
X** Jyrki Yli-Nokari (jty@intrin.UUCP)
X** Intrinsic, Ltd.
X** 
X** You may use this code for anything you like as long as
X** you are not selling it and the credit is given and
X** this message retained.
X*/
X
X/*
X** Here is the GNUPLOT HP Laserjet driver I promised to send to the net.
X** Following is a set of diffs to the GNUPLOT version V1.1 term.c
X** In case you don't have the patch program, you must insert the diffs
X** by hand. This should be fairly easy with a proper editor
X** since they are almost in one piece.
X**
X** Also there are some fixes to the HP26xx driver that was in the
X** V1.1 distribution.
X**
X** To get the laserjet driver, add -DHPLJET to TERMFLAGS in Makefile
X** (/DHPLJET in make.msc and HPLJET in compile.com).
X**
X** The driver consists of two parts: general raster plotting routines
X** (#ifdef RASTER) and the laserjet driver using them (#ifdef HPLJET).
X**
X** The laserjet driver contains actually three different "terminal types":
X** laserjet1, laserjet2 and laserjet3. The difference between them is the size
X** of the picture "laserjet3" being the biggest.
X*/
X
X/*
X** NOTE:
X** When sending the plot to the laserjet there must be absolutely
X** NO character translation done by the operating system.
X** Normally, in UNIX, the (operating system) terminal driver
X** translates newlines to CR/LF pairs. This is called the "cooked mode".
X** Some operating systems might add CR/LF pairs if they think there
X** is a too long line. ALL THIS IS STRICTLY PROHIBITED.
X** ALL DATA TO THE LASERJET MUST BE SENT WHEN THE LINE IS IN RAW MODE.
X**
X
X/*
X** The laserjet math is a pain since we have to deal with
X** decipoints (720/inch), dots (300/inch), pixels (100-300/inch),
X** characters (10/inch horiz., 6/inch vertic.) and the size of
X** the plottable surface in A4 (about 7.8 inches horizontally).
X** On top of this we also support different plot sizes!
X*/
X
X#define HPLJET_PIXSIZE	(hpljet_pixel)
X		/* Laserjet pixel size in laserjet minimum dots */
X#define HPLJET_PPI (300/HPLJET_PIXSIZE)
X		/* Laserjet raster scaling factor, Pixels Per Inch */
X#define HPLJET_WIDTH 5600
X		/* ~ Number of horizontal decipoints in A4 */
X#define HPLJET_IN2DP(x) (720*(x))
X		/* convert INches TO DeciPoints */
X#define HPLJET_PX2DP(x) (HPLJET_IN2DP(x)/HPLJET_PPI)
X		/* convert PiXels TO DeciPoints */
X#define HPLJET_HC2DP(x) (72*(x))
X		/* convert Horizontal Characters TO DeciPoints */
X#define HPLJET_VC2DP(x) (120*(x))
X		/* convert Vertical Characters TO DeciPoints */
X#define HPLJET_LMARG ((HPLJET_WIDTH - HPLJET_PX2DP(HPLJETXMAX))/2)
X		/* Picture left margin in decipoints */
X#define HPLJET_RMARG ((HPLJET_WIDTH + HPLJET_PX2DP(HPLJETXMAX))/2)
X		/* Picture right margin in decipoints */
X#define HPLJETXMAX 640
X		/* Number of pixels in X-axis */
X#define HPLJETYMAX 640
X		/* Number of pixels in Y-axis */
X#define HPLJETXLAST (HPLJETXMAX - 1)
X		/* Last valid X-pixel value */
X#define HPLJETYLAST (HPLJETYMAX - 1)
X		/* Last valid Y-pixel value */
X
X#define HPLJETVCHAR	(HPLJET_PPI/6)
X		/* Vertical pixel size of the character font */
X#define HPLJETHCHAR	(HPLJET_PPI/10)
X		/* Horizontal pixel size of the character font */
X#define HPLJET1VCHAR	(300/6)
X		/* Vertical pixel size of the character font */
X#define HPLJET1HCHAR	(300/10)
X		/* Horizontal pixel size of the character font */
X#define HPLJET2VCHAR	(150/6)
X		/* Vertical pixel size of the character font */
X#define HPLJET2HCHAR	(150/10)
X		/* Horizontal pixel size of the character font */
X#define HPLJET3VCHAR	(100/6)
X		/* Vertical pixel size of the character font */
X#define HPLJET3HCHAR	(100/10)
X		/* Horizontal pixel size of the character font */
X/*
X** (I guess) VTIC and HTIC are used as
X** "small units that look like equal length".
X** They determine (at least) the length of "bars" in axises and
X** the size of plotting symbols.
X*/
X#define HPLJETVTIC		6
X#define HPLJETHTIC		6
X
X/*
X** We use laserjet1, laserjet2 and laserjet3 for different
X** pixel sizes of the picture (1 is the smallest).
X** The size of the text, however, remains the same.
X** These three terminal types use mostly the same
X** functions, only the init-function determines the size of the picture.
X** Also, the h_char and v_char are different, but they are
X** not used.
X*/
X
X/*
X** Initialize (once) for graphics
X*/
Xstatic int hpljet_pixel = 3;
X
XHPLJET1init()
X{
X	hpljet_pixel = 1;
X}
X
XHPLJET2init()
X{
X	hpljet_pixel = 2;
X}
X
XHPLJET3init()
X{
X	hpljet_pixel = 3;
X}
X
XHPLJETmove(x, y)
X{
X	r_move((unsigned)x, (unsigned)y);
X}
X
XHPLJETvector(x, y)
X{
X	r_draw((unsigned)x, (unsigned)y, (pixel)1);
X}
X
X/*
X** Enter graphics mode:
X**	- allocate raster buffer
X**	- set resolution
X*/
XHPLJETgraphics()
X{
X	r_makeraster(HPLJETXMAX, HPLJETYMAX);
X	fprintf(outfile,"\033*t%dR", HPLJET_PPI);
X/*	                             1
X**	1. Set resolution pixels/inch
X*/
X}
X
X/*
X** (re-)enter text mode,
X** output raster and deallocate it.
X*/
XHPLJETtext()
X{
X	int x, y;
X	unsigned v, i;
X
X	fprintf(outfile, "\033&a%dH\033&a%dV", HPLJET_LMARG, HPLJET_VC2DP(2));
X	fprintf(outfile, "\033*r1A");
X	for (y = r_ysize-1; y >= 0; y--) {
X		fprintf(outfile, "\033*b%dW", r_xsize/8);
X		for (x = 0; x < r_xsize; x += 8) {
X			v = 0;
X			for (i = 0; i < 8; i++) {
X				v = (v << 1) | r_getpixel((unsigned)x + i, (unsigned)y);
X			}
X			putc((char)v, outfile);
X		}
X	}
X	r_freeraster();
X	fprintf(outfile, "\033*rB\f");
X}
X
X/*
X** Select line type [-2:8]
X** line types:
X**	-2 = border line
X**	-1 = x/y axis line
X**	0-8 = function plot lines.
X**	Dummy function here.
X*/
XHPLJETlinetype(linetype)
Xint linetype;
X{
X}
X
X/*
X** Put text "str" to the lower right corner of the screen.
X** "row" is the row number [0:1].
X** Actually in the laserjet, put the text above the upper right corner.
X*/
XHPLJETlrput_text(row,str)
Xunsigned int row;
Xchar str[];
X{
X	
X	fprintf(outfile, "\033&a%dH\033&a%dV",
X	        HPLJET_RMARG - HPLJET_HC2DP(strlen(str)), HPLJET_VC2DP(row));
X	fputs(str, outfile);
X}
X
X/*
X** Put text "str" to the upper left corner of the screen.
X** "row" is the (serial) number of function to be plotted.
X** Actually in the laserjet, put the text under the lower left corner.
X*/
XHPLJETulput_text(row,str)
Xunsigned int row;
Xchar str[];
X{
X	fprintf(outfile, "\033&a%dH\033&a%dV",
X	        HPLJET_LMARG,
X	        HPLJET_VC2DP(row+3)+HPLJET_PX2DP(HPLJETYMAX));
X	fputs(str, outfile);
X}
X
X/*
X** RETURN to normal mode (exit gnuplot)
X*/
XHPLJETreset()
X{
X}
X
END_OF_FILE
if test 6360 -ne `wc -c <'hpljet.trm'`; then
    echo shar: \"'hpljet.trm'\" unpacked with wrong size!
fi
# end of 'hpljet.trm'
fi
if test -f 'hrcgraph.asm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hrcgraph.asm'\"
else
echo shar: Extracting \"'hrcgraph.asm'\" \(7978 characters\)
sed "s/^X//" >'hrcgraph.asm' <<'END_OF_FILE'
XTITLE	Hercules graphics module
X
X;	Michael Gordon - 8-Dec-86
X;
X; Certain routines were taken from the Hercules BIOS of	Dave Tutelman - 8/86
X; Others came from pcgraph.asm included in GNUPLOT by Colin Kelley
X;
X; modified slightly by Colin Kelley - 22-Dec-86
X;	added header.mac, parameterized declarations
X; added dgroup: in HVmodem to reach HCh_Parms and HGr_Parms - 30-Jan-87
X
Xinclude header.mac
X
Xif1
Xinclude lineproc.mac
Xendif
X
X
XGPg1_Base equ 0B800h	; Graphics page 1 base address
X
X_text	segment
X
X	public _H_line, _H_color, _H_mask, _HVmode, _H_puts
X
Xhpixel	proc near
X	ror word ptr bmask,1
X	jc cont
X	ret
Xcont:
X	push ax
X	push bx
X	push cx
X	push dx
X	push si
X	mov cx,ax		; x
X	mov dx,bx		; y
X;
X; [couldn't this be done faster with a lookup table? -cdk]
X;
X	; first compute the address of byte to be modified
X	; = 90*[row/4] + [col/8] + 2^D*[row/4] + 2^F*page
X	mov	bh,cl		; col (low order) in BH
X	mov	bl,dl		; row (low order) in BL
X	and	bx,0703H	; mask the col & row remainders
XIFDEF iAPX286
X	shr	cx,3		; col / 8
X	shr	dx,2		; row / 4
X	mov	al,90
X	mul	dx		; AX = 90*[ row/4 ]
X	add	ax,cx		;  ... + col/8
X	shl	bl,5		; align row remainder
XELSE			; same as above, obscure but fast for 8086
X	shr	cx,1		; divide col by 8
X	shr	cx,1
X	shr	cx,1
X	shr	dx,1		; divide row by 4
X	shr	dx,1
X	shl	dx,1		; begin fast multiply by 90 (1011010 B)
X	mov	ax,dx
X	shl	dx,1
X	shl	dx,1
X	add	ax,dx
X	shl	dx,1
X	add	ax,dx
X	shl	dx,1
X	shl	dx,1
X	add	ax,dx		; end fast multiply by 90
X	add	ax,cx		; add on the col/8
X	shl	bl,1		; align row remainder
X	shl	bl,1
X	shl	bl,1
X	shl	bl,1
X	shl	bl,1
XENDIF
X	add	ah,bl		; use aligned row remainder
Xend_adr_calc:			; address of byte is now in AX
X	mov	dx,GPg1_Base	; base of pixel display to DX
X	mov	es,dx		; ...and thence to segment reg
X	mov	si,ax		; address of byte w/ pixel to index reg
X	mov	cl,bh		; bit addr in byte
X	mov	al,80H		; '1000 0000' in AL 
X	shr	al,cl		; shift mask to line up with bit to read/write
Xset_pix:			; set the pixel
X	or	es:[si],al	; or the mask with the right byte
X	pop si
X	pop dx
X	pop cx
X	pop bx
X	pop ax
X	ret
Xhpixel endp
X
Xlineproc _H_line, hpixel
X
X;
X; clear - clear page 1 of the screen buffer to zero (effectively, blank
X;	the screen)
X;
Xclear   proc near
X	push es
X	push ax
X	push cx
X	push di
X	mov ax, GPg1_Base
X	mov es, ax
X	xor di, di
X	mov cx, 4000h
X	xor ax, ax
X	cld
X	rep stosw			; zero out screen page
X	pop di
X	pop cx
X	pop ax
X	pop es
X	ret
Xclear	endp
X
Xbeginproc _H_color
X	push bp
X	mov bp,sp
X	mov al,[bp+X]			; color
X	mov byte ptr color,al
X	pop bp
X	ret
X_H_color endp
X
Xbeginproc _H_mask
X	push bp
X	mov bp,sp
X	mov ax,[bp+X]			; mask
X	mov word ptr bmask,ax
X	pop bp
X	ret
X_H_mask endp
X
XHCtrl_Port	equ	03B8H	; Hercules 6845 control port IO addr
XHIndx_Port	equ	03B4H	; Hercules 6845 index port IO addr
XHScrn_Enable	equ	008h	; Control port bit to enable video
XHCh_Mode	equ	020h	; Character output mode
XHGr_Mode	equ	082h	; Graphics output mode page 1
X
Xparm_count equ 12
X
Xbeginproc _HVmode
X	push bp
X	mov bp, sp
X	push si
X	mov ax, [bp+X]
X	or ah, al
X	mov al, HCh_Mode		; Assume character mode is wanted
X	mov si, offset dgroup:HCh_Parms
X	cmp ah, 0			; nonzero means switch to graphics
X	jz vmode_ok
X	call near ptr clear		; clear the graphics page
X	mov al, HGr_Mode
X	mov si, offset dgroup:HGr_Parms
Xvmode_ok:
X	mov dx, HCtrl_Port
X	out dx, al			; Set Hercules board to proper mode
X	call near ptr setParms		; Set the 6845 parameters
X	or al, HScrn_Enable		; Enable the video output
X	out dx, al
X	pop si
X	pop bp
X	ret
X_HVmode	endp
X
XsetParms proc near		; Send 6845 parms to Hercules board
X	push ax
X	push dx
X	push si			
X	mov dx, HIndx_Port	; Index port addr -> DX
X	mov ah, 0		; 0 -> parameter counter
Xsp_loop:
X	mov al, ah
X	out dx, al		; output to 6845 addr register
X	inc dx			; next output to data register
X	mov al, [si]		; next control byte -> al
X	inc si
X	out dx, al		; output control byte
X	dec dx			; 6845 index addr -> dx
X	inc ah			; bump addr
X	cmp ah, parm_count
X	jnz sp_loop
X	pop si
X	pop dx
X	pop ax
X	ret
XsetParms endp
X
X; H_puts - print text in graphics mode
X;
X;	cx = row
X;	bx = column
X;	si = address of string (null terminated) to print
X
Xbeginproc _H_puts
X	push bp
X	mov bp, sp
X	push si
X	push ds
X	mov si, [bp+X]			; string offset
X
Xifdef LARGE_DATA
X	mov ds, [bp+X+2]		; string segment
X	mov cx, [bp+X+4]		; row
X	mov bx, [bp+X+6]		; col
Xelse
X	mov cx, [bp+X+2]		; row
X	mov bx, [bp+X+4]		; col
Xendif
X
Xploop:	lodsb				; get next char
X	or	al, al			; end of display?
X	je	pdone
X	call near ptr display
X	inc	bx			; bump to next column
X	jmp	ploop
Xpdone:	pop ds
X	pop si
X	pop bp
X	ret
X_H_puts	endp
X
X;
X; display - output an 8x8 character from the IBM ROM to the Herc board
X;
X; AX = char, BX = column (0-89), CX = row(0-42)  ** all preserved **
X;
XCON8	db	8
XCON180	db	180
XIBMROM	equ	0F000h
XCHARTAB	equ	0FA6Eh
X
Xdisplay	proc near
X	push	ds			; save the lot
X	push	es
X	push	ax
X	push	bx
X	push	cx
X	push	dx
X	push	si
X	push	di
X
X; setup ds -> IBM ROM, and si -> index into IBM ROM character table located
X;	at 0fa6eh in the ROM
X
X	and	ax, 07fh
X	mul	cs:CON8			; mult by 8 bytes of table per char
X	mov	si, ax
X	mov	ax, IBMROM
X	mov	ds, ax
X	assume	ds:nothing
X	add	si, CHARTAB		; add offset of character table
X
X; compute index into Hercules screen memory for scan line 0.  The remaining
X;	seven scan lines are all at fixed offsets from the first.
X;
X;	Since graphics mode treats the screen as sets of 16x4 "characters",
X;	we need to map an 8x8 real character onto the front or back of
X;	a pair of graphics "characters".  The first four scan lines of our
X;	8x8 character will map to the top graphics "character", and the second
X;	four scan lines map to the graphics character on the "line" (4 scan
X;	lines high) below it.
X;
X;	For some exotic hardware reason (probably speed), all scan line 0
X;	bits (i.e. every fourth scan line) are stored in memory locations
X;	0-2000h in the screen buffer.  All scan line 1 bits are stored
X;	2000h-4000h.  Within these banks, they are stored by rows.  The first
X;	scan line on the screen (scan line 0 of graphics character row 0)
X;	is the first 45 words of memory in the screen buffer.  The next 45
X;	words are the first scan line graphics row 1, and since graphics
X;	"characters" are 4 bits high, this second scan line is physically
X;	the fifth scan line displayed on the screen.
X;
X;	SO, to display an 8x8 character, the 1st and 5th rows of dots are
X;	both scan line 0 of the graphics "character", the 2nd and 6th are
X;	scan line 1, and so on.
X;
X;	The column (0-89) tells which byte in a scan line we need to load.
X;	Since it takes two rows of graphics characters to hold one row of
X;	our characters, column+90 is a index to scan line 4 rows of pixels
X;	higher (n+4).  Thus 180 bytes of screen memory in any bank (0h, 2000h,
X;	4000h, 6000h) represent a row of 8x8 characters.
X;	
X;	The starting location in screen memory for the first scan line of
X;	a character to be displayed will be:  	(row*180)+column
X;	The 5th scan line will be at:		(row*180)+column+90
X;
X;	The second and 6th scan lines will be at the above offsets plus
X;	the bank offset of 2000h.  The third and 7th, add 4000h and finally
X;	the 4th and 8th, add 6000h.
X;
X	mov	ax, GPg1_Base
X	mov	es, ax			; es = hercules page 0
X	mov	ax, cx			; get row
X	mul	cs:CON180		; mult by 180(10)
X	mov	di, ax			; di = index reg
X	cld				; insure right direction
X
X;output 8 segments of character to video ram
X
X	lodsb				; line 0
X	mov	es:[di+bx], al
X	lodsb
X	mov	es:[di+bx+2000h], al	; line 1
X	lodsb
X	mov	es:[di+bx+4000h], al	; line 2
X	lodsb
X	mov	es:[di+bx+6000h], al	; line 3
X	lodsb
X	mov	es:[di+bx+90], al	; line 4
X	lodsb
X	mov	es:[di+bx+2000h+90], al	; line 5
X	lodsb
X	mov	es:[di+bx+4000h+90], al	; line 6
X	lodsb
X	mov	es:[di+bx+6000h+90], al	; line 7
X
X	pop	di
X	pop	si
X	pop	dx
X	pop	cx
X	pop	bx
X	pop	ax
X	pop	es
X	pop	ds
X	ret
Xdisplay	endp
X
X_text	ends
X
X_data	segment
Xbmask	dw -1
Xcolor	db 1
X_data	ends
X
Xconst	segment
XHCh_Parms db 	61H, 50H, 52H, 0FH, 19H, 06H, 19H, 19H, 02H, 0DH, 0BH, 0CH
XHGr_Parms db	35H, 2DH, 2EH, 07H, 5BH, 02H, 57H, 57H, 02H, 03H, 00H, 00H
Xconst	ends
X
X	end
X---------------------------end HRCGRAPH.ASM-------------------------------
X
X
END_OF_FILE
if test 7978 -ne `wc -c <'hrcgraph.asm'`; then
    echo shar: \"'hrcgraph.asm'\" unpacked with wrong size!
fi
# end of 'hrcgraph.asm'
fi
if test -f 'internal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'internal.c'\"
else
echo shar: Extracting \"'internal.c'\" \(13596 characters\)
sed "s/^X//" >'internal.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  internal.c
X *
X *  Copyright (C) 1986, 1987  Colin Kelley, Thomas Williams
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <math.h>
X#include <stdio.h>
X#include "plot.h"
X
Xextern BOOLEAN undefined;
X
Xchar *strcpy();
X
Xstruct value *pop(), *complex(), *integer();
Xdouble magnitude(), angle(), real();
X
Xstruct value stack[STACK_DEPTH];
X
Xint s_p = -1;   /* stack pointer */
X
X
X/*
X * System V and MSC 4.0 call this when they wants to print an error message.
X * Don't!
X */
Xmatherr()
X{
X	return (undefined = TRUE);		/* don't print error message */
X}
X
X
Xreset_stack()
X{
X	s_p = -1;
X}
X
X
Xcheck_stack()	/* make sure stack's empty */
X{
X	if (s_p != -1)
X		fprintf(stderr,"\nwarning:  internal error--stack not empty!\n");
X}
X
X
Xstruct value *pop(x)
Xstruct value *x;
X{
X	if (s_p  < 0 )
X		int_error("stack underflow",NO_CARET);
X	*x = stack[s_p--];
X	return(x);
X}
X
X
Xpush(x)
Xstruct value *x;
X{
X	if (s_p == STACK_DEPTH - 1)
X		int_error("stack overflow",NO_CARET);
X	stack[++s_p] = *x;
X}
X
X
X#define ERR_VAR "undefined variable: "
X
Xf_push(x)
Xunion argument *x;		/* contains pointer to value to push; */
X{
Xstatic char err_str[sizeof(ERR_VAR) + MAX_ID_LEN] = ERR_VAR;
Xstruct udvt_entry *udv;
X
X	udv = x->udv_arg;
X	if (udv->udv_undef) {	 /* undefined */
X		(void) strcpy(&err_str[sizeof(ERR_VAR) - 1], udv->udv_name);
X		int_error(err_str,NO_CARET);
X	}
X	push(&(udv->udv_value));
X}
X
X
Xf_pushc(x)
Xunion argument *x;
X{
X	push(&(x->v_arg));
X}
X
X
Xf_pushd(x)
Xunion argument *x;
X{
X	push(&(x->udf_arg->dummy_value));
X}
X
X
X#define ERR_FUN "undefined function: "
X
Xf_call(x)  /* execute a udf */
Xunion argument *x;
X{
Xstatic char err_str[sizeof(ERR_FUN) + MAX_ID_LEN] = ERR_FUN;
Xregister struct udft_entry *udf;
X
X	udf = x->udf_arg;
X	if (!udf->at) { /* undefined */
X		(void) strcpy(&err_str[sizeof(ERR_FUN) - 1],
X				udf->udf_name);
X		int_error(err_str,NO_CARET);
X	}
X	(void) pop(&(udf->dummy_value));
X
X	execute_at(udf->at);
X}
X
X
Xstatic int_check(v)
Xstruct value *v;
X{
X	if (v->type != INT)
X		int_error("non-integer passed to boolean operator",NO_CARET);
X}
X
X
Xf_lnot()
X{
Xstruct value a;
X	int_check(pop(&a));
X	push(integer(&a,!a.v.int_val) );
X}
X
X
Xf_bnot()
X{
Xstruct value a;
X	int_check(pop(&a));
X	push( integer(&a,~a.v.int_val) );
X}
X
X
Xf_bool()
X{			/* converts top-of-stack to boolean */
X	int_check(&top_of_stack);
X	top_of_stack.v.int_val = !!top_of_stack.v.int_val;
X}
X
X
Xf_lor()
X{
Xstruct value a,b;
X	int_check(pop(&b));
X	int_check(pop(&a));
X	push( integer(&a,a.v.int_val || b.v.int_val) );
X}
X
Xf_land()
X{
Xstruct value a,b;
X	int_check(pop(&b));
X	int_check(pop(&a));
X	push( integer(&a,a.v.int_val && b.v.int_val) );
X}
X
X
Xf_bor()
X{
Xstruct value a,b;
X	int_check(pop(&b));
X	int_check(pop(&a));
X	push( integer(&a,a.v.int_val | b.v.int_val) );
X}
X
X
Xf_xor()
X{
Xstruct value a,b;
X	int_check(pop(&b));
X	int_check(pop(&a));
X	push( integer(&a,a.v.int_val ^ b.v.int_val) );
X}
X
X
Xf_band()
X{
Xstruct value a,b;
X	int_check(pop(&b));
X	int_check(pop(&a));
X	push( integer(&a,a.v.int_val & b.v.int_val) );
X}
X
X
Xf_uminus()
X{
Xstruct value a;
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			a.v.int_val = -a.v.int_val;
X			break;
X		case CMPLX:
X			a.v.cmplx_val.real =
X				-a.v.cmplx_val.real;
X			a.v.cmplx_val.imag =
X				-a.v.cmplx_val.imag;
X	}
X	push(&a);
X}
X
X
Xf_eq() /* note: floating point equality is rare because of roundoff error! */
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val ==
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val ==
X						b.v.cmplx_val.real &&
X					   b.v.cmplx_val.imag == 0.0);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (b.v.int_val == a.v.cmplx_val.real &&
X					   a.v.cmplx_val.imag == 0.0);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real==
X						b.v.cmplx_val.real &&
X						a.v.cmplx_val.imag==
X						b.v.cmplx_val.imag);
X			}
X	}
X	push(integer(&a,result));
X}
X
X
Xf_ne()
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val !=
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val !=
X						b.v.cmplx_val.real ||
X					   b.v.cmplx_val.imag != 0.0);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (b.v.int_val !=
X						a.v.cmplx_val.real ||
X					   a.v.cmplx_val.imag != 0.0);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real !=
X						b.v.cmplx_val.real ||
X						a.v.cmplx_val.imag !=
X						b.v.cmplx_val.imag);
X			}
X	}
X	push(integer(&a,result));
X}
X 
X
Xf_gt()
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val >
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val >
X						b.v.cmplx_val.real);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (a.v.cmplx_val.real >
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real >
X						b.v.cmplx_val.real);
X			}
X	}
X	push(integer(&a,result));
X}
X
X
Xf_lt()
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val <
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val <
X						b.v.cmplx_val.real);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (a.v.cmplx_val.real <
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real <
X						b.v.cmplx_val.real);
X			}
X	}
X	push(integer(&a,result));
X}
X
X
Xf_ge()
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val >=
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val >=
X						b.v.cmplx_val.real);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (a.v.cmplx_val.real >=
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real >=
X						b.v.cmplx_val.real);
X			}
X	}
X	push(integer(&a,result));
X}
X
X
Xf_le()
X{
Xstruct value a, b;
X	register int result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					result = (a.v.int_val <=
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.int_val <=
X						b.v.cmplx_val.real);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					result = (a.v.cmplx_val.real <=
X						b.v.int_val);
X					break;
X				case CMPLX:
X					result = (a.v.cmplx_val.real <=
X						b.v.cmplx_val.real);
X			}
X	}
X	push(integer(&a,result));
X}
X
X
Xf_plus()
X{
Xstruct value a, b, result;
X	(void) pop(&b);
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					(void) integer(&result,a.v.int_val +
X						b.v.int_val);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.int_val +
X						b.v.cmplx_val.real,
X					   b.v.cmplx_val.imag);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					(void) complex(&result,b.v.int_val +
X						a.v.cmplx_val.real,
X					   a.v.cmplx_val.imag);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.cmplx_val.real+
X						b.v.cmplx_val.real,
X						a.v.cmplx_val.imag+
X						b.v.cmplx_val.imag);
X			}
X	}
X	push(&result);
X}
X
X
Xf_minus()
X{
Xstruct value a, b, result;
X	(void) pop(&b);
X	(void) pop(&a);		/* now do a - b */
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					(void) integer(&result,a.v.int_val -
X						b.v.int_val);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.int_val -
X						b.v.cmplx_val.real,
X					   -b.v.cmplx_val.imag);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					(void) complex(&result,a.v.cmplx_val.real -
X						b.v.int_val,
X					    a.v.cmplx_val.imag);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.cmplx_val.real-
X						b.v.cmplx_val.real,
X						a.v.cmplx_val.imag-
X						b.v.cmplx_val.imag);
X			}
X	}
X	push(&result);
X}
X
X
Xf_mult()
X{
Xstruct value a, b, result;
X	(void) pop(&b);
X	(void) pop(&a);	/* now do a*b */
X
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					(void) integer(&result,a.v.int_val *
X						b.v.int_val);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.int_val *
X						b.v.cmplx_val.real,
X						a.v.int_val *
X						b.v.cmplx_val.imag);
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					(void) complex(&result,b.v.int_val *
X						a.v.cmplx_val.real,
X						b.v.int_val *
X						a.v.cmplx_val.imag);
X					break;
X				case CMPLX:
X					(void) complex(&result,a.v.cmplx_val.real*
X						b.v.cmplx_val.real-
X						a.v.cmplx_val.imag*
X						b.v.cmplx_val.imag,
X						a.v.cmplx_val.real*
X						b.v.cmplx_val.imag+
X						a.v.cmplx_val.imag*
X						b.v.cmplx_val.real);
X			}
X	}
X	push(&result);
X}
X
X
Xf_div()
X{
Xstruct value a, b, result;
Xregister double square;
X	(void) pop(&b);
X	(void) pop(&a);	/* now do a/b */
X
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					if (b.v.int_val)
X					  (void) integer(&result,a.v.int_val /
X						b.v.int_val);
X					else {
X					  (void) integer(&result,0);
X					  undefined = TRUE;
X					}
X					break;
X				case CMPLX:
X					square = b.v.cmplx_val.real*
X						b.v.cmplx_val.real +
X						b.v.cmplx_val.imag*
X						b.v.cmplx_val.imag;
X					if (square)
X						(void) complex(&result,a.v.int_val*
X						b.v.cmplx_val.real/square,
X						-a.v.int_val*
X						b.v.cmplx_val.imag/square);
X					else {
X						(void) complex(&result,0.0,0.0);
X						undefined = TRUE;
X					}
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					if (b.v.int_val)
X					  
X					  (void) complex(&result,a.v.cmplx_val.real/
X						b.v.int_val,
X						a.v.cmplx_val.imag/
X						b.v.int_val);
X					else {
X						(void) complex(&result,0.0,0.0);
X						undefined = TRUE;
X					}
X					break;
X				case CMPLX:
X					square = b.v.cmplx_val.real*
X						b.v.cmplx_val.real +
X						b.v.cmplx_val.imag*
X						b.v.cmplx_val.imag;
X					if (square)
X					(void) complex(&result,(a.v.cmplx_val.real*
X						b.v.cmplx_val.real+
X						a.v.cmplx_val.imag*
X						b.v.cmplx_val.imag)/square,
X						(a.v.cmplx_val.imag*
X						b.v.cmplx_val.real-
X						a.v.cmplx_val.real*
X						b.v.cmplx_val.imag)/
X							square);
X					else {
X						(void) complex(&result,0.0,0.0);
X						undefined = TRUE;
X					}
X			}
X	}
X	push(&result);
X}
X
X
Xf_mod()
X{
Xstruct value a, b;
X	(void) pop(&b);
X	(void) pop(&a);	/* now do a%b */
X
X	if (a.type != INT || b.type != INT)
X		int_error("can only mod ints",NO_CARET);
X	if (b.v.int_val)
X		push(integer(&a,a.v.int_val % b.v.int_val));
X	else {
X		push(integer(&a,0));
X		undefined = TRUE;
X	}
X}
X
X
Xf_power()
X{
Xstruct value a, b, result;
Xregister int i, t, count;
Xregister double mag, ang;
X	(void) pop(&b);
X	(void) pop(&a);	/* now find a**b */
X
X	switch(a.type) {
X		case INT:
X			switch (b.type) {
X				case INT:
X					count = abs(b.v.int_val);
X					t = 1;
X					for(i = 0; i < count; i++)
X						t *= a.v.int_val;
X					if (b.v.int_val >= 0)
X						(void) integer(&result,t);
X					else
X						(void) complex(&result,1.0/t,0.0);
X					break;
X				case CMPLX:
X					mag =
X					  pow(magnitude(&a),fabs(b.v.cmplx_val.real));
X					if (b.v.cmplx_val.real < 0.0)
X						mag = 1.0/mag;
X					ang = angle(&a)*b.v.cmplx_val.real+
X					  b.v.cmplx_val.imag;
X					(void) complex(&result,mag*cos(ang),
X						mag*sin(ang));
X			}
X			break;
X		case CMPLX:
X			switch (b.type) {
X				case INT:
X					if (a.v.cmplx_val.imag == 0.0) {
X						mag = pow(a.v.cmplx_val.real,(double)abs(b.v.int_val));
X						if (b.v.int_val < 0)
X							mag = 1.0/mag;
X						(void) complex(&result,mag,0.0);
X					}
X					else {
X						/* not so good, but...! */
X						mag = pow(magnitude(&a),(double)abs(b.v.int_val));
X						if (b.v.int_val < 0)
X							mag = 1.0/mag;
X						ang = angle(&a)*b.v.int_val;
X						(void) complex(&result,mag*cos(ang),
X							mag*sin(ang));
X					}
X					break;
X				case CMPLX:
X					mag = pow(magnitude(&a),fabs(b.v.cmplx_val.real));
X					if (b.v.cmplx_val.real < 0.0)
X					  mag = 1.0/mag;
X					ang = angle(&a)*b.v.cmplx_val.real+ b.v.cmplx_val.imag;
X					(void) complex(&result,mag*cos(ang),
X						mag*sin(ang));
X			}
X	}
X	push(&result);
X}
X
X
Xf_factorial()
X{
Xstruct value a;
Xregister int i;
Xregister double val;
X
X	(void) pop(&a);	/* find a! (factorial) */
X
X	switch (a.type) {
X		case INT:
X			val = 1.0;
X			for (i = a.v.int_val; i > 1; i--)  /*fpe's should catch overflows*/
X				val *= i;
X			break;
X		default:
X			int_error("factorial (!) argument must be an integer",
X			NO_CARET);
X		}
X
X	push(complex(&a,val,0.0));
X			
X}
X
X
Xint
Xf_jump(x)
Xunion argument *x;
X{
X	return(x->j_arg);
X}
X
X
Xint
Xf_jumpz(x)
Xunion argument *x;
X{
Xstruct value a;
X	int_check(&top_of_stack);
X	if (top_of_stack.v.int_val) {	/* non-zero */
X		(void) pop(&a);
X		return 1;				/* no jump */
X	}
X	else
X		return(x->j_arg);		/* leave the argument on TOS */
X}
X
X
Xint
Xf_jumpnz(x)
Xunion argument *x;
X{
Xstruct value a;
X	int_check(&top_of_stack);
X	if (top_of_stack.v.int_val)	/* non-zero */
X		return(x->j_arg);		/* leave the argument on TOS */
X	else {
X		(void) pop(&a);
X		return 1;				/* no jump */
X	}
X}
X
X
Xint
Xf_jtern(x)
Xunion argument *x;
X{
Xstruct value a;
X
X	int_check(pop(&a));
X	if (a.v.int_val)
X		return(1);				/* no jump; fall through to TRUE code */
X	else
X		return(x->j_arg);		/* go jump to FALSE code */
X}
END_OF_FILE
if test 13596 -ne `wc -c <'internal.c'`; then
    echo shar: \"'internal.c'\" unpacked with wrong size!
fi
# end of 'internal.c'
fi
if test -f 'iris4d.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'iris4d.trm'\"
else
echo shar: Extracting \"'iris4d.trm'\" \(2282 characters\)
sed "s/^X//" >'iris4d.trm' <<'END_OF_FILE'
X/*
XHere are the additions to GNUplot so it runs on an IRIS4D series computer.
XDon't forget to compile with -DIRIS4D and include -Zg as one of the
Xlibraries.  The window that the plot goes to can be reshaped and moved, but
Xyou will have to replot the data.
X
X+----------------------------------+-----------------------------+
X|John H. Merritt                   |  Yesterday I knew nothing,  |
X|Applied Research Corporation      |  Today I know that.         |
X|merritt@iris613.gsfc.nasa.gov     |                             |
X+----------------------------------+-----------------------------+
X*/
X
X/* Provided by John H. Merritt (Applied Research Corporation) 7/1/89 */
X/* INTERNET: merritt@iris613.gsfc.nasa.gov */
X
X#include <gl.h>
X#define IRIS4D_XMAX 1024
X#define IRIS4D_YMAX 1024
X
X#define IRIS4D_XLAST (IRIS4D_XMAX - 1)
X#define IRIS4D_YLAST (IRIS4D_YMAX - 1)
X
X#define IRIS4D_VCHAR (IRIS4D_YMAX/30)
X#define IRIS4D_HCHAR (IRIS4D_XMAX/72)
X#define IRIS4D_VTIC (IRIS4D_YMAX/80)
X#define IRIS4D_HTIC (IRIS4D_XMAX/80)
X
XIRIS4D_init()
X{
X  foreground();
X  winopen("Gnuplot");
X  deflinestyle(1, 0x3FFF); /* Long dash */
X  deflinestyle(2, 0x5555); /* dotted */
X  deflinestyle(3, 0x3333); /* short dash */
X  deflinestyle(4, 0xB5AD); /* dotdashed */
X  return;
X}
X
XIRIS4D_graphics()
X{
X  reshapeviewport();
X  ortho2((Coord)0, (Coord)IRIS4D_XMAX, (Coord)0, (Coord)IRIS4D_YMAX);
X  color(WHITE);
X  clear();
X  
X  return;
X}
X
XIRIS4D_text()
X{
X  return; /* enter text from another window!!! */
X}
X
XIRIS4D_linetype(linetype)
Xint linetype;
X{
X  static int pen_color[5] = {1, 2, 3, 4, 5};
X  
X  linetype = linetype % 5;
X  color((Colorindex) pen_color[linetype]);
X  setlinestyle(linetype);
X  return;
X}
X
XIRIS4D_move(x, y)
Xunsigned int x, y;
X{
X  move2i(x, y);
X  return;
X}
X
XIRIS4D_cmove(x, y)
Xunsigned int x, y;
X{
X  cmov2i(x, y);
X  return;
X}
X
XIRIS4D_vector(x, y)
Xunsigned x, y;
X{
X  draw2i(x, y);
X  return;
X}
X
XIRIS4D_lrput_text(row, str)
Xunsigned int row;
Xchar *str;
X{
X  IRIS4D_cmove(IRIS4D_XMAX - IRIS4D_HTIC - IRIS4D_HCHAR*(strlen(str)+1),
X          IRIS4D_VTIC + IRIS4D_VCHAR*(row+1)) ;
X  charstr(str);
X  return;
X}
X
X
XIRIS4D_ulput_text(row,str)
Xunsigned int row ;
Xchar *str ;
X{
X  IRIS4D_cmove(IRIS4D_HTIC, IRIS4D_YMAX - IRIS4D_VTIC - IRIS4D_VCHAR*(row+1)) ;
X  charstr(str);
X  return;
X}
X
XIRIS4D_reset()
X{
X  return;
X}
END_OF_FILE
if test 2282 -ne `wc -c <'iris4d.trm'`; then
    echo shar: \"'iris4d.trm'\" unpacked with wrong size!
fi
# end of 'iris4d.trm'
fi
if test -f 'lineproc.mac' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lineproc.mac'\"
else
echo shar: Extracting \"'lineproc.mac'\" \(1979 characters\)
sed "s/^X//" >'lineproc.mac' <<'END_OF_FILE'
X; lineproc.mac
X; MASM macro definition for Bresenham line-drawing routine
X; Colin Kelley
X; January 13, 1987
X
X
XINCAX	equ 40h			; for Self-Modifying Code
XINCBX	equ 43h
XDECAX	equ 48h
XDECBX	equ 4bh
X
X; usage:
X;   lineproc linename, pixelname
X;
X; where linemane is the name you want for the proc, and pixelname is the
X;   name of the routine that linename is to call to set pixels
X;
X
Xlineproc macro linename, pixelname
Xbeginproc linename
X
X	push bp
X	mov bp,sp
X	push si
X	push di
X	mov ax,[bp+X]		; x1
X	mov bx,[bp+X+2]		; y1
X	mov cx,[bp+X+4]		; x2
X	mov si,[bp+X+6]		; y2
X
X	cmp ax,cx		; x1,x2
X	jne i19
X	cmp bx,si		; y1,y2
X	jne i19
X
X	call pixelname
X
X	jmp i28
Xi19:
X	mov dx,ax		; dx,x1
X	sub dx,cx		; x2
X	jnc noabsx
X	neg dx
Xnoabsx:
X	mov di,bx		; dy,y1
X	sub di,si		; y2
X	jnc noabsy
X	neg di			; dy
Xnoabsy:
X	cmp dx,di		; dx,dy
X	jb i21			; go iterate y's
X;
X; iterate x's
X;
X	cmp bx,si		; y1,y2
X	jb forwardy
X	mov byte ptr cs:yinc1,DECBX
X	jmp short i22
Xforwardy:
X	mov byte ptr cs:yinc1,INCBX
Xi22:
X	cmp ax,cx		; x1,x2
X	jae l20004
X	mov byte ptr cs:xinc1,INCAX
X	jmp short l20005
Xl20004:
X	mov byte ptr cs:xinc1,DECAX
Xl20005:
X	mov bp,dx		; sum,dx
X	shr bp,1		; sum
Xd23:
X	cmp ax,cx		; x1,x2
X	je i28			; done
Xxinc1:	inc ax			; may become inc or dec
X	add bp,di		; sum,dy
X	cmp bp,dx
X	jb i27
X	sub bp,dx		; sum,dx
Xyinc1:	inc bx			; may become inc or dec
Xi27:
X	call pixelname
X	jmp short d23
X
X;
X; else iterate y's
X;
Xi21:
X	cmp ax,cx		; x1,x2
X	jae l20006
X	mov byte ptr cs:xinc2,INCAX
X	jmp short l20007
Xl20006:
X	mov byte ptr cs:xinc2,DECAX
Xl20007:
X	cmp bx,si		; y1,y2
X	jb forwardy2
X	mov byte ptr cs:yinc2,DECBX
X	jmp short i29
Xforwardy2:
X	mov byte ptr cs:yinc2,INCBX
Xi29:
X	mov bp,di		; sum,dy
X	shr bp,1		; sum,1
Xd30:
X	cmp bx,si		; y1,y2
X	je i28
Xyinc2:	inc bx			; may become inc or dec
X	add bp,dx		; sum,dx
X	cmp bp,di		; sum,dy
X	jb i34
X	sub bp,di		; sum,dy
Xxinc2:	inc ax			; may become inc or dec
Xi34:
X	call near ptr pixelname
X	jmp short d30
X;
X; clean up and exit
X;
Xi28:	pop di
X	pop si
X	pop bp
X	ret
X
Xlinename endp
X	endm
END_OF_FILE
if test 1979 -ne `wc -c <'lineproc.mac'`; then
    echo shar: \"'lineproc.mac'\" unpacked with wrong size!
fi
# end of 'lineproc.mac'
fi
if test -f 'link.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'link.com'\"
else
echo shar: Extracting \"'link.com'\" \(151 characters\)
sed "s/^X//" >'link.com' <<'END_OF_FILE'
X$ link/exe=gnuplot command,eval,graphics,internal,misc,parse,plot,scanner, -
Xstandard,[]term,util,version,sys$input:/opt
Xsys$share:vaxcrtl.exe/share
X$
END_OF_FILE
if test 151 -ne `wc -c <'link.com'`; then
    echo shar: \"'link.com'\" unpacked with wrong size!
fi
# end of 'link.com'
fi
if test -f 'link.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'link.opt'\"
else
echo shar: Extracting \"'link.opt'\" \(125 characters\)
sed "s/^X//" >'link.opt' <<'END_OF_FILE'
Xcommand+eval+graphics+internal+misc+parse+plot+scanner+standard+term+util+version+pcgraph+corgraph+hrcgraph,gnuplot,nul,ega;
END_OF_FILE
if test 125 -ne `wc -c <'link.opt'`; then
    echo shar: \"'link.opt'\" unpacked with wrong size!
fi
# end of 'link.opt'
fi
if test -f 'link.otc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'link.otc'\"
else
echo shar: Extracting \"'link.otc'\" \(175 characters\)
sed "s/^X//" >'link.otc' <<'END_OF_FILE'
X\tc\lib\C0l command eval graphics internal misc parse plot scanner standard term util version ,gnuplot,gnuplot, \tc\lib\emu \tc\lib\mathl \tc\lib\cl \tc\lib\graphics
X        
END_OF_FILE
if test 175 -ne `wc -c <'link.otc'`; then
    echo shar: \"'link.otc'\" unpacked with wrong size!
fi
# end of 'link.otc'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
