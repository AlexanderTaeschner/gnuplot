Newsgroups: comp.sources.misc
From: allbery@uunet.UU.NET (Brandon S. Allbery - comp.sources.misc)
Subject: v08i038: GnuPlot v1.10A (part 4 of 7)
Reply-To: canoaf@ntvax.UUCP (Augustine Cano)

Posting-number: Volume 8, Issue 38
Submitted-by: canoaf@ntvax.UUCP (Augustine Cano)
Archive-name: gnuplot1.10A/part04

[OOPS!!!  I had to patch these after receiving them -- and managed to lose the
name of the person who submitted them in the process.  Duh.  The name shown
is a "best guess".  Submitter, please correct me.  ++bsa]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  plot.c plot.h polar.dem postscpt.trm qms.trm readme.tc
#   regis.trm scanner.c selanar.trm shar simple.dem standard.c tek.trm
#   term.c
# Wrapped by allbery@uunet on Sat Sep  9 13:47:22 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'plot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'plot.c'\"
else
echo shar: Extracting \"'plot.c'\" \(5472 characters\)
sed "s/^X//" >'plot.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  plot.c
X *
X *  Copyright (C) 1986, 1987  Thomas Williams, Colin Kelley
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X *
X *  The Turbo C code was supplied by William E Wilson, 1988-1989
X *
X */
X
X#include <stdio.h>
X#include <setjmp.h>
X#include <signal.h>
X#include "plot.h"
X
X/* on some compilers (Turbo C) interrupt is a reserved word */
X#ifdef MSDOS               
X#define interrupt intrrtn  /*something different*/
X#endif
X
Xchar *getenv(),*strcat(),*strcpy(),*strncpy();
X
Xextern char input_line[];
Xextern FILE *outfile;
Xextern int term;
Xextern struct termentry term_tbl[];
X
X#ifndef STDOUT
X#define STDOUT 1
X#endif
X
Xjmp_buf env;
X
Xstruct value *integer(),*complex();
X
X
Xextern f_push(),f_pushc(),f_pushd(),f_call(),f_lnot(),f_bnot(),f_uminus()
X        ,f_lor(),f_land(),f_bor(),f_xor(),f_band(),f_eq(),f_ne(),f_gt(),f_lt(),
X        f_ge(),f_le(),f_plus(),f_minus(),f_mult(),f_div(),f_mod(),f_power(),
X        f_factorial(),f_bool(),f_jump(),f_jumpz(),f_jumpnz(),f_jtern();
X
Xextern f_real(),f_imag(),f_arg(),f_conjg(),f_sin(),f_cos(),f_tan(),f_asin(),
X        f_acos(),f_atan(),f_sinh(),f_cosh(),f_tanh(),f_int(),f_abs(),f_sgn(),
X        f_sqrt(),f_exp(),f_log10(),f_log(),f_besj0(),f_besj1(),f_besy0(),f_besy1(),
X#ifdef GAMMA
X        f_gamma(),
X#endif
X        f_floor(),f_ceil();
X
X
Xstruct ft_entry ft[] = {        /* built-in function table */
X
X/* internal functions: */
X        {"push", f_push},       {"pushc", f_pushc},     {"pushd", f_pushd},
X        {"call", f_call},       {"lnot", f_lnot},       {"bnot", f_bnot},
X        {"uminus", f_uminus},                                   {"lor", f_lor},
X        {"land", f_land},       {"bor", f_bor},         {"xor", f_xor},
X        {"band", f_band},       {"eq", f_eq},           {"ne", f_ne},
X        {"gt", f_gt},           {"lt", f_lt},           {"ge", f_ge},
X        {"le", f_le},           {"plus", f_plus},       {"minus", f_minus},
X        {"mult", f_mult},       {"div", f_div},         {"mod", f_mod},
X        {"power", f_power}, {"factorial", f_factorial},
X        {"bool", f_bool},       {"jump", f_jump},       {"jumpz", f_jumpz},
X        {"jumpnz",f_jumpnz},{"jtern", f_jtern},
X
X/* standard functions: */
X        {"real", f_real},       {"imag", f_imag},       {"arg", f_arg},
X        {"conjg", f_conjg}, {"sin", f_sin},             {"cos", f_cos},
X        {"tan", f_tan},         {"asin", f_asin},       {"acos", f_acos},
X        {"atan", f_atan},       {"sinh", f_sinh},       {"cosh", f_cosh},
X        {"tanh", f_tanh},       {"int", f_int},         {"abs", f_abs},
X        {"sgn", f_sgn},         {"sqrt", f_sqrt},       {"exp", f_exp},
X        {"log10", f_log10},     {"log", f_log},         {"besj0", f_besj0},
X        {"besj1", f_besj1},     {"besy0", f_besy0},     {"besy1", f_besy1},
X#ifdef GAMMA
X        {"gamma", f_gamma},
X#endif
X        {"floor", f_floor},     {"ceil", f_ceil},
X        {NULL, NULL}
X};
X
Xstatic struct udvt_entry udv_pi = {NULL, "pi",FALSE};
X/* first in linked list */
Xstruct udvt_entry *first_udv = &udv_pi;
Xstruct udft_entry *first_udf = NULL;
X
X
X
X#ifdef vms
X
X#define HOME "sys$login:"
X
X#else /* vms */
X#ifdef MSDOS
X
X#define HOME "GNUPLOT"
X
X#else /* MSDOS */
X
X#define HOME "HOME"
X
X#endif /* MSDOS */
X#endif /* vms */
X
X#ifdef unix
X#define PLOTRC ".gnuplot"
X#else
X#define PLOTRC "gnuplot.ini"
X#endif
X
X
X#ifdef __TURBOC__
Xvoid interrupt()
X#else
Xinterrupt()
X#endif
X{
X#ifdef MSDOS
X#ifdef __TURBOC__
X  (void) signal(SIGINT, interrupt);
X#else
X	void ss_interrupt();
X	(void) signal(SIGINT, ss_interrupt);
X#endif
X#else
X	(void) signal(SIGINT, interrupt);
X#endif
X	(void) signal(SIGFPE, SIG_DFL);	/* turn off FPE trapping */
X	if (term)
X		(*term_tbl[term].text)();	/* hopefully reset text mode */
X	(void) fflush(outfile);
X	(void) putc('\n',stderr);
X	longjmp(env, TRUE);		/* return to prompt */
X}
X
X
Xmain()
X{
Xregister FILE *plotrc;
Xregister char *gnuterm=NULL;
Xstatic char home[sizeof(PLOTRC)+80];
X
X	setbuf(stderr,(char *)NULL);
X#ifdef VMS
X	outfile = stdout; /* never close stdout--even if duped. */
X#else
X	outfile = fdopen(dup(STDOUT),"w");
X#endif
X	(void) complex(&udv_pi.udv_value, Pi, 0.0);
X	show_version();
X	init();  /* Can set term if it wishes. */
X
X/* thanks to osupyr!alden (Dave Alden) for the GNUTERM code */
X
X	if (!(gnuterm = getenv("GNUTERM")) && term == 0)
X		gnuterm = TERM;
X	if (gnuterm != NULL)
X		(void) strcat(input_line,gnuterm); /* input_line has "set term " */
X	else
X		input_line[0] = '\0';   /* No SET TERM command needed. */
X
X	if (!setjmp(env))				/* come back here from printerror() */
X		do_line();
X
X	if (!setjmp(env)) {
X#ifdef MSDOS 
X#ifdef __TURBOC__
X		(void) signal(SIGINT, interrupt);	/* go there on interrupt char */
X#else
X		void ss_interrupt();
X		save_stack();				/* work-around for MSC 4.0/MSDOS 3.x bug */
X		(void) signal(SIGINT, ss_interrupt);
X#endif
X#else /* MSDOS */
X		(void) signal(SIGINT, interrupt);	/* go there on interrupt char */
X#endif /* MSDOS */
X		if (!(plotrc = (fopen(PLOTRC,"r")))) {
X#ifdef vms
X			(void) strncpy(home,HOME,sizeof(home));
X			plotrc = fopen(strcat(home,PLOTRC),"r");
X#else /* vms */
X			(void) strcat(strncpy(home,getenv(HOME),sizeof(home)),"/");
X			plotrc = fopen(strcat(home,PLOTRC),"r");
X#endif /* vms */
X		}
X		if (plotrc)
X			load_file(plotrc);
X	}
X
Xloop:	com_line();
X		goto loop;
X}
END_OF_FILE
if test 5472 -ne `wc -c <'plot.c'`; then
    echo shar: \"'plot.c'\" unpacked with wrong size!
fi
# end of 'plot.c'
fi
if test -f 'plot.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'plot.h'\"
else
echo shar: Extracting \"'plot.h'\" \(5830 characters\)
sed "s/^X//" >'plot.h' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  plot.h
X *
X *  Copyright (C) 1986, 1987  Thomas Williams, Colin Kelley
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#define PROGRAM "G N U P L O T"
X#define PROMPT "gnuplot> "
X#define SHELL "/bin/sh"		/* used if SHELL env variable not set */
X
X#ifdef vms
X#define HELP  "gnuplot "
X#else /* vms */
X#define HELP  "/usr/local/bin/help gnuplot"
X#endif /* vms */
X
X#define SAMPLES 160			/* default number of samples for a plot */
X#define ZERO	1e-8		/* default for 'zero' set option */
X
X#ifdef __TURBOC__
X#ifndef PC
X#define PC 1
X#endif
X#endif
X
X#ifdef PC
X#define TERM "egalib"
X#else
X#ifdef UNIXPC
X#define TERM "unixpc"
X#else
X#define TERM "tek40xx"		/* put your most common term type here! */
X#endif 
X#endif
X
X#define TRUE 1
X#define FALSE 0
X
X#define Pi 3.141592653589793
X
X#define MAX_POINTS 1
X#define MAX_LINE_LEN 255	/* maximum number of chars allowed on line */
X#define MAX_TOKENS 200
X#define MAX_ID_LEN 20		/* max length of an identifier */
X
X#define MAX_AT_LEN 150		/* max number of entries in action table */
X#define STACK_DEPTH 100
X#define NO_CARET (-1)
X
X
X#ifdef vms
X#define OS "VMS "
X#endif
X
X#ifdef unix
X#define OS "unix "
X#endif
X
X#ifdef MSDOS
X#define OS "MS-DOS "
X#endif
X
X#ifndef OS
X#define OS ""
X#endif
X
X/*
X * note about HUGE:  this number is just used as a flag for really
X *   big numbers, so it doesn't have to be the absolutely biggest number
X *   on the machine.
X *
X * define HUGE here if your compiler doesn't define it in <math.h>
X * example:
X#define HUGE 1e38
X */
X#ifndef HUGE 
X#ifdef HUGE_VAL  /* __TURBOC__ and VMS C ver 3.0 (ansi type compilers) */
X#define HUGE HUGE_VAL
X#else
X#define HUGE 1e38
X#endif
X#endif
X
X#define END_OF_COMMAND (c_token >= num_tokens || equals(c_token,";"))
X
X
X#ifdef vms
X
X#define is_comment(c) ((c) == '#' || (c) == '!')
X#define is_system(c) ((c) == '$')
X
X#else /* vms */
X
X#define is_comment(c) ((c) == '#')
X#define is_system(c) ((c) == '!')
X
X#endif /* vms */
X
X/*
X * If you're memcpy() has another name, define it below as bcopy() is.
X * If you don't have a memcpy():
X#define NOCOPY
X */
X
X#ifdef BCOPY
X#define memcpy(dest,src,len) bcopy(src,dest,len)
X#endif /* BCOPY */
X
X#ifdef vms
X#define memcpy(dest,src,len) lib$movc3(&len,src,dest)
X#endif /* vms */
X
X#define top_of_stack stack[s_p]
X
Xtypedef int BOOLEAN;
Xtypedef int (*FUNC_PTR)();
X
Xenum operators {
X	PUSH, PUSHC, PUSHD, CALL, LNOT, BNOT, UMINUS, LOR, LAND, BOR, XOR,
X	BAND, EQ, NE, GT, LT, GE, LE, PLUS, MINUS, MULT, DIV, MOD, POWER,
X	FACTORIAL, BOOL, JUMP, JUMPZ, JUMPNZ, JTERN, SF_START
X};
X
X#define is_jump(operator) ((operator) >=(int)JUMP && (operator) <(int)SF_START)
X
Xenum DATA_TYPES {
X	INT, CMPLX
X};
X
Xenum PLOT_TYPE {
X	FUNC, DATA
X};
X
Xenum PLOT_STYLE {
X	LINES, POINTS, IMPULSES
X};
X
Xstruct cmplx {
X	double real, imag;
X};
X
Xstruct value {
X	enum DATA_TYPES type;
X	union {
X		int int_val;
X		struct cmplx cmplx_val;
X	} v;
X};
X
Xstruct lexical_unit {	/* produced by scanner */
X	BOOLEAN is_token;	/* true if token, false if a value */ 
X	struct value l_val;
X	int start_index;	/* index of first char in token */
X	int length;			/* length of token in chars */
X};
X
Xstruct ft_entry {		/* standard/internal function table entry */
X	char *f_name;		/* pointer to name of this function */
X	FUNC_PTR func;		/* address of function to call */
X};
X
Xstruct udft_entry {				/* user-defined function table entry */
X	struct udft_entry *next_udf; /* pointer to next udf in linked list */
X	char udf_name[MAX_ID_LEN+1]; /* name of this function entry */
X	struct at_type *at;			/* pointer to action table to execute */
X	char *definition; 			/* definition of function as typed */
X	struct value dummy_value;	/* current value of dummy variable */
X};
X
Xstruct udvt_entry {			/* user-defined value table entry */
X	struct udvt_entry *next_udv; /* pointer to next value in linked list */
X	char udv_name[MAX_ID_LEN+1]; /* name of this value entry */
X	BOOLEAN udv_undef;		/* true if not defined yet */
X	struct value udv_value;	/* value it has */
X};
X
Xunion argument {			/* p-code argument */
X	int j_arg;				/* offset for jump */
X	struct value v_arg;		/* constant value */
X	struct udvt_entry *udv_arg;	/* pointer to dummy variable */
X	struct udft_entry *udf_arg; /* pointer to udf to execute */
X};
X
Xstruct at_entry {			/* action table entry */
X	enum operators index;	/* index of p-code function */
X	union argument arg;
X};
X
Xstruct at_type {
X	int a_count;				/* count of entries in .actions[] */
X	struct at_entry actions[MAX_AT_LEN];
X		/* will usually be less than MAX_AT_LEN is malloc()'d copy */
X};
X
Xstruct coordinate {
X	BOOLEAN undefined;	/* TRUE if value off screen */
X#ifdef PC
X	float x, y;			/* memory is tight on PCs! */
X#else
X	double x, y;
X#endif /* PC */
X};
X
Xstruct curve_points {
X	struct curve_points *next_cp;	/* pointer to next plot in linked list */
X	enum PLOT_TYPE plot_type;
X	enum PLOT_STYLE plot_style;
X	char *title;
X	int p_count;					/* count of points in .points[] */
X	struct coordinate points[MAX_POINTS];
X		/* will usually be less in malloc()'d copy */
X};
X
Xstruct termentry {
X	char *name;
X	unsigned int xmax,ymax,v_char,h_char,v_tic,h_tic;
X	FUNC_PTR init,reset,text,graphics,move,vector,linetype,lrput_text,
X		ulput_text,point;
X};
X
X/*
X * SS$_NORMAL is "normal completion", STS$M_INHIB_MSG supresses
X * printing a status message.
X * SS$_ABORT is the general abort status code.
X from:	Martin Minow
X	decvax!minow
X */
X#ifdef	vms
X#include		<ssdef.h>
X#include		<stsdef.h>
X#define	IO_SUCCESS	(SS$_NORMAL | STS$M_INHIB_MSG)
X#define	IO_ERROR	SS$_ABORT
X#endif /* vms */
X
X#ifndef	IO_SUCCESS	/* DECUS or VMS C will have defined these already */
X#define	IO_SUCCESS	0
X#endif
X#ifndef	IO_ERROR
X#define	IO_ERROR	1
X#endif
END_OF_FILE
if test 5830 -ne `wc -c <'plot.h'`; then
    echo shar: \"'plot.h'\" unpacked with wrong size!
fi
# end of 'plot.h'
fi
if test -f 'polar.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'polar.dem'\"
else
echo shar: Extracting \"'polar.dem'\" \(554 characters\)
sed "s/^X//" >'polar.dem' <<'END_OF_FILE'
X#
X# Show some of the new polar capabilities.
X#
Xset polar
Xset xrange [0:2*pi]
Xplot .5,1,1.5
Xpause -1 "Three circles (with aspect ratio distortion)"
Xplot cos(2*x)
Xpause -1 "Hit return"
Xplot 2*sqrt(cos(x)),-2*sqrt(cos(x))
Xpause -1
Xset offset pi/4,pi/4,0,0
Xplot sin(4*x),cos(4*x)
Xpause -1
Xset yrange [-3:3]
Xplot x/cos(3*x)
Xset autoscale
Xpause -1
Xplot 1-sin(x)
Xpause -1
Xset xrange [0:12*pi]
Xplot 2*x
Xpause -1
Xbutterfly(x)=exp(cos(x))-2*cos(4*x)+sin(x/12)**5
Xset samples 800
Xpause 0 "This is a big one (many samples), be patient..."
Xplot butterfly(x)
Xpause -1
END_OF_FILE
if test 554 -ne `wc -c <'polar.dem'`; then
    echo shar: \"'polar.dem'\" unpacked with wrong size!
fi
# end of 'polar.dem'
fi
if test -f 'postscpt.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscpt.trm'\"
else
echo shar: Extracting \"'postscpt.trm'\" \(2014 characters\)
sed "s/^X//" >'postscpt.trm' <<'END_OF_FILE'
X/* thanks to richb@yarra.OZ (Rich Burridge) for the Postscript driver */
X#define PS_XMAX 540
X#define PS_YMAX 720
X
X#define PS_XLAST (PS_XMAX - 1)
X#define PS_YLAST (PS_YMAX - 1)
X
X#define PS_VCHAR (PS_YMAX/30)
X#define PS_HCHAR (PS_XMAX/72)
X#define PS_VTIC (PS_YMAX/80)
X#define PS_HTIC (PS_XMAX/80)
X
X
XPS_init()
X{
X  (void) fprintf(outfile,"%%!\n") ;
X  (void) fprintf(outfile,"/off {36 add} def\n") ;
X  (void) fprintf(outfile,"/mv {off exch off moveto} def\n") ;
X  (void) fprintf(outfile,"/ln {off exch off lineto} def\n") ;
X  (void) fprintf(outfile,"/Times-Roman findfont 12 scalefont setfont\n") ;
X  (void) fprintf(outfile,"0.25 setlinewidth\n") ;
X}
X
X
XPS_graphics()
X{
X  (void) fprintf(outfile,"newpath\n") ;
X}
X
X
XPS_text()
X{
X  (void) fprintf(outfile,"stroke\n") ;
X  (void) fprintf(outfile,"showpage\n") ;
X}
X
X
XPS_linetype(linetype)
Xint linetype ;
X{
X  (void) fprintf(outfile,"stroke [") ;
X  switch ((linetype+2)%7)
X    {
X      case 0 :                                 /* solid. */
X      case 2 : break ;
X      case 1 :                                 /* longdashed. */
X      case 6 : (void) fprintf(outfile,"9 3") ;
X               break ;
X      case 3 : (void) fprintf(outfile,"3") ;            /* dotted. */
X               break ;
X      case 4 : (void) fprintf(outfile,"6 3") ;          /* shortdashed. */
X               break ;
X      case 5 : (void) fprintf(outfile,"3 3 6 3") ;      /* dotdashed. */
X    }
X  (void) fprintf(outfile,"] 0 setdash\n") ;
X}
X 
X 
XPS_move(x,y)
Xunsigned int x,y ;
X{
X  (void) fprintf(outfile,"%1d %1d mv\n",y,x) ;
X}
X 
X 
XPS_vector(x,y)
Xunsigned int x,y ;
X{
X  (void) fprintf(outfile,"%1d %1d ln\n",y,x) ;
X}
X 
X 
XPS_lrput_text(row,str)
Xunsigned int row ;
Xchar str[] ;
X{
X  PS_move(PS_XMAX - PS_HTIC - PS_HCHAR*(strlen(str)+1),
X          PS_VTIC + PS_VCHAR*(row+1)) ;
X  (void) fprintf(outfile,"(%s) show\n",str) ;
X}
X
X
XPS_ulput_text(row,str)
Xunsigned int row ;
Xchar str[] ;
X{
X  PS_move(PS_HTIC, PS_YMAX - PS_VTIC - PS_VCHAR*(row+1)) ;
X  (void) fprintf(outfile,"(%s) show\n",str) ;
X}
X
X
XPS_reset()
X{
X}
X
X
END_OF_FILE
if test 2014 -ne `wc -c <'postscpt.trm'`; then
    echo shar: \"'postscpt.trm'\" unpacked with wrong size!
fi
# end of 'postscpt.trm'
fi
if test -f 'qms.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qms.trm'\"
else
echo shar: Extracting \"'qms.trm'\" \(1674 characters\)
sed "s/^X//" >'qms.trm' <<'END_OF_FILE'
X#define QMS_XMAX 9000
X#define QMS_YMAX 6000
X
X#define QMS_XLAST (QMS_XMAX - 1)
X#define QMS_YLAST (QMS_YMAX - 1)
X
X#define QMS_VCHAR		120
X#define QMS_HCHAR		75
X#define QMS_VTIC		70
X#define QMS_HTIC		70
X
X
XQMS_init()
X{
X/* This was just ^IOL, but at Rutgers at least we need some more stuff */
X  fprintf(outfile,"^PY^-\n^IOL\n^ISYNTAX00000^F^IB11000^IJ00000^IT00000\n");
X}
X
X
XQMS_graphics()
X{
X	fprintf(outfile,"^IGV\n");
X}
X
X
X
XQMS_text()
X{
X/* added ^-, because ^, after an ^I command doesn't actually print a page */
X/* Did anybody try this code out?  [uhh...-cdk] */
X	fprintf(outfile,"^IGE\n^-^,");
X}
X
X
XQMS_linetype(linetype)
Xint linetype;
X{
Xstatic int width[2+9] = {7, 3, 3, 3, 3, 5, 5, 5, 7, 7, 7};
X/*
X * I don't know about Villanova, but on our printer, using ^V without
X * previously setting up a pattern crashes the microcode.
X * [nope, doesn't crash here. -cdk]
X */
X    static int type[2+9] =  {0, 0, 0, 2, 5, 0, 2, 5, 0, 2, 5};
X	if (linetype >= 9)
X		linetype %= 9;
X    fprintf(outfile,"^PW%02d\n^V%x\n",width[linetype+2], type[linetype+2]); 
X}
X
X
XQMS_move(x,y)
Xint x,y;
X{
X	fprintf(outfile,"^U%05d:%05d\n", 1000 + x, QMS_YLAST + 1000 - y);
X}
X
X
XQMS_vector(x2,y2)
Xint x2,y2;
X{
X	fprintf(outfile,"^D%05d:%05d\n", 1000 + x2, QMS_YLAST + 1000 - y2);
X}
X
X
XQMS_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	QMS_move(QMS_XMAX-QMS_HTIC-QMS_HCHAR*(strlen(str)+1),
X		QMS_VTIC+QMS_VCHAR*(row+1));
X	fprintf(outfile,"^IGE\n%s\n^IGV\n",str);
X}
X
XQMS_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	QMS_move(QMS_HTIC*2,QMS_YMAX-QMS_VTIC-QMS_VCHAR*(row+1));
X	fprintf(outfile,"^IGE\n%s\n^IGV\n",str);
X}
X
X
XQMS_reset()
X{
X/* add ^- just in case last thing was ^I command */
X	fprintf(outfile,"^-^,\n");
X}
X
X
END_OF_FILE
if test 1674 -ne `wc -c <'qms.trm'`; then
    echo shar: \"'qms.trm'\" unpacked with wrong size!
fi
# end of 'qms.trm'
fi
if test -f 'readme.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readme.tc'\"
else
echo shar: Extracting \"'readme.tc'\" \(967 characters\)
sed "s/^X//" >'readme.tc' <<'END_OF_FILE'
XFor those of you that will be compiling this code with Turbo C, there
Xare a few things that you will need to know.  First, this code can only
Xbe compiled with TC 2.0 or higher.  This is because of the special graphics
Xroutines that were utilized.  When compiling it is normal to receive a
Xnumber of warnings.  You should not get any errors though.  The warnings
Xare normally functions not returning values and some warnings about possible
Xincorrect assignments.  The program runs fine in spite of these.
X
XThe other thing that you must do after compiling is to make sure that the
X.BGI files are installed in the subdirectory that the program is to be run
Xfrom.  Even if you put gnuplot on your path, you must have these files in your
Xcurrent subdirectory.  If you want to fully path the program you can change
Xthe init() routine to include the path to the .bgi files.  If you do this,
Xsend the code back to us.
X
XGood Luck and have fun!
X
XWilliam E Wilson
Xwilson@nauvax
END_OF_FILE
if test 967 -ne `wc -c <'readme.tc'`; then
    echo shar: \"'readme.tc'\" unpacked with wrong size!
fi
# end of 'readme.tc'
fi
if test -f 'regis.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'regis.trm'\"
else
echo shar: Extracting \"'regis.trm'\" \(2172 characters\)
sed "s/^X//" >'regis.trm' <<'END_OF_FILE'
X#define REGISXMAX 800             
X#define REGISYMAX 440
X
X#define REGISXLAST (REGISXMAX - 1)
X#define REGISYLAST (REGISYMAX - 1)
X
X#define REGISVCHAR		20  	
X#define REGISHCHAR		8		
X#define REGISVTIC		8
X#define REGISHTIC		6
X
XREGISinit()
X{
X	fprintf(outfile,"\033[r\033[24;1H");
X/*                   1     2
X	1. reset scrolling region
X	2. locate cursor on bottom line
X*/
X}
X
X
X/* thanks to calmasd!dko (Dan O'Neill) for adding S(E) for vt125s */
XREGISgraphics()
X{
X	fprintf(outfile,"\033[2J\033P1pS(C0)S(E)");
X/*                   1      2      3	4
X	1. clear screen
X	2. enter ReGIS graphics
X	3. turn off graphics diamond cursor
X	4. clear graphics screen
X*/
X}
X
X
XREGIStext()
X{
X	fprintf(outfile,"\033\\\033[24;1H");
X/*	                   1    2
X	1. Leave ReGIS graphics mode
X 	2. locate cursor on last line of screen
X*/
X}
X
X
XREGISlinetype(linetype)
Xint     linetype;
X{
X      /* This will change color in order G,R,B,G-dot,R-dot,B-dot */
Xstatic int in_map[9 + 2] = {2, 2, 3, 2, 1, 3, 2, 1, 3, 2, 1};
Xstatic int lt_map[9 + 2] = {1, 4, 1, 1, 1, 4, 4, 4, 6, 6, 6};
X
X	if (linetype >= 9)
X		linetype %= 9;
X	fprintf(outfile, "W(I%d)", in_map[linetype + 2]);
X	fprintf(outfile, "W(P%d)", lt_map[linetype + 2]);
X}
X
X
XREGISmove(x,y)
Xint x,y;
X{
X	fprintf(outfile,"P[%d,%d]",x,REGISYLAST-y,x,REGISYLAST-y);
X}
X
X
XREGISvector(x,y)
Xint x,y;
X{
X	fprintf(outfile,"v[]v[%d,%d]",x,REGISYLAST - y);
X/* the initial v[] is needed to get the first pixel plotted */
X}
X
X
XREGISlrput_text(row,str)
Xint row;
Xchar *str;
X{
X	REGISmove(REGISXMAX-REGISHTIC-REGISHCHAR*(strlen(str)+3),
X		REGISVTIC+REGISVCHAR*(row+1));
X	(void) putc('T',outfile); (void) putc('\'',outfile);
X	while (*str) {
X		(void) putc(*str,outfile);
X		if (*str == '\'')
X			(void) putc('\'',outfile);	/* send out another one */
X		str++;
X	}
X	(void) putc('\'',outfile);
X}
X
X
XREGISulput_text(row,str)
Xint row;
Xchar *str;
X{
X	REGISmove(REGISVTIC,REGISYMAX-REGISVTIC*2-REGISVCHAR*row);
X	(void) putc('T',outfile); (void) putc('\'',outfile);
X	while (*str) {
X		(void) putc(*str,outfile);
X		if (*str == '\'')
X			(void) putc('\'',outfile);	/* send out another one */
X		str++;
X	}
X	(void) putc('\'',outfile);
X}
X
X
XREGISreset()
X{
X	fprintf(outfile,"\033[2J\033[24;1H");
X}
X
X
END_OF_FILE
if test 2172 -ne `wc -c <'regis.trm'`; then
    echo shar: \"'regis.trm'\" unpacked with wrong size!
fi
# end of 'regis.trm'
fi
if test -f 'scanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scanner.c'\"
else
echo shar: Extracting \"'scanner.c'\" \(7076 characters\)
sed "s/^X//" >'scanner.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  scanner.c
X *
X *  Copyright (C) 1986, 1987  Colin Kelley, Thomas Williams
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "plot.h"
X
Xextern BOOLEAN screen_ok;
X
X#ifdef vms
X
X#include stdio
X#include descrip
X#include errno
X
X#define MAILBOX "PLOT$MAILBOX"
X#define pclose(f) fclose(f)
X
X#endif /* vms */
X
X
X#define isident(c) (isalnum(c) || (c) == '_')
X
X#ifndef STDOUT
X#define STDOUT 1
X#endif
X
X#define LBRACE '{'
X#define RBRACE '}'
X
X#define APPEND_TOKEN {token[t_num].length++; current++;}
X
X#define SCAN_IDENTIFIER while (isident(expression[current + 1]))\
X				APPEND_TOKEN
X
Xextern struct lexical_unit token[MAX_TOKENS];
X
Xstatic int t_num;	/* number of token I'm working on */
X
Xchar *strcat(), *strcpy(), *strncpy();
X
X/*
X * scanner() breaks expression[] into lexical units, storing them in token[].
X *   The total number of tokens found is returned as the function value.
X *   Scanning will stop when '\0' is found in expression[], or when token[]
X *     is full.
X *
X *	 Scanning is performed by following rules:
X *
X *		Current char	token should contain
X *     -------------    -----------------------
X *		1.  alpha		all following alpha-numerics
X *		2.  digit		0 or more following digits, 0 or 1 decimal point,
X *						  0 or more digits, 0 or 1 'e' or 'E',
X *						  0 or more digits.
X *		3.  ^,+,-,/		only current char
X *		    %,~,(,)
X *		    [,],;,:,
X *		    ?,comma
X *		4.  &,|,=,*		current char; also next if next is same
X *		5.  !,<,>		current char; also next if next is =
X *		6.  ", '		all chars up until matching quote
X *
X *		white space between tokens is ignored
X */
Xscanner(expression)
Xchar expression[];
X{
Xregister int current;	/* index of current char in expression[] */
Xregister int quote;
Xchar brace;
X
X	for (current = t_num = 0;
X	    t_num < MAX_TOKENS && expression[current] != '\0';
X	    current++) {
Xagain:
X		if (isspace(expression[current]))
X			continue;						/* skip the whitespace */
X		token[t_num].start_index = current;
X		token[t_num].length = 1;
X		token[t_num].is_token = TRUE;	/* to start with...*/
X
X		if (expression[current] == '`') {
X			substitute(&expression[current],MAX_LINE_LEN - current);
X			goto again;
X		}
X		if (isalpha(expression[current])) {
X			SCAN_IDENTIFIER;
X		} else if (isdigit(expression[current]) || expression[current] == '.'){
X			token[t_num].is_token = FALSE;
X			token[t_num].length = get_num(&expression[current]);
X			current += (token[t_num].length - 1);
X		} else if (expression[current] == LBRACE) {
X			token[t_num].is_token = FALSE;
X			token[t_num].l_val.type = CMPLX;
X			if ((sscanf(&expression[++current],"%lf , %lf %c",
X				&token[t_num].l_val.v.cmplx_val.real,
X				&token[t_num].l_val.v.cmplx_val.imag,
X				&brace) != 3) || (brace != RBRACE))
X					int_error("invalid complex constant",t_num);
X			token[t_num].length += 2;
X			while (expression[++current] != RBRACE) {
X				token[t_num].length++;
X				if (expression[current] == '\0')			/* { for vi % */
X					int_error("no matching '}'", t_num);
X			}
X		} else if (expression[current] == '\'' || expression[current] == '\"'){
X			token[t_num].length++;
X			quote = expression[current];
X			while (expression[++current] != quote) {
X				if (!expression[current]) {
X					expression[current] = quote;
X					expression[current+1] = '\0';
X					break;
X				} else
X					token[t_num].length++;
X			}
X		} else switch (expression[current]) {
X			case '^':
X			case '+':
X			case '-':
X			case '/':
X			case '%':
X			case '~':
X			case '(':
X			case ')':
X			case '[':
X			case ']':
X			case ';':
X			case ':':
X			case '?':
X			case ',':
X				break;
X			case '&':
X			case '|':
X			case '=':
X			case '*':
X				if (expression[current] == expression[current + 1])
X					APPEND_TOKEN;
X				break;
X			case '!':
X			case '<':
X			case '>':
X				if (expression[current + 1] == '=')
X					APPEND_TOKEN;
X				break;
X			default:
X				int_error("invalid character",t_num);
X			}
X		++t_num;	/* next token if not white space */
X	}
X
X/* Now kludge an extra token which points to '\0' at end of expression[].
X   This is useful so printerror() looks nice even if we've fallen off the
X   line. */
X
X		token[t_num].start_index = current;
X		token[t_num].length = 0;
X	return(t_num);
X}
X
X
Xget_num(str)
Xchar str[];
X{
Xdouble atof();
Xregister int count = 0;
Xlong atol();
Xregister long lval;
X
X	token[t_num].is_token = FALSE;
X	token[t_num].l_val.type = INT;		/* assume unless . or E found */
X	while (isdigit(str[count]))
X		count++;
X	if (str[count] == '.') {
X		token[t_num].l_val.type = CMPLX;
X		while (isdigit(str[++count]))	/* swallow up digits until non-digit */
X			;
X		/* now str[count] is other than a digit */
X	}
X	if (str[count] == 'e' || str[count] == 'E') {
X		token[t_num].l_val.type = CMPLX;
X		if (str[++count] == '-')
X			count++;
X		if (!isdigit(str[count])) {
X			token[t_num].start_index += count;
X			int_error("expecting exponent",t_num);
X		}
X		while (isdigit(str[++count]))
X			;
X	}
X	if (token[t_num].l_val.type == INT) {
X 		lval = atol(str);
X		if ((token[t_num].l_val.v.int_val = lval) != lval)
X			int_error("integer overflow; change to floating point",t_num);
X	} else {
X		token[t_num].l_val.v.cmplx_val.imag = 0.0;
X		token[t_num].l_val.v.cmplx_val.real = atof(str);
X	}
X	return(count);
X}
X
X
X#ifdef MSDOS
X
Xsubstitute()
X{
X	int_error("substitution not supported by MS-DOS!",t_num);
X}
X
X#else /* MSDOS */
X
Xsubstitute(str,max)			/* substitute output from ` ` */
Xchar *str;
Xint max;
X{
Xregister char *last;
Xregister int i,c;
Xregister FILE *f;
XFILE *popen();
Xstatic char pgm[MAX_LINE_LEN+1],output[MAX_LINE_LEN+1];
X
X#ifdef vms
Xint chan;
Xstatic $DESCRIPTOR(pgmdsc,pgm);
Xstatic $DESCRIPTOR(lognamedsc,MAILBOX);
X#endif /* vms */
X
X	i = 0;
X	last = str;
X	while (*(++last) != '`') {
X		if (*last == '\0')
X			int_error("unmatched `",t_num);
X		pgm[i++] = *last;
X	}
X	pgm[i] = '\0';		/* end with null */
X	max -= strlen(last);	/* max is now the max length of output sub. */
X  
X#ifdef vms
X  	pgmdsc.dsc$w_length = i;
X   	if (!((vaxc$errno = sys$crembx(0,&chan,0,0,0,0,&lognamedsc)) & 1))
X   		os_error("sys$crembx failed",NO_CARET);
X   
X   	if (!((vaxc$errno = lib$spawn(&pgmdsc,0,&lognamedsc,&1)) & 1))
X   		os_error("lib$spawn failed",NO_CARET);
X   
X   	if ((f = fopen(MAILBOX,"r")) == NULL)
X   		os_error("mailbox open failed",NO_CARET);
X#else /* vms */
X  	if ((f = popen(pgm,"r")) == NULL)
X  		os_error("popen failed",NO_CARET);
X#endif /* vms */
X
X	i = 0;
X	while ((c = getc(f)) != EOF) {
X		output[i++] = ((c == '\n') ? ' ' : c);	/* newlines become blanks*/
X		if (i == max) {
X			(void) pclose(f);
X			int_error("substitution overflow", t_num);
X		}
X	}
X	(void) pclose(f);
X	if (i + strlen(last) > max)
X		int_error("substitution overflowed rest of line", t_num);
X	(void) strncpy(output+i,last+1,MAX_LINE_LEN-i);
X									/* tack on rest of line to output */
X	(void) strcpy(str,output);				/* now replace ` ` with output */
X	screen_ok = FALSE;
X}
X#endif /* MS-DOS */
END_OF_FILE
if test 7076 -ne `wc -c <'scanner.c'`; then
    echo shar: \"'scanner.c'\" unpacked with wrong size!
fi
# end of 'scanner.c'
fi
if test -f 'selanar.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'selanar.trm'\"
else
echo shar: Extracting \"'selanar.trm'\" \(666 characters\)
sed "s/^X//" >'selanar.trm' <<'END_OF_FILE'
X/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
X   Selanar driver */
X
XSEL_init()
X{
X	fprintf(outfile,"\033\062");
X/*					1
X	1. set to ansi mode
X*/
X}
X
X
XSEL_graphics()
X{
X	fprintf(outfile,"\033[H\033[J\033\061\033\014");
X/*                   1           2       3
X	1. clear ANSI screen
X	2. set to TEK mode
X	3. clear screen
X*/
X}
X
X
XSEL_text()
X{
X	TEK40move(0,12);
X	fprintf(outfile,"\033\062");
X/*                   1
X	1. into ANSI mode
X*/
X}
X
XSEL_reset()
X{
X	fprintf(outfile,"\033\061\033\012\033\062\033[H\033[J");
X/*                   1        2       3      4
X1       set tek mode
X2       clear screen
X3       set ansi mode
X4       clear screen
X*/
X}
X
END_OF_FILE
if test 666 -ne `wc -c <'selanar.trm'`; then
    echo shar: \"'selanar.trm'\" unpacked with wrong size!
fi
# end of 'selanar.trm'
fi
if test ! -d 'shar' ; then
    echo shar: Creating directory \"'shar'\"
    mkdir 'shar'
fi
if test -f 'simple.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'simple.dem'\"
else
echo shar: Extracting \"'simple.dem'\" \(551 characters\)
sed "s/^X//" >'simple.dem' <<'END_OF_FILE'
X#
X# gnuplot> set term <term-type>
X# gnuplot> load 'simple.dem'
X#
Xset samples 50
Xplot [-10:10] sin(x),atan(x),cos(atan(x))
Xset samples 100
Xplot [-pi/2:pi] cos(x),-(sin(x) > sin(x+1) ? sin(x) : sin(x+1))
Xset samples 200
Xplot [-3:5] asin(x),acos(x)
Xplot [-30:20] besj0(x)*0.12e1 with impulses, (x**besj0(x))-2.5 with points
Xset samples 400
Xplot [-10:10] real(sin(x)**besj0(x))
Xplot [-5*pi:5*pi] [-5:5] real(tan(x)/atan(x)), 1/x
Xset autoscale
Xset samples 800
Xplot [-30:20] sin(x*20)*atan(x)
Xplot [-19:19] '1.dat'with impulses ,'2.dat' ,'3.dat' with lines
END_OF_FILE
if test 551 -ne `wc -c <'simple.dem'`; then
    echo shar: \"'simple.dem'\" unpacked with wrong size!
fi
# end of 'simple.dem'
fi
if test -f 'standard.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'standard.c'\"
else
echo shar: Extracting \"'standard.c'\" \(5952 characters\)
sed "s/^X//" >'standard.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  standard.c
X *
X *  Copyright (C) 1986, 1987  Thomas Williams, Colin Kelley
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <math.h>
X#include <stdio.h>
X#include "plot.h"
X
Xextern BOOLEAN undefined;
X
X#ifdef vms
X#include <errno.h>
X#else
Xextern int errno;
X#endif /* vms */
X
X
Xextern struct value stack[STACK_DEPTH];
Xextern int s_p;
X
Xstruct value *pop(), *complex(), *integer();
X
Xdouble magnitude(), angle(), real(), imag();
X
X
Xf_real()
X{
Xstruct value a;
X	push( complex(&a,real(pop(&a)), 0.0) );
X}
X
Xf_imag()
X{
Xstruct value a;
X	push( complex(&a,imag(pop(&a)), 0.0) );
X}
X
Xf_arg()
X{
Xstruct value a;
X	push( complex(&a,angle(pop(&a)), 0.0) );
X}
X
Xf_conjg()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,real(&a),-imag(&a) ));
X}
X
Xf_sin()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,sin(real(&a))*cosh(imag(&a)), cos(real(&a))*sinh(imag(&a))) );
X}
X
Xf_cos()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,cos(real(&a))*cosh(imag(&a)), -sin(real(&a))*sinh(imag(&a))));
X}
X
Xf_tan()
X{
Xstruct value a;
Xregister double den;
X	(void) pop(&a);
X	if (imag(&a) == 0.0)
X		push( complex(&a,tan(real(&a)),0.0) );
X	else {
X		den = cos(2*real(&a))+cosh(2*imag(&a));
X		if (den == 0.0) {
X			undefined = TRUE;
X			push( &a );
X		}
X		else
X			push( complex(&a,sin(2*real(&a))/den, sinh(2*imag(&a))/den) );
X	}
X}
X
Xf_asin()
X{
Xstruct value a;
Xregister double alpha, beta, x, y;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0) {
X		if (fabs(x) > 1.0) {
X			undefined = TRUE;
X			push(complex(&a,0.0, 0.0));
X		} else
X			push( complex(&a,asin(x),0.0) );
X	} else {
X		beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
X		alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
X		push( complex(&a,asin(beta), log(alpha + sqrt(alpha*alpha-1))) );
X	}
X}
X
Xf_acos()
X{
Xstruct value a;
Xregister double alpha, beta, x, y;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0) {
X		if (fabs(x) > 1.0) {
X			undefined = TRUE;
X			push(complex(&a,0.0, 0.0));
X		} else
X			push( complex(&a,acos(x),0.0) );
X	} else {
X		alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
X		beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
X		push( complex(&a,acos(beta), log(alpha + sqrt(alpha*alpha-1))) );
X	}
X}
X
Xf_atan()
X{
Xstruct value a;
Xregister double x, y;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0)
X		push( complex(&a,atan(x), 0.0) );
X	else if (x == 0.0 && fabs(y) == 1.0) {
X		undefined = TRUE;
X		push(complex(&a,0.0, 0.0));
X	} else
X		push( complex(&a,atan(2*x/(1-x*x-y*y)),
X	    		log((x*x+(y+1)*(y+1))/(x*x+(y-1)*(y-1)))/4) );
X}
X
Xf_sinh()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,sinh(real(&a))*cos(imag(&a)), cosh(real(&a))*sin(imag(&a))) );
X}
X
Xf_cosh()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,cosh(real(&a))*cos(imag(&a)), sinh(real(&a))*sin(imag(&a))) );
X}
X
Xf_tanh()
X{
Xstruct value a;
Xregister double den;
X	(void) pop(&a);
X	den = cosh(2*real(&a)) + cos(2*imag(&a));
X	push( complex(&a,sinh(2*real(&a))/den, sin(2*imag(&a))/den) );
X}
X
Xf_int()
X{
Xstruct value a;
X	push( integer(&a,(int)real(pop(&a))) );
X}
X
X
Xf_abs()
X{
Xstruct value a;
X	(void) pop(&a);
X	switch (a.type) {
X		case INT:
X			push( integer(&a,abs(a.v.int_val)) );			
X			break;
X		case CMPLX:
X			push( complex(&a,magnitude(&a), 0.0) );
X	}
X}
X
Xf_sgn()
X{
Xstruct value a;
X	(void) pop(&a);
X	switch(a.type) {
X		case INT:
X			push( integer(&a,(a.v.int_val > 0) ? 1 : 
X					(a.v.int_val < 0) ? -1 : 0) );
X			break;
X		case CMPLX:
X			push( integer(&a,(a.v.cmplx_val.real > 0.0) ? 1 : 
X					(a.v.cmplx_val.real < 0.0) ? -1 : 0) );
X			break;
X	}
X}
X
X
Xf_sqrt()
X{
Xstruct value a;
Xregister double mag, ang;
X	(void) pop(&a);
X	mag = sqrt(magnitude(&a));
X	if (imag(&a) == 0.0 && real(&a) < 0.0)
X		push( complex(&a,0.0,mag) );
X	else
X	{
X		if ( (ang = angle(&a)) < 0.0)
X			ang += 2*Pi;
X		ang /= 2;
X		push( complex(&a,mag*cos(ang), mag*sin(ang)) );
X	}
X}
X
X
Xf_exp()
X{
Xstruct value a;
Xregister double mag, ang;
X	(void) pop(&a);
X	mag = exp(real(&a));
X	ang = imag(&a);
X	push( complex(&a,mag*cos(ang), mag*sin(ang)) );
X}
X
X
Xf_log10()
X{
Xstruct value a;
Xregister double l10;;
X	(void) pop(&a);
X	l10 = log(10.0);	/***** replace with a constant! ******/
X	push( complex(&a,log(magnitude(&a))/l10, angle(&a)/l10) );
X}
X
X
Xf_log()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( complex(&a,log(magnitude(&a)), angle(&a)) );
X}
X
X
Xf_besj0()	/* j0(a) = sin(a)/a */
X{
Xstruct value a;
X	a = top_of_stack;
X	f_sin();
X	push(&a);
X	f_div();
X}
X
X
Xf_besj1()	/* j1(a) = sin(a)/(a**2) - cos(a)/a */
X{
Xstruct value a;
X	a = top_of_stack;
X	f_sin();
X	push(&a);
X	push(&a);
X	f_mult();
X	f_div();
X	push(&a);
X	f_cos();
X	push(&a);
X	f_div();
X	f_minus();
X}
X
X
Xf_besy0()	/* y0(a) = -cos(a)/a */
X{
Xstruct value a;
X	a = top_of_stack;
X	f_cos();
X	push(&a);
X	f_div();
X	f_uminus();
X}
X
X
Xf_besy1()	/* y1(a) = -cos(a)/(a**2) - sin(a)/a */
X{
Xstruct value a;
X
X	a = top_of_stack;
X	f_cos();
X	push(&a);
X	push(&a);
X	f_mult();
X	f_div();
X	push(&a);
X	f_sin();
X	push(&a);
X	f_div();
X	f_plus();
X	f_uminus();
X}
X
X
Xf_floor()
X{
Xstruct value a;
X
X	(void) pop(&a);
X	switch (a.type) {
X		case INT:
X			push( integer(&a,(int)floor((double)a.v.int_val)));			
X			break;
X		case CMPLX:
X			push( complex(&a,floor(a.v.cmplx_val.real),
X				floor(a.v.cmplx_val.imag)) );
X	}
X}
X
X
Xf_ceil()
X{
Xstruct value a;
X
X	(void) pop(&a);
X	switch (a.type) {
X		case INT:
X			push( integer(&a,(int)ceil((double)a.v.int_val)));			
X			break;
X		case CMPLX:
X			push( complex(&a,ceil(a.v.cmplx_val.real), ceil(a.v.cmplx_val.imag)) );
X	}
X}
X
X#ifdef GAMMA
X
Xf_gamma()
X{
Xextern int signgam;
Xregister double y;
Xstruct value a;
X
X	y = gamma(real(pop(&a)));
X	if (y > 88.0) {
X		undefined = TRUE;
X		push( integer(&a,0) );
X	}
X	else
X		push( complex(&a,signgam * exp(y),0.0) );
X}
X
X#endif /* GAMMA */
END_OF_FILE
if test 5952 -ne `wc -c <'standard.c'`; then
    echo shar: \"'standard.c'\" unpacked with wrong size!
fi
# end of 'standard.c'
fi
if test -f 'tek.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tek.trm'\"
else
echo shar: Extracting \"'tek.trm'\" \(1332 characters\)
sed "s/^X//" >'tek.trm' <<'END_OF_FILE'
X#define TEK40XMAX 1024
X#define TEK40YMAX 780
X
X#define TEK40XLAST (TEK40XMAX - 1)
X#define TEK40YLAST (TEK40YMAX - 1)
X
X#define TEK40VCHAR		25
X#define TEK40HCHAR		14
X#define TEK40VTIC		11
X#define TEK40HTIC		11	
X
X#define HX 0x20		/* bit pattern to OR over 5-bit data */
X#define HY 0x20
X#define LX 0x40
X#define LY 0x60
X
X#define LOWER5 31
X#define UPPER5 (31<<5)
X
X
XTEK40init()
X{
X}
X
X
XTEK40graphics()
X{
X	fprintf(outfile,"\033\014");
X/*                   1
X	1. clear screen
X*/
X}
X
X
XTEK40text()
X{
X	TEK40move(0,12);
X	fprintf(outfile,"\037");
X/*                   1
X	1. into alphanumerics
X*/
X}
X
X
XTEK40linetype(linetype)
Xint linetype;
X{
X}
X
X
XTEK40move(x,y)
Xunsigned int x,y;
X{
X	(void) putc('\035', outfile);	/* into graphics */
X	TEK40vector(x,y);
X}
X
X
XTEK40vector(x,y)
Xunsigned int x,y;
X{
X	(void) putc((HY | (y & UPPER5)>>5), outfile);
X	(void) putc((LY | (y & LOWER5)), outfile);
X	(void) putc((HX | (x & UPPER5)>>5), outfile);
X	(void) putc((LX | (x & LOWER5)), outfile);
X}
X
X
XTEK40lrput_text(row,str)
Xunsigned int row;
Xchar str[];
X{
X	TEK40move(TEK40XMAX - TEK40HTIC - TEK40HCHAR*(strlen(str)+1),
X		TEK40VTIC + TEK40VCHAR*(row+1));
X	fprintf(outfile,"\037%s\n",str);
X}
X
X
XTEK40ulput_text(row,str)
Xunsigned int row;
Xchar str[];
X{
X	TEK40move(TEK40HTIC, TEK40YMAX - TEK40VTIC - TEK40VCHAR*(row+1));
X	fprintf(outfile,"\037%s\n",str);
X}
X
X
XTEK40reset()
X{
X}
X
X
END_OF_FILE
if test 1332 -ne `wc -c <'tek.trm'`; then
    echo shar: \"'tek.trm'\" unpacked with wrong size!
fi
# end of 'tek.trm'
fi
if test -f 'term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.c'\"
else
echo shar: Extracting \"'term.c'\" \(19496 characters\)
sed "s/^X//" >'term.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  term.c
X *
X *  Copyright (C) 1986, 1987  Colin Kelley, Thomas Williams
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <stdio.h>
X#include "plot.h"
X
Xchar *getenv();
X
Xextern FILE *outfile;
Xextern BOOLEAN term_init;
Xextern int term;
X
Xextern char input_line[];
Xextern struct lexical_unit token[];
Xextern struct termentry term_tbl[];
X
X/* This is needed because the unixplot library only writes to stdout. */
XFILE save_stdout;
Xint unixplot=0;
X
X#define NICE_LINE		0
X#define POINT_TYPES		6
X
X
Xdo_point(x,y,number)
Xint x,y;
Xint number;
X{
Xregister int htic,vtic;
Xregister struct termentry *t;
X
X	number %= POINT_TYPES;
X	t = &term_tbl[term];
X	htic = (t->h_tic/2);	/* should be in term_tbl[] in later version */
X	vtic = (t->v_tic/2);	
X
X	if ( x < t->h_tic || y < t->v_tic || x >= t->xmax-t->h_tic ||
X		y >= t->ymax-t->v_tic ) 
X		return;				/* add clipping in later version maybe */
X
X	switch(number) {
X		case 0: /* do diamond */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x+htic,y);
X				(*t->vector)(x,y+vtic);
X				(*t->vector)(x-htic,y);
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 1: /* do plus */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x-htic,y);
X				(*t->vector)(x+htic,y);
X				(*t->move)(x,y-vtic);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x,y+vtic);
X				break;
X		case 2: /* do box */ 
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 3: /* do X */ 
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->move)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x+htic,y-vtic);
X				break;
X		case 4: /* do triangle */ 
X				(*t->move)(x,y+(4*vtic/3));
X				(*t->vector)(x-(4*htic/3),y-(2*vtic/3));
X				(*t->vector)(x+(4*htic/3),y-(2*vtic/3));
X				(*t->vector)(x,y+(4*vtic/3));
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 5: /* do star */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x-htic,y);
X				(*t->vector)(x+htic,y);
X				(*t->move)(x,y-vtic);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x,y+vtic);
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->move)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x+htic,y-vtic);
X				break;
X	}
X}
X
X
X/*
X * general point routine
X */
Xline_and_point(x,y,number)
Xint x,y,number;
X{
X	/* temporary(?) kludge to allow terminals with bad linetypes 
X		to make nice marks */
X
X	(*term_tbl[term].linetype)(NICE_LINE);
X	do_point(x,y,number);
X}
X
X
X#ifdef HPLJET
X#define RASTER
X#endif /* HPLJET */
X
X#ifdef RASTER
X/*
X** General raster plotting routines.
X** Raster routines written and copyrighted 1987 by
X** Jyrki Yli-Nokari (jty@intrin.UUCP)
X** Intrinsic, Ltd.
X** 
X** You may use this code for anything you like as long as
X** you are not selling it and the credit is given and
X** this message retained.
X**
X** The plotting area is defined as a huge raster.
X** The raster is stored in a dynamically allocated pixel array r_p
X**
X** The raster is allocated (and initialized to zero) with
X** r_makeraster(xsize, ysize)
X** and freed with r_freeraster()
X**
X** Valid (unsigned) coordinates range from zero to (xsize-1,ysize-1)
X**
X** Plotting is done via r_move(x, y) and r_draw(x, y, value) functions,
X** where the point (x,y) is the target to go from the current point
X** and value is the value (of type pixel) to be stored in every pixel.
X**
X** Internally all plotting goes through r_setpixel(x, y, val).
X** If you want different plotting styles (like OR, XOR...), use "value"
X** in r_draw() to mark different styles and change r_setpixel() accordingly.
X*/
X
X#define IN(i,size)	((unsigned)i < (unsigned)size)
Xtypedef char pixel;	/* the type of one pixel in raster */
Xtypedef pixel *raster[];	/* the raster */
X
Xstatic raster *r_p;	/* global pointer to raster */
Xstatic unsigned r_currx, r_curry;	/* the current coordinates */
Xstatic unsigned r_xsize, r_ysize;	/* the size of the raster */
X
Xchar *calloc();
Xvoid free();
X
X/*
X** set pixel (x, y, val) to value val (this can be 1/0 or a color number).
X*/
Xvoid
Xr_setpixel(x, y, val)
Xunsigned x, y;
Xpixel val;
X{
X	if (IN(x, r_xsize) && IN(y, r_ysize)) {
X		*(((*r_p)[y]) + x) = val;
X	}
X#ifdef RASTERDEBUG
X	else {
X		fprintf(stderr, "Warning: setpixel(%d, %d, %d) out of bounds\n", x, y, val);
X	}
X#endif
X}
X
X/*
X** get pixel (x,y) value
X*/
Xpixel
Xr_getpixel(x, y)
Xunsigned x, y;
X{
X	if (IN(x, r_xsize) && IN(y, r_ysize)) {
X		return *(((*r_p)[y]) + x);
X	} else {
X#ifdef RASTERDEBUG
X		fprintf(stderr, "Warning: getpixel(%d,%d) out of bounds\n", x, y);
X#endif
X		return 0;
X	}
X}
X
X/*
X** allocate the raster
X*/
Xvoid
Xr_makeraster(x, y)
Xunsigned x, y;
X{
X	register unsigned j;
X	
X	/* allocate row pointers */
X	if ((r_p = (raster *)calloc(y, sizeof(pixel *))) == (raster *)0) {
X		fprintf(stderr, "Raster buffer allocation failure\n");
X		exit(1);
X	}
X	for (j = 0; j < y; j++) {
X		if (((*r_p)[j] = (pixel *)calloc(x, sizeof(pixel))) == (pixel *)0) {
X			fprintf(stderr, "Raster buffer allocation failure\n");
X			exit(1);
X		}
X	}
X	r_xsize = x; r_ysize = y;
X	r_currx = r_curry = 0;
X}
X	
X/*
X** plot a line from (x0,y0) to (x1,y1) with color val.
X*/
Xvoid
Xr_plot(x0, y0, x1, y1, val)
Xunsigned x0, y0, x1, y1;
Xpixel val;
X{
X	unsigned hx, hy, i;
X	int e, dx, dy;
X
X	hx = abs((int)(x1 - x0));
X	hy = abs((int)(y1 - y0));
X	dx = (x1 > x0) ? 1 : -1;
X	dy = (y1 > y0) ? 1 : -1;
X	
X	if (hx > hy) {
X		/*
X		** loop over x-axis
X		*/
X		e = hy + hy - hx;
X		for (i = 0; i <= hx; i++) {
X			r_setpixel(x0, y0, val);
X			if (e > 0) {
X				y0 += dy;
X				e += hy + hy - hx - hx;
X			} else {
X				e += hy + hy;
X			}
X			x0 += dx;
X		}
X	} else {
X		/*
X		** loop over y-axis
X		*/
X		e = hx + hx - hy;
X		for (i = 0; i <= hy; i++) {
X			r_setpixel(x0, y0, val);
X			if (e > 0) {
X				x0 += dx;
X				e += hx + hx - hy - hy;
X			} else {
X				e += hx + hx;
X			}
X			y0 += dy;
X		}
X	}
X}
X
X/*
X** move to (x,y)
X*/
Xvoid
Xr_move(x, y)
Xunsigned x, y;
X{
X	r_currx = x;
X	r_curry = y;
X}
X
X/*
X** draw to (x,y) with color val
X** (move pen down)
X*/
Xvoid
Xr_draw(x, y, val)
Xunsigned x, y;
Xpixel val;
X{
X	r_plot(r_currx, r_curry, x, y, val);
X	r_currx = x;
X	r_curry = y;
X}
X
X/*
X** free the allocated raster
X*/
Xvoid
Xr_freeraster()
X{
X	int y;
X
X	for (y = 0; y < r_ysize; y++) {
X		free((char *)(*r_p)[y]);
X	}
X	free((char *)r_p);
X}
X#endif /* RASTER */
X
X#ifdef HPLJET
X#include "hpljet.trm"
X#endif /* HPLJET */
X
X#ifdef PC
X#include "pc.trm"
X#endif /* PC */
X
X#ifdef AED
X#include "aed.trm"
X#endif /* AED */
X
X#ifdef BITGRAPH
X#include "bitgraph.trm"
X#endif /* BITGRAPH */
X
X#ifdef HP26
X#include "hp26.trm"
X#endif /* HP26 */
X
X#ifdef HP75
X#include "hp75.trm"
X#endif /* HP75 */
X
X#ifdef IRIS4D
X#include "iris4d.trm"
X#endif /* IRIS4D */
X 
X#ifdef POSTSCRIPT
X#include "postscpt.trm"
X#endif /* POSTSCRIPT */
X
X
X#ifdef QMS
X#include "qms.trm"
X#endif /* QMS */
X
X
X#ifdef REGIS
X#include "regis.trm"
X#endif /* REGIS */
X
X
X#ifdef SELANAR
X#include "selanar.trm"
X#endif /* SELANAR */
X
X
X#ifdef TEK
X#include "tek.trm"
X#endif /* TEK */
X
X
X#ifdef V384
X#include "v384.trm"
X#endif /* V384 */
X
X
X#ifdef UNIXPLOT
X/*
X   Unixplot library writes to stdout.  A fix was put in place by
X   ..!arizona!naucse!jdc to let set term and set output redirect
X   stdout.  All other terminals write to outfile.
X*/
X#include "unixplot.trm"
X#endif /* UNIXPLOT */
X
X#ifdef UNIXPC     /* unix-PC  ATT 7300 or 3b1 machine */
X#include "unixpc.trm"
X#endif /* UNIXPC */
X
X
XUNKNOWN_null()
X{
X}
X
X
X/*
X * term_tbl[] contains an entry for each terminal.  "unknown" must be the
X *   first, since term is initialized to 0.
X */
Xstruct termentry term_tbl[] = {
X	{"unknown", 100, 100, 1, 1, 1, 1, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null,
X	UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null,
X	UNKNOWN_null, UNKNOWN_null}
X#ifdef HPLJET
X	,{"laserjet1",HPLJETXMAX,HPLJETYMAX,HPLJET1VCHAR, HPLJET1HCHAR, HPLJETVTIC,
X		HPLJETHTIC, HPLJET1init,HPLJETreset, HPLJETtext, HPLJETgraphics, 
X		HPLJETmove, HPLJETvector,HPLJETlinetype,HPLJETlrput_text,
X		HPLJETulput_text, line_and_point}
X	,{"laserjet2",HPLJETXMAX,HPLJETYMAX,HPLJET2VCHAR, HPLJET2HCHAR, HPLJETVTIC, 
X		HPLJETHTIC, HPLJET2init,HPLJETreset, HPLJETtext, HPLJETgraphics, 
X		HPLJETmove, HPLJETvector,HPLJETlinetype,HPLJETlrput_text,
X		HPLJETulput_text, line_and_point}
X	,{"laserjet3",HPLJETXMAX,HPLJETYMAX,HPLJET3VCHAR, HPLJET3HCHAR, HPLJETVTIC, 
X		HPLJETHTIC, HPLJET3init,HPLJETreset, HPLJETtext, HPLJETgraphics, 
X		HPLJETmove, HPLJETvector,HPLJETlinetype,HPLJETlrput_text,
X		HPLJETulput_text, line_and_point}
X#endif
X
X#ifdef PC
X#ifdef __TURBOC__
X
X	,{"egalib", EGALIB_XMAX, EGALIB_YMAX, EGALIB_VCHAR, EGALIB_HCHAR,
X		EGALIB_VTIC, EGALIB_HTIC, EGALIB_init, EGALIB_reset,
X		EGALIB_text, EGALIB_graphics, EGALIB_move, EGALIB_vector,
X		EGALIB_linetype, EGALIB_lrput_text, EGALIB_ulput_text, line_and_point}
X
X	,{"vgalib", VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X		VGA_VTIC, VGA_HTIC, VGA_init, VGA_reset,
X		VGA_text, VGA_graphics, VGA_move, VGA_vector,
X		VGA_linetype, VGA_lrput_text, VGA_ulput_text, line_and_point}
X
X	,{"vgamono", VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X		VGA_VTIC, VGA_HTIC, VGA_init, VGA_reset,
X		VGA_text, VGA_graphics, VGA_move, VGA_vector,
X		VGAMONO_linetype, VGA_lrput_text, VGA_ulput_text, line_and_point}
X
X	,{"mcga", MCGA_XMAX, MCGA_YMAX, MCGA_VCHAR, MCGA_HCHAR,
X		MCGA_VTIC, MCGA_HTIC, MCGA_init, MCGA_reset,
X		MCGA_text, MCGA_graphics, MCGA_move, MCGA_vector,
X		MCGA_linetype, MCGA_lrput_text, MCGA_ulput_text, line_and_point}
X
X	,{"cga", CGA_XMAX, CGA_YMAX, CGA_VCHAR, CGA_HCHAR,
X		CGA_VTIC, CGA_HTIC, CGA_init, CGA_reset,
X		CGA_text, CGA_graphics, CGA_move, CGA_vector,
X		CGA_linetype, CGA_lrput_text, CGA_ulput_text, line_and_point}
X
X	,{"hercules", HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
X		HERC_VTIC, HERC_HTIC, HERC_init, HERC_reset,
X		HERC_text, HERC_graphics, HERC_move, HERC_vector,
X		HERC_linetype, HERC_lrput_text, HERC_ulput_text, line_and_point}
X
X#else
X	,{"cga", CGA_XMAX, CGA_YMAX, CGA_VCHAR, CGA_HCHAR,
X		CGA_VTIC, CGA_HTIC, CGA_init, CGA_reset,
X		CGA_text, CGA_graphics, CGA_move, CGA_vector,
X		CGA_linetype, CGA_lrput_text, CGA_ulput_text, line_and_point}
X
X	,{"egabios", EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
X		EGA_VTIC, EGA_HTIC, EGA_init, EGA_reset,
X		EGA_text, EGA_graphics, EGA_move, EGA_vector,
X		EGA_linetype, EGA_lrput_text, EGA_ulput_text, do_point}
X
X#ifdef EGALIB
X	,{"egalib", EGALIB_XMAX, EGALIB_YMAX, EGALIB_VCHAR, EGALIB_HCHAR,
X		EGALIB_VTIC, EGALIB_HTIC, EGALIB_init, EGALIB_reset,
X		EGALIB_text, EGALIB_graphics, EGALIB_move, EGALIB_vector,
X		EGALIB_linetype, EGALIB_lrput_text, EGALIB_ulput_text, do_point}
X#endif
X
X#ifdef HERCULES
X	,{"hercules", HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
X		HERC_VTIC, HERC_HTIC, HERC_init, HERC_reset,
X		HERC_text, HERC_graphics, HERC_move, HERC_vector,
X		HERC_linetype, HERC_lrput_text, HERC_ulput_text, line_and_point}
X#endif /* HERCULES */
X
X#ifdef ATT6300
X	,{"att", ATT_XMAX, ATT_YMAX, ATT_VCHAR, ATT_HCHAR,
X		ATT_VTIC, ATT_HTIC, ATT_init, ATT_reset,
X		ATT_text, ATT_graphics, ATT_move, ATT_vector,
X		ATT_linetype, ATT_lrput_text, ATT_ulput_text, line_and_point}
X#endif
X
X#ifdef CORONA
X	,{"corona325", COR_XMAX, COR_YMAX, COR_VCHAR, COR_HCHAR,
X		COR_VTIC, COR_HTIC, COR_init, COR_reset,
X		COR_text, COR_graphics, COR_move, COR_vector,
X		COR_linetype, COR_lrput_text, COR_ulput_text, line_and_point}
X#endif /* CORONA */
X#endif /* TURBOC */
X#endif /* PC */
X
X#ifdef AED
X	,{"aed512", AED5_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
X		AED_VTIC, AED_HTIC, AED_init, AED_reset, 
X		AED_text, AED_graphics, AED_move, AED_vector, 
X		AED_linetype, AED5_lrput_text, AED_ulput_text, do_point}
X	,{"aed767", AED_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
X		AED_VTIC, AED_HTIC, AED_init, AED_reset, 
X		AED_text, AED_graphics, AED_move, AED_vector, 
X		AED_linetype, AED_lrput_text, AED_ulput_text, do_point}
X#endif
X
X#ifdef UNIXPC
X	,{"unixpc",uPC_XMAX,uPC_YMAX,uPC_VCHAR, uPC_HCHAR, uPC_VTIC, 
X		uPC_HTIC, uPC_init,uPC_reset, uPC_text, uPC_graphics, 
X		uPC_move, uPC_vector,uPC_linetype,uPC_lrput_text,
X		uPC_ulput_text, line_and_point}
X#endif
X
X#ifdef BITGRAPH
X	,{"bitgraph",BG_XMAX,BG_YMAX,BG_VCHAR, BG_HCHAR, BG_VTIC, 
X		BG_HTIC, BG_init,BG_reset, BG_text, BG_graphics, 
X		BG_move, BG_vector,BG_linetype,BG_lrput_text,
X		BG_ulput_text, line_and_point}
X#endif
X
X#ifdef HP26
X	,{"hp2623A",HP26_XMAX,HP26_YMAX, HP26_VCHAR, HP26_HCHAR,HP26_VTIC,HP26_HTIC,
X		HP26_init,HP26_reset,HP26_text, HP26_graphics, HP26_move, HP26_vector,
X		HP26_linetype, HP26_lrput_text, HP26_ulput_text, line_and_point}
X#endif
X
X#ifdef HP75
X	,{"hp7580B",HP75_XMAX,HP75_YMAX, HP75_VCHAR, HP75_HCHAR,HP75_VTIC,HP75_HTIC,
X		HP75_init,HP75_reset,HP75_text, HP75_graphics, HP75_move, HP75_vector,
X		HP75_linetype, HP75_lrput_text, HP75_ulput_text, do_point}
X#endif
X
X#ifdef IRIS4D
X	,{"iris4d", IRIS4D_XMAX, IRIS4D_YMAX, IRIS4D_VCHAR,
X		IRIS4D_HCHAR, IRIS4D_VTIC, IRIS4D_HTIC,
X		IRIS4D_init, IRIS4D_reset, IRIS4D_text,
X		IRIS4D_graphics, IRIS4D_move, IRIS4D_vector,
X		IRIS4D_linetype, IRIS4D_lrput_text, IRIS4D_ulput_text,
X		do_point}
X#endif
X
X#ifdef POSTSCRIPT
X	,{"postscript", PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, PS_VTIC, PS_HTIC,
X		PS_init, PS_reset, PS_text, PS_graphics, PS_move, PS_vector,
X		PS_linetype, PS_lrput_text, PS_ulput_text, line_and_point}
X#endif
X
X#ifdef QMS
X	,{"qms",QMS_XMAX,QMS_YMAX, QMS_VCHAR, QMS_HCHAR, QMS_VTIC, QMS_HTIC,
X		QMS_init,QMS_reset, QMS_text, QMS_graphics, QMS_move, QMS_vector,
X		QMS_linetype,QMS_lrput_text,QMS_ulput_text,line_and_point}
X#endif
X
X#ifdef REGIS
X	,{"regis", REGISXMAX, REGISYMAX, REGISVCHAR, REGISHCHAR, REGISVTIC,
X		REGISHTIC, REGISinit, REGISreset, REGIStext, REGISgraphics,
X		REGISmove,REGISvector,REGISlinetype, REGISlrput_text, REGISulput_text,
X		line_and_point}
X#endif
X
X
X#ifdef SELANAR
X	,{"selanar",TEK40XMAX,TEK40YMAX,TEK40VCHAR, TEK40HCHAR, TEK40VTIC, 
X		TEK40HTIC, SEL_init, SEL_reset, SEL_text, SEL_graphics, 
X		TEK40move, TEK40vector, TEK40linetype, TEK40lrput_text,
X		TEK40ulput_text, line_and_point}
X#endif
X
X#ifdef TEK
X	,{"tek40xx",TEK40XMAX,TEK40YMAX,TEK40VCHAR, TEK40HCHAR, TEK40VTIC, 
X		TEK40HTIC, TEK40init, TEK40reset, TEK40text, TEK40graphics, 
X		TEK40move, TEK40vector, TEK40linetype, TEK40lrput_text,
X		TEK40ulput_text, line_and_point}
X#endif
X
X#ifdef UNIXPLOT
X	,{"unixplot", UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR, UP_VTIC, UP_HTIC,
X		UP_init, UP_reset, UP_text, UP_graphics, UP_move, UP_vector,
X		UP_linetype, UP_lrput_text, UP_ulput_text, line_and_point}
X#endif
X
X#ifdef V384
X	,{"vx384", V384_XMAX, V384_YMAX, V384_VCHAR, V384_HCHAR, V384_VTIC,
X		V384_HTIC, V384_init, V384_reset, V384_text, V384_graphics,
X		V384_move, V384_vector, V384_linetype, V384_lrput_text,
X		V384_ulput_text, do_point}
X#endif
X	};
X
X#define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry))
X
X
Xlist_terms()
X{
Xregister int i;
X
X	fprintf(stderr,"\navailable terminals types:\n");
X	for (i = 0; i < TERMCOUNT; i++)
X		fprintf(stderr,"\t%s\n",term_tbl[i].name);
X	(void) putc('\n',stderr);
X}
X
X
Xset_term(c_token)
Xint c_token;
X{
Xregister int i,t;
X
X	if (!token[c_token].is_token)
X		int_error("terminal name expected",c_token);
X	t = -1;
X
X	for (i = 0; i < TERMCOUNT; i++) {
X   		if (!strncmp(input_line + token[c_token].start_index,term_tbl[i].name,
X			token[c_token].length)) {
X			if (t != -1)
X				int_error("ambiguous terminal name",c_token);
X			t = i;
X		}
X	}
X	if (t == -1)
X		int_error("unknown terminal type; type just 'set terminal' for a list",
X			c_token);
X	else if (!strncmp("unixplot",term_tbl[t].name,sizeof(unixplot))) {
X		UP_redirect (2);  /* Redirect actual stdout for unixplots */
X	}
X	else if (unixplot) {
X		UP_redirect (3);  /* Put stdout back together again. */
X	}
X	term_init = FALSE;
X	return(t);
X}
X
X
X/*
X   Routine to detect what terminal is being used (or do anything else
X   that would be nice).  One anticipated (or allowed for) side effect
X   is that the global ``term'' may be set.
X*/
Xinit()
X{
Xchar *term_name = NULL;
Xint t = -1, i;
X#ifdef __TURBOC__
X  int g_driver,g_mode;
X  char far *c1,*c2;
X
X/* Some of this code including BGI drivers is copyright Borland Intl. */
X	g_driver=DETECT;
X	      get_path();
X        initgraph(&g_driver,&g_mode,path);
X        c1=getdrivername();
X        c2=getmodename(g_mode);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X        closegraph();
X	fprintf(stderr,"\tTC Graphics, driver %s  mode %s\n",c1,c2);
X#endif
X#ifdef VMS
X/*
X   Determine if we have a regis terminal.  If not use TERM 
X   (tek40xx) as default.
X*/
X#include <descrip>
X#include <dvidef>
X
Xextern int term;
Xchar *term_str="tt:";
Xtypedef struct
X          {
X          short cond_value;
X          short count;
X          int info;
X          }  status_block;
Xtypedef struct
X          {
X          short buffer_len;
X          short item_code;
X          int buffer_addr;
X          int ret_len_addr;
X          }  item_desc;
Xstruct {
X    item_desc dev_type;
X      int terminator;
X   }  dvi_list;
X   int status, dev_type, zero=0;
X   char buffer[255];
X   $DESCRIPTOR(term_desc, term_str);
X
X/* set up dvi item list */
X	dvi_list.dev_type.buffer_len = 4;
X	dvi_list.dev_type.item_code = DVI$_TT_REGIS;
X	dvi_list.dev_type.buffer_addr = &dev_type;
X	dvi_list.dev_type.ret_len_addr = 0;
X
X	dvi_list.terminator = 0;
X
X/* See what type of terminal we have. */
X	status = SYS$GETDVIW (0, 0, &term_desc, &dvi_list, 0, 0, 0, 0);
X	if ((status & 1) && dev_type) {
X		term_name = "regis";
X	}
X#endif
X	if (term_name != NULL) {
X	/* We have a name to set! */
X		for (i = 0; i < TERMCOUNT; i++) {
X   			if (!strncmp("regis",term_tbl[i].name,5)) {
X				t = i;
X			}
X		}
X		if (t != -1)
X			term = t;
X	}
X}
X
X
X/*
X	This is always defined so we don't have to have command.c know if it
X	is there or not.
X*/
X#ifndef UNIXPLOT
XUP_redirect(caller) int caller; {}
X#else
XUP_redirect (caller)
Xint caller;
X/*
X	Unixplot can't really write to outfile--it wants to write to stdout.
X	This is normally ok, but the original design of gnuplot gives us
X	little choice.  Originally users of unixplot had to anticipate
X	their needs and redirect all I/O to a file...  Not very gnuplot-like.
X
X	caller:  1 - called from SET OUTPUT "FOO.OUT"
X			 2 - called from SET TERM UNIXPLOT
X			 3 - called from SET TERM other
X			 4 - called from SET OUTPUT
X*/
X{
X	switch (caller) {
X	case 1:
X	/* Don't save, just replace stdout w/outfile (save was already done). */
X		if (unixplot)
X			*(stdout) = *(outfile);  /* Copy FILE structure */
X	break;
X	case 2:
X		if (!unixplot) {
X			fflush(stdout);
X			save_stdout = *(stdout);
X			*(stdout) = *(outfile);  /* Copy FILE structure */
X			unixplot = 1;
X		}
X	break;
X	case 3:
X	/* New terminal in use--put stdout back to original. */
X		closepl();
X		fflush(stdout);
X		*(stdout) = save_stdout;  /* Copy FILE structure */
X		unixplot = 0;
X	break;
X	case 4:
X	/*  User really wants to go to normal output... */
X		if (unixplot) {
X			fflush(stdout);
X			*(stdout) = save_stdout;  /* Copy FILE structure */
X		}
X	break;
X	}
X}
X#endif
END_OF_FILE
if test 19496 -ne `wc -c <'term.c'`; then
    echo shar: \"'term.c'\" unpacked with wrong size!
fi
# end of 'term.c'
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
