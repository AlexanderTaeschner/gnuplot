Newsgroups: comp.sources.misc
From: allbery@uunet.UU.NET (Brandon S. Allbery - comp.sources.misc)
Subject: v08i037: GnuPlot v1.10A (part 3 of 7)
Reply-To: canoaf@ntvax.UUCP (Augustine Cano)

Posting-number: Volume 8, Issue 37
Submitted-by: canoaf@ntvax.UUCP (Augustine Cano)
Archive-name: gnuplot1.10A/part03

[OOPS!!!  I had to patch these after receiving them -- and managed to lose the
name of the person who submitted them in the process.  Duh.  The name shown
is a "best guess".  Submitter, please correct me.  ++bsa]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 7)."
# Contents:  make.msc makefile.3b1 makefile.tc makefile.unx misc.c
#   parse.c pc.trm pcgraph.asm
# Wrapped by allbery@uunet on Sat Sep  9 13:47:21 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'make.msc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make.msc'\"
else
echo shar: Extracting \"'make.msc'\" \(1136 characters\)
sed "s/^X//" >'make.msc' <<'END_OF_FILE'
XOBJS = 	command.obj eval.obj graphics.obj internal.obj misc.obj parse.obj plot.obj scanner.obj standard.obj term.obj util.obj version.obj pcgraph.asm corgraph.asm hrcgraph.asm
X
X# /AC means use compact model (small code, large data)
XCFLAGS = /AC /DPC #/Zi #/Od
X
XTERMFLAGS = /DHERCULES /DATT6300 /DCORONA /DPOSTSCRIPT /DHP75 /DTEK /DV384 /DEGALIB
X
XLINKFLAGS = #/codeview
X
X# default rules
X.c.obj:
X	msc $(CFLAGS) $*;
X
X.asm.obj:
X	masm $*;
X
Xpcgraph.obj: pcgraph.asm header.mac lineproc.mac
X
Xcorgraph.obj: corgraph.asm header.mac lineproc.mac
X
Xhrcgraph.obj: hrcgraph.asm header.mac lineproc.mac
X
Xcommand.obj: command.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgraphics.obj: graphics.c plot.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h
X
Xparse.obj: parse.c plot.h
X
Xplot.obj: plot.c plot.h
X
Xscanner.obj: scanner.c plot.h
X
Xstandard.obj: standard.c plot.h
X
Xterm.obj: term.c plot.h
X	msc $(CFLAGS) $(TERMFLAGS) term;
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
X
X# use link.opt to avoid command-line overflow
X
Xgnuplot.exe: $(OBJS)
X link$(LINKFLAGS) @link.opt
X exepack gnuplot.exe gnupack.exe
X del gnuplot.exe
X ren gnupack.exe gnuplot.exe
END_OF_FILE
if test 1136 -ne `wc -c <'make.msc'`; then
    echo shar: \"'make.msc'\" unpacked with wrong size!
fi
# end of 'make.msc'
fi
if test -f 'makefile.3b1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.3b1'\"
else
echo shar: Extracting \"'makefile.3b1'\" \(3933 characters\)
sed "s/^X//" >'makefile.3b1' <<'END_OF_FILE'
X# "make all" will compile all the necessary programs, gnuplot itself, the
X# help system and helptree (to make the help tree out of the flat file.)
X#
X# "make install will install all the necessary pieces to run gnuplot
X# successfully.  This includes creating the help tree in /usr/local/help.
X
X# If you do not wish the destinations of the executable and manual page to
X# be at the default locations (see below), feel free to change them.
X# The location of the help system and help tree also have default values.
X# If you want them somewhere else or would like to test the whole system
X# before you run "make install", you have to set environment variables so
X# that gnuplot finds them.  See README.3B1 for details.
X
X# where to install executable on 'make install'
XDEST=/usr/local/bin/gnuplot
X# where to install man page on 'make man_install'
XMANDEST=/usr/man/man1/gnuplot.1
X
X# -DFORK if you have vfork()
X# -DBCOPY if your memcpy() is called bcopy() (a Berkeleyism, right?)
X# -DNOCOPY if you don't have a memcpy() by any name
X# -DGAMMA if you've got gamma(3)
X# -O if you trust your compiler's optimizer
XCFLAGS = -DGAMMA -DUNIXPC -O # -gx # debug it.
X
X# -D<terminal> in TERMFLAGS iff you wish to support <terminal>
X# -DAED         AED 512 and AED 767
X# -DBITGRAPH    BBN BitGraph
X# -DHP26        HP2623A and maybe others
X# -DHP75        HP7580, and probably other HPs
X# -DHPLJET      HP LaserJet laserprinter
X# -DPOSTSCRIPT  Postscript
X# -DQMS         QMS/QUIC laserprinter (Talaris 1200 and others)
X# -DREGIS       ReGis graphics (vt125, vt220, vt240, Gigis...)
X# -DSELANAR     Selanar
X# -DTEK         Tektronix 4010, and probably others
X# -DUNIXPC      unixpc (ATT 3b1 or ATT 7300)
X# -DUNIXPLOT    unixplot
X# -DV384        Vectrix 384 and tandy color printer
X
XTERMFLAGS = -DUNIXPC -DUNIXPLOT
X
X
XOBJS = 	command.o eval.o graphics.o internal.o misc.o parse.o plot.o scanner.o\
X    standard.o term.o util.o
X
X# -lplot if you have -DUNIXPLOT
XLIBS = -lm -lplot
X
X# If you do not wish to compile the help system or make the help directory
X# tree, feel free to comment out the appropriate lines that do it.
X
Xall:	gnuplot help_system doc_tree
X
Xgnuplot: $(OBJS) version.o
X	ld /lib/crt0s.o /lib/shlib.ifile $(OBJS) version.o $(LIBS) -o gnuplot
X
Xhelp_system:
X	( cd help ; make )
X
Xdoc_tree:
X	( cd docs ; make helptree )
X
X# note that directory /usr/local/help must exist for the help tree
X# to be created
Xinstall: gnuplot help_system doc_tree man_install
X	cp gnuplot $(DEST)
X	strip $(DEST)
X	docs/helptree -t /usr/local/help/gnuplot < docs/gnuplot.hlp
X	cd help; make install
X
Xman_install: gnuplot.1
X	cp gnuplot.1 $(MANDEST)
X
Xterm.o: term.c aed.trm bitgraph.trm hp26.trm hp75.trm hpljet.trm pc.trm \
X	postscpt.trm qms.trm regis.trm selanar.trm tek.trm unixpc.trm \
X	unixplot.trm v384.trm
X	cc $(CFLAGS) $(TERMFLAGS) -c term.c
X
X
X$(OBJS): plot.h
X
Xclean:
X	rm -f *.o gnuplot
X
X	( cd help ; make clean )
X	( cd docs ; make clean )
X
Xspotless:
X	rm -f *.o gnuplot Makefile help/Makefile
X
X	( cd help ; make clean -f makefile.unx )
X	( cd docs ; make clean )
X
X#
X# if you have the Rich $alz shar package, you can use this make shar section.
X#
X
Xshars:	spotless shar/gnuplot.shar.1 shar/gnuplot.shar.2 \
X	shar/gnuplot.shar.3 shar/gnuplot.shar.4 shar/gnuplot.shar.5 \
X	shar/gnuplot.shar.6 shar/gnuplot.shar.7
X
Xshar/gnuplot.shar.1: [1-9]* [A-Z]* [a-f]*
X	shar -n1 -e7 [1-9]* [A-Z]* [a-f]* > shar/gnuplot.shar.1
X
Xshar/gnuplot.shar.2: [g-l]*
X	shar -n2 -e7 [g-l]* > shar/gnuplot.shar.2
X
Xshar/gnuplot.shar.3: [m-o]* p[a-i]*
X	shar -n3 -e7 [m-o]* p[a-i]* > shar/gnuplot.shar.3
X
Xshar/gnuplot.shar.4: p[j-z]* [q-t]*
X	shar -n4 -e7 p[j-z]* [q-t]* > shar/gnuplot.shar.4
X
Xshar/gnuplot.shar.5: [u-z]*
X	shar -n5 -e7 [u-z]* > shar/gnuplot.shar.5
X
Xshar/gnuplot.shar.6: docs/[A-Z]* docs/[a-g]*
X	cd docs; make clean; cd ..
X	shar -n6 -e7 docs docs/[A-Z]* docs/[a-g]* > shar/gnuplot.shar.6
X
Xshar/gnuplot.shar.7: docs/[h-z]* help/*
X	shar -n7 -e7 docs/[h-z]* help help/* > shar/gnuplot.shar.7
X
END_OF_FILE
if test 3933 -ne `wc -c <'makefile.3b1'`; then
    echo shar: \"'makefile.3b1'\" unpacked with wrong size!
fi
# end of 'makefile.3b1'
fi
if test -f 'makefile.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.tc'\"
else
echo shar: Extracting \"'makefile.tc'\" \(1127 characters\)
sed "s/^X//" >'makefile.tc' <<'END_OF_FILE'
X# make file for Turbo C
X# Modified from MSC make by John Campbell and Bill Wilson
X# The compile and link includes debug flags.  Take them out if you
X# do not want them included
X
XOBJS = 	command.obj eval.obj graphics.obj internal.obj misc.obj parse.obj plot.obj scanner.obj standard.obj term.obj util.obj version.obj 
X
Xgnuplot.exe: $(OBJS) 
X tlink /m /s /v /l @link.otc
X
X# /AC means use compact model (small code, large data)
XCFLAGS = -c -f -ml -M -y -v -I\tc\include -DMSDOS -DPC
XTERMFLAGS = 
X# -DHERCULES -DCGA
X
X# default rules
X.c.obj:
X	tcc $(CFLAGS) $*
X
Xcommand.obj: command.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgraphics.obj: graphics.c plot.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h
X
Xparse.obj: parse.c plot.h
X
Xplot.obj: plot.c plot.h
X
Xscanner.obj: scanner.c plot.h
X
Xstandard.obj: standard.c plot.h
X
Xterm.obj: term.c plot.h \
X	aed.trm bitgraph.trm hp26.trm hp75.trm hpljet.trm pc.trm \
X	postscpt.trm qms.trm regis.trm selanar.trm tek.trm unixpc.trm \
X	unixplot.trm v384.trm
X	tcc $(CFLAGS) $(TERMFLAGS) term.c
X	
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
X
X# use link.opt to avoid command-line overflow
X
END_OF_FILE
if test 1127 -ne `wc -c <'makefile.tc'`; then
    echo shar: \"'makefile.tc'\" unpacked with wrong size!
fi
# end of 'makefile.tc'
fi
if test -f 'makefile.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.unx'\"
else
echo shar: Extracting \"'makefile.unx'\" \(3970 characters\)
sed "s/^X//" >'makefile.unx' <<'END_OF_FILE'
X# "make all" will compile all the necessary programs, gnuplot itself, the
X# help system and helptree (to make the help tree out of the flat file.)
X#
X# "make install will install all the necessary pieces to run gnuplot
X# successfully.  This includes creating the help tree in /usr/local/help.
X
X# If you do not wish the destinations of the executable and manual page to
X# be at the default locations (see below), feel free to change them.
X# The location of the help system and help tree also have default values.
X# If you want them somewhere else or would like to test the whole system
X# before you run "make install", you have to set environment variables so
X# that gnuplot finds them.  See README.3B1 for details.
X
X# where to install executable on 'make install'
XDEST=/usr/local/bin/gnuplot
X# where to install man page on 'make man_install'
XMANDEST=/usr/man/man1/gnuplot.1
X
X# -DFORK if you have vfork()
X# -DBCOPY if your memcpy() is called bcopy() (a Berkeleyism, right?)
X# -DNOCOPY if you don't have a memcpy() by any name
X# -DGAMMA if you've got gamma(3)
X# -O if you trust your compiler's optimizer
XCFLAGS = -DVFORK -DBCOPY -DGAMMA #-gx #-O
X
X# -D<terminal> in TERMFLAGS iff you wish to support <terminal>
X# -DAED         AED 512 and AED 767
X# -DBITGRAPH    BBN BitGraph
X# -DHP26        HP2623A and maybe others
X# -DHP75        HP7580, and probably other HPs
X# -DHPLJET      HP LaserJet laserprinter
X# -DPOSTSCRIPT  Postscript
X# -DQMS         QMS/QUIC laserprinter (Talaris 1200 and others)
X# -DREGIS       ReGis graphics (vt125, vt220, vt240, Gigis...)
X# -DSELANAR     Selanar
X# -DTEK         Tektronix 4010, and probably others
X# -DUNIXPC      unixpc (ATT 3b1 or ATT 7300)
X# -DUNIXPLOT    unixplot
X# -DV384        Vectrix 384 and tandy color printer
X
XTERMFLAGS = -DAED -DBITGRAPH -DHP26 -DHP75 -DPOSTSCRIPT -DQMS -DREGIS -DSELANAR -DTEK -DUNIXPLOT -DV384
X
X
XOBJS = 	command.o eval.o graphics.o internal.o misc.o parse.o plot.o scanner.o\
X    standard.o term.o util.o
X
X# -lplot if you have -DUNIXPLOT
XLIBS = -lm -lplot
X
X# If you do not wish to compile the help system or make the help directory
X# tree, feel free to comment out the appropriate lines that do it.
X
Xall:	gnuplot help_system doc_tree
X
Xgnuplot: $(OBJS) version.o
X	cc $(OBJS) version.o $(LIBS) -o gnuplot
X
Xhelp_system:
X	( cd help ; make )
X
Xdoc_tree:
X	( cd docs ; make helptree )
X
X# note that directory /usr/local/help must exist for the help tree
X# to be created
Xinstall: gnuplot help_system doc_tree man_install
X	cp gnuplot $(DEST)
X	strip $(DEST)
X	docs/helptree -t /usr/local/help/gnuplot < docs/gnuplot.hlp
X	cd help; make install
X
Xman_install: gnuplot.1
X	cp gnuplot.1 $(MANDEST)
X
Xterm.o: term.c aed.trm bitgraph.trm hp26.trm hp75.trm hpljet.trm pc.trm \
X	postscpt.trm qms.trm regis.trm selanar.trm tek.trm unixpc.trm \
X	unixplot.trm v384.trm
X	cc $(CFLAGS) $(TERMFLAGS) -c term.c
X
X
X$(OBJS): plot.h
X
Xclean:
X	rm -f *.o gnuplot
X
X	( cd help ; make clean )
X	( cd docs ; make clean )
X
Xspotless:
X	rm -f *.o gnuplot Makefile help/Makefile
X
X	( cd help ; make clean -f makefile.unx )
X	( cd docs ; make clean )
X
X#
X# if you have the Rich $alz shar package, you can use this make shar section.
X#
X
Xshars:	spotless shar/gnuplot.shar.1 shar/gnuplot.shar.2 \
X	shar/gnuplot.shar.3 shar/gnuplot.shar.4 shar/gnuplot.shar.5 \
X	shar/gnuplot.shar.6 shar/gnuplot.shar.7
X
Xshar/gnuplot.shar.1: [1-9]* [A-Z]* [a-f]*
X	shar -n1 -e7 [1-9]* [A-Z]* [a-f]* > shar/gnuplot.shar.1
X
Xshar/gnuplot.shar.2: [g-l]*
X	shar -n2 -e7 [g-l]* > shar/gnuplot.shar.2
X
Xshar/gnuplot.shar.3: [m-o]* p[a-i]*
X	shar -n3 -e7 [m-o]* p[a-i]* > shar/gnuplot.shar.3
X
Xshar/gnuplot.shar.4: p[j-z]* [q-t]*
X	shar -n4 -e7 p[j-z]* [q-t]* > shar/gnuplot.shar.4
X
Xshar/gnuplot.shar.5: [u-z]*
X	shar -n5 -e7 [u-z]* > shar/gnuplot.shar.5
X
Xshar/gnuplot.shar.6: docs/[A-Z]* docs/[a-g]*
X	cd docs; make clean; cd ..
X	shar -n6 -e7 docs docs/[A-Z]* docs/[a-g]* > shar/gnuplot.shar.6
X
Xshar/gnuplot.shar.7: docs/[h-z]* help/*
X	shar -n7 -e7 docs/[h-z]* help help/* > shar/gnuplot.shar.7
X
END_OF_FILE
if test 3970 -ne `wc -c <'makefile.unx'`; then
    echo shar: \"'makefile.unx'\" unpacked with wrong size!
fi
# end of 'makefile.unx'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
echo shar: Extracting \"'misc.c'\" \(6275 characters\)
sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  misc.c
X *
X *  Copyright (C) 1986, 1987  Thomas Williams, Colin Kelley
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <stdio.h>
X#include "plot.h"
X#ifdef __TURBOC__
X#include <graphics.h>
X#endif
X
Xextern BOOLEAN autoscale;
Xextern BOOLEAN polar;
Xextern BOOLEAN log_x, log_y;
Xextern FILE* outfile;
Xextern char outstr[];
Xextern int samples;
Xextern int term;
Xextern double zero;
Xextern double roff, loff, toff, boff;
X
Xextern BOOLEAN screen_ok;
X
Xextern int c_token;
Xextern struct at_type at;
Xextern struct ft_entry ft[];
Xextern struct udft_entry *first_udf;
Xextern struct udvt_entry *first_udv;
Xextern struct termentry term_tbl[];
X
Xchar *malloc();
X
Xstruct at_type *temp_at();
X
X
X/*
X * cp_free() releases any memory which was previously malloc()'d to hold
X *   curve points.
X */
Xcp_free(cp)
Xstruct curve_points *cp;
X{
X	if (cp) {
X		cp_free(cp->next_cp);
X		if (cp->title)
X			free((char *)cp->title);
X		free((char *)cp);
X	}
X}
X
X
X
Xsave_functions(fp)
XFILE *fp;
X{
Xregister struct udft_entry *udf = first_udf;
X	
X	if (fp) {
X		while (udf) {
X			if (udf->definition)
X				fprintf(fp,"%s\n",udf->definition);
X			udf = udf->next_udf;
X		}
X		(void) fclose(fp);
X	} else
X		os_error("Cannot open save file",c_token);			
X}
X
X
Xsave_variables(fp)
XFILE *fp;
X{
Xregister struct udvt_entry *udv = first_udv->next_udv;	/* skip pi */
X
X	if (fp) {
X		while (udv) {
X			if (!udv->udv_undef) {
X				fprintf(fp,"%s = ",udv->udv_name);
X				disp_value(fp,&(udv->udv_value));
X				(void) putc('\n',fp);
X			}
X			udv = udv->next_udv;
X		}
X		(void) fclose(fp);
X	} else
X		os_error("Cannot open save file",c_token);			
X}
X
X
Xsave_all(fp)
XFILE *fp;
X{
Xregister struct udft_entry *udf = first_udf;
Xregister struct udvt_entry *udv = first_udv->next_udv;	/* skip pi */
X
X	if (fp) {
X		while (udf) {
X			if (udf->definition)
X				fprintf(fp,"%s\n",udf->definition);
X			udf = udf->next_udf;
X		}
X		while (udv) {
X			if (!udv->udv_undef) {
X				fprintf(fp,"%s = ",udv->udv_name);
X				disp_value(fp,&(udv->udv_value));
X				(void) putc('\n',fp);
X			}
X			udv = udv->next_udv;
X		}
X		(void) fclose(fp);
X	} else
X		os_error("Cannot open save file",c_token);			
X}
X
X
Xload_file(fp)
XFILE *fp;
X{
Xregister int len;
Xextern char input_line[];
X
X	if (fp) {
X		while (fgets(input_line,MAX_LINE_LEN,fp)) {
X			len = strlen(input_line) - 1;
X			if (input_line[len] == '\n')
X				input_line[len] = '\0';
X
X			screen_ok = FALSE;	/* make sure command line is
X					   echoed on error */
X			do_line();
X		}
X		(void) fclose(fp);
X	} else
X		os_error("Cannot open load file",c_token);
X}
X
X
Xshow_style(name,style)
Xchar name[];
Xenum PLOT_STYLE style;
X{
X	fprintf(stderr,"\t%s are plotted with ",name);
X	switch (style) {
X		case LINES: fprintf(stderr,"lines\n"); break;
X		case POINTS: fprintf(stderr,"points\n"); break;
X		case IMPULSES: fprintf(stderr,"impulses\n"); break;
X	}
X}
X
Xshow_range(name,min,max)
Xchar name;
Xdouble min,max;
X{
X	fprintf(stderr,"\t%crange is [%g : %g]\n",name,min,max);
X}
X
Xshow_zero()
X{
X	fprintf(stderr,"\tzero is %g\n",zero);
X}
X
Xshow_offsets()
X{
X	fprintf(stderr,"\toffsets are %g, %g, %g, %g\n",roff,loff,toff,boff);
X}
X
Xshow_samples()
X{
X	fprintf(stderr,"\tsampling rate is %d\n",samples);
X}
X
Xshow_output()
X{
X	fprintf(stderr,"\toutput is sent to %s\n",outstr);
X}
X
Xshow_term()
X{
X	fprintf(stderr,"\tterminal type is %s\n",term_tbl[term].name);
X}
X
Xshow_polar()
X{
X	if (polar)
X		fprintf(stderr,"\tPolar coordinates are in effect\n");
X	else
X		fprintf(stderr,"\tRectangular coordinates are in effect\n");
X}
X
Xshow_autoscale()
X{
X	fprintf(stderr,"\tautoscaling is %s\n",(autoscale)? "ON" : "OFF");
X}
X
Xshow_logscale()
X{
X	if (log_x && log_y)
X		fprintf(stderr,"\tlogscaling both x and y axes\n");
X	else if (log_x)
X		fprintf(stderr,"\tlogscaling x axis\n");
X	else if (log_y)
X		fprintf(stderr,"\tlogscaling y axis\n");
X	else
X		fprintf(stderr,"\tno logscaling\n");
X}
X
Xshow_variables()
X{
Xregister struct udvt_entry *udv = first_udv;
X
X	fprintf(stderr,"\n\tVariables:\n");
X	while (udv) {
X		fprintf(stderr,"\t%-*s ",MAX_ID_LEN,udv->udv_name);
X		if (udv->udv_undef)
X			fputs("is undefined\n",stderr);
X		else {
X			fputs("= ",stderr);
X			disp_value(stderr,&(udv->udv_value));
X			(void) putc('\n',stderr);
X		}
X		udv = udv->next_udv;
X	}
X}
X
X
Xshow_functions()
X{
Xregister struct udft_entry *udf = first_udf;
X
X	fprintf(stderr,"\n\tUser-Defined Functions:\n");
X
X	while (udf) {
X		if (udf->definition)
X			fprintf(stderr,"\t%s\n",udf->definition);
X		else
X			fprintf(stderr,"\t%s is undefined\n",udf->udf_name);
X		udf = udf->next_udf;
X	}
X}
X
X
Xshow_at()
X{
X	(void) putc('\n',stderr);
X	disp_at(temp_at(),0);
X}
X
X
Xdisp_at(curr_at, level)
Xstruct at_type *curr_at;
Xint level;
X{
Xregister int i, j;
Xregister union argument *arg;
X
X	for (i = 0; i < curr_at->a_count; i++) {
X		(void) putc('\t',stderr);
X		for (j = 0; j < level; j++)
X			(void) putc(' ',stderr);	/* indent */
X
X			/* print name of instruction */
X
X		fputs(ft[(int)(curr_at->actions[i].index)].f_name,stderr);
X		arg = &(curr_at->actions[i].arg);
X
X			/* now print optional argument */
X
X		switch(curr_at->actions[i].index) {
X		  case PUSH:	fprintf(stderr," %s\n", arg->udv_arg->udv_name);
X					break;
X		  case PUSHC:	(void) putc(' ',stderr);
X					disp_value(stderr,&(arg->v_arg));
X					(void) putc('\n',stderr);
X					break;
X		  case PUSHD:	fprintf(stderr," %s dummy\n",
X					  arg->udf_arg->udf_name);
X					break;
X		  case CALL:	fprintf(stderr," %s", arg->udf_arg->udf_name);
X					if (arg->udf_arg->at) {
X						(void) putc('\n',stderr);
X						disp_at(arg->udf_arg->at,level+2); /* recurse! */
X					} else
X						fputs(" (undefined)\n",stderr);
X					break;
X		  case JUMP:
X		  case JUMPZ:
X		  case JUMPNZ:
X		  case JTERN:
X					fprintf(stderr," +%d\n",arg->j_arg);
X					break;
X		  default:
X					(void) putc('\n',stderr);
X		}
X	}
X}
X
X
Xshow_version()
X{
Xextern char version[];
Xextern char date[];
Xstatic char *authors[] = {"Thomas Williams","Colin Kelley"};
Xint x;
Xlong time();
X
X	x = time((long *)NULL) & 1;
X	fprintf(stderr,"\n\t%s\n\t%sversion %s\n\tlast modified %s\n",
X		PROGRAM, OS, version, date);
X	fprintf(stderr,"\tCopyright (C) 1986, 1987  %s, %s\n\n",
X		authors[x],authors[1-x]);
X}
END_OF_FILE
if test 6275 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
fi
# end of 'misc.c'
fi
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(7828 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X/*
X *
X *    G N U P L O T  --  parse.c
X *
X *  Copyright (C) 1986, 1987  Colin Kelley, Thomas Williams
X *
X *  You may use this code as you wish if credit is given and this message
X *  is retained.
X *
X *  Please e-mail any useful additions to vu-vlsi!plot so they may be
X *  included in later releases.
X *
X *  This file should be edited with 4-column tabs!  (:set ts=4 sw=4 in vi)
X */
X
X#include <stdio.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <errno.h>
X#include "plot.h"
X
Xextern BOOLEAN undefined;
X
X#ifndef vms
Xextern int errno;
X#endif
X
Xextern int num_tokens,c_token;
Xextern struct lexical_unit token[];
Xextern char c_dummy_var[];			/* name of current dummy variable */
Xextern struct udft_entry *dummy_func;	/* pointer to dummy variable's func */
X
Xchar *malloc();
X
Xstruct value *pop(),*integer(),*complex();
Xstruct at_type *temp_at(), *perm_at();
Xstruct udft_entry *add_udf();
Xstruct udvt_entry *add_udv();
Xunion argument *add_action();
X
Xstruct at_type at;
Xstatic jmp_buf fpe_env;
X
X#define dummy (struct value *) 0
X#ifdef __TURBOC__
Xvoid fpe(int xXx)
X#else
Xfpe()
X#endif
X{
X#ifdef PC	/* thanks to lotto@wjh12.UUCP for telling us about this  */
X	_fpreset();
X#endif
X	(void) signal(SIGFPE, fpe);
X	undefined = TRUE;
X	longjmp(fpe_env, TRUE);
X}
X
X
Xevaluate_at(at_ptr,val_ptr)
Xstruct at_type *at_ptr;
Xstruct value *val_ptr;
X{
X	undefined = FALSE;
X	errno = 0;
X	reset_stack();
X	if (setjmp(fpe_env))
X		return;				/* just bail out */
X	(void) signal(SIGFPE, fpe);	/* catch core dumps on FPEs */
X
X	execute_at(at_ptr);
X
X	(void) signal(SIGFPE, SIG_DFL);
X
X	if (errno == EDOM || errno == ERANGE) {
X		undefined = TRUE;
X	} else {
X		(void) pop(val_ptr);
X		check_stack();
X	}
X}
X
X
Xstruct value *
Xconst_express(valptr)
Xstruct value *valptr;
X{
Xregister int tkn = c_token;
X	if (END_OF_COMMAND)
X		int_error("constant expression required",c_token);
X	evaluate_at(temp_at(),valptr);	/* run it and send answer back */
X	if (undefined) {
X		int_error("undefined value",tkn);
X	}
X	return(valptr);
X}
X
X
Xstruct at_type *
Xtemp_at()	/* build a static action table and return its pointer */
X{
X	at.a_count = 0;		/* reset action table !!! */
X	express();
X	return(&at);
X}
X
X
X/* build an action table, put it in dynamic memory, and return its pointer */
X
Xstruct at_type *
Xperm_at()
X{
Xregister struct at_type *at_ptr;
Xregister unsigned int len;
X
X	(void) temp_at();
X	len = sizeof(struct at_type) -
X		(MAX_AT_LEN - at.a_count)*sizeof(struct at_entry);
X	if (at_ptr = (struct at_type *) malloc(len))
X		(void) memcpy(at_ptr,&at,len);
X	return(at_ptr);
X}
X
X
X#ifdef NOCOPY
X/*
X * cheap and slow version of memcpy() in case you don't have one
X */
Xmemcpy(dest,src,len)
Xchar *dest,*src;
Xunsigned int len;
X{
X	while (len--)
X		*dest++ = *src++;
X}
X#endif /* NOCOPY */
X
X
Xexpress()  /* full expressions */
X{
X	xterm();
X	xterms();
X}
X
Xxterm()  /* ? : expressions */
X{
X	aterm();
X	aterms();
X}
X
X
Xaterm()
X{
X	bterm();
X	bterms();
X}
X
X
Xbterm()
X{
X	cterm();
X	cterms();
X}
X
X
Xcterm()
X{
X	dterm();
X	dterms();
X}
X
X
Xdterm()
X{	
X	eterm();
X	eterms();
X}
X
X
Xeterm()
X{
X	fterm();
X	fterms();
X}
X
X
Xfterm()
X{
X	gterm();
X	gterms();
X}
X
X
Xgterm()
X{
X	hterm();
X	hterms();
X}
X
X
Xhterm()
X{
X	unary(); /* - things */
X	iterms(); /* * / % */
X}
X
X
Xfactor()
X{
Xregister int value;
X
X	if (equals(c_token,"(")) {
X		c_token++;
X		express();
X		if (!equals(c_token,")"))
X			int_error("')' expected",c_token);
X		c_token++;
X	}
X	else if (isnumber(c_token)) {
X		convert(&(add_action(PUSHC)->v_arg),c_token);
X		c_token++;
X	}
X	else if (isletter(c_token)) {
X		if ((c_token+1 < num_tokens)  && equals(c_token+1,"(")) {
X			value = standard(c_token);
X			if (value) {	/* it's a standard function */
X				c_token += 2;
X				express();
X				if (!equals(c_token,")"))
X					int_error("')' expected",c_token);
X				c_token++;
X				(void) add_action(value);
X			}
X			else {
X				value = c_token;
X				c_token += 2;
X				express();
X				if (!equals(c_token,")"))
X					int_error("')' expected",c_token);
X				c_token++;
X				add_action(CALL)->udf_arg = add_udf(value);
X			}
X		}
X		else {
X			if (equals(c_token,c_dummy_var)) {
X				c_token++;
X				add_action(PUSHD)->udf_arg = dummy_func;
X			}
X			else {
X				add_action(PUSH)->udv_arg = add_udv(c_token);
X				c_token++;
X			}
X		}
X	} /* end if letter */
X	else
X		int_error("invalid expression ",c_token);
X
X	/* add action code for ! (factorial) operator */
X	while (equals(c_token,"!")) {
X		c_token++;
X		(void) add_action(FACTORIAL);
X	}
X	/* add action code for ** operator */
X	if (equals(c_token,"**")) {
X			c_token++;
X			unary();
X			(void) add_action(POWER);
X	}
X
X}
X
X
X
Xxterms()
X{  /* create action code for ? : expressions */
X
X	if (equals(c_token,"?")) {
X		register int savepc1, savepc2;
X		register union argument *argptr1,*argptr2;
X		c_token++;
X		savepc1 = at.a_count;
X		argptr1 = add_action(JTERN);
X		express();
X		if (!equals(c_token,":"))
X			int_error("expecting ':'",c_token);
X		c_token++;
X		savepc2 = at.a_count;
X		argptr2 = add_action(JUMP);
X		argptr1->j_arg = at.a_count - savepc1;
X		express();
X		argptr2->j_arg = at.a_count - savepc2;
X	}
X}
X
X
Xaterms()
X{  /* create action codes for || operator */
X
X	while (equals(c_token,"||")) {
X		register int savepc;
X		register union argument *argptr;
X		c_token++;
X		savepc = at.a_count;
X		argptr = add_action(JUMPNZ);	/* short-circuit if already TRUE */
X		aterm();
X		argptr->j_arg = at.a_count - savepc;/* offset for jump */
X		(void) add_action(BOOL);
X	}
X}
X
X
Xbterms()
X{ /* create action code for && operator */
X
X	while (equals(c_token,"&&")) {
X		register int savepc;
X		register union argument *argptr;
X		c_token++;
X		savepc = at.a_count;
X		argptr = add_action(JUMPZ);	/* short-circuit if already FALSE */
X		bterm();
X		argptr->j_arg = at.a_count - savepc;/* offset for jump */
X		(void) add_action(BOOL);
X	}
X}
X
X
Xcterms()
X{ /* create action code for | operator */
X
X	while (equals(c_token,"|")) {
X		c_token++;
X		cterm();
X		(void) add_action(BOR);
X	}
X}
X
X
Xdterms()
X{ /* create action code for ^ operator */
X
X	while (equals(c_token,"^")) {
X		c_token++;
X		dterm();
X		(void) add_action(XOR);
X	}
X}
X
X
Xeterms()
X{ /* create action code for & operator */
X
X	while (equals(c_token,"&")) {
X		c_token++;
X		eterm();
X		(void) add_action(BAND);
X	}
X}
X
X
Xfterms()
X{ /* create action codes for == and != operators */
X
X	while (TRUE) {
X		if (equals(c_token,"==")) {
X			c_token++;
X			fterm();
X			(void) add_action(EQ);
X		}
X		else if (equals(c_token,"!=")) {
X			c_token++;
X			fterm();
X			(void) add_action(NE);
X		}
X		else break;
X	}
X}
X
X
Xgterms()
X{ /* create action code for < > >= or <= operators */
X	
X	while (TRUE) {
X		/* I hate "else if" statements */
X		if (equals(c_token,">")) {
X			c_token++;
X			gterm();
X			(void) add_action(GT);
X		}
X		else if (equals(c_token,"<")) {
X			c_token++;
X			gterm();
X			(void) add_action(LT);
X		}		
X		else if (equals(c_token,">=")) {
X			c_token++;
X			gterm();
X			(void) add_action(GE);
X		}
X		else if (equals(c_token,"<=")) {
X			c_token++;
X			gterm();
X			(void) add_action(LE);
X		}
X		else break;
X	}
X
X}
X
X
X
Xhterms()
X{ /* create action codes for + and - operators */
X
X	while (TRUE) {
X			if (equals(c_token,"+")) {
X				c_token++;
X				hterm();
X				(void) add_action(PLUS);
X			}
X			else if (equals(c_token,"-")) {
X				c_token++;
X				hterm();
X				(void) add_action(MINUS);
X			}
X			else break;
X	}
X}
X
X
Xiterms()
X{ /* add action code for * / and % operators */
X
X	while (TRUE) {
X			if (equals(c_token,"*")) {
X				c_token++;
X				unary();
X				(void) add_action(MULT);
X			}
X			else if (equals(c_token,"/")) {
X				c_token++;
X				unary();
X				(void) add_action(DIV);
X			}
X			else if (equals(c_token,"%")) {
X				c_token++;
X				unary();
X				(void) add_action(MOD);
X			}
X			else break;
X	}
X}
X
X
Xunary()
X{ /* add code for unary operators */
X	if (equals(c_token,"!")) {
X		c_token++;
X		unary();
X		(void) add_action(LNOT);
X	}
X	else if (equals(c_token,"~")) {
X		c_token++;
X		unary();
X		(void) add_action(BNOT);
X	}
X	else if (equals(c_token,"-")) {
X		c_token++;
X		unary();
X		(void) add_action(UMINUS);
X	}
X	else
X		factor();
X}
END_OF_FILE
if test 7828 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
if test -f 'pc.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pc.trm'\"
else
echo shar: Extracting \"'pc.trm'\" \(15550 characters\)
sed "s/^X//" >'pc.trm' <<'END_OF_FILE'
X#ifdef __TURBOC__
X#include <graphics.h>
X#include <dos.h>
X#include <string.h>
X  int g_driver, g_mode, g_error;
X  char far *path;
X  char *pathp, path_s[128];
X
Xget_path()
X{
X   path=getenv("BGI");
X   if (path==NULL) {
X      strcpy(path_s,_argv[0]);
X      pathp=strrchr(path_s,'\\');
X      *pathp=0x00;
X      path=path_s;
X   }
X}
X
X#endif
X
X/* all of the Turbo C routines for the different graphics devices go here */
X
X#define EGALIB_XMAX 640
X#define EGALIB_YMAX 350
X
X#define EGALIB_XLAST (EGA_XMAX - 1)
X#define EGALIB_YLAST (EGA_YMAX - 1)
X
X#define EGALIB_VCHAR 14
X#define EGALIB_HCHAR 8
X#define EGALIB_VTIC 4
X#define EGALIB_HTIC 5
X
Xstatic int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
Xstatic int ega256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};
X
Xstatic int *egacolor;
X
Xstatic char near buf[80];	/* kludge since EGA.LIB is compiled SMALL */
X
Xstatic int pattern[] = {0xffff, 0x0f0f, 0xffff, 0xaaaa, 0x3333, 0x3f3f, 0x0f0f};
X
Xstatic int graphics_on = FALSE;
Xint startx, starty;
X
Xpause()								/* press any key to continue... */
X{
X	while (kbhit())
X		(void) getch();				/* flush the keyboard buffer */
X	while (!kbhit())
X		;
X}
X
X
XPC_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X#ifdef __TURBOC__
X	gotoxy(78-strlen(str),24-row);
X	puts(str);
X#else
X	PC_curloc(24-row,78-strlen(str));
X	PC_puts(str);
X#endif
X}
X
XPC_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X#ifdef __TURBOC__
X	gotoxy(2,row+1);
X	puts(str);
X#else
X	PC_curloc(row+1,2);
X	PC_puts(str);
X#endif
X}
X
XPC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X#ifdef __TURBOC__
X	closegraph();
X#else
X	Vmode(3);
X#endif
X}
X
XPC_reset()
X{
X#ifdef __TURBOC__
X	closegraph();
X#endif
X}
X
X
X#ifdef __TURBOC__ 
X
X#define VGA_XMAX 640
X#define VGA_YMAX 480
X
X#define VGA_XLAST (VGA_XMAX - 1)
X#define VGA_YLAST (VGA_YMAX - 1)
X
X#define VGA_VCHAR 14
X#define VGA_HCHAR 8
X#define VGA_VTIC 4
X#define VGA_HTIC 5
X
Xstatic int vga256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};
X
Xstatic int *vgacolor;
X
XVGA_init()
X{
X	g_driver=VGA;
X	g_mode=2;
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver!=9){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X            
X/*          int_error("color EGA board not found",NO_CARET);*/
X        }
X        if(g_driver==VGA) vgacolor=vga256color;
X}
X
XVGA_graphics()
X{       g_driver=VGA;
X	g_mode=2;
X	graphics_on = TRUE;
X	initgraph(&g_driver,&g_mode,path);
X}
X
XVGA_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	setcolor(vgacolor[linetype+2]);
X}
X
XVGA_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	outtextxy(630-(strlen(str)*8),450-row*16,buf);
X}
X
X#define VGA_reset EGALIB_reset
X#define VGA_text EGALIB_text
X#define VGA_move EGALIB_move
X#define VGA_vector EGALIB_vector
X#define VGA_ulput_text EGALIB_ulput_text
X
XVGAMONO_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
X#define MCGA_XMAX 640
X#define MCGA_YMAX 480
X
X#define MCGA_XLAST (MCGA_XMAX - 1)
X#define MCGA_YLAST (MCGA_YMAX - 1)
X
X#define MCGA_VCHAR 14
X#define MCGA_HCHAR 8
X#define MCGA_VTIC 4
X#define MCGA_HTIC 5
X
Xstatic int *MCGAcolor;
X
XMCGA_init()
X{
X	g_driver=MCGA;
X	g_mode=5;
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver!=2){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X            
X        }
X}
X
XMCGA_graphics()
X{       g_driver=MCGA;
X	g_mode=5;
X	graphics_on = TRUE;
X	initgraph(&g_driver,&g_mode,path);
X}
X
X
XMCGA_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	outtextxy(630-(strlen(str)*8),450-row*16,buf);
X}
X
X#define MCGA_reset EGALIB_reset
X#define MCGA_text EGALIB_text
X#define MCGA_move EGALIB_move
X#define MCGA_vector EGALIB_vector
X#define MCGA_ulput_text EGALIB_ulput_text
X
XMCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
X
XEGALIB_init()
X{
X	g_driver=EGA;
X	g_mode=1;
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver<3 || g_driver>4){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X            
X/*          int_error("color EGA board not found",NO_CARET);*/
X        }
X        if(g_driver==EGA) egacolor=ega256color;
X        if(g_driver==EGA64) egacolor=ega64color;
X}
X
XEGALIB_graphics()
X{
X	graphics_on = TRUE;
X	initgraph(&g_driver,&g_mode,path);
X}
X
XEGALIB_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	closegraph();
X}
X
XEGALIB_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	setcolor(egacolor[linetype+2]);
X}
X
XEGALIB_move(x,y)
X{
X        moveto(x,getmaxy()-y);
X}
X
X
XEGALIB_vector(x,y)
X{
X	lineto(x,getmaxy()-y);
X}
X
X
XEGALIB_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	outtextxy(630-(strlen(str)*8),320-row*16,buf);
X}
X
XEGALIB_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	outtextxy(10,row*16+16,buf);
X}
X
XEGALIB_reset()
X{
X  	closegraph();
X}
X
X#define CGA_XMAX 640
X#define CGA_YMAX 200
X
X#define CGA_XLAST (CGA_XMAX - 1)
X#define CGA_YLAST (CGA_YMAX - 1)
X
X#define CGA_VCHAR 8
X#define CGA_HCHAR 8
X#define CGA_VTIC 2
X#define CGA_HTIC 3
X
XCGA_init()
X{
X	g_driver=CGA;
X	g_mode=4;
X	initgraph(&g_driver,&g_mode,path);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X/*	PC_color(1);		 monochrome */
X
X}
X
XCGA_graphics()
X{
X	graphics_on = TRUE;
X	g_driver=CGA;
X	g_mode=4;
X	initgraph(&g_driver,&g_mode,path);
X	/*	Vmode(6);*/
X}
X
X#define CGA_text PC_text
X
XCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X/*	PC_mask(pattern[linetype+2]); */
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
XCGA_move(x,y)
X{
X	moveto(x,y);
X}
X
X
XCGA_vector(x,y)
X{
X	lineto(x,y);
X}
X
X#define CGA_lrput_text PC_lrput_text
X#define CGA_ulput_text PC_ulput_text
X
X
X#define CGA_reset PC_reset
X
X#define HERC_XMAX 720
X#define HERC_YMAX 348
X
X#define HERC_XLAST (HERC_XMAX - 1)
X#define HERC_YLAST (HERC_YMAX - 1)
X
X#define HERC_VCHAR 8
X#define HERC_HCHAR 8
X#define HERC_VTIC 4
X#define HERC_HTIC 4
X
XHERC_init()
X{
X	g_driver=HERCMONO;
X	g_mode=0;
X  	initgraph(&g_driver,&g_mode,path);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X}
X
XHERC_graphics()
X{
X	g_driver=HERCMONO;
X	g_mode=0;
X	initgraph(&g_driver,&g_mode,path);
X	graphics_on = TRUE;
X}
X
XHERC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	closegraph();
X}
X
XHERC_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X
X	setlinestyle(linetype,0,1);
X}
X
XHERC_move(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X	moveto(x,y);
X}
X
XHERC_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X
X	lineto(x,y);
X}
X
X/*
X   Thanks to James Dugal (jpd@usl.edu) for patching these two HERC 
X   routines.  (We need to remove the OLD (probably bad) code someday.)
X*/
X
XHERC_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X#ifdef OLDHERC
X    gotoxy(79-strlen(str),24-row);
X    puts(str);
X#else
X    strcpy((char far *)buf,str);
X    outtextxy(710-(strlen(str)*8),318-row*10,buf);
X#endif
X}
X
XHERC_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X#ifdef OLDHERC
X    gotoxy(2,row+1);
X    puts(str);
X#else
X    strcpy((char far *)buf,str);
X    outtextxy(10,row*10+10,buf);
X#endif
X}
X
X#define HERC_reset PC_reset
X
X
X#else
X
Xpause()								/* press any key to continue... */
X{
X	while (kbhit())
X		(void) getch();				/* flush the keyboard buffer */
X	while (!kbhit())
X		;
X}
X
X
XPC_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	PC_curloc(24-row,78-strlen(str));
X	PC_puts(str);
X}
X
XPC_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	PC_curloc(row+1,2);
X	PC_puts(str);
X}
X
XPC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	Vmode(3);
X}
X
XPC_reset()
X{
X}
X#define CGA_XMAX 640
X#define CGA_YMAX 200
X
X#define CGA_XLAST (CGA_XMAX - 1)
X#define CGA_YLAST (CGA_YMAX - 1)
X
X#define CGA_VCHAR 8
X#define CGA_HCHAR 8
X#define CGA_VTIC 2
X#define CGA_HTIC 3
X
XCGA_init()
X{
X	PC_color(1);		/* monochrome */
X}
X
XCGA_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(6);
X}
X
X#define CGA_text PC_text
X
XCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	PC_mask(pattern[linetype+2]);
X}
X
XCGA_move(x,y)
X{
X	startx = x;
X	starty = y;
X}
X
X
XCGA_vector(x,y)
X{
X	PC_line(startx,CGA_YLAST-starty,x,CGA_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X#define CGA_lrput_text PC_lrput_text
X#define CGA_ulput_text PC_ulput_text
X
X
X#define CGA_reset PC_reset
X
X
X#define EGA_XMAX 640
X#define EGA_YMAX 350
X
X#define EGA_XLAST (EGA_XMAX - 1)
X#define EGA_YLAST (EGA_YMAX - 1)
X
X#define EGA_VCHAR 14
X#define EGA_HCHAR 8
X#define EGA_VTIC 5
X#define EGA_HTIC 5
X
Xstatic int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
Xstatic int ega256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};
X
Xstatic int *egacolor;
X
X
XEGA_init()
X{
X	PC_mask(0xffff);
X	egacolor = ega256color;		/* should be smarter */
X}
X
XEGA_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(16);
X}
X
X#define EGA_text PC_text
X
XEGA_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	PC_color(egacolor[linetype+2]);
X}
X
XEGA_move(x,y)
X{
X	startx = x;
X	starty = y;
X}
X
XEGA_vector(x,y)
X{
X	PC_line(startx,EGA_YLAST-starty,x,EGA_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X#define EGA_lrput_text PC_lrput_text
X#define EGA_ulput_text PC_ulput_text
X
X
X#define EGA_reset PC_reset
X
X
X
X#ifdef EGALIB
X
X#define EGALIB_XMAX 640
X#define EGALIB_YMAX 350
X
X#define EGALIB_XLAST (EGA_XMAX - 1)
X#define EGALIB_YLAST (EGA_YMAX - 1)
X
X#define EGALIB_VCHAR 14
X#define EGALIB_HCHAR 8
X#define EGALIB_VTIC 4
X#define EGALIB_HTIC 5
X
X#include "mcega.h"
X
XEGALIB_init()
X{
X	GPPARMS();
X	if (GDTYPE != 5) {
X		term = 0;
X		int_error("color EGA board not found",NO_CARET);
X	}
X	egacolor = (GDMEMORY < 256) ? ega64color : ega256color;
X}
X
XEGALIB_graphics()
X{
X	graphics_on = TRUE;
X	GPINIT();
X}
X
XEGALIB_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	GPTERM();
X}
X
XEGALIB_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	GPCOLOR(egacolor[linetype+2]);
X}
X
XEGALIB_move(x,y)
X{
X	GPMOVE(x,GDMAXROW-y);
X}
X
X
XEGALIB_vector(x,y)
X{
X	GPLINE(x,GDMAXROW-y);
X}
X
X
XEGALIB_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	GotoXY(78-strlen(str),24-row);
X	gprintf(buf);
X}
X
XEGALIB_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	strcpy((char far *)buf,str);
X	GotoXY(2,row+1);
X	gprintf(buf);
X}
X
X#define EGALIB_reset PC_reset
X
X#endif /* EGALIB */
X
X
X#ifdef HERCULES
X
X#define HERC_XMAX 720
X#define HERC_YMAX 348
X
X#define HERC_XLAST (HERC_XMAX - 1)
X#define HERC_YLAST (HERC_YMAX - 1)
X
X#define HERC_VCHAR 8
X#define HERC_HCHAR 8
X#define HERC_VTIC 4
X#define HERC_HTIC 4
X
X
XHERC_init()
X{
X}
X
XHERC_graphics()
X{
X	HVmode(1);
X	graphics_on = TRUE;
X}
X
XHERC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	HVmode(0);
X}
X
XHERC_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	H_mask(pattern[linetype+2]);
X}
X
XHERC_move(x,y)
X{
X	if (x < 0)
X		startx = 0;
X	else if (x > HERC_XLAST)
X		startx = HERC_XLAST;
X	else
X		startx = x;
X
X	if (y < 0)
X		starty = 0;
X	else if (y > HERC_YLAST)
X		starty = HERC_YLAST;
X	else
X		starty = y;
X}
X
XHERC_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X
X	H_line(startx,HERC_YLAST-starty,x,HERC_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
XHERC_lrput_text(row,str)
Xint row;
Xchar str[];
X{
X	H_puts(str, 41-row, 87-strlen(str));
X}
X
XHERC_ulput_text(row,str)
Xint row;
Xchar str[];
X{
X	H_puts(str, row+1, 2);
X}
X
X#define HERC_reset PC_reset
X
X#endif /* HERCULES */
X
X
X/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
X   ATT 6300 driver */ 
X
X
X#ifdef ATT6300
X
X#define ATT_XMAX 640
X#define ATT_YMAX 400
X
X#define ATT_XLAST (ATT_XMAX - 1)
X#define ATT_YLAST (ATT_YMAX - 1)
X
X#define ATT_VCHAR 8
X#define ATT_HCHAR 8
X#define ATT_VTIC 3
X#define ATT_HTIC 3
X
X#define ATT_init CGA_init
X
XATT_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(0x40);        /* 40H is the magic number for the AT&T driver */
X}
X
X#define ATT_text CGA_text
X
X#define ATT_linetype CGA_linetype
X
X#define ATT_move CGA_move
X
XATT_vector(x,y)
X{
X	PC_line(startx,ATT_YLAST-starty,x,ATT_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X#define ATT_lrput_text PC_lrput_text
X#define ATT_ulput_text PC_ulput_text
X
X
X#define ATT_reset CGA_reset
X
X#endif  /* ATT6300 */
X
X
X#ifdef CORONA
X
X#define COR_XMAX 640
X#define COR_YMAX 325
X
X#define COR_XLAST (COR_XMAX - 1)
X#define COR_YLAST (COR_YMAX - 1)
X
X#define COR_VCHAR 13
X#define COR_HCHAR 8
X#define COR_VTIC 4
X#define COR_HTIC 4
X
X
Xstatic int corscreen;		/* screen number, 0 - 7 */
X
XCOR_init()
X{
Xregister char *p;
X	if (!(p = getenv("CORSCREEN")))
X		int_error("must run CORPLOT for Corona graphics",NO_CARET);
X	corscreen = *p - '0';
X}
X
XCOR_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(3);				/* clear text screen */
X	grinit(corscreen);
X	grandtx();
X}
X
XCOR_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	grreset();
X	txonly();
X	Vmode(3);
X}
X
XCOR_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	Cor_mask(pattern[linetype+2]);
X}
X
XCOR_move(x,y)
X{
X	if (x < 0)
X		startx = 0;
X	else if (x > COR_XLAST)
X		startx = COR_XLAST;
X	else
X		startx = x;
X
X	if (y < 0)
X		starty = 0;
X	else if (y > COR_YLAST)
X		starty = COR_YLAST;
X	else
X		starty = y;
X}
X
XCOR_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > COR_XLAST)
X		x = COR_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > COR_YLAST)
X		y = COR_YLAST;
X
X	Cor_line(startx,COR_YLAST-starty,x,COR_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X#define COR_lrput_text PC_lrput_text
X#define COR_ulput_text PC_ulput_text
X
X#define COR_reset PC_reset
X
X#endif /* CORONA */
X
X#endif /* __TURBOC__ */
X
END_OF_FILE
if test 15550 -ne `wc -c <'pc.trm'`; then
    echo shar: \"'pc.trm'\" unpacked with wrong size!
fi
# end of 'pc.trm'
fi
if test -f 'pcgraph.asm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcgraph.asm'\"
else
echo shar: Extracting \"'pcgraph.asm'\" \(3165 characters\)
sed "s/^X//" >'pcgraph.asm' <<'END_OF_FILE'
XTITLE	PC graphics module
X;	Colin Kelley
X;	December 22, 1986
X;	modified January 1987 to use LINEPROC.MAC
X
Xinclude header.mac
X
Xif1
Xinclude lineproc.mac
Xendif
X
X
X_text	segment
X
X	public _PC_line, _PC_color, _PC_mask, _PC_curloc, _PC_puts, _Vmode
X	public _save_stack, _ss_interrupt
X	extrn _interrupt:near
X
Xpcpixel proc near
X	ror word ptr linemask,1
X	jc cont
X	ret
Xcont:
X	push ax
X	push bx
X	push cx
X	push dx
X	push bp
X	mov cx,ax		; x
X	mov dx,bx		; y
X	mov ah,0ch		; ah = write pixel
X	mov al,byte ptr color
X
X	mov bh, 0		; page 0
X	int 10h
X	pop bp
X	pop dx
X	pop cx
X	pop bx
X	pop ax
X	ret
Xpcpixel endp
X
Xlineproc _PC_line, pcpixel
X
X_PC_color proc near
X	push bp
X	mov bp,sp
X	mov al,[bp+X]			; color
X	mov byte ptr color,al
X	pop bp
X	ret
X_PC_color endp
X
X_PC_mask proc near
X	push bp
X	mov bp,sp
X	mov ax,[bp+X]			; mask
X	mov word ptr linemask,ax
X	pop bp
X	ret
X_PC_mask endp
X
X_Vmode	proc near
X	push bp
X	mov bp,sp
X	push si
X	push di
X	mov ax,[bp+X]
X	int 10h
X	pop di
X	pop si
X	pop bp
X	ret
X_Vmode	endp
X
X_PC_curloc proc near
X	push bp
X	mov bp,sp
X	mov dh, byte ptr [bp+X] ; row number
X	mov dl, byte ptr [bp+X+2] ; col number
X	mov bh, 0
X	mov ah, 2
X	int 10h
X	pop bp
X	ret
X_PC_curloc endp
X
X;
X; thanks to watale!broehl for finding a bug here--I wasn't pushing BP
X;   and reloading AH before INT 10H, which is necessary on genuine IBM
X;   boards...
X;
X_PC_puts proc near
X	push bp
X	mov bp,sp
X	push si
X	mov bl,byte ptr color
X	mov si,[bp+X]		; offset
X
Xifdef LARGE_DATA
X	mov es,[bp+X+2]		; segment if large or compact data model
Xendif
X
Xputs2:
X
Xifdef LARGE_DATA
X	mov al,es:[si]
Xelse
X	mov al,[si]
Xendif
X	or al,al
X	jz puts3
X	mov ah,0eh		; write TTY char
X	int 10h
X	inc si
X	jmp short puts2
Xputs3:	pop si
X	pop bp
X	ret
X_PC_puts endp
X
X
X; int kbhit();
X;   for those without MSC 4.0
X; Use BIOS interrupt 16h to determine if a key is waiting in the buffer.
X; Return nonzero if so.
X;
X
Xbeginproc _kbhit
X	mov ah, 1		; function code 1 is keyboard test
X	int 16h			; keyboard functions
X	jnz kbfin		; Exit if char available
X	xor ax, ax		; No char:  return zero.
Xkbfin:	ret
X_kbhit	endp
X
X
X; _save_stack and _ss_interrupt are needed due to a bug in the MSC 4.0
X; code when run under MS-DOS 3.x.  Starting with 3.0, MS-DOS automatically
X; switches to an internal stack during system calls.  This leaves SS:SP
X; pointing at MS-DOS's stack when the ^C interrupt (INT 23H) is triggered.
X; MSC should restore its own stack before calling the user signal() routine,
X; but it doesn't.
X;
X; Presumably this code will be unnecessary in later releases of the compiler.
X;
X
X; _save_stack saves the current SS:SP to be loaded later by _ss_interrupt.
X;
X
Xbeginproc _save_stack
X	mov ax,ss
X	mov cs:save_ss,ax
X	mov ax,sp
X	mov cs:save_sp,ax
X	ret
X_save_stack endp
X
X
X; _ss_interrupt is called on ^C (INT 23H).  It restores SS:SP as saved in
X; _save_stack and then jumps to the C routine interrupt().
X;
Xbeginproc _ss_interrupt
X	cli			; no interrupts while the stack is changed!
X	mov ax,-1		; self-modifying code again
Xsave_ss	equ this word - 2
X	mov ss,ax
X	mov sp,-1		; here too
Xsave_sp equ this word - 2
X	sti
X	jmp _interrupt		; now it's safe to call the real routine
X_ss_interrupt endp
X
X
X_text	ends
X
X
Xconst	segment
Xlinemask dw -1
Xcolor	db 1
Xconst	ends
X
X	end
END_OF_FILE
if test 3165 -ne `wc -c <'pcgraph.asm'`; then
    echo shar: \"'pcgraph.asm'\" unpacked with wrong size!
fi
# end of 'pcgraph.asm'
fi
echo shar: End of archive 3 \(of 7\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
