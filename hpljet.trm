/* GNUPLOT - hpljet.trm */
/*
 * Copyright (C) 1990   
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted, 
 * provided that the above copyright notice appear in all copies and 
 * that both that copyright notice and this permission notice appear 
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the modified code.  Modifications are to be distributed 
 * as patches to released version.
 *  
 * This software  is provided "as is" without express or implied warranty.
 * 
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *  Hewlett-Packard Laserjet
 *
 * AUTHORS
 *  Jyrki Yli-Nokari (jty@intrin.UUCP)
 *
 * send your comments or suggestions to (pixar!info-gnuplot@sun.com).
 * 
 */

/*
** Hewlett-Packard Laserjet
** Driver written and copyrighted 1987 by
** Jyrki Yli-Nokari (jty@intrin.UUCP)
** Intrinsic, Ltd.
** 
** You may use this code for anything you like as long as
** you are not selling it and the credit is given and
** this message retained.
*/

/*
** The driver consists of two parts: general raster plotting routines
** (#ifdef RASTER) and the laserjet driver using them (#ifdef HPLJET).
**
** The laserjet driver contains actually three different "terminal types":
** laserjet1, laserjet2 and laserjet3. The difference between them is the size
** of the picture; "laserjet3" being the biggest.
*/


#ifdef HPLJET
#define RASTER
#endif /* HPLJET */

#ifdef RASTER
/*
** General raster plotting routines.
** Raster routines written and copyrighted 1987 by
** Jyrki Yli-Nokari (jty@intrin.UUCP)
** Intrinsic, Ltd.
** 
** You may use this code for anything you like as long as
** you are not selling it and the credit is given and
** this message retained.
**
** The plotting area is defined as a huge raster.
** The raster is stored in a dynamically allocated pixel array r_p
**
** The raster is allocated (and initialized to zero) with
** r_makeraster(xsize, ysize)
** and freed with r_freeraster()
**
** Valid (unsigned) coordinates range from zero to (xsize-1,ysize-1)
**
** Plotting is done via r_move(x, y) and r_draw(x, y, value) functions,
** where the point (x,y) is the target to go from the current point
** and value is the value (of type pixel) to be stored in every pixel.
**
** Internally all plotting goes through r_setpixel(x, y, val).
** If you want different plotting styles (like OR, XOR...), use "value"
** in r_draw() to mark different styles and change r_setpixel() accordingly.
*/

#define IN(i,size)	((unsigned)i < (unsigned)size)
typedef char pixel;	/* the type of one pixel in raster */
typedef pixel *raster[];	/* the raster */

static raster *r_p;	/* global pointer to raster */
static unsigned r_currx, r_curry;	/* the current coordinates */
static unsigned r_xsize, r_ysize;	/* the size of the raster */

/*
** set pixel (x, y, val) to value val (this can be 1/0 or a color number).
*/
void
r_setpixel(x, y, val)
unsigned x, y;
pixel val;
{
	if (IN(x, r_xsize) && IN(y, r_ysize)) {
		*(((*r_p)[y]) + x) = val;
	}
#ifdef RASTERDEBUG
	else {
		fprintf(stderr, "Warning: setpixel(%d, %d, %d) out of bounds\n", x, y, val);
	}
#endif
}

/*
** get pixel (x,y) value
*/
pixel
r_getpixel(x, y)
unsigned x, y;
{
	if (IN(x, r_xsize) && IN(y, r_ysize)) {
		return *(((*r_p)[y]) + x);
	} else {
#ifdef RASTERDEBUG
		fprintf(stderr, "Warning: getpixel(%d,%d) out of bounds\n", x, y);
#endif
		return 0;
	}
}

/*
** allocate the raster
*/
void
r_makeraster(x, y)
unsigned x, y;
{
	register unsigned j;
	
	/* allocate row pointers */
	r_p = (raster *)alloc(y * sizeof(pixel *), "raster buffer");
	bzero(r_p, y * sizeof(pixel *));
	for (j = 0; j < y; j++) {
		(*r_p)[j] = (pixel *)alloc(x * sizeof(pixel), "raster buffer");
		bzero((*r_p)[j], x * sizeof(pixel));
	}
	r_xsize = x; r_ysize = y;
	r_currx = r_curry = 0;
}
	
/*
** plot a line from (x0,y0) to (x1,y1) with color val.
*/
void
r_plot(x0, y0, x1, y1, val)
unsigned x0, y0, x1, y1;
pixel val;
{
	unsigned hx, hy, i;
	int e, dx, dy;

	hx = abs((int)(x1 - x0));
	hy = abs((int)(y1 - y0));
	dx = (x1 > x0) ? 1 : -1;
	dy = (y1 > y0) ? 1 : -1;
	
	if (hx > hy) {
		/*
		** loop over x-axis
		*/
		e = hy + hy - hx;
		for (i = 0; i <= hx; i++) {
			r_setpixel(x0, y0, val);
			if (e > 0) {
				y0 += dy;
				e += hy + hy - hx - hx;
			} else {
				e += hy + hy;
			}
			x0 += dx;
		}
	} else {
		/*
		** loop over y-axis
		*/
		e = hx + hx - hy;
		for (i = 0; i <= hy; i++) {
			r_setpixel(x0, y0, val);
			if (e > 0) {
				x0 += dx;
				e += hx + hx - hy - hy;
			} else {
				e += hx + hx;
			}
			y0 += dy;
		}
	}
}

/*
** move to (x,y)
*/
void
r_move(x, y)
unsigned x, y;
{
	r_currx = x;
	r_curry = y;
}

/*
** draw to (x,y) with color val
** (move pen down)
*/
void
r_draw(x, y, val)
unsigned x, y;
pixel val;
{
	r_plot(r_currx, r_curry, x, y, val);
	r_currx = x;
	r_curry = y;
}

/*
** free the allocated raster
*/
void
r_freeraster()
{
	int y;

	for (y = 0; y < r_ysize; y++) {
		(void) free((char *)(*r_p)[y]);
	}
	(void) free((char *)r_p);
}
#endif /* RASTER */



/*
** NOTE:
** When sending the plot to the laserjet there must be absolutely
** NO character translation done by the operating system.
** Normally, in UNIX, the (operating system) terminal driver
** translates newlines to CR/LF pairs. This is called the "cooked mode".
** Some operating systems might add CR/LF pairs if they think there
** is a too long line. ALL THIS IS STRICTLY PROHIBITED.
** ALL DATA TO THE LASERJET MUST BE SENT WHEN THE LINE IS IN RAW MODE.
**

/*
** The laserjet math is a pain since we have to deal with
** decipoints (720/inch), dots (300/inch), pixels (100-300/inch),
** characters (10/inch horiz., 6/inch vertic.) and the size of
** the plottable surface in A4 (about 7.8 inches horizontally).
** On top of this we also support different plot sizes!
*/

#define HPLJET_PIXSIZE	(hpljet_pixel)
		/* Laserjet pixel size in laserjet minimum dots */
#define HPLJET_PPI (300/HPLJET_PIXSIZE)
		/* Laserjet raster scaling factor, Pixels Per Inch */
#define HPLJET_WIDTH 5600
		/* ~ Number of horizontal decipoints in A4 */
#define HPLJET_IN2DP(x) (720*(x))
		/* convert INches TO DeciPoints */
#define HPLJET_PX2DP(x) (HPLJET_IN2DP(x)/HPLJET_PPI)
		/* convert PiXels TO DeciPoints */
#define HPLJET_HC2DP(x) (72*(x))
		/* convert Horizontal Characters TO DeciPoints */
#define HPLJET_VC2DP(x) (120*(x))
		/* convert Vertical Characters TO DeciPoints */
#define HPLJET_LMARG ((HPLJET_WIDTH - HPLJET_PX2DP(HPLJETXMAX))/2)
		/* Picture left margin in decipoints */
#define HPLJET_RMARG ((HPLJET_WIDTH + HPLJET_PX2DP(HPLJETXMAX))/2)
		/* Picture right margin in decipoints */
#define HPLJETXMAX 640
		/* Number of pixels in X-axis */
#define HPLJETYMAX 640
		/* Number of pixels in Y-axis */
#define HPLJETXLAST (HPLJETXMAX - 1)
		/* Last valid X-pixel value */
#define HPLJETYLAST (HPLJETYMAX - 1)
		/* Last valid Y-pixel value */

#define HPLJETVCHAR	(HPLJET_PPI/6)
		/* Vertical pixel size of the character font */
#define HPLJETHCHAR	(HPLJET_PPI/10)
		/* Horizontal pixel size of the character font */
#define HPLJET1VCHAR	(300/6)
		/* Vertical pixel size of the character font */
#define HPLJET1HCHAR	(300/10)
		/* Horizontal pixel size of the character font */
#define HPLJET2VCHAR	(150/6)
		/* Vertical pixel size of the character font */
#define HPLJET2HCHAR	(150/10)
		/* Horizontal pixel size of the character font */
#define HPLJET3VCHAR	(100/6)
		/* Vertical pixel size of the character font */
#define HPLJET3HCHAR	(100/10)
		/* Horizontal pixel size of the character font */
/*
** (I guess) VTIC and HTIC are used as
** "small units that look like equal length".
** They determine (at least) the length of "bars" in axises and
** the size of plotting symbols.
*/
#define HPLJETVTIC		6
#define HPLJETHTIC		6

/*
** We use laserjet1, laserjet2 and laserjet3 for different
** pixel sizes of the picture (1 is the smallest).
** The size of the text, however, remains the same.
** These three terminal types use mostly the same
** functions, only the init-function determines the size of the picture.
** Also, the h_char and v_char are different, but they are
** not used.
*/

/*
** Initialize (once) for graphics
*/
static int hpljet_pixel = 3;

HPLJET1init()
{
	hpljet_pixel = 1;
}

HPLJET2init()
{
	hpljet_pixel = 2;
}

HPLJET3init()
{
	hpljet_pixel = 3;
}

HPLJETmove(x, y)
{
	r_move((unsigned)x, (unsigned)y);
}

HPLJETvector(x, y)
{
	r_draw((unsigned)x, (unsigned)y, (pixel)1);
}

/*
** Enter graphics mode:
**	- allocate raster buffer
**	- set resolution
*/
HPLJETgraphics()
{
	r_makeraster(HPLJETXMAX, HPLJETYMAX);
	fprintf(outfile,"\033*t%dR", HPLJET_PPI);
/*	                             1
**	1. Set resolution pixels/inch
*/
}

/*
** (re-)enter text mode,
** output raster and deallocate it.
*/
HPLJETtext()
{
	int x, y;
	unsigned v, i;

	fprintf(outfile, "\033&a%dH\033&a%dV", HPLJET_LMARG, HPLJET_VC2DP(2));
	fprintf(outfile, "\033*r1A");
	for (y = r_ysize-1; y >= 0; y--) {
		fprintf(outfile, "\033*b%dW", r_xsize/8);
		for (x = 0; x < r_xsize; x += 8) {
			v = 0;
			for (i = 0; i < 8; i++) {
				v = (v << 1) | r_getpixel((unsigned)x + i, (unsigned)y);
			}
			putc((char)v, outfile);
		}
	}
	r_freeraster();
	fprintf(outfile, "\033*rB\f");
}

/*
** Select line type [-2:8]
** line types:
**	-2 = border line
**	-1 = x/y axis line
**	0-8 = function plot lines.
**	Dummy function here.
*/
HPLJETlinetype(linetype)
int linetype;
{
}

/* put_text was added by Russell Lang, eln272v@monu1.cc.monash.oz
 * IT IS UNTESTED
 */
/* Put text "str" at pixel position x,y
**/
HPLJETput_text(x,y,str)
unsigned x,y;
char str[];
{
	fprintf(outfile, "\033&a%dH\033&a%dV",
	        HPLJET_PX2DP(x), HPLJET_PX2DP(y) );
	fputs(str, outfile);
}
	

/*
** Put text "str" to the lower right corner of the screen.
** "row" is the row number [0:1].
** Actually in the laserjet, put the text above the upper right corner.
*/
HPLJETlrput_text(row,str)
unsigned int row;
char str[];
{
	
	fprintf(outfile, "\033&a%dH\033&a%dV",
	        HPLJET_RMARG - HPLJET_HC2DP(strlen(str)), HPLJET_VC2DP(row));
	fputs(str, outfile);
}

/*
** Put text "str" to the upper left corner of the screen.
** "row" is the (serial) number of function to be plotted.
** Actually in the laserjet, put the text under the lower left corner.
*/
HPLJETulput_text(row,str)
unsigned int row;
char str[];
{
	fprintf(outfile, "\033&a%dH\033&a%dV",
	        HPLJET_LMARG,
	        HPLJET_VC2DP(row+3)+HPLJET_PX2DP(HPLJETYMAX));
	fputs(str, outfile);
}

/*
** RETURN to normal mode (exit gnuplot)
*/
HPLJETreset()
{
}

