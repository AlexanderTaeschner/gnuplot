#ifdef __TURBOC__
#include <graphics.h>
#include <dos.h>
#include <string.h>
  int g_driver, g_mode, g_error;
  char far *path;
  char *pathp, path_s[128];

get_path()
{
   path=getenv("BGI");
   if (path==NULL) {
      strcpy(path_s,_argv[0]);
      pathp=strrchr(path_s,'\\');
      *pathp=0x00;
      path=path_s;
   }
}

#endif

/* all of the Turbo C routines for the different graphics devices go here */

#define EGALIB_XMAX 640
#define EGALIB_YMAX 350

#define EGALIB_XLAST (EGA_XMAX - 1)
#define EGALIB_YLAST (EGA_YMAX - 1)

#define EGALIB_VCHAR 14
#define EGALIB_HCHAR 8
#define EGALIB_VTIC 4
#define EGALIB_HTIC 5

static int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
static int ega256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};

static int *egacolor;

static char near buf[80];	/* kludge since EGA.LIB is compiled SMALL */

static int pattern[] = {0xffff, 0x0f0f, 0xffff, 0xaaaa, 0x3333, 0x3f3f, 0x0f0f};

static int graphics_on = FALSE;
int startx, starty;

pause()								/* press any key to continue... */
{
	while (kbhit())
		(void) getch();				/* flush the keyboard buffer */
	while (!kbhit())
		;
}


PC_lrput_text(row,str)
int row;
char str[];
{
#ifdef __TURBOC__
	gotoxy(78-strlen(str),24-row);
	puts(str);
#else
	PC_curloc(24-row,78-strlen(str));
	PC_puts(str);
#endif
}

PC_ulput_text(row,str)
int row;
char str[];
{
#ifdef __TURBOC__
	gotoxy(2,row+1);
	puts(str);
#else
	PC_curloc(row+1,2);
	PC_puts(str);
#endif
}

PC_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
#ifdef __TURBOC__
	closegraph();
#else
	Vmode(3);
#endif
}

PC_reset()
{
#ifdef __TURBOC__
	closegraph();
#endif
}


#ifdef __TURBOC__ 

#define VGA_XMAX 640
#define VGA_YMAX 480

#define VGA_XLAST (VGA_XMAX - 1)
#define VGA_YLAST (VGA_YMAX - 1)

#define VGA_VCHAR 14
#define VGA_HCHAR 8
#define VGA_VTIC 4
#define VGA_HTIC 5

static int vga256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};

static int *vgacolor;

VGA_init()
{
	g_driver=VGA;
	g_mode=2;
        initgraph(&g_driver,&g_mode,path);
        if(g_driver!=9){
          term=0;
          switch (g_driver){
            case -2: fprintf(stderr,"Graphics card not detected.\n");
                     break;
            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
                     break;
            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
                     break;
            case -5: fprintf(stderr,"Insufficient memory to load ",
                             "graphics driver.");
                     break;
            }
            
/*          int_error("color EGA board not found",NO_CARET);*/
        }
        if(g_driver==VGA) vgacolor=vga256color;
}

VGA_graphics()
{       g_driver=VGA;
	g_mode=2;
	graphics_on = TRUE;
	initgraph(&g_driver,&g_mode,path);
}

VGA_linetype(linetype)
{
	if (linetype >= 13)
		linetype %= 13;
	setcolor(vgacolor[linetype+2]);
}

VGA_lrput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	outtextxy(630-(strlen(str)*8),450-row*16,buf);
}

#define VGA_reset EGALIB_reset
#define VGA_text EGALIB_text
#define VGA_move EGALIB_move
#define VGA_vector EGALIB_vector
#define VGA_ulput_text EGALIB_ulput_text

VGAMONO_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
	setlinestyle(4,pattern[linetype+2],1);
}

#define MCGA_XMAX 640
#define MCGA_YMAX 480

#define MCGA_XLAST (MCGA_XMAX - 1)
#define MCGA_YLAST (MCGA_YMAX - 1)

#define MCGA_VCHAR 14
#define MCGA_HCHAR 8
#define MCGA_VTIC 4
#define MCGA_HTIC 5

static int *MCGAcolor;

MCGA_init()
{
	g_driver=MCGA;
	g_mode=5;
        initgraph(&g_driver,&g_mode,path);
        if(g_driver!=2){
          term=0;
          switch (g_driver){
            case -2: fprintf(stderr,"Graphics card not detected.\n");
                     break;
            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
                     break;
            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
                     break;
            case -5: fprintf(stderr,"Insufficient memory to load ",
                             "graphics driver.");
                     break;
            }
            
        }
}

MCGA_graphics()
{       g_driver=MCGA;
	g_mode=5;
	graphics_on = TRUE;
	initgraph(&g_driver,&g_mode,path);
}


MCGA_lrput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	outtextxy(630-(strlen(str)*8),450-row*16,buf);
}

#define MCGA_reset EGALIB_reset
#define MCGA_text EGALIB_text
#define MCGA_move EGALIB_move
#define MCGA_vector EGALIB_vector
#define MCGA_ulput_text EGALIB_ulput_text

MCGA_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
	setlinestyle(4,pattern[linetype+2],1);
}


EGALIB_init()
{
	g_driver=EGA;
	g_mode=1;
        initgraph(&g_driver,&g_mode,path);
        if(g_driver<3 || g_driver>4){
          term=0;
          switch (g_driver){
            case -2: fprintf(stderr,"Graphics card not detected.\n");
                     break;
            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
                     break;
            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
                     break;
            case -5: fprintf(stderr,"Insufficient memory to load ",
                             "graphics driver.");
                     break;
            }
            
/*          int_error("color EGA board not found",NO_CARET);*/
        }
        if(g_driver==EGA) egacolor=ega256color;
        if(g_driver==EGA64) egacolor=ega64color;
}

EGALIB_graphics()
{
	graphics_on = TRUE;
	initgraph(&g_driver,&g_mode,path);
}

EGALIB_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	closegraph();
}

EGALIB_linetype(linetype)
{
	if (linetype >= 13)
		linetype %= 13;
	setcolor(egacolor[linetype+2]);
}

EGALIB_move(x,y)
{
        moveto(x,getmaxy()-y);
}


EGALIB_vector(x,y)
{
	lineto(x,getmaxy()-y);
}


EGALIB_lrput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	outtextxy(630-(strlen(str)*8),320-row*16,buf);
}

EGALIB_ulput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	outtextxy(10,row*16+16,buf);
}

EGALIB_reset()
{
  	closegraph();
}

#define CGA_XMAX 640
#define CGA_YMAX 200

#define CGA_XLAST (CGA_XMAX - 1)
#define CGA_YLAST (CGA_YMAX - 1)

#define CGA_VCHAR 8
#define CGA_HCHAR 8
#define CGA_VTIC 2
#define CGA_HTIC 3

CGA_init()
{
	g_driver=CGA;
	g_mode=4;
	initgraph(&g_driver,&g_mode,path);
          switch (g_driver){
            case -2: fprintf(stderr,"Graphics card not detected.\n");
                     break;
            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
                     break;
            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
                     break;
            case -5: fprintf(stderr,"Insufficient memory to load ",
                             "graphics driver.");
                     break;
            }
/*	PC_color(1);		 monochrome */

}

CGA_graphics()
{
	graphics_on = TRUE;
	g_driver=CGA;
	g_mode=4;
	initgraph(&g_driver,&g_mode,path);
	/*	Vmode(6);*/
}

#define CGA_text PC_text

CGA_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
/*	PC_mask(pattern[linetype+2]); */
	setlinestyle(4,pattern[linetype+2],1);
}

CGA_move(x,y)
{
	moveto(x,y);
}


CGA_vector(x,y)
{
	lineto(x,y);
}

#define CGA_lrput_text PC_lrput_text
#define CGA_ulput_text PC_ulput_text


#define CGA_reset PC_reset

#define HERC_XMAX 720
#define HERC_YMAX 348

#define HERC_XLAST (HERC_XMAX - 1)
#define HERC_YLAST (HERC_YMAX - 1)

#define HERC_VCHAR 8
#define HERC_HCHAR 8
#define HERC_VTIC 4
#define HERC_HTIC 4

HERC_init()
{
	g_driver=HERCMONO;
	g_mode=0;
  	initgraph(&g_driver,&g_mode,path);
          switch (g_driver){
            case -2: fprintf(stderr,"Graphics card not detected.\n");
                     break;
            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
                     break;
            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
                     break;
            case -5: fprintf(stderr,"Insufficient memory to load ",
                             "graphics driver.");
                     break;
            }
}

HERC_graphics()
{
	g_driver=HERCMONO;
	g_mode=0;
	initgraph(&g_driver,&g_mode,path);
	graphics_on = TRUE;
}

HERC_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	closegraph();
}

HERC_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;

	setlinestyle(linetype,0,1);
}

HERC_move(x,y)
{
	if (x < 0)
		x = 0;
	else if (x > HERC_XLAST)
		x = HERC_XLAST;

	if (y < 0)
		y = 0;
	else if (y > HERC_YLAST)
		y = HERC_YLAST;
	moveto(x,y);
}

HERC_vector(x,y)
{
	if (x < 0)
		x = 0;
	else if (x > HERC_XLAST)
		x = HERC_XLAST;
	if (y < 0)
		y = 0;
	else if (y > HERC_YLAST)
		y = HERC_YLAST;

	lineto(x,y);
}

/*
   Thanks to James Dugal (jpd@usl.edu) for patching these two HERC 
   routines.  (We need to remove the OLD (probably bad) code someday.)
*/

HERC_lrput_text(row,str)
int row;
char str[];
{
#ifdef OLDHERC
    gotoxy(79-strlen(str),24-row);
    puts(str);
#else
    strcpy((char far *)buf,str);
    outtextxy(710-(strlen(str)*8),318-row*10,buf);
#endif
}

HERC_ulput_text(row,str)
int row;
char str[];
{
#ifdef OLDHERC
    gotoxy(2,row+1);
    puts(str);
#else
    strcpy((char far *)buf,str);
    outtextxy(10,row*10+10,buf);
#endif
}

#define HERC_reset PC_reset


#else

pause()								/* press any key to continue... */
{
	while (kbhit())
		(void) getch();				/* flush the keyboard buffer */
	while (!kbhit())
		;
}


PC_lrput_text(row,str)
int row;
char str[];
{
	PC_curloc(24-row,78-strlen(str));
	PC_puts(str);
}

PC_ulput_text(row,str)
int row;
char str[];
{
	PC_curloc(row+1,2);
	PC_puts(str);
}

PC_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	Vmode(3);
}

PC_reset()
{
}
#define CGA_XMAX 640
#define CGA_YMAX 200

#define CGA_XLAST (CGA_XMAX - 1)
#define CGA_YLAST (CGA_YMAX - 1)

#define CGA_VCHAR 8
#define CGA_HCHAR 8
#define CGA_VTIC 2
#define CGA_HTIC 3

CGA_init()
{
	PC_color(1);		/* monochrome */
}

CGA_graphics()
{
	graphics_on = TRUE;
	Vmode(6);
}

#define CGA_text PC_text

CGA_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
	PC_mask(pattern[linetype+2]);
}

CGA_move(x,y)
{
	startx = x;
	starty = y;
}


CGA_vector(x,y)
{
	PC_line(startx,CGA_YLAST-starty,x,CGA_YLAST-y);
	startx = x;
	starty = y;
}

#define CGA_lrput_text PC_lrput_text
#define CGA_ulput_text PC_ulput_text


#define CGA_reset PC_reset


#define EGA_XMAX 640
#define EGA_YMAX 350

#define EGA_XLAST (EGA_XMAX - 1)
#define EGA_YLAST (EGA_YMAX - 1)

#define EGA_VCHAR 14
#define EGA_HCHAR 8
#define EGA_VTIC 5
#define EGA_HTIC 5

static int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
static int ega256color[] = {1,8,2,3,4,5,9,14,12,15,13,10,11,7,6};

static int *egacolor;


EGA_init()
{
	PC_mask(0xffff);
	egacolor = ega256color;		/* should be smarter */
}

EGA_graphics()
{
	graphics_on = TRUE;
	Vmode(16);
}

#define EGA_text PC_text

EGA_linetype(linetype)
{
	if (linetype >= 13)
		linetype %= 13;
	PC_color(egacolor[linetype+2]);
}

EGA_move(x,y)
{
	startx = x;
	starty = y;
}

EGA_vector(x,y)
{
	PC_line(startx,EGA_YLAST-starty,x,EGA_YLAST-y);
	startx = x;
	starty = y;
}

#define EGA_lrput_text PC_lrput_text
#define EGA_ulput_text PC_ulput_text


#define EGA_reset PC_reset



#ifdef EGALIB

#define EGALIB_XMAX 640
#define EGALIB_YMAX 350

#define EGALIB_XLAST (EGA_XMAX - 1)
#define EGALIB_YLAST (EGA_YMAX - 1)

#define EGALIB_VCHAR 14
#define EGALIB_HCHAR 8
#define EGALIB_VTIC 4
#define EGALIB_HTIC 5

#include "mcega.h"

EGALIB_init()
{
	GPPARMS();
	if (GDTYPE != 5) {
		term = 0;
		int_error("color EGA board not found",NO_CARET);
	}
	egacolor = (GDMEMORY < 256) ? ega64color : ega256color;
}

EGALIB_graphics()
{
	graphics_on = TRUE;
	GPINIT();
}

EGALIB_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	GPTERM();
}

EGALIB_linetype(linetype)
{
	if (linetype >= 13)
		linetype %= 13;
	GPCOLOR(egacolor[linetype+2]);
}

EGALIB_move(x,y)
{
	GPMOVE(x,GDMAXROW-y);
}


EGALIB_vector(x,y)
{
	GPLINE(x,GDMAXROW-y);
}


EGALIB_lrput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	GotoXY(78-strlen(str),24-row);
	gprintf(buf);
}

EGALIB_ulput_text(row,str)
int row;
char str[];
{
	strcpy((char far *)buf,str);
	GotoXY(2,row+1);
	gprintf(buf);
}

#define EGALIB_reset PC_reset

#endif /* EGALIB */


#ifdef HERCULES

#define HERC_XMAX 720
#define HERC_YMAX 348

#define HERC_XLAST (HERC_XMAX - 1)
#define HERC_YLAST (HERC_YMAX - 1)

#define HERC_VCHAR 8
#define HERC_HCHAR 8
#define HERC_VTIC 4
#define HERC_HTIC 4


HERC_init()
{
}

HERC_graphics()
{
	HVmode(1);
	graphics_on = TRUE;
}

HERC_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	HVmode(0);
}

HERC_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
	H_mask(pattern[linetype+2]);
}

HERC_move(x,y)
{
	if (x < 0)
		startx = 0;
	else if (x > HERC_XLAST)
		startx = HERC_XLAST;
	else
		startx = x;

	if (y < 0)
		starty = 0;
	else if (y > HERC_YLAST)
		starty = HERC_YLAST;
	else
		starty = y;
}

HERC_vector(x,y)
{
	if (x < 0)
		x = 0;
	else if (x > HERC_XLAST)
		x = HERC_XLAST;
	if (y < 0)
		y = 0;
	else if (y > HERC_YLAST)
		y = HERC_YLAST;

	H_line(startx,HERC_YLAST-starty,x,HERC_YLAST-y);
	startx = x;
	starty = y;
}

HERC_lrput_text(row,str)
int row;
char str[];
{
	H_puts(str, 41-row, 87-strlen(str));
}

HERC_ulput_text(row,str)
int row;
char str[];
{
	H_puts(str, row+1, 2);
}

#define HERC_reset PC_reset

#endif /* HERCULES */


/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
   ATT 6300 driver */ 


#ifdef ATT6300

#define ATT_XMAX 640
#define ATT_YMAX 400

#define ATT_XLAST (ATT_XMAX - 1)
#define ATT_YLAST (ATT_YMAX - 1)

#define ATT_VCHAR 8
#define ATT_HCHAR 8
#define ATT_VTIC 3
#define ATT_HTIC 3

#define ATT_init CGA_init

ATT_graphics()
{
	graphics_on = TRUE;
	Vmode(0x40);        /* 40H is the magic number for the AT&T driver */
}

#define ATT_text CGA_text

#define ATT_linetype CGA_linetype

#define ATT_move CGA_move

ATT_vector(x,y)
{
	PC_line(startx,ATT_YLAST-starty,x,ATT_YLAST-y);
	startx = x;
	starty = y;
}

#define ATT_lrput_text PC_lrput_text
#define ATT_ulput_text PC_ulput_text


#define ATT_reset CGA_reset

#endif  /* ATT6300 */


#ifdef CORONA

#define COR_XMAX 640
#define COR_YMAX 325

#define COR_XLAST (COR_XMAX - 1)
#define COR_YLAST (COR_YMAX - 1)

#define COR_VCHAR 13
#define COR_HCHAR 8
#define COR_VTIC 4
#define COR_HTIC 4


static int corscreen;		/* screen number, 0 - 7 */

COR_init()
{
register char *p;
	if (!(p = getenv("CORSCREEN")))
		int_error("must run CORPLOT for Corona graphics",NO_CARET);
	corscreen = *p - '0';
}

COR_graphics()
{
	graphics_on = TRUE;
	Vmode(3);				/* clear text screen */
	grinit(corscreen);
	grandtx();
}

COR_text()
{
	if (graphics_on) {
		graphics_on = FALSE;
		pause();
	}
	grreset();
	txonly();
	Vmode(3);
}

COR_linetype(linetype)
{
	if (linetype >= 5)
		linetype %= 5;
	Cor_mask(pattern[linetype+2]);
}

COR_move(x,y)
{
	if (x < 0)
		startx = 0;
	else if (x > COR_XLAST)
		startx = COR_XLAST;
	else
		startx = x;

	if (y < 0)
		starty = 0;
	else if (y > COR_YLAST)
		starty = COR_YLAST;
	else
		starty = y;
}

COR_vector(x,y)
{
	if (x < 0)
		x = 0;
	else if (x > COR_XLAST)
		x = COR_XLAST;
	if (y < 0)
		y = 0;
	else if (y > COR_YLAST)
		y = COR_YLAST;

	Cor_line(startx,COR_YLAST-starty,x,COR_YLAST-y);
	startx = x;
	starty = y;
}

#define COR_lrput_text PC_lrput_text
#define COR_ulput_text PC_ulput_text

#define COR_reset PC_reset

#endif /* CORONA */

#endif /* __TURBOC__ */

