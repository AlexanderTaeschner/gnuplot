C RCS $Id: gnuplot.doc,v 1.421 2007/02/27 04:04:32 sfeam Exp $
C
C Copyright (C) 1986 - 1993, 1998, 1999, 2000, 2001, 2004   Thomas Williams, Colin Kelley et al.
C
^ <h2> An Interactive Plotting Program </h2><p>
^ <h2>  Thomas Williams & Colin Kelley</h2><p>
^ <h2>  Version 4.2 organized by Hans-Bernhard Broeker and others</h2><p>
^ <h2>Major contributors (alphabetic order):</h2>
^<ul><h3>
^<li>  Hans-Bernhard Broeker
^<li>  John Campbell
^<li>  Robert Cunningham
^<li>  David Denholm
^<li>  Gershon Elber
^<li>  Roger Fearick
^<li>  Carsten Grammes
^<li>  Lucas Hart
^<li>  Lars Hecking
^<li>  Thomas Koenig
^<li>  David Kotz
^<li>  Ed Kubaitis
^<li>  Russell Lang
^<li>  Alexander Lehmann
^<li>  Alexander Mai
^<li>  Ethan A Merritt
^<li>  Petr Mikulik
^<li>  Carsten Steger
^<li>  Tom Tkacik
^<li>  Jos Van der Woude
^<li>  Alex Woo
^<li>  James R. Van Zandt
^<li>  Johannes Zellner
^</h3></ul> <p>
^<h2>  Copyright (C) 1986 - 1993, 1998 - 2004   Thomas Williams, Colin Kelley<p>
^   Mailing list for comments: gnuplot-info@lists.sourceforge.net <p>
^   Mailing list for bug reports: gnuplot-bugs@lists.sourceforge.net <p>
^</h2><p>
^<h3> This manual was prepared by Dick Crawford</h3><p>
^<h3> Last revised: February 2007</h3><p>
^<hr>
1 gnuplot
2 Copyright
?copyright
?license
     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 Permission to use, copy, and distribute this software and its
 documentation for any purpose with or without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.

 Permission to modify the software is granted, but not the right to
 distribute the complete modified source code.  Modifications are to
 be distributed as patches to the released version.  Permission to
 distribute binaries produced by compiling modified sources is granted,
 provided you
   1. distribute the corresponding source modifications from the
    released version in the form of a patch file along with the binaries,
   2. add special version identification to distinguish your version
    in addition to the base release version number,
   3. provide your name and address as the primary contact for the
    support of your modified version, and
   4. retain our contact information in regard to use of the base
    software.
 Permission to distribute the released version of the source code along
 with corresponding source modifications in the form of a patch file is
 granted with same provisions 2 through 4 for binary distributions.

 This software is provided "as is" without express or implied warranty
 to the extent permitted by applicable law.


       AUTHORS

       Original Software:
          Thomas Williams,  Colin Kelley.

       Gnuplot 2.0 additions:
          Russell Lang, Dave Kotz, John Campbell.

       Gnuplot 3.0 additions:
          Gershon Elber and many others.

       Gnuplot 4.0 additions:
          See list of contributors at head of this document.
2 Introduction
?introduction
?
 `gnuplot` is a command-driven interactive function and data plotting program.

 Any command-line arguments are assumed to be names of files containing
 `gnuplot` commands, with the exception of standard X11 arguments, which are
 processed first.  Each file is loaded with the `load` command, in the order
 specified.  `gnuplot` exits after the last file is processed.  The special
 filename "-" is used to denote standard input.  When no load files are named,
 `gnuplot` enters into an interactive mode.  See help for `batch/interactive`
 for more details.

 `gnuplot` is case sensitive (commands and function names written in lowercase
 are not the same as those written in CAPS).  All command names may be
 abbreviated as long as the abbreviation is not ambiguous.  Any number of
 commands may appear on a line (with the exception that `load` or `call` must
 be the final command), separated by semicolons (;).  Strings are indicated
 with quotes.  They may be either single or double quotation marks, e.g.,

       load "filename"
       cd 'dir'

 although there are some subtle differences (see `syntax` for more details).

 Many `gnuplot` commands have multiple options. Version 4 is less sensitive
 to the order of these options than earlier versions, but some order-dependence
 remains. If you see error messages about unrecognized options, please try
 again using the exact order listed in the documentation.

 Commands may extend over several input lines by ending each line but the last
 with a backslash (\).  The backslash must be the _last_ character on each
 line.  The effect is as if the backslash and newline were not there.  That
 is, no white space is implied, nor is a comment terminated.  Therefore,
 commenting out a continued line comments out the entire command
 (see `comments`).  But note that if an error occurs somewhere on a multi-line
 command, the parser may not be able to locate precisely where the error is
 and in that case will not necessarily point to the correct line.

 In this document, curly braces ({}) denote optional arguments and a vertical
 bar (|) separates mutually exclusive choices.  `gnuplot` keywords or `help`
 topics are indicated by backquotes or `boldface` (where available).  Angle
 brackets (<>) are used to mark replaceable tokens.  In many cases, a default
 value of the token will be taken for optional arguments if the token is
 omitted, but these cases are not always denoted with braces around the angle
 brackets.

 For on-line help on any topic, type `help` followed by the name of the topic
 or just `help` or `?` to get a menu of available topics.

 The new `gnuplot` user should begin by reading about `plotting` (if on-line,
 type `help plotting`).

 See the simple.dem demo, also available together with other demos on the web page
^ <a href="http://www.gnuplot.info/demo/simple.html">
           http://www.gnuplot.info/demo/simple.html
^ </a>
2 Seeking-assistance
^ <a name="Seeking-assistance"></a>
?help-desk
?seeking-assistance
 There is a mailing list for `gnuplot` users.  Note, however, that the
 newsgroup
       comp.graphics.apps.gnuplot
 is identical to the mailing list (they both carry the same set of messages).
 We prefer that you read the messages through the newsgroup rather than
 subscribing to the mailing list.  Instructions for subscribing to gnuplot
 mailing lists may be found via the gnuplot development website on SourceForge
^ <a href="http://sourceforge.net/projects/gnuplot">
           http://sourceforge.net/projects/gnuplot
^ </a>

 The address for mailing to list members is:
       gnuplot-info@lists.sourceforge.net

 Bug reports and code contributions should be mailed to:
       gnuplot-bugs@lists.sourceforge.net

 The list of those interested in beta-test versions is:
       gnuplot-beta@lists.sourceforge.net

 There is also the canonical (if occasionally out-of-date) gnuplot web page at

^ <a href="http://www.gnuplot.info">
           http://www.gnuplot.info
^ </a>

 Before seeking help, please check the

^ <a href="http://www.gnuplot.info/faq/">
           FAQ (Frequently Asked Questions) list.
^ </a>

 When posting a question, please include full details of the version of
 `gnuplot`, the machine, and operating system you are using.  A _small_ script
 demonstrating the problem may be useful.  Function plots are preferable to
 datafile plots.  If email-ing to gnuplot-info, please state whether or not
 you are subscribed to the list, so that users who use news will know to email
 a reply to you.  There is a form for such postings on the WWW site.

2 New features introduced in version 4.2
?new-features
?version 4.2 features
 Gnuplot version 4.2 offers many new features introduced since the preceding
 official version 4.0. This section lists major additions and gives a partial
 list of changes and minor new features. For a more exhaustive list, see the
 NEWS file.

3 New plot styles

4 Histogram
 Histograms, or bar charts, can be produced.
 See `histograms`.

4 Label plots
 In coordination with the new `datastrings` feature described below, gnuplot
 can draw a label at each vertex of a curve.
 See `labels`.

4 Image data
 The `image` and `rgbimage` styles allow to plot 2D images (from ascii or
 `binary` files) and map them in a 2D or 3D plot.
 See `image` and `rgbimage`.

4 Filled curves
 The plot style `fillstyle` has been augmented to allow to fill the area
 between two input curves with a color or a pattern.
 See `filledcurves`.

4 Vectors
 Gnuplot can draw plots with vectors with a small arrowhead, requiring four or
 six columns of data for 2D or 3D, respectively.
 See `vectors`.

3 Input from binary data files
 Gnuplot can now read a generic `binary` input, including matrix binary and
 `general binary` (until now gnuplot supported only its own `binary matrix`
 format). Several matrix file formats are autodetected (`gpbin`, `edf`, `avs`).
 Binary data files are mainly useful for `image` and `rgbimage` drawings.
 See `binary` and `binary general filetype`.

3 New plot elements

4 RGB colors
 Explicit RGB colors can be specified for all plot elements instead of
 specifying a predefined linetype.
 See `colorspec`.

4 Arbitrary rectangles
 You can place rectangles with desired fill style and border anywhere in a 2D
 plot.
 See `set object rectangle`.

3 String handling
4 String and text data read from datafiles
 Gnuplot can now read and process text fields in datafiles.
 See `datastrings`.
4 User-defined string variables, operators, and functions
 String variables and string functions are introduced. Most gnuplot commands
 that previously required a string constant will now also accept a string
 variable, a string expression, or a function that returns a string.
 See `string variables`.

3 Macros
 Gnuplot supports command line macro expansion  by '@stringvariablename'.
 See `macros`.

3 Auto-layout of multiple plots on a page
 The `multiplot` mode is now able to layout automatically simple
 multiplots without having to set the size or the position for each plot.
 See `multiplot`.

3 Internal variables
 Gnuplot now exports several "read-only" variables such as GPVAL_TERM,
 GPVAL_X_MIN, etc.
 See `gnuplot-defined variables`.

3 New or revised terminal drivers
4 `wxt`
 The `wxt` terminal is an interactive and cross-platform terminal for on-screen
 rendering. It uses the wxWidgets library for its user interface, and Cairo
 associated with Pango for the actual rendering, providing nice plots with
 antialiasing on lines and text. The terminal supports the full range of
 gnuplot capabilities, including mousing, pm3d plots, image plots and
 enhanced text.
4 `emf`
 The `emf` terminal generates an Enhanced Metafile Format file. This file
 format is the metafile standard on MS Win32 Systems. The emf terminal
 supports pm3d, rgb color, and image plot modes.
4 `gif`, `jpeg`, `png`
 The code for the terminals using the `gd` library has been consolidated.
 The `gif` terminal also knows how to produce an animated gif from a sequence
 of plots.
4 `postscript`
 The `postscript` terminal can load prologue files, which can contain
 additional user-defined sections with, for example, character encodings.
 See `postscript prologue`.
4 `ai`
 The Adobe Illustrator `ai` driver is outdated. Since Adobe Illustrator
 understands PostScript files, `set terminal post level1 ...` should be used
 instead.
4 `epslatex`, `pslatex`, `pstex`
 The terminals supporting an output to latex augmented by PostScript commands
 have been consolidated. Many options are the same as in the `postscript`
 terminal.
4 `windows`
 The `windows` terminal now supports the `enhanced text` mode.

3 Canvas size
?canvas size
?canvas
?set term size

 In earlier versions of gnuplot, some terminal types used the values from
 `set size` to control also the size of the output canvas; others did not.
 The use of 'set size' for this purpose was deprecated in version 4.2.
 In version 4.3 almost all terminals now behave as follows:

 `set term <terminal_type> size <XX>, <YY>` controls the size of the output
 file, or "canvas". Please see individual terminal documentation for allowed
 values of the size parameters.  By default, the plot will fill this canvas.

 `set size <XX>, <YY>` scales the plot itself relative to the size of the
 canvas.  Scale values less than 1 will cause the plot to not fill the entire
 canvas.  Scale values larger than 1 will cause only a portion of the plot to
 fit on the canvas.  Please be aware that setting scale values larger than 1
 may cause problems on some terminal types.

 The major exception to this convention is the PostScript driver, which
 by default continues to act as it has in earlier versions. Be warned that
 the next version of gnuplot may change the default behaviour of the
 PostScript driver as well.

 Example:

       set size 0.5, 0.5
       set term png size 600, 400
       set output "figure.png"
       plot "data" using lines

 These commands will produce an output file "figure.png" that is 600 pixels
 wide and 400 pixels tall. The plot will fill the lower left quarter of this
 canvas.  This is consistent with the way multiplot mode has always worked,
 however it is a change in the way the png driver worked for single plots in
 version 4.0.

2 Backwards compatibility
?backwards compatibility
?compatibility
 Gnuplot version 4.0 deprecated certain syntax used in earlier versions, but
 continued to recognize it.  This is now under the control of a configuration
 option, and can be disabled as follows:

       ./configure --disable-backwards-compatibility

 Notice: Deprecated syntax items may be disabled permanently in some future
 version of gnuplot.

 One major difference is the introduction of keywords to disambiguate complex
 commands, particularly commands containing string variables. A notable issue
 was the use of bare numbers to specify offsets, line and point types.
 Illustrative examples:

 Deprecated:
       set title "Old" 0,-1
       set data linespoints
       plot 1 2 4               # horizontal line at y=1
 New:
       TITLE = "New"
       set title TITLE offset char 0, char -1
       set style data linespoints
       plot 1 linetype 2 pointtype 4

 Another compatibility issue is the effect of the command `set size` outside
 when not in multiplot mode.  In earlier versions, the command
 `set size <xx>, <yy>` caused some terminals to change both the size of the plot
 and the size of the canvas is was drawn on; other terminatls changed only the
 plot size.  The use of `set size` to change the canvas size is now deprecated.

 Please see `set size`, `set term size` and also the documentation for
 individual terminals.

2 Features introduced in version 4.0
?version 4 features
 Gnuplot version 4.0 contained many features introduced since the preceding
 official version 3.7.  These are summarized here.

3 Mouse and hotkey support in interactive terminals

 Interaction with the current plot via mouse and hotkeys is supported for the
 X11, OS/2 Presentation Manager, ggi, Windows, and wxWidgets terminals. See
 `mouse input` for more information on mousing. See help for `bind` for
 information on hotkeys. Also see the documentation for individual mousing
 terminals `ggi`, `pm`, `windows`, `wxt` and `x11`.

 Sample script: mousevariables.dem

3 New terminals

 `aqua`: New terminal for Mac OS X. Requires AquaTerm 1.0 or later.

 `epslatex`: New terminal. Prepares eps figures for inclusion in LaTeX
 documents.

 `gif`: Consolidated with png/jpeg terminals. Requires libgd.

 `ggi`: New full-screen interactive terminal for Linux. Interface to the
 General Graphics Interface Library.

 `pdf`: New terminal exporting Adobe Portable Document Format. Requires libpdf.

 `png` and `jpeg`: Support for GIF, PNG and JPEG image output is provided by a
 new driver via libgd. The new driver supports many more features than the
 old png driver, including TrueType fonts. Requires libgd.

 `svg`: New terminal exporting Scalable Vector Graphics.

3 New plot style `pm3d`

 The `splot` command is now capable of plotting 2D maps and 3D surfaces
 colored by greyscale or color palettes. See help for `set pm3d`, `set palette`,
 `set cbrange`, `set view map`, `set colorbox` and `test palette`.

 Sample scripts: pm3d.dem pm3dcolors.dem pm3dgamma.dem

3 Filled boxes

 A solid color or patterned fill style can be set for any plot style that
 contains boxes. See `boxes`, `boxerrorbars`, `boxxyerrorbars`,
 `candlesticks`, `set style fill`.

 Sample scripts: fillstyle.dem candlesticks.dem

3 New plot option smooth frequency

 Input data can be filtered through several built-in routines for interpolation
 or approximation of data.  See `smooth`, `frequency`, `unique`.

 Sample scripts: step.dem mgr.dem

3 Improved text options

 Most gnuplot plot commands that produce text labels now accept modifiers to
 specify text color, font, size, and rotation angle. See `set label`.
 Not all terminal types support these options, however.  The enhanced text
 mode previously available for the postscript and pm terminals has been
 extended to other terminal types as well.  Terminal types currently supported
 include aqua, dumb, jpeg, pdf, pm, png, postscript, x11, windows, and wxt.
 See `enhanced text`.

 Sample scripts: textcolor.dem textrotate.dem

3 More text encodings

 Several terminals, including `postscript`, `x11` and `pm`, support additional
 text `encodings`: ISO 8859-1 (Latin 1), ISO 8859-2 (Latin 2), ISO 8859-15
 (variant of 8859-1 with Euro sign), KOI8-R and KOI8-U (cyrillic), and
 miscellaneous codepages. See `encoding` for more details.

3 Arrows

 Single- or double-ended arrows can be placed on a plot individually from the
 command line or from a data file via the `plot with vectors` style.
 See `set style arrow`, `plotting styles vectors`.

 Sample scripts: arrowstyle.dem vector.dem

3 Data file format

 The new `set datafile` command can be used to specify information about the
 format of input data files, including the characters used to separate fields,
 to indicate comment lines, and to specify missing data.  Gnuplot now attempts
 to recognize text fields with embedded blanks as single entities based on the
 datafile format settings.  This allows input from csv (comma-separated value)
 files such as those exported by spreadsheet programs. See `set datafile`.
 See also the `binary` option (introduced in 4.2).

3 New commands

 `set view map` selects a top-view 2D projection of 3D surface plot.

 `set term push` and `set term pop` save and restore the current terminal type.

 `load` and `save` commands accept piped input and output, respectively.

3 Other changes and additions

 Since gnuplot 4.0, `unset <something>` is preferred to `set no<something>`.
 The older form has been deprecated.
 Version 4.2 continues to allow the older syntax, but such backwards
 compatibility may be lost in future versions.

 Commands of the form `set <something> <style>` also are deprecated in favor
 of the more general form `set style <something> <options>`.  Many more plot
 elements now have style options of their own, including arrows, filled
 areas, lines, and points. There are also style settings for input data and
 formatting. Please see `set style`, `set decimalsign`, and `set datafile`.

 The MS Windows package includes an additional executable `pgnuplot.exe` to
 support piping command through standard input, which is otherwise not
 available for graphical applications on this system.

3 Accompanying documentation

 In directory docs/psdocs/ you may find new information in the gnuplot output
 postscript file guide, list of postscript symbols in different encodings.

 Improved FAQ. Please read it before asking your question in a public forum.

 There are plenty of new demos *.dem in the demo/ directory. Please run them,
 for example by
       load "all.dem"
 before asking for help.  Plots produced by the demo scripts can also be viewed
 at
^ <a href="http://www.gnuplot.info/demo/">
 http://www.gnuplot.info/demo/
^ </a>

2 Batch/Interactive Operation
?batch/interactive
 `gnuplot` may be executed in either batch or interactive modes, and the two
 may even be mixed together on many systems.

 Any command-line arguments are assumed to be names of files containing
 `gnuplot` commands (with the exception of standard X11 arguments, which are
 processed first).  Each file is loaded with the `load` command, in the order
 specified.  `gnuplot` exits after the last file is processed.  When no load
 files are named, `gnuplot` enters into an interactive mode.  The special
 filename "-" is used to denote standard input.

 Both the `exit` and `quit` commands terminate the current command file and
 `load` the next one, until all have been processed.

 Examples:

 To launch an interactive session:
       gnuplot

 To launch a batch session using two command files "input1" and "input2":
       gnuplot input1 input2

 To launch an interactive session after an initialization file "header" and
 followed by another command file "trailer":
       gnuplot header - trailer
2 Command-line-editing
?line-editing
?editing
?command-line-editing
 Command-line editing is supported by the Unix, Atari, VMS, MS-DOS and OS/2
 versions of `gnuplot`.  Also, a history mechanism allows previous commands to
 be edited and re-executed.  After the command line has been edited, a newline
 or carriage return will enter the entire line without regard to where the
 cursor is positioned.

 (The readline function in `gnuplot` is not the same as the readline used in
 GNU Bash and GNU Emacs.  If the GNU version is desired, it may be selected
 instead of the `gnuplot` version at compile time.)


 The editing commands are as follows:

@start table - first is interactive cleartext form
       `Line-editing`:

       ^B    moves back a single character.
       ^F    moves forward a single character.
       ^A    moves to the beginning of the line.
       ^E    moves to the end of the line.
       ^H    and DEL delete the previous character.
       ^D    deletes the current character.
       ^K    deletes from current position to the end of line.
       ^L,^R redraws line in case it gets trashed.
       ^U    deletes the entire line.
       ^W    deletes from the current word to the end of line.

       `History`:

       ^P    moves back through history.
       ^N    moves forward through history.
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{Command-line Editing Commands} \\ \hline \hline
#Character & Function \\ \hline
# & \multicolumn{1}{|c|}{Line Editing}\\ \cline{2-2}
#\verb~^B~ & move back a single character.\\
#\verb~^F~ & move forward a single character.\\
#\verb~^A~ & move to the beginning of the line.\\
#\verb~^E~ & move to the end of the line.\\
#\verb~^H, DEL~ & delete the previous character.\\
#\verb~^D~ & delete the current character.\\
#\verb~^K~ & delete from current position to the end of line.\\
#\verb~^L, ^R~ & redraw line in case it gets trashed.\\
#\verb~^U~ & delete the entire line. \\
#\verb~^W~ & delete from the current word to the end of line. \\ \hline
# & \multicolumn{1}{|c|}{History} \\ \cline{2-2}
#\verb~^P~ & move back through history.\\
#\verb~^N~ & move forward through history.\\
%c l .
%Character@Function
%_
%@Line Editing
%^B@move back a single character.
%^F@move forward a single character.
%^A@move to the beginning of the line.
%^E@move to the end of the line.
%^H, DEL@delete the previous character.
%^D@delete the current character.
%^K@delete from current position to the end of line.
%^L, ^R@redraw line in case it gets trashed.
%^U@delete the entire line.
%^W@delete from the current word to the end of line.
%_
%@History
%^P@move back through history.
%^N@move forward through history.
@end table

 On the IBM PC, the use of a TSR program such as DOSEDIT or CED may be desired
 for line editing.  The default makefile assumes that this is the case;  by
 default `gnuplot` will be compiled with no line-editing capability.  If you
 want to use `gnuplot`'s line editing, set READLINE in the makefile and add
 readline.obj to the link file.  The following arrow keys may be used on the
 IBM PC and Atari versions if readline is used:

@start table - first is interactive cleartext form
       Left  Arrow      - same as ^B.
       Right Arrow      - same as ^F.
       Ctrl Left  Arrow - same as ^A.
       Ctrl Right Arrow - same as ^E.
       Up    Arrow      - same as ^P.
       Down  Arrow      - same as ^N.
#\begin{tabular}{|cl|} \hline
#Arrow key  & Function \\ \hline
#Left       & same as \verb~^B~. \\
#Right      & same as \verb~^F~. \\
#Ctrl Left  & same as \verb~^A~. \\
#Ctrl Right & same as \verb~^E~. \\
#Up         & same as \verb~^P~. \\
#Down       & same as \verb~^N~. \\
%c l .
%Arrow key@Function
%_
%Left Arrow@same as ^B.
%Right Arrow@same as ^F.
%Ctrl Left Arrow@same as ^A.
%Ctrl Right Arrow@same as ^E.
%Up Arrow@same as ^P.
%Down Arrow@same as ^N.
%_
@end table

 The Atari version of readline defines some additional key aliases:

@start table - first is interactive cleartext form
       Undo            - same as ^L.
       Home            - same as ^A.
       Ctrl Home       - same as ^E.
       Esc             - same as ^U.
       Help            - `help` plus return.
       Ctrl Help       - `help`.
#\begin{tabular}{|cl|} \hline
#Key & Function \\ \hline
#Undo      & same as \verb~^L~. \\
#Home      & same as \verb~^A~. \\
#Ctrl Home & same as \verb~^E~. \\
#Esc       & same as \verb~^U~. \\
#Help      & `{\bf help}` plus return. \\
#Ctrl Help & `{\bf help}`. \\
%c l .
%Key@Function
%_
%Undo@same as ^L.
%Home@same as ^A.
%Ctrl Home@same as ^E.
%Esc@same as ^U.
%Help@help plus return.
%Ctrl Help@help .
%_
@end table
2 Comments
?comments
 Comments are supported as follows: a `#` may appear in most places in a line
 and `gnuplot` will ignore the rest of the line.  It will not have this effect
 inside quotes, inside numbers (including complex numbers), inside command
 substitutions, etc.  In short, it works anywhere it makes sense to work.

 See also `set datafile commentschars` for specifying comment characters in
 data files.
2 Coordinates
?coordinates
 The commands `set arrow`, `set key`, `set label` and `set object` allow you
 to draw something at an arbitrary position on the graph.  This position is
 specified by the syntax:

       {<system>} <x>, {<system>} <y> {,{<system>} <z>}

 Each <system> can either be `first`, `second`, `graph`, `screen`, or
 `character`.

 `first` places the x, y, or z coordinate in the system defined by the left
 and bottom axes; `second` places it in the system defined by the second axes
 (top and right); `graph` specifies the area within the axes---0,0 is bottom
 left and 1,1 is top right (for splot, 0,0,0 is bottom left of plotting area;
 use negative z to get to the base---see `set ticslevel`); `screen`
 specifies the screen area (the entire area---not just the portion selected by
 `set size`), with 0,0 at bottom left and 1,1 at top right; and `character`
 gives the position in character widths and heights from the bottom left of
 the screen area (screen 0,0), `character` coordinates depend on the chosen
 font size.

 If the coordinate system for x is not specified, `first` is used.  If the
 system for y is not specified, the one used for x is adopted.

 In some cases, the given coordinate is not an absolute position but a
 relative value (e.g., the second position in `set arrow` ... `rto`).  In
 most cases, the given value serves as difference to the first position.
 If the given coordinate resides in a logarithmic axis the value is
 interpreted as factor. For example,

       set logscale x
       set arrow 100,5 rto 10,2

 plots an arrow from position 100,5 to position 1000,7 since the x axis is
 logarithmic while the y axis is linear.

 If one (or more) axis is timeseries, the appropriate coordinate should
 be given as a quoted time string according to the `timefmt` format string.
 See `set xdata` and `set timefmt`.  `gnuplot` will also accept an integer
 expression, which will be interpreted as seconds from 1 January 2000.
2 Datastrings
?datastrings
 The configuration option --enable-datastrings allows gnuplot to read and
 process text fields in datafiles. A text field consists of either an arbitrary
 string of printable characters containing no whitespace or an arbitrary string
 of characters, possibly including whitespace, delimited by double quotes.
 The following sample line from a datafile is interpreted to contain four
 columns, with a text field in column 3:

   1.000 2.000 "Third column is all of this text" 4.00

 Text fields can be positioned within a 2-D or 3-D plot using the commands:

   plot 'datafile' using 1:2:4 with labels
   splot 'datafile using 1:2:3:4 with labels

 A column of text data can also be used to label the ticmarks along one or more
 of the plot axes. The example below plots a line through a series of points
 with (X,Y) coordinates taken from columns 3 and 4 of the input datafile.
 However, rather than generating regularly spaced tics along the x axis
 labeled numerically, gnuplot will position a tic mark along the x axis at the
 X coordinate of each point and label the tic mark with text taken from column
 1 of the input datafile.

   set xtics
   plot 'datafile' using 3:4:xticlabels(1) with linespoints

 There is also an option that will interpret the first entry in a column of
 input data as a text field, and use it as the key title for data plotted from
 that column. The example given below will use the first entry in column 2 to
 generate a title in the key box, while processing the remainder of columns
 2 and 4 to draw the required line:

   plot 'datafile' using 1:(f($2)/$4) title 2 with lines

 See `set style labels`, `using xticlabels`, `plot title`, `using`.
2 Environment
?environment
 A number of shell environment variables are understood by `gnuplot`.  None of
 these are required, but may be useful.

 If GNUTERM is defined, it is used as the name of the terminal type to be
 used.  This overrides any terminal type sensed by `gnuplot` on start-up, but
 is itself overridden by the .gnuplot (or equivalent) start-up file
 (see `start-up`) and, of course, by later explicit changes.

 On Unix, AmigaOS, AtariTOS, MS-DOS and OS/2, GNUHELP may be defined to be the
 pathname of the HELP file (gnuplot.gih).

 On VMS, the logical name GNUPLOT$HELP should be defined as the name of the
 help library for `gnuplot`.  The `gnuplot` help can be put inside any system
 help library, allowing access to help from both within and outside `gnuplot`
 if desired.

 On Unix, HOME is used as the name of a directory to search for a .gnuplot
 file if none is found in the current directory.  On AmigaOS, AtariTOS,
 MS-DOS, Windows and OS/2, GNUPLOT is used.  On Windows, the NT-specific
 variable USERPROFILE is tried, too. VMS, SYS$LOGIN: is used. Type `help
 start-up`.

 On Unix, PAGER is used as an output filter for help messages.

 On Unix, AtariTOS and AmigaOS, SHELL is used for the `shell` command.  On
 MS-DOS and OS/2, COMSPEC is used for the `shell` command.

 On MS-DOS, if the BGI or Watcom interface is used, PCTRM is used to tell
 the maximum resolution supported by your monitor by setting it to
 S<max. horizontal resolution>. E.g. if your monitor's maximum resolution is
 800x600, then use:
       set PCTRM=S800
 If PCTRM is not set, standard VGA is used.

 FIT_SCRIPT may be used to specify a `gnuplot` command to be executed when a
 fit is interrupted---see `fit`.  FIT_LOG specifies the default filename of the
 logfile maintained by fit.

 GNUPLOT_LIB may be used to define additional search directories for data
 and command files. The variable may contain a single directory name, or
 a list of directories separated by a platform-specific path separator,
 eg. ':' on Unix, or ';' on DOS/Windows/OS/2/Amiga platforms. The contents
 of GNUPLOT_LIB are appended to the `loadpath` variable, but not saved
 with the `save` and `save set` commands.

 Several gnuplot terminal drivers access TrueType fonts via the gd library.
 For these drivers the font search path is controlled by the environmental
 variable GDFONTPATH.  Furthermore, a default font for these drivers may be
 set via the environmental variable GNUPLOT_DEFAULT_GDFONT.

 The postscript terminal uses its own font search path. It is controlled by
 the environmental variable GNUPLOT_FONTPATH. The format is the same as for
 GNUPLOT_LIB. The contents of GNUPLOT_FONTPATH are appended to the `fontpath`
 variable, but not saved with the `save` and `save set` commands.

 GNUPLOT_PS_DIR is used by the postscript driver to use external prologue
 files. Depending on the build process, gnuplot contains either a builtin
 copy of those files or simply a default hardcoded path. Use this variable
 to test the postscript terminal with custom prologue files. See
 `postscript prologue`.
2 Expressions
?expressions
 In general, any mathematical expression accepted by C, FORTRAN, Pascal, or
 BASIC is valid.  The precedence of these operators is determined by the
 specifications of the C programming language.  White space (spaces and tabs)
 is ignored inside expressions.

 Complex constants are expressed as {<real>,<imag>}, where <real> and <imag>
 must be numerical constants.  For example, {3,2} represents 3 + 2i; {0,1}
 represents 'i' itself.  The curly braces are explicitly required here.

 Note that gnuplot uses both "real" and "integer" arithmetic, like FORTRAN and
 C.  Integers are entered as "1", "-10", etc; reals as "1.0", "-10.0", "1e1",
 3.5e-1, etc.  The most important difference between the two forms is in
 division: division of integers truncates: 5/2 = 2; division of reals does
 not: 5.0/2.0 = 2.5.  In mixed expressions, integers are "promoted" to reals
 before evaluation: 5/2e0 = 2.5.  The result of division of a negative integer
 by a positive one may vary among compilers.  Try a test like "print -5/2" to
 determine if your system chooses -2 or -3 as the answer.

 The integer expression "1/0" may be used to generate an "undefined" flag,
 which causes a point to ignored; the `ternary` operator gives an example.

 The real and imaginary parts of complex expressions are always real, whatever
 the form in which they are entered: in {3,2} the "3" and "2" are reals, not
 integers.

 Gnuplot can also perform simple operations on strings and string variables.
 For example, the expression ("A" . "B" eq "AB") evaluates as true, illustrating
 the string concatenation operator and the string equality operator.

 A string which contains a numerical value is promoted to the corresponding
 integer or real value if used in a numerical expression. Thus ("3" + "4" == 7)
 and (6.78 == "6.78") both evaluate to true.  An integer, but not a real or
 complex value, is promoted to a string if used in string concatenation.
 A typical case is the use of integers to construct file names or other strings;
 e.g. ("file" . 4 eq "file4") is true.

 Substrings can be specified using a postfixed range descriptor [beg:end].
 For example, "ABCDEF"[3:4] == "CD"   and   "ABCDEF"[4:*] == "DEF"
 The syntax "string"[beg:end] is exactly equivalent to calling the built-in
 string-valued function substr("string",beg,end), except that you cannot
 omit either beg or end from the function call.
3 Functions
?expressions functions
?functions
 The functions in `gnuplot` are the same as the corresponding functions in
 the Unix math library, except that all functions accept integer, real, and
 complex arguments, unless otherwise noted.

 For those functions that accept or return angles that may be given in either
 degrees or radians (sin(x), cos(x), tan(x), asin(x), acos(x), atan(x),
 atan2(x) and arg(z)), the unit may be selected by `set angles`, which
 defaults to radians.

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{Math library functions} \\ \hline \hline
#Function & Arguments & Returns \\ \hline
%c c l .
%Function@Arguments@Returns
%_
4 abs
?expressions functions abs
?functions abs
?abs
#abs(x) & any  &  absolute value of $x$, $|x|$; same type \\
#abs(x) & complex &  length of $x$, $\sqrt{{\mbox{real}(x)^{2} +
#\mbox{imag}(x)^{2}}}$ \\
%abs(x)@any@absolute value of $x$, $|x|$; same type
%abs(x)@complex@length of $x$, $sqrt{roman real (x) sup 2 + roman imag (x) sup 2}$
 The `abs(x)` function returns the absolute value of its argument.  The
 returned value is of the same type as the argument.

 For complex arguments, abs(x) is defined as the length of x in the complex
 plane [i.e.,  sqrt(real(x)**2 + imag(x)**2) ].
4 acos
?expressions functions acos
?functions acos
?acos
#acos(x) & any  & $\cos^{-1} x$ (inverse cosine) \\
%acos(x)@any@$cos sup -1 x$ (inverse cosine)
 The `acos(x)` function returns the arc cosine (inverse cosine) of its
 argument.  `acos` returns its argument in radians or degrees, as selected by
 `set angles`.
4 acosh
?expressions functions acosh
?functions acosh
?acosh
#acosh(x) & any  & $\cosh^{-1} x$ (inverse hyperbolic cosine) in radians \\
%acosh(x)@any@$cosh sup -1 x$ (inverse hyperbolic cosine) in radians
 The `acosh(x)` function returns the inverse hyperbolic cosine of its argument
 in radians.
4 arg
?expressions functions arg
?functions arg
?arg
#arg(x) & complex & the phase of $x$ \\
%arg(x)@complex@the phase of $x$
 The `arg(x)` function returns the phase of a complex number in radians or
 degrees, as selected by `set angles`.
4 asin
?expressions functions asin
?functions asin
?asin
#asin(x) & any  & $\sin^{-1} x$ (inverse sin) \\
%asin(x)@any@$sin sup -1 x$ (inverse sin)
 The `asin(x)` function returns the arc sin (inverse sin) of its argument.
 `asin` returns its argument in radians or degrees, as selected by `set
 angles`.
4 asinh
?expressions functions asinh
?functions asinh
?asinh
#asinh(x) & any  & $\sinh^{-1} x$ (inverse hyperbolic sin) in radians \\
%asinh(x)@any@$sinh sup -1 x$ (inverse hyperbolic sin) in radians
 The `asinh(x)` function returns the inverse hyperbolic sin of its argument in
 radians.
4 atan
?expressions functions atan
?functions atan
?atan
#atan(x) & any  & $\tan^{-1} x$ (inverse tangent) \\
%atan(x)@any@$tan sup -1 x$ (inverse tangent)
 The `atan(x)` function returns the arc tangent (inverse tangent) of its
 argument.  `atan` returns its argument in radians or degrees, as selected by
 `set angles`.
4 atan2
?expressions functions atan2
?functions atan2
?atan2
#atan2(y,x) & int or real & $\tan^{-1} (y/x)$ (inverse tangent) \\
%atan2(y,x)@int or real@$tan sup -1 (y/x)$ (inverse tangent)
 The `atan2(y,x)` function returns the arc tangent (inverse tangent) of the
 ratio of the real parts of its arguments.  `atan2` returns its argument in
 radians or degrees, as selected by `set angles`, in the correct quadrant.
4 atanh
?expressions functions atanh
?functions atanh
?atanh
#atanh(x) & any  & $\tanh^{-1} x$ (inverse hyperbolic tangent) in radians \\
%atanh(x)@any@$tanh sup -1 x$ (inverse hyperbolic tangent) in radians
 The `atanh(x)` function returns the inverse hyperbolic tangent of its
 argument in radians.
4 besj0
?expressions functions besj0
?functions besj0
?besj0
#besj0(x) & int or real &  $j_{0}$ Bessel function of $x$, in radians \\
%besj0(x)@int or real@$j sub 0$ Bessel function of $x$, in radians
 The `besj0(x)` function returns the j0th Bessel function of its argument.
 `besj0` expects its argument to be in radians.
4 besj1
?expressions functions besj1
?functions besj1
?besj1
#besj1(x) & int or real & $j_{1}$ Bessel function of $x$, in radians \\
%besj1(x)@int or real@$j sub 1$ Bessel function of $x$, in radians
 The `besj1(x)` function returns the j1st Bessel function of its argument.
 `besj1` expects its argument to be in radians.
4 besy0
?expressions functions besy0
?functions besy0
?besy0
#besy0(x) & int or real & $y_{0}$ Bessel function of $x$, in radians \\
%besy0(x)@int or real@$y sub 0$ Bessel function of $x$, in radians
 The `besy0(x)` function returns the y0th Bessel function of its argument.
 `besy0` expects its argument to be in radians.
4 besy1
?expressions functions besy1
?functions besy1
?besy1
#besy1(x) & int or real & $y_{1}$ Bessel function of $x$, in radians \\
%besy1(x)@int or real@$y sub 1$ Bessel function of $x$, in radians
 The `besy1(x)` function returns the y1st Bessel function of its argument.
 `besy1` expects its argument to be in radians.
4 ceil
?expressions functions ceil
?functions ceil
?ceil
#ceil(x) & any & $\lceil x \rceil$, smallest integer not less than $x$
#(real part) \\
%ceil(x)@any@$left ceiling x right ceiling$, smallest integer not less than $x$ (real part)
 The `ceil(x)` function returns the smallest integer that is not less than its
 argument.  For complex numbers, `ceil` returns the smallest integer not less
 than the real part of its argument.
4 cos
?expressions functions cos
?functions cos
?cos
#cos(x) & any & $\cos x$, cosine of $x$ \\
%cos(x)@radians@$cos~x$, cosine of $x$
 The `cos(x)` function returns the cosine of its argument.  `cos` accepts its
 argument in radians or degrees, as selected by `set angles`.
4 cosh
?expressions functions cosh
?functions cosh
?cosh
#cosh(x) & any & $\cosh x$, hyperbolic cosine of $x$ in radians \\
%cosh(x)@any@$cosh~x$, hyperbolic cosine of $x$ in radians
 The `cosh(x)` function returns the hyperbolic cosine of its argument.  `cosh`
 expects its argument to be in radians.
4 erf
?expressions functions erf
?functions erf
?erf
#erf(x) & any & $\mbox{erf}(\mbox{real}(x))$,  error function of real($x$) \\
%erf(x)@any@$erf ( roman real (x))$, error function of real ($x$)
 The `erf(x)` function returns the error function of the real part of its
 argument.  If the argument is a complex value, the imaginary component is
 ignored.  See `erfc`, `inverf`, and `norm`.
4 erfc
?expressions functions erfc
?functions erfc
?erfc
#erfc(x) & any & $\mbox{erfc}(\mbox{real}(x))$,  1.0 - error function of real($x$) \\
%erfc(x)@any@$erfc ( roman real (x))$, 1.0 - error function of real ($x$)
 The `erfc(x)` function returns 1.0 - the error function of the real part of
 its argument.  If the argument is a complex value, the imaginary component is
 ignored.  See `erf`, `inverf`, and `norm`.
4 exp
?expressions functions exp
?functions exp
?exp
#exp(x) & any & $e^{x}$,  exponential function of $x$ \\
%exp(x)@any@$e sup x$, exponential function of $x$
 The `exp(x)` function returns the exponential function of its argument (`e`
 raised to the power of its argument).  On some implementations (notably
 suns), exp(-x) returns undefined for very large x.  A user-defined function
 like safe(x) = x<-100 ? 0 : exp(x) might prove useful in these cases.
4 floor
?expressions functions floor
?functions floor
?floor
#floor(x) & any & $\lfloor x \rfloor$,  largest integer not greater
#than $x$ (real part) \\
%floor(x)@any@$left floor x right floor$, largest integer not greater than $x$ (real part)
 The `floor(x)` function returns the largest integer not greater than its
 argument.  For complex numbers, `floor` returns the largest integer not
 greater than the real part of its argument.
4 gamma
?expressions functions gamma
?functions gamma
?gamma
#gamma(x) & any & $\mbox{gamma}(\mbox{real}(x))$,  gamma function of real($x$) \\
%gamma(x)@any@$GAMMA ( roman real (x))$, gamma function of real ($x$)
 The `gamma(x)` function returns the gamma function of the real part of its
 argument.  For integer n, gamma(n+1) = n!.  If the argument is a complex
 value, the imaginary component is ignored.
4 ibeta
?expressions functions ibeta
?functions ibeta
?ibeta
#ibeta(p,q,x) & any & $\mbox{ibeta}(\mbox{real}(p,q,x))$,  ibeta function of real($p$,$q$,$x$) \\
%ibeta(p,q,x)@any@$ibeta ( roman real (p,q,x))$, ibeta function of real ($p$,$q$,$x$)
 The `ibeta(p,q,x)` function returns the incomplete beta function of the real
 parts of its arguments. p, q > 0 and x in [0:1].  If the arguments are
 complex, the imaginary components are ignored.
4 inverf
?expressions functions inverf
?functions inverf
?inverf
#inverf(x) & any &  inverse error function of real($x$)  \\
%inverf(x)@any@inverse error function real($x$)
 The `inverf(x)` function returns the inverse error function of the real part
 of its argument.   See `erf` and `invnorm`.
4 igamma
?expressions functions igamma
?functions igamma
?igamma
#igamma(a,x) & any & $\mbox{igamma}(\mbox{real}(a,x))$,  igamma function of real($a$,$x$) \\
%igamma(a,x)@any@$igamma ( roman real (a,x))$, igamma function of real ($a$,$x$)
 The `igamma(a,x)` function returns the normalized incomplete gamma
 function of the real parts of its arguments, where a > 0 and x >= 0.
 The standard notation is P(a,x), e.g. Abramowitz and Stegun (6.5.1),
 with limiting value of 1 as x approaches infinity.  If the arguments
 are complex, the imaginary components are ignored.
4 imag
?expressions functions imag
?functions imag
?imag
#imag(x) & complex &  imaginary part of $x$ as a real number \\
%imag(x)@complex@imaginary part of $x$ as a real number
 The `imag(x)` function returns the imaginary part of its argument as a real
 number.
4 invnorm
?expressions functions invnorm
?functions invnorm
?invnorm
#invnorm(x) & any &  inverse normal distribution function of real($x$)  \\
%invnorm(x)@any@inverse normal distribution function real($x$)
 The `invnorm(x)` function returns the inverse cumulative normal (Gaussian)
 distribution function of the real part of its argument.  See `norm`.
4 int
?expressions functions int
?functions int
?int
#int(x) & real &  integer part of $x$, truncated toward zero \\
%int(x)@real@integer part of $x$, truncated toward zero
 The `int(x)` function returns the integer part of its argument, truncated
 toward zero.
4 lambertw
?expressions functions lambertw
?functions lambertw
?lambertw
#lambertw(x) & real & Lambert W function \\
%lambertw(x)@real@Lambert W function
 The lambertw function returns the value of the principal branch of
 Lambert's W function, which is defined by the equation (W(z)*exp(W(z))=z.
 z must be a real number with z >= -exp(-1).
4 lgamma
?expressions functions lgamma
?functions lgamma
?lgamma
#lgamma(x) & any & $\mbox{lgamma}(\mbox{real}(x))$,  lgamma function of real($x$) \\
%lgamma(x)@any@$lgamma ( roman real (x))$, lgamma function of real ($x$)
 The `lgamma(x)` function returns the natural logarithm of the gamma function
 of the real part of its argument.  If the argument is a complex value, the
 imaginary component is ignored.
4 log
?expressions functions log
?functions log
?log
#log(x) & any & $\log_{e} x$,  natural logarithm (base $e$) of $x$ \\
%log(x)@any@$ln~x$, natural logarithm (base $e$) of $x$
 The `log(x)` function returns the natural logarithm (base `e`) of its
 argument.  See `log10`.
4 log10
?expressions functions log10
?functions log10
?log10
#log10(x) & any & $\log_{10} x$,  logarithm (base $10$) of $x$ \\
%log10(x)@any@${log sub 10}~x$, logarithm (base $10$) of $x$
 The `log10(x)` function returns the logarithm (base 10) of its argument.
4 norm
?expressions functions norm
?functions norm
?norm
#norm(x) & any & normal distribution (Gaussian) function of real($x$) \\
%norm(x)@any@$norm(x)$, normal distribution function of real($x$)
 The `norm(x)` function returns the cumulative normal (Gaussian) distribution
 function of the real part of its argument.   See `invnorm`, `erf` and `erfc`.
4 rand
?expressions functions rand
?functions rand
?rand
#rand(x) & any & $\mbox{rand}(x)$,  pseudo random number generator \\
%rand(x)@any@$rand (x)$, pseudo random number generator
 `rand(0)`  returns a pseudo random number in the interval [0:1] generated
            from the current value of two internal 32-bit seeds.
 `rand(-1)` resets both seeds to a standard value.
 `rand(x)`  for x>0 sets both seeds to a value based on the value of x.
 `rand({x,y})` for x>0 sets seed1 to x and seed2 to y.
 Note: This behavior has changed starting with gnuplot version 3.8l. Older
 scripts that expected rand(x>0) to produce sequential pseudo-random numbers
 from the same seeded sequence must be changed to call rand(0) instead.
4 real
?expressions functions real
?functions real
?real
#real(x) & any &  real part of $x$ \\
%real(x)@any@real part of $x$
 The `real(x)` function returns the real part of its argument.
4 sgn
?expressions functions sgn
?functions sgn
?sgn
#sgn(x) & any & 1 if $x>0$, -1 if $x<0$, 0 if $x=0$. imag($x$) ignored \\
%sgn(x)@any@1 if $x > 0$, -1 if $x < 0$, 0 if $x = 0$. $roman imag (x)$ ignored
 The `sgn(x)` function returns 1 if its argument is positive, -1 if its
 argument is negative, and 0 if its argument is 0.  If the argument is a
 complex value, the imaginary component is ignored.
4 sin
?expressions functions sin
?functions sin
?sin
#sin(x) & any & $\sin x$, sine of $x$ \\
%sin(x)@any@$sin~x$, sine of $x$
 The `sin(x)` function returns the sine of its argument.  `sin` expects its
 argument to be in radians or degrees, as selected by `set angles`.
4 sinh
?expressions functions sinh
?functions sinh
?sinh
#sinh(x) & any & $\sinh x$, hyperbolic sine of $x$ in radians \\
%sinh(x)@any@$sinh~x$, hyperbolic sine of $x$ in radians
 The `sinh(x)` function returns the hyperbolic sine of its argument.  `sinh`
 expects its argument to be in radians.
4 sqrt
?expressions functions sqrt
?functions sqrt
?sqrt
#sqrt(x) & any & $\sqrt{x}$,  square root of $x$ \\
%sqrt(x)@any@$sqrt x $, square root of $x$
 The `sqrt(x)` function returns the square root of its argument.
4 tan
?expressions functions tan
?functions tan
?tan
#tan(x) & any & $\tan x$,  tangent of $x$ \\
%tan(x)@any@$tan~x$, tangent of $x$
 The `tan(x)` function returns the tangent of its argument.  `tan` expects
 its argument to be in radians or degrees, as selected by `set angles`.
4 tanh
?expressions functions tanh
?functions tanh
?tanh
#tanh(x) & any & $\tanh x$, hyperbolic tangent of $x$ in radians\\
%tanh(x)@any@$tanh~x$, hyperbolic tangent of $x$ in radians
 The `tanh(x)` function returns the hyperbolic tangent of its argument.  `tanh`
 expects its argument to be in radians.
@end table

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{String functions} \\ \hline \hline
#Function & Arguments & Returns \\ \hline
%c c l .
%Function@Arguments@Returns
%_
4 gprintf
?expressions functions gprintf
?functions gprintf
#gprintf("format",x) & any & string result from applying gnuplot's format parser \\
%gprintf("format",x)@any@string result from applysing gnuplot's format parser
 `gprintf("format",x)` applies gnuplot's own format specifiers to the single
 variable x and returns the resulting string. If you want standard C-language
 format specifiers, you must instead use `sprintf("format",x)`.
 See `format specifiers`.
4 sprintf
?expressions functions sprintf
?functions sprintf
?sprintf
#sprintf("format",x,...) & multiple & string result from C-language sprintf \\
%sprintf("format",x,...)@multiple@string result from C-language sprintf
 `sprintf("format",var1,var2,...)` applies standard C-language format specifiers
 to multiple arguments (10 max) and returns the resulting string. If you want to
 use gnuplot's own format specifiers, you must instead call `gprintf()`.
 For information on sprintf format specifiers, please see standard C-language
 documentation or the unix sprintf man page.
4 strlen
?expressions functions strlen
?functions strlen
?strlen
#strlen("string") & string & int length of string \\
%strlen("string")@string@int length of string
 `strlen("string")` returns the number of characters in the string.
4 strstrt
?expressions functions strstrt
?functions strstrt
?strstrt
#strstrt("string","key") & strings & int index of first character of substring "key" \\
%strstrt("string","key")@strings@int index of first character of substring "key"
 `strstrt("string","key")` searches for the character string "key" in "string"
 and returns the index to the first character of "key". If "key" is not found,
 returns 0. Similar to C library function strstr except that it returns an
 index rather than a string pointer. strstrt("hayneedlestack","needle") = 4.
4 substr
?expressions functions substr
?functions substr
?substr
=substring
#substr("string",beg,end) & multiple & string "string"[beg:end] \\
%substr("string",beg,end)@multiple@string "string"[beg:end]
 `substr("string",beg,end)` returns the substring consisting of characters
 beg through end of the original string. This is exactly equivalent to the
 expression "string"[beg:end] except that you do not have the option of
 ommitting beg or end.
4 system
?expressions functions system
?functions system
?system function
=system
#system("command") & string & string containing output stream of shell command \\
%system("command")@string@stdout containing output stream of shell command
 `system("command")` executes "command" using the standard shell and returns
 the resulting character stream from stdout as string variable.
 One optional trailing newline is ignored.

 This can be used to import external functions into gnuplot scripts using
 'f(x) = real(system(sprintf("somecommand %f", x)))'.
4 word
?expressions functions word
?functions word
?word
=word
#word("string",n) & string, int & returns the nth word in "string" \\
%word("string",n)@string, int@returns the nth word in "string"
 `word("string",n)` returns the nth word in string. For example,
 `word("one two three",2)` returns the string "two".
4 words
?expressions functions words
?functions words
?words
=words
#words("string") & string & returns the number of words in "string" \\
%words("string")@string@returns the number of words in "string"
 `words("string")` returns the number of words in string. For example,
 `words(" a b c d")` returns the 4.
@end table

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{other {\bf gnuplot} functions} \\ \hline \hline
#Function & Arguments & Returns \\ \hline
%c c l .
%Function@Arguments@Returns
%_
4 column
?expressions functions column
?functions column
?column
#column(x) & int & column $x$ during datafile manipulation. \\
%column(x)@int@ column $x$ during datafile manipulation.
 `column(x)` may be used only in expressions as part of `using` manipulations
 to fits or datafile plots.  It evaluates to the numerical value of the contents
 of column x. See `plot datafile using`.
4 defined
?expressions functions defined
?functions defined
?defined
#defined(X) & variable name & [DEPRECATED] returns 1 if X is defined, 0 otherwise. \\
%defined(X)@variable name@ [DEPRECATED] returns 1 if X is defined, 0 otherwise.
 `defined(X)` [DEPRECATED] returns 1 if a variable named X has been defined, otherwise
 it returns 0.
4 exists
?expressions functions exists
?functions exists
?exists
#exists("X") & "variable name" & returns 1 if a variable named X is defined, 0 otherwise. \\
%exists("X")@"variable name"@ returns 1 if a variable named X is defined, 0 otherwise.
 The argument to exists() is a string constant or a string variable;
 if the string contains the name of a defined variable, the function returns 1.
 Otherwise the function returns 0.
4 stringcolumn
?expressions functions stringcolumn
?functions stringcolumn
?stringcolumn
?strcol
?expressions functions strcol
?functions strcol
?strcol
#stringcolumn(x) & int & content of column $x$ as a string. \\
%stringcolumn(x)@int@ content column $x$ as a string.
 `stringcolumn(x)` may be used only in expressions as part of `using` manipulations
 to fits or datafile plots.  It returns the content of column x as a string variable.
 See `plot datafile using`.
4 timecolumn
?expressions functions timecolumn
?functions timecolumn
?timecolumn
#timecolumn(x) & int & timecolumn $x$ during datafile manipulation. \\
%timecolumn(x)@int@ timecolumn $x$ during datafile manipulation.
 `timecolumn(x)` may be used only in expressions as part of `using`
 manipulations to fits or datafile plots.   See `plot datafile using`.

 It reads the data starting at that column as a time/date value and
 returns its value in gnuplot's internal time representation of
 "seconds since the millennium".

 To find the right `timefmt` string to use, `timecolumn` searches for a
 `using` specification with the same column number as its argument.
 If one is found, `timefmt` pattern of the target axis for this specifier
 is used.  Otherwise, `timecolumn` chooses the x axis `timefmt` per default.
4 tm_hour
?expressions tm_hour
?functions tm_hour
?tm_hour
#tm\_hour(x) & int & the hour \\
%tm_hour(x)@int@the hour
 The `tm_hour` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the hour (an integer in the range 0--23) as a real.
4 tm_mday
?expressions tm_mday
?functions tm_mday
?tm_mday
#tm\_mday(x) & int & the day of the month \\
%tm_mday(x)@int@the day of the month
 The `tm_mday` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the day of the month (an integer in the range 1--31)
 as a real.
4 tm_min
?expressions tm_min
?functions tm_min
?tm_min
#tm\_min(x) & int & the minute \\
%tm_min(x)@int@the minute
 The `tm_min` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the minute (an integer in the range 0--59) as a real.
4 tm_mon
?expressions tm_mon
?functions tm_mon
?tm_mon
#tm\_mon(x) & int & the month \\
%tm_mon(x)@int@the month
 The `tm_mon` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the month (an integer in the range 0--11) as a real.
4 tm_sec
?expressions tm_sec
?functions tm_sec
?tm_sec
#tm\_sec(x) & int & the second \\
%tm_sec(x)@int@the second
 The `tm_sec` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the second (an integer in the range 0--59) as a real.
4 tm_wday
?expressions tm_wday
?functions tm_wday
?tm_wday
#tm\_wday(x) & int & the day of the week \\
%tm_wday(x)@int@the day of the week
 The `tm_wday` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the day of the week (an integer in the range 0--6) as
 a real.
4 tm_yday
?expressions tm_yday
?functions tm_yday
?tm_yday
#tm\_yday(x) & int & the day of the year \\
%tm_yday(x)@int@the day of the year
 The `tm_yday` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the day of the year (an integer in the range 1--366)
 as a real.
4 tm_year
?expressions tm_year
?functions tm_year
?tm_year
#tm\_year(x) & int & the year \\
%tm_year(x)@int@the year
 The `tm_year` function interprets its argument as a time, in seconds from
 1 Jan 2000.  It returns the year (an integer) as a real.
4 valid
?expressions functions valid
?functions valid
?valid
#valid(x) & int & test validity of $\mbox{column}(x)$ during datafile manip.\\
%valid(x)@int@ test validity of column($x$) during datafile manip.
 `valid(x)` may be used only in expressions as part of `using` manipulations
 to fits or datafile plots.  See `plot datafile using`.
@end table
 See also
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 airfoil.dem: use of functions and complex variables for airfoils demo.
^ </a>

4 Random number generator
?expressions random
?functions random
?random
 The behavior of the built-in function `rand(x)` has changed as of version 3.8l.
 Older scripts that expected rand(x>0) to produce sequential pseudo-random
 numbers from the same seeded sequence must be changed to call rand(0) instead.
 The current behavior is as follows:
  `rand(0)`  returns a pseudo random number in the interval [0:1] generated
             from the current value of two internal 32-bit seeds.
  `rand(-1)` resets both seeds to a standard value.
  `rand(x)`  for x>0 sets both seeds to a value based on the value of x.
  `rand({x,y})` for x>0 sets seed1 to x and seed2 to y.

3 Operators
?expressions operators
?operators
 The operators in `gnuplot` are the same as the corresponding operators in the
 C programming language, except that all operators accept integer, real, and
 complex arguments, unless otherwise noted.  The ** operator (exponentiation)
 is supported, as in FORTRAN.

 Parentheses may be used to change order of evaluation.
4 Unary
?expressions operators unary
?operators unary
?unary
 The following is a list of all the unary operators and their usages:

@start table - first is interactive cleartext form
     Symbol      Example    Explanation
       -           -a          unary minus
       +           +a          unary plus (no-operation)
       ~           ~a        * one's complement
       !           !a        * logical negation
       !           a!        * factorial
       $           $3        * call arg/column during `using` manipulation
=factorial
=negation
=one's complement
=operator precedence
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{Unary Operators}\\ \hline \hline
#Symbol & Example & Explanation \\ \hline
#\verb@-@ & \verb@-a@ & unary minus \\
#\verb@+@ & \verb@+a@ & unary plus (no-operation) \\
#\verb@~@ & \verb@~a@ & * one's complement \\
#\verb@!@ & \verb@!a@ & * logical negation \\
#\verb@!@ & \verb@a!@ & * factorial \\
#\verb@$@ & \verb@$3@ & * call arg/column during `using` manipulation \\
C ugly hack: doc2ms uses $ as delimiter for eqn's so it doesn't seem to
C be able to print them. So we have to typeset this table without using
C eqn (at least that's the only solution I found, without any real docs
C on *roff and eqn
C First, terminate the table doc2ms.c already started:
%.TE
C ... then turn off eqn delimiters:
%.EQ
%delim off
%.EN
C ... and restart the table:
%.TS
%center box tab (@) ;
%c c l .
%Symbol@Example@Explanation
%_
%-@-a@unary minus
%+@+a@unary plus (no-operation)
%~@~a@* one's complement
%!@!a@* logical negation
%!@a!@* factorial
%$@$3@* call arg/column during `using` manipulation
%_
@end table
 (*) Starred explanations indicate that the operator requires an integer
 argument.

 Operator precedence is the same as in Fortran and C.  As in those languages,
 parentheses may be used to change the order of operation.  Thus -2**2 = -4,
 but (-2)**2 = 4.

 The factorial operator returns a real number to allow a greater range.
4 Binary
?expressions operators binary
?operators binary
 The following is a list of all the binary operators and their usages:

@start table - first is interactive cleartext form
     Symbol       Example      Explanation
       **          a**b          exponentiation
       *           a*b           multiplication
       /           a/b           division
       %           a%b         * modulo
       +           a+b           addition
       -           a-b           subtraction
       ==          a==b          equality
       !=          a!=b          inequality
       <           a<b           less than
       <=          a<=b          less than or equal to
       >           a>b           greater than
       >=          a>=b          greater than or equal to
       &           a&b         * bitwise AND
       ^           a^b         * bitwise exclusive OR
       |           a|b         * bitwise inclusive OR
       &&          a&&b        * logical AND
       ||          a||b        * logical OR
       .           A.B           string concatenation
       eq          A eq B        string equality
       ne          A ne B        string inequality
=bitwise operators
=string operators
=modulo
=exponentiation
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{Binary Operators} \\ \hline \hline
#Symbol & Example & Explanation \\ \hline
#\verb~**~ & \verb~a**b~ & exponentiation\\
#\verb~*~ & \verb~a*b~ & multiplication\\
#\verb~/~ & \verb~a/b~ & division\\
#\verb~%~ & \verb~a%b~ & * modulo\\
#\verb~+~ & \verb~a+b~ & addition\\
#\verb~-~ & \verb~a-b~ & subtraction\\
#\verb~==~ & \verb~a==b~ & equality\\
#\verb~!=~ & \verb~a!=b~ & inequality\\
#\verb~<~ & \verb~a<b~ & less than\\
#\verb~<=~ & \verb~a<=b~ & less than or equal to\\
#\verb~>~ & \verb~a>b~ & greater than\\
#\verb~>=~ & \verb~a>=b~ & greater than or equal to\\
#\verb~&~ & \verb~a&b~ & * bitwise AND\\
#\verb~^~ & \verb~a^b~ & * bitwise exclusive OR\\
#\verb~|~ & \verb~a|b~ & * bitwise inclusive OR\\
#\verb~&&~ & \verb~a&&b~ & * logical AND\\
#\verb~||~ & \verb~a||b~ & * logical OR\\
#\verb~.~ & \verb~A.B~ & string concatenation\\
#\verb~eq~ & \verb~A eq B~ & string equality\\
#\verb~ne~ & \verb~A ne B~ & string inequality\\
%c c l .
%Symbol@Example@Explanation
%_
%**@a**b@exponentiation
%*@a*b@multiplication
%/@a/b@division
%%@a%b@* modulo
%+@a+b@addition
%-@a-b@subtraction
%==@a==b@equality
%!=@a!=b@inequality
%<@a<b@less than
%<=@a<=b@less than or equal to
%>@a>b@greater than
%>=@a>=b@greater than or equal to
%&@a&b@* bitwise AND
%^@a^b@* bitwise exclusive OR
%|@a|b@* bitwise inclusive OR
%&&@a&&b@* logical AND
%||@a||b@* logical OR
%.@a.b@string concatenation
%eq@A eq B@string equality
%ne@A ne B@string inequality

@end table
 (*) Starred explanations indicate that the operator requires integer
 arguments.
 Capital letters A and B indicate that the operator requires string arguments.

 Logical AND (&&) and OR (||) short-circuit the way they do in C.  That is,
 the second `&&` operand is not evaluated if the first is false; the second
 `||` operand is not evaluated if the first is true.
4 Ternary
?expressions operators ternary
?operators ternary
?ternary
 There is a single ternary operator:

@start table - first is interactive cleartext form
     Symbol       Example      Explanation
       ?:          a?b:c     ternary operation
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{Ternary Operator} \\ \hline \hline
#Symbol & Example & Explanation \\ \hline
#\verb~?:~ & \verb~a?b:c~ & ternary operation\\
%c c l .
%Symbol@Example@Explanation
%_
%?:@a?b:c@* ternary operation

@end table
 The ternary operator behaves as it does in C.  The first argument (a), which
 must be an integer, is evaluated.  If it is true (non-zero), the second
 argument (b) is evaluated and returned; otherwise the third argument (c) is
 evaluated and returned.

 The ternary operator is very useful both in constructing piecewise functions
 and in plotting points only when certain conditions are met.

 Examples:

 Plot a function that is to equal sin(x) for 0 <= x < 1, 1/x for 1 <= x < 2,
 and undefined elsewhere:
       f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
       plot f(x)
^ <img align=bottom src="http://www.gnuplot.info/doc/ternary.gif" alt="[ternary.gif]" width=640 height=480>
 Note that `gnuplot` quietly ignores undefined values, so the final branch of
 the function (1/0) will produce no plottable points.  Note also that f(x)
 will be plotted as a continuous function across the discontinuity if a line
 style is used.  To plot it discontinuously, create separate functions for the
 two pieces.  (Parametric functions are also useful for this purpose.)

 For data in a file, plot the average of the data in columns 2 and 3 against
 the datum in column 1, but only if the datum in column 4 is non-negative:

       plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )

 Please see `plot datafile using` for an explanation of the `using` syntax.

3 Gnuplot-defined variables
?gnuplot-defined variables
 The variable `pi` is defined to be pi, see
       print pi

 Additionally, gnuplot may define some variables under various operations.

 Working with interactive terminals with `mouse` functionality defines
 variables with names that begin "MOUSE_", see `mouse variables` for details.

 Further, there are several "read-only" variables that begin "GPVAL_", like
 GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN,... Type `show variables all`
 to display their list and values. Values related to axes parameters (ranges, log
 base) are values used during the last plot, not those currently `set`.

 The `fit` mechanism uses several variables with names that begin "FIT_".  It
 is safest to avoid using such names.  "FIT_LIMIT", however, is one that you
 may wish to redefine. Under `set fit errorvariables`, the error for each
 fitted parameter will be stored in a variable named like the parameter, but
 with "_err" appended. See the documentation on `fit` for details.

 See `user-defined variables`, `mouse variables`, and `fit`.

3 User-defined variables and functions
?expressions user-defined
?user-defined variables
?user-defined
?variables
 New user-defined variables and functions of one through five variables may
 be declared and used anywhere, including on the `plot` command itself.

 User-defined function syntax:
       <func-name>( <dummy1> {,<dummy2>} ... {,<dummy5>} ) = <expression>

 where <expression> is defined in terms of <dummy1> through <dummy5>.

 User-defined variable syntax:
       <variable-name> = <constant-expression>

 Examples:
       w = 2
       q = floor(tan(pi/2 - 0.1))
       f(x) = sin(w*x)
       sinc(x) = sin(pi*x)/(pi*x)
       delta(t) = (t == 0)
       ramp(t) = (t > 0) ? t : 0
       min(a,b) = (a < b) ? a : b
       comb(n,k) = n!/(k!*(n-k)!)
       len3d(x,y,z) = sqrt(x*x+y*y+z*z)
       plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)

       file = "mydata.inp"
       file(n) = sprintf("run_%d.dat",n)

^ <img align=bottom src="http://www.gnuplot.info/doc/userdefined.gif" alt="[userdefined.gif]" width=640 height=480>
 The final two examples illustrate a user-defined string variable and a
 user-defined string function.

 Note that the variable `pi` is already defined.  But it is in no way magic;
 you may redefine it to be whatever you like. Some other variables may be
 defined under various gnuplot operations like mousing in interactive terminals
 or fitting; see `gnuplot-defined variables` for details.

 You can check for existence of a given variable V by the exists("V")
 expression. For example
       a = 10
       if (exists("a")) print "a is defined"
       if (!exists("b")) print "b is not defined"

 Valid names are the same as in most programming languages: they must begin
 with a letter, but subsequent characters may be letters, digits, "$", or "_".

 See `show functions`, `functions`, `gnuplot-defined variables`, `macros`.
2 Glossary
?glossary
 Throughout this document an attempt has been made to maintain consistency of
 nomenclature.  This cannot be wholly successful because as `gnuplot` has
 evolved over time, certain command and keyword names have been adopted that
 preclude such perfection.  This section contains explanations of the way
 some of these terms are used.

 A "page" or "screen" is the entire area addressable by `gnuplot`.  On a
 monitor, it is the full screen; on a plotter, it is a single sheet of paper.

 A screen may contain one or more "plots".  A plot is defined by an abscissa
 and an ordinate, although these need not actually appear on it, as well as
 the margins and any text written therein.

 A plot contains one "graph".  A graph is defined by an abscissa and an
 ordinate, although these need not actually appear on it.

 A graph may contain one or more "lines".  A line is a single function or
 data set.  "Line" is also a plotting style.  The word will also be used in
 sense "a line of text".  Presumably the context will remove any ambiguity.

 The lines on a graph may have individual names.  These may be listed
 together with a sample of the plotting style used to represent them in
 the "key", sometimes also called the "legend".

 The word "title" occurs with multiple meanings in `gnuplot`.  In this
 document, it will always be preceded by the adjective "plot", "line", or
 "key" to differentiate among them.

 A 2-d graph may have up to four labelled axes.  The names of the four axes
 for these usages are "x" for the axis along the bottom border of the plot,
 "y" for the left border, "x2" for the top border, and "y2" for the right
 border.

 A 3-d graph may have up to three labelled axes -- "x", "y" and "z".  It is
 not possible to say where on the graph any particular axis will fall because
 you can change the direction from which the graph is seen with `set view`.

 When discussing data files, the term "record" will be resurrected and used
 to denote a single line of text in the file, that is, the characters between
 newline or end-of-record characters.  A "point" is the datum extracted from
 a single record.  A "datablock" is a set of points from consecutive records,
 delimited by blank records.  A line, when referred to in the context of a
 data file, is a subset of a datablock.
2 linetype, colors, and styles
?linetype
?colors
 Each gnuplot terminal type provides a set of distinct "linetypes". These may
 differ in color, in thickness, in dot/dash pattern, or in some combination of
 color and dot/dash. The default linetypes for a particular terminal can be
 previewed by issuing the `test` command after setting the terminal type.
 The pre-defined colors and dot/dash patterns are not guaranteed to be
 consistent for all terminal types, but all terminals use the special linetype
 -1 to mean a solid line in the primary foreground color (normally black).
 By default, successive functions or datafiles plotted by a single command will
 be assigned successive linetypes.  You can override this default by specifying
 a particular linetype for any function, datafile, or plot element.

 Examples:

      plot "foo", "bar"                 # plot two files using linetypes 1, 2
      plot sin(x) linetype 4            # terminal-specific linetype color 4
      plot sin(x) lt -1                 # black

=colors
 For many terminal types it is also possible to assign user-defined colors
 using explicit rgb (red, green, blue) values, named colors, or color values
 that refer to the current PM3D palette.

 Examples:

      plot sin(x) lt rgb "violet"       # one of gnuplot's named colors
      plot sin(x) lt rgb "#FF00FF"      # explicit RGB triple in hexadecimal
      plot sin(x) lt palette cb -45     # whatever color corresponds to -45
                                        # in the current cbrange of the palette
      plot sin(x) lt palette frac 0.3   # fractional value along the palette

 See `show palette colornames`, `set palette`, `cbrange`.

 For terminals that support dot/dash patterns, each default linetype has both
 a dot-dash pattern and a default color. However, you can override the default
 color by using the keyword `linecolor`, abbreviated `lc`.  For example, the
 postscript terminal provides a dashed blue line as linetype 3.  The plot
 commands below use this same dash pattern for three plots, one in blue (the
 default), another in red (the default for linetype 1), and a third in gold.

 Example:

      set term postscript dashed color
      plot 'foo' lt 3, 'baz' lt 3 linecolor 1, 'bar' lt 3 lc rgb 'gold'

 Lines can have additional properties such as linewidth.  You can associate
 these various properties, as well as equivalent properties for point symbols,
 into user-defined "line styles" using the command `set style line`.  Once
 you have defined a linestyle, you can use it in a plot command to control
 the appearance of one or more plot elements.

 Examples:

      # define a new line style with terminal-independent color cyan,
      # linewidth 3, and associated point type 6 (a circle with a dot in it).
      set style line 5 lt rgb "cyan" lw 3 pt 6
      plot sin(x) with linespoints ls 5          # user-defined line style 5

 See `linestyle`, `set style line`.
3 colorspec
?colorspec
?rgbcolor
=colors
 Many commands allow you to specify a linetype with an explicit color. This
 option is only possible for terminals that support RGB color or pm3d palettes.

 Syntax:

       ... {linetype | lt} <colorspec>

 where <colorspec> has one of the following forms:

       rgbcolor "colorname"
       rgbcolor "#RRGGBB"
       rgbcolor variable
       palette frac <val>      # <val> runs from 0 to 1
       palette cb <value>      # <val> lies within cbrange
       palette z

 "colorname" refers to one of the color names built in to gnuplot. For a list
 of the available names, see `show palette colornames`.

 "#RRGGBB" is a hexadecimal constant preceded by the "#" symbol. The RRGGBB
 represents the red, green, and blue components of the color, each on a scale
 from 0 - 255.  For example, magenta = full-scale red + full-scale blue would
 be represented by #FF00FF, which is the hexadecimal representation of
 (255 << 16) + (0 << 8) + (255).

 "rgb variable" requires an additional column in the `using` specifier, and
 is only available in 3D plotting mode (splot). The extra column is interpreted
 as a 24-bit packed RGB triple. These are most easily specified in a data file
 as hexidecimal values (see above).

 Example:

       rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
       splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable

 The color palette is a linear gradient of colors that smoothly maps a
 single numerical value onto a particular color.  Two such mappings are always
 in effect. `palette frac`  maps a fractional value between 0 and 1 onto the
 full range of the color palette.  `palette cb` maps the range of the color
 axis onto the same palette.  See `set cbrange`.  See also `set colorbox`.
 You can use either of these to select a constant color from the current
 palette.

 "palette z" maps the z value of each plot segment or plot element into the
 cbrange mapping of the palette. This allows smoothly-varying color along a
 3d line or surface. This option applies only to 3D plots (splot).

2 mouse input
?mouse input
 The `x11`, `pm`, `windows`, `ggi`, and `wxt` terminals allow interaction with
 the current plot using the mouse. They also support the definition of hotkeys
 to activate pre-defined functions by hitting a single key while the mouse
 focus is in the active plot window.  It is even possible to combine mouse
 input with `batch` command scripts, by invoking the command `pause mouse`
 and then using the mouse variables returned by mouse clicking as parameters
 for subsequent scripted actions. See `bind` and `mouse variables`.
 See also the command `set mouse`.
3 bind
?commands bind
?bind
 The `bind` allows defining or redefining a hotkey, i.e. a sequence of gnuplot
 commands which will be executed when a certain key or key sequence is pressed
 while the driver's window has the input focus. Note that `bind` is only
 available if gnuplot was compiled with `mouse` support and it is used by all
 mouse-capable terminals. Bindings overwrite the builtin bindings (like in
 every real editor), except <space> and 'q' which cannot be rebound (unless
 one exception, see below). Mouse buttons cannot be rebound.

 You get the list of all hotkeys by typing `bind` or by hitting 'h' in the
 graph window.

 Note that multikey-bindings with modifiers have to be quoted.

 Normally hotkeys are only recognized when the currently active plot window
 has focus. `bind allwindows <key> ...` (short form: `bind all <key> ...`)
 causes the binding for <key> to apply to all gnuplot plot windows, active
 or not.  In this case gnuplot variable MOUSE_KEY_WINDOW is set to the ID
 of the originating window, and may be used by the bound command.

 By default, the <space> hotkey raises gnuplot's command window. On some
 terminals (e.g. x11, wx, pm), 'q' closes the graph window. These defaults can
 be changed to ctrl-space and ctrl-q by starting gnuplot as 'gnuplot -ctrlq',
 see `x11 command-line-options`, or by the X Resource 'gnuplot*ctrlq'.
 Note: if <space> (or ctrl-space) does not raise the gnuplot window under X11,
 see discussion in `raise`.

 Syntax:
       bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
       bind!

 Examples:

 - set bindings:

     bind a "replot"
     bind "ctrl-a" "plot x*x"
     bind "ctrl-alt-a" 'print "great"'
     bind Home "set view 60,30; replot"
     bind all Home 'print "This is window ",MOUSE_KEY_WINDOW'

 - show bindings:
     bind "ctrl-a"          # shows the binding for ctrl-a
     bind                   # shows all bindings

 - remove bindings:
     bind "ctrl-alt-a" ""   # removes binding for ctrl-alt-a
                              (note that builtins cannot be removed)
     bind!                  # installs default (builtin) bindings

 - bind a key to toggle something:
   v=0
   bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term x11 raise"

 Modifiers (ctrl / alt) are case insensitive, keys not:
     ctrl-alt-a == CtRl-alT-a
     ctrl-alt-a != ctrl-alt-A

 List of modifiers (alt == meta):
     ctrl, alt

 List of supported special keys:

    "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
    "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
    "PageUp", "PageDown", "End", "Begin",

    "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
    "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
    "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
    "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
    "KP_Divide",

    "KP_1" - "KP_9", "F1" - "F12"

 See also help for `mouse` and `if`.

3 Mouse variables
?mouse variables
 When mousing is active, clicking in the active window will set several user
 variables that can be accessed from the gnuplot command line. The coordinates
 of the mouse at the time of the click are stored in MOUSE_X MOUSE_Y MOUSE_X2
 and MOUSE_Y2. The mouse button clicked, and any meta-keys active at that time,
 are stored in MOUSE_BUTTON MOUSE_SHIFT MOUSE_ALT and MOUSE_CTRL.  These
 variables are set to undefined at the start of every plot, and only become
 defined in the event of a mouse click in the active plot window. To determine
 from a script if the mouse has been clicked in the active plot window, it is
 sufficient to test for any one of these variables being defined.

       plot 'something'
       pause mouse
       if (defined(MOUSE_BUTTON)) call 'something_else'; \
       else print "No mouse click."

 It is also possible to track keystrokes in the plot window using the mousing
 code.

       plot 'something'
       pause mouse keypress
       print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y

 When `pause mouse keypress` is terminated by a keypress, then MOUSE_KEY will
 contain the ascii character value of the key that was pressed. MOUSE_CHAR will
 contain the character itself as a string variable.  If the pause command is
 terminated abnormally (e.g. by ctrl-C or by externally closing the plot window)
 then MOUSE_KEY will equal -1.

 Note that after a zoom by mouse, you can read the new ranges as GPVAL_X_MIN,
 GPVAL_X_MAX, GPVAL_Y_MIN, and GPVAL_Y_MAX, see `gnuplot-defined variables`.


2 Plotting
?plotting
 There are three `gnuplot` commands which actually create a plot: `plot`,
 `splot` and `replot`.  `plot` generates 2-d plots, `splot` generates 3-d
 plots (actually 2-d projections, of course), and `replot` appends its
 arguments to the previous `plot` or `splot` and executes the modified
 command.

 Much of the general information about plotting can be found in the discussion
 of `plot`; information specific to 3-d can be found in the `splot` section.

 `plot` operates in either rectangular or polar coordinates -- see `set polar`
 for details of the latter.  `splot` operates only in rectangular coordinates,
 but the `set mapping` command allows for a few other coordinate systems to be
 treated.  In addition, the `using` option allows both `plot` and `splot` to
 treat almost any coordinate system you'd care to define.

 `plot` also lets you use each of the four borders -- x (bottom), x2 (top), y
 (left) and y2 (right) -- as an independent axis.  The `axes` option lets you
 choose which pair of axes a given function or data set is plotted against.  A
 full complement of `set` commands exists to give you complete control over
 the scales and labelling of each axis.  Some commands have the name of an
 axis built into their names, such as `set xlabel`.  Other commands have one
 or more axis names as options, such as `set logscale xy`.  Commands and
 options controlling the z axis have no effect on 2-d graphs.

 `splot` can plot surfaces and contours in addition to points and/or lines.
 In addition to `splot`, see `set isosamples` for information about defining
 the grid for a 3-d function;  `splot datafile` for information about the
 requisite file structure for 3-d data values; and `set contour` and
 `set cntrparam` for information about contours.

 In `splot`, control over the scales and labels of the axes are the same as
 with `plot`, except that commands and options controlling the x2 and y2 axes
 have no effect whereas of course those controlling the z axis do take effect.
2 Start-up
^ <a name="start-up"></a>
?startup
?start
?.gnuplot
 When `gnuplot` is run, it looks for an initialization file to load.
 This file is called `.gnuplot` on Unix and AmigaOS systems, and
 `GNUPLOT.INI` on other systems.  If this file is not found in the
 current directory, the program will look for it in the HOME directory
 (under AmigaOS, Atari(single)TOS, MS-DOS, Windows and OS/2, the
 environment variable `GNUPLOT` should contain the name of this
 directory; on Windows NT, it will use `USERPROFILE` if GNUPLOT isn't
 defined).  Note: if NOCWDRC is defined during the installation,
 `gnuplot` will not read from the current directory.

 If the initialization file is found, `gnuplot` executes the commands in it.
 These may be any legal `gnuplot` commands, but typically they are limited to
 setting the terminal and defining frequently-used functions or variables.
2 String constants and string variables
?strings
?string variables
 In addition to string constants, most gnuplot commands also accept a string
 variable, a string expression, or a function that returns a string.
 For example, the following four methods of creating a plot all result in the
 same plot title:

       four = "4"
       graph4 = "Title for plot #4"
       graph(n) = sprintf("Title for plot #%d",n)

       plot 'data.4' title "Title for plot #4"
       plot 'data.4' title graph4
       plot 'data.4' title "Title for plot #".four
       plot 'data.4' title graph(4)

 Since integers are promoted to strings when operated on by the string
 concatenation operator, the following method also works:

       N = 4
       plot 'data.'.N title "Title for plot #".N

 In general, elements on the command line will only be evaluated as possible
 string variables if they are not otherwise recognizable as part of the normal
 gnuplot syntax. So the following sequence of commands is legal, although
 probably should be avoided so as not to cause confusion:

       plot = "my_datafile.dat"
       title = "My Title"
       plot plot title title

 There are three binary operators that require string operands: the string
 concatenation operator ".", the string equality operator "eq" and the string
 inequality operator "ne".  The following example will print TRUE.

      if ("A"."B" eq "AB") print "TRUE"

 See also the two string formatting functions `gprintf` and `sprintf`.

=substring
 Substrings can be specified by appending a range specifier to any string,
 string variable, or string-valued function.  The range specifier has the
 form [begin:end], where begin is the index of the first character of the
 substring and end is the index of the last character of the substring.
 The first character has index 1.  The begin or end fields may be empty, or
 contain '*', to indicate the true start or end of the original string.
 E.g.  str[:] and str[*:*] both describe the full string str.
2 Substitution and Command line macros
?substitution
 When a command line to gnuplot is first read, i.e. before it is interpreted
 or executed, two forms of lexical substitution are performed. These are
 triggered by the presence of text in backquotes (ascii character 96) or
 preceded by @ (ascii character 64).
3 Substitution of system commands in backquotes
?substitution backquotes
?backquotes
?system commands
 Command-line substitution is specified by a system command enclosed in
 backquotes.  This command is spawned and the output it produces replaces
 the backquoted text on the command line.  Some implementations also support
 pipes;  see `plot datafile special-filenames`.

 Command-line substitution can be used anywhere on the `gnuplot` command
 line, except inside strings delimited by single quotes.

 Example:

 This will run the program `leastsq` and replace `leastsq` (including
 backquotes) on the command line with its output:
       f(x) = `leastsq`

 or, in VMS
       f(x) = `run leastsq`

 These will generate labels with the current time and userid:
       set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
       set timestamp "generated on %Y-%m-%d by `whoami`"
3 Substitution of string variables as macros
?substitution macros
?macros
=exists
 Substitution of command line macros is disabled by default, but may be
 enabled using the `set macros` command.  If macro substitution is enabled,
 the character @ is used to trigger substitution of the current value of a
 string variable into the command line. The text in the string variable may
 contain any number of lexical elements.  This allows string variables to be
 used as command line macros.  Only string constants may be expanded using this
 mechanism, not string-valued expressions.
 For example:

       set macros
       style1 = "lines lt 4 lw 2"
       style2 = "points lt 3 pt 5 ps 2"
       range1 = "using 1:3"
       range2 = "using 1:5"
       plot "foo" @range1 with @style1, "bar" @range2 with @style2

 The line containing @ symbols is expanded on input, so that by the time it is
 executed the effect is identical to having typed in full

       plot "foo" using 1:3 with lines lt 4 lw 2, \
            "bar" using 1:5 with points lt 3 pt 5 ps 2

 The function exists() may be useful in connection with macro evaluation.
 The following example checks that C can safely be expanded as the name of
 a user-defined variable:

       C = "pi"
       if (exists(C)) print C," = ", @C

 Macro expansion does not occur inside either single or double quotes.
 However macro expansion does occur inside backquotes.
3 String variables, macros, and command line substitution
?mixing_macros_backquotes
?substitution mixing_macros_backquotes
 The interaction of string variables, backquotes and macro substitution is
 somewhat complicated.  Backquotes do not block macro substitution, so

       filename = "mydata.inp"
       lines = ` wc --lines @filename | sed "s/ .*//" `

 results in the number of lines in mydata.inp being stored in the integer
 variable lines. And double quotes do not block backquote substitution, so

       mycomputer = "`uname -n`"

 results in the string returned by the system command `uname -n` being stored
 in the string variable mycomputer.

 However, macro substitution is not performed inside double quotes, so you
 cannot define a system command as a macro and then use both macro and backquote
 substitution at the same time.

        machine_id = "uname -n"
        mycomputer = "`@machine_id`"  # doesn't work!!

 This fails because the double quotes prevent @machine_id from being interpreted
 as a macro. To store a system command as a macro and execute it later you must
 instead include the backquotes as part of the macro itself.  This is
 accomplished by defining the macro as shown below.  Notice that the sprintf
 format nests all three types of quotes.

       machine_id = sprintf('"`uname -n`"')
       mycomputer = @machine_id
2 Syntax
?syntax
?specify
?punctuation
 Version 4 of gnuplot is much less sensitive than earlier versions to the
 order of keywords and suboptions. However, if you get error messages from
 specifying options that you think should work, please try rearranging them
 into the exact order listed by the documentation.

 Options and any accompanying parameters are separated by spaces whereas lists
 and coordinates are separated by commas.  Ranges are separated by colons and
 enclosed in brackets [], text and file names are enclosed in quotes, and a
 few miscellaneous things are enclosed in parentheses.  Braces {} are used for
 a few special purposes.

 Commas are used to separate coordinates on the `set` commands `arrow`,
 `key`, and `label`; the list of variables being fitted (the list after the
 `via` keyword on the `fit` command); lists of discrete contours or the loop
 parameters which specify them on the `set cntrparam` command; the arguments
 of the `set` commands `dgrid3d`, `dummy`, `isosamples`, `offsets`, `origin`,
 `samples`, `size`, `time`, and `view`; lists of tics or the loop parameters
 which specify them; the offsets for titles and axis labels; parametric
 functions to be used to calculate the x, y, and z coordinates on the `plot`,
 `replot` and `splot` commands; and the complete sets of keywords specifying
 individual plots (data sets or functions) on the `plot`, `replot` and `splot`
 commands.

 Parentheses are used to delimit sets of explicit tics (as opposed to loop
 parameters) and to indicate computations in the `using` filter of the `fit`,
 `plot`, `replot` and `splot` commands.

 (Parentheses and commas are also used as usual in function notation.)

 Square brackets are used to delimit ranges given in `set`, `plot`
 or `splot` commands.

 Colons are used to separate extrema in `range` specifications (whether they
 are given on `set`, `plot` or `splot` commands) and to separate entries in
 the `using` filter of the `plot`, `replot`, `splot` and `fit` commands.

 Semicolons are used to separate commands given on a single command line.

 Braces are used in text to be specially processed by some terminals, like
 `postscript`.  They are also used to denote complex numbers: {3,2} = 3 + 2i.

 At present you should not embed \n inside {} when using the PostScript
 terminal in `enhanced text` mode.

 The EEPIC, Imagen, Uniplex, LaTeX, and TPIC drivers allow a newline to be
 specified by \\ in a single-quoted string or \\\\ in a double-quoted string.
3 Quote Marks
?quotes
?syntax quotes
 Gnuplot uses three forms of quote marks for delimiting text strings,
 double-quote (ascii 34), single-quote (ascii 39), and backquote (ascii 96).

 Filenames may be entered with either single- or double-quotes.  In this
 manual the command examples generally single-quote filenames and double-quote
 other string tokens for clarity.

 String constants and text strings used for labels, titles, or other plot
 elements may be enclosed in either single quotes or double quotes. Further
 processing of the quoted text depends on the choice of quote marks.

 Backslash processing of special characters like \n (newline) and
 \345 (octal character code) is performed for double-quoted strings.  In
 single-quoted strings, backslashes are just ordinary characters.  To get
 a single-quote (ascii 39) in a single-quoted string, it has to be doubled.
 Thus the strings "d\" s' b\\" and 'd" s'' b\' are completely equivalent.

 Text justification is the same for each line of a multi-line string.
 Thus the center-justified string
       "This is the first line of text.\nThis is the second line."
 will produce
                        This is the first line of text.
                           This is the second line.
 but
       'This is the first line of text.\nThis is the second line.'
 will produce
           This is the first line of text.\nThis is the second line.

 Enhanced text processing is performed for both double-quoted text and
 single-quoted text, but only by terminals supporting this mode.
 See `enhanced text`.

 Back-quotes are used to enclose system commands for substitution into the
 command line.  See `substitution`.
2 Time/Date data
^ <a name="Time/Date data"></a>
^ <a name="Time/date"></a>
?time/date
 `gnuplot` supports the use of time and/or date information as input data.
 This feature is activated by the commands `set xdata time`, `set ydata time`,
 etc.

 Internally all times and dates are converted to the number of seconds from
 the year 2000.  The command `set timefmt` defines the format for all inputs:
 data files, ranges, tics, label positions---in short, anything that accepts a
 data value must receive it in this format.  Since only one input format can
 be in force at a given time, all time/date quantities being input at the same
 time must be presented in the same format.  Thus if both x and y data in a
 file are time/date, they must be in the same format.

 The conversion to and from seconds assumes Universal Time (which is the same
 as Greenwich Standard Time).  There is no provision for changing the time
 zone or for daylight savings.  If all your data refer to the same time zone
 (and are all either daylight or standard) you don't need to worry about these
 things.  But if the absolute time is crucial for your application, you'll
 need to convert to UT yourself.

 Commands like `show xrange` will re-interpret the integer according to
 `timefmt`.  If you change `timefmt`, and then `show` the quantity again, it
 will be displayed in the new `timefmt`.  For that matter, if you give the
 deactivation command (like `set xdata`), the quantity will be shown in its
 numerical form.

 The command `set format` defines the format that will be used for tic labels,
 whether or not the specified axis is time/date.

 If time/date information is to be plotted from a file, the `using` option
 _must_ be used on the `plot` or `splot` command.  These commands simply use
 white space to separate columns, but white space may be embedded within the
 time/date string.  If you use tabs as a separator, some trial-and-error may
 be necessary to discover how your system treats them.

 The following example demonstrates time/date plotting.

 Suppose the file "data" contains records like

       03/21/95 10:00  6.02e23

 This file can be plotted by

       set xdata time
       set timefmt "%m/%d/%y"
       set xrange ["03/21/95":"03/22/95"]
       set format x "%m/%d"
       set timefmt "%m/%d/%y %H:%M"
       plot "data" using 1:3

 which will produce xtic labels that look like "03/21".

 See the descriptions of each command for more details.
1 Commands
?commands
 This section lists the commands acceptable to `gnuplot` in alphabetical
 order.  Printed versions of this document contain all commands; on-line
 versions may not be complete.  Indeed, on some systems there may be no
 commands at all listed under this heading.

 Note that in most cases unambiguous abbreviations for command names and their
 options are permissible, i.e., "`p f(x) w li`" instead of "`plot f(x) with
 lines`".

 In the syntax descriptions, braces ({}) denote optional arguments and a
 vertical bar (|) separates mutually exclusive choices.
2 cd
?commands cd
?cd
 The `cd` command changes the working directory.

 Syntax:
       cd '<directory-name>'

 The directory name must be enclosed in quotes.

 Examples:
       cd 'subdir'
       cd ".."

 It is recommended for DOS and Windows users to use
 single-quotes---backslash [\] has special significance inside
 double-quotes and has to be escaped.  For example,
       cd "c:\newdata"
 fails, but
       cd 'c:\newdata'
       cd "c:\\newdata"
 works as expected.
2 call
?commands call
?call
 The `call` command is identical to the load command with one exception: you
 can have up to ten additional parameters to the command (delimited according
 to the standard parser rules) which can be substituted into the lines read
 from the file.  As each line is read from the `call`ed input file, it is
 scanned for the sequence `$` (dollar-sign) followed by a digit (0--9).  If
 found, the sequence is replaced by the corresponding parameter from the
 `call` command line.  If the parameter was specified as a string in the
 `call` line, it is substituted without its enclosing quotes.  Sequence `$#`
 is replaced by the number of passed parameters.  `$` followed by any character
 will be that character; e.g. use `$$` to get a single `$`.  Providing more
 than ten parameters on the `call` command line will cause an error.  A
 parameter that was not provided substitutes as nothing.  Files being `call`ed
 may themselves contain `call` or `load` commands.

 The `call` command _must_ be the last command on a multi-command line.

 Syntax:
       call "<input-file>" <parameter-0> <parm-1> ... <parm-9>

 The name of the input file must be enclosed in quotes, and it is recommended
 that parameters are similarly enclosed in quotes (future versions of gnuplot
 may treat quoted and unquoted arguments differently).

 Example:

 If the file 'calltest.gp' contains the line:
       print "argc=$# p0=$0 p1=$1 p2=$2 p3=$3 p4=$4 p5=$5 p6=$6 p7=x$7x"

 entering the command:
       call 'calltest.gp' "abcd" 1.2 + "'quoted'" -- "$2"

 will display:
       argc=7 p0=abcd p1=1.2 p2=+ p3='quoted' p4=- p5=- p6=$2 p7=xx

 NOTE: there is a clash in syntax with the datafile `using` callback
 operator.  Use `$$n` or `column(n)` to access column n from a datafile inside
 a `call`ed datafile plot.
2 clear
?commands clear
?clear
 The `clear` command erases the current screen or output device as specified
 by `set output`.  This usually generates a formfeed on hardcopy devices.  Use
 `set terminal` to set the device type.

 For some terminals `clear` erases only the portion of the plotting surface
 defined by `set size`, so for these it can be used in conjunction with `set
 multiplot` to create an inset.

 Example:
       set multiplot
       plot sin(x)
       set origin 0.5,0.5
       set size 0.4,0.4
       clear
       plot cos(x)
       unset multiplot

 Please see `set multiplot`, `set size`, and `set origin` for details of these
 commands.
2 exit
?commands exit
?exit
 The commands `exit` and `quit`, as well as the END-OF-FILE character (usually
 Ctrl-D) terminate input from the current input stream: terminal session, pipe,
 and file input (pipe).

 If input streams are nested (inherited `load` scripts), then reading will
 continue in the parent stream. When the top level stream is closed, the
 program itself will exit.

 The command `exit gnuplot` will immediately and unconditionally cause gnuplot
 to exit even if the input stream is multiply nested.  In this case any open
 output files may not be completed cleanly. Example of use:

       bind "ctrl-x" "unset output; exit gnuplot"

 See help for `batch/interactive` for more details.
2 fit
?commands fit
?fit
?least-squares
?Marquardt
 The `fit` command can fit a user-defined function to a set of data points
 (x,y) or (x,y,z), using an implementation of the nonlinear least-squares
 (NLLS) Marquardt-Levenberg algorithm.  Any user-defined variable occurring in
 the function body may serve as a fit parameter, but the return type of the
 function must be real.

 Syntax:
       fit {[xrange] {[yrange]}} <function> '<datafile>'
           {datafile-modifiers}
           via '<parameter file>' | <var1>{,<var2>,...}

 Ranges may be specified to temporarily limit the data which is to be fitted;
 any out-of-range data points are ignored. The syntax is
       [{dummy_variable=}{<min>}{:<max>}],
 analogous to `plot`; see `plot ranges`.

 <function> is any valid `gnuplot` expression, although it is usual to use a
 previously user-defined function of the form f(x) or f(x,y).

 <datafile> is treated as in the `plot` command.  All the `plot datafile`
 modifiers (`using`, `every`,...) except `smooth` and the deprecated `thru`
 are applicable to `fit`. See `plot datafile`.

 The default data formats for fitting functions with a single independent
 variable, y=f(x), are {x:}y or x:y:s; those formats can be changed with
 the datafile `using` qualifier.  The third item (a column number or an
 expression), if present, is interpreted as the standard deviation of the
 corresponding y value and is used to compute a weight for the datum, 1/s**2.
 Otherwise, all data points are weighted equally, with a weight of one.
 Note that if you don't specify a `using` option at all, no y deviations are
 read from the datafile even if it does have a third column, so you'll
 always get unit weights.

 To fit a function with two independent variables, z=f(x,y), the required
 format is `using` with four items, x:y:z:s.  The complete format must be
 given---no default columns are assumed for a missing token.  Weights for
 each data point are evaluated from 's' as above.  If error estimates are
 not available, a constant value can be specified as a constant expression
 (see `plot datafile using`), e.g., `using 1:2:3:(1)`.

 Multiple datasets may be simultaneously fit with functions of one
 independent variable by making y a 'pseudo-variable', e.g., the dataline
 number, and fitting as two independent variables.  See `fit multi-branch`.

 The `via` qualifier specifies which parameters are to be adjusted, either
 directly, or by referencing a parameter file.

 Examples:
       f(x) = a*x**2 + b*x + c
       g(x,y) = a*x**2 + b*y**2 + c*x*y
       FIT_LIMIT = 1e-6
       fit f(x) 'measured.dat' via 'start.par'
       fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
       fit f(x) './data/trash.dat' using 1:2:3 via a, b, c
       fit g(x,y) 'surface.dat' using 1:2:3:(1) via a, b, c

 After each iteration step, detailed information about the current state
 of the fit is written to the display.  The same information about the
 initial and final states is written to a log file, "fit.log".  This file
 is always appended to, so as to not lose any previous fit history;  it
 should be deleted or renamed as desired. By using the command
 `set fit logfile`, the name of the log file can be changed.

 If gnuplot was built with this option, and you activated it using `set fit
 errorvariables`, the error for each fitted parameter will be stored in
 a variable named like the parameter, but with "_err" appended.  Thus the
 errors can be used as input for further computations.

 The fit may be interrupted by pressing Ctrl-C (any key but Ctrl-C under
 MSDOS and Atari Multitasking Systems).  After the current iteration
 completes, you have the option to (1) stop the fit and accept the current
 parameter values, (2) continue the fit, (3) execute a `gnuplot` command
 as specified by the environment variable FIT_SCRIPT.  The default for
 FIT_SCRIPT is `replot`, so if you had previously plotted both the data
 and the fitting function in one graph, you can display the current state
 of the fit.

 Once `fit` has finished, the `update` command may be used to store final
 values in a file for subsequent use as a parameter file.   See `update`
 for details.
3 adjustable parameters
?commands fit parameters
?fit parameters
?commands fit adjustable_parameters
?fit adjustable_parameters
?fit_parameters
 There are two ways that `via` can specify the parameters to be adjusted,
 either directly on the command line or indirectly, by referencing a
 parameter file.  The two use different means to set initial values.

 Adjustable parameters can be specified by a comma-separated list of variable
 names after the `via` keyword.  Any variable that is not already defined
 is created with an initial value of 1.0.  However, the fit is more likely
 to converge rapidly if the variables have been previously declared with more
 appropriate starting values.

 In a parameter file, each parameter to be varied and a corresponding initial
 value are specified, one per line, in the form
       varname = value

 Comments, marked by '#', and blank lines are permissible.  The
 special form
       varname = value       # FIXED

 means that the variable is treated as a 'fixed parameter', initialized by the
 parameter file, but not adjusted by `fit`.  For clarity, it may be useful to
 designate variables as fixed parameters so that their values are reported by
 `fit`.  The keyword `# FIXED` has to appear in exactly this form.

3 short introduction
?commands fit beginners_guide
?fit beginners_guide
?fit guide
?fitting
 `fit` is used to find a set of parameters that 'best' fits your data to your
 user-defined function.  The fit is judged on the basis of the sum of the
 squared differences or 'residuals' (SSR) between the input data points and
 the function values, evaluated at the same places.  This quantity is often
 called 'chisquare' (i.e., the Greek letter chi, to the power of 2).  The
 algorithm attempts to minimize SSR, or more precisely, WSSR, as the residuals
 are 'weighted' by the input data errors (or 1.0) before being squared;
 see `fit error_estimates` for details.

 That's why it is called 'least-squares fitting'.  Let's look at an example
 to see what is meant by 'non-linear', but first we had better go over some
 terms.  Here it is convenient to use z as the dependent variable for
 user-defined functions of either one independent variable, z=f(x), or two
 independent variables, z=f(x,y).  A parameter is a user-defined variable
 that `fit` will adjust, i.e., an unknown quantity in the function
 declaration.  Linearity/non-linearity refers to the relationship of the
 dependent variable, z, to the parameters which `fit` is adjusting, not of
 z to the independent variables, x and/or y.  (To be technical, the
 second {and higher} derivatives of the fitting function with respect to
 the parameters are zero for a linear least-squares problem).

 For linear least-squares (LLS), the user-defined function will be a sum of
 simple functions, not involving any parameters, each multiplied by one
 parameter.  NLLS handles more complicated functions in which parameters can
 be used in a large number of ways.  An example that illustrates the
 difference between linear and nonlinear least-squares is the Fourier series.
 One member may be written as
      z=a*sin(c*x) + b*cos(c*x).
 If a and b are the unknown parameters and c is constant, then estimating
 values of the parameters is a linear least-squares problem.  However, if
 c is an unknown parameter, the problem is nonlinear.

 In the linear case, parameter values can be determined by comparatively
 simple linear algebra, in one direct step.  However LLS is a special case
 which is also solved along with more general NLLS problems by the iterative
 procedure that `gnuplot` uses.  `fit` attempts to find the minimum by doing
 a search.  Each step (iteration) calculates WSSR with a new set of parameter
 values.  The Marquardt-Levenberg algorithm selects the parameter values for
 the next iteration.  The process continues until a preset criterion is met,
 either (1) the fit has "converged" (the relative change in WSSR is less than
 FIT_LIMIT), or (2) it reaches a preset iteration count limit, FIT_MAXITER
 (see `fit control variables`).  The fit may also be interrupted
 and subsequently halted from the keyboard (see `fit`).  The user variable
 FIT_CONVERGED contains 1 if the previous fit command terminated due to
 convergence; it contains 0 if the previous fit terminated for any other
 reason.

 Often the function to be fitted will be based on a model (or theory) that
 attempts to describe or predict the behaviour of the data.  Then `fit` can
 be used to find values for the free parameters of the model, to determine
 how well the data fits the model, and to estimate an error range for each
 parameter.  See `fit error_estimates`.

 Alternatively, in curve-fitting, functions are selected independent of
 a model (on the basis of experience as to which are likely to describe
 the trend of the data with the desired resolution and a minimum number
 of parameters*functions.)  The `fit` solution then provides an analytic
 representation of the curve.

 However, if all you really want is a smooth curve through your data points,
 the `smooth` option to `plot` may be what you've been looking for rather
 than `fit`.
3 error estimates
?commands fit error_estimates
?fit error_estimates
?fit errors
 In `fit`, the term "error" is used in two different contexts, data error
 estimates and parameter error estimates.

 Data error estimates are used to calculate the relative weight of each data
 point when determining the weighted sum of squared residuals, WSSR or
 chisquare.  They can affect the parameter estimates, since they determine
 how much influence the deviation of each data point from the fitted function
 has on the final values.  Some of the `fit` output information, including
 the parameter error estimates, is more meaningful if accurate data error
 estimates have been provided.

 The 'statistical overview' describes some of the `fit` output and gives some
 background for the 'practical guidelines'.
4 statistical overview
?commands fit error statistical_overview
?fit error statistical_overview
?statistical_overview
 The theory of non-linear least-squares (NLLS) is generally described in terms
 of a normal distribution of errors, that is, the input data is assumed to be
 a sample from a population having a given mean and a Gaussian (normal)
 distribution about the mean with a given standard deviation.  For a sample of
 sufficiently large size, and knowing the population standard deviation, one
 can use the statistics of the chisquare distribution to describe a "goodness
 of fit" by looking at the variable often called "chisquare".  Here, it is
 sufficient to say that a reduced chisquare (chisquare/degrees of freedom,
 where degrees of freedom is the number of datapoints less the number of
 parameters being fitted) of 1.0 is an indication that the weighted sum of
 squared deviations between the fitted function and the data points is the
 same as that expected for a random sample from a population characterized by
 the function with the current value of the parameters and the given standard
 deviations.

 If the standard deviation for the population is not constant, as in counting
 statistics where variance = counts, then each point should be individually
 weighted when comparing the observed sum of deviations and the expected sum
 of deviations.

 At the conclusion `fit` reports 'stdfit', the standard deviation of the fit,
 which is the rms of the residuals, and the variance of the residuals, also
 called 'reduced chisquare' when the data points are weighted.  The number of
 degrees of freedom (the number of data points minus the number of fitted
 parameters) is used in these estimates because the parameters used in
 calculating the residuals of the datapoints were obtained from the same data.
 These values are exported to the variables
       FIT_NDF = Number of degrees of freedom
       FIT_WSSR = Weighted sum-of-squares residual
       FIT_STDFIT = sqrt(WSSR/NDF)

 To estimate confidence levels for the parameters, one can use the minimum
 chisquare obtained from the fit and chisquare statistics to determine the
 value of chisquare corresponding to the desired confidence level, but
 considerably more calculation is required to determine the combinations of
 parameters which produce such values.

 Rather than determine confidence intervals, `fit` reports parameter error
 estimates which are readily obtained from the variance-covariance matrix
 after the final iteration.  By convention, these estimates are called
 "standard errors" or "asymptotic standard errors", since they are calculated
 in the same way as the standard errors (standard deviation of each parameter)
 of a linear least-squares problem, even though the statistical conditions for
 designating the quantity calculated to be a standard deviation are not
 generally valid for the NLLS problem.  The asymptotic standard errors are
 generally over-optimistic and should not be used for determining confidence
 levels, but are useful for qualitative purposes.

 The final solution also produces a correlation matrix, which gives an
 indication of the correlation of parameters in the region of the solution;
 if one parameter is changed, increasing chisquare, does changing another
 compensate?  The main diagonal elements, autocorrelation, are all 1; if
 all parameters were independent, all other elements would be nearly 0.  Two
 variables which completely compensate each other would have an off-diagonal
 element of unit magnitude, with a sign depending on whether the relation is
 proportional or inversely proportional.  The smaller the magnitudes of the
 off-diagonal elements, the closer the estimates of the standard deviation
 of each parameter would be to the asymptotic standard error.
4 practical guidelines
?commands fit error practical_guidelines
?fit error practical_guidelines
?practical_guidelines
?guidelines
 If you have a basis for assigning weights to each data point, doing so lets
 you make use of additional knowledge about your measurements, e.g., take into
 account that some points may be more reliable than others.  That may affect
 the final values of the parameters.

 Weighting the data provides a basis for interpreting the additional `fit`
 output after the last iteration.  Even if you weight each point equally,
 estimating an average standard deviation rather than using a weight of 1
 makes WSSR a dimensionless variable, as chisquare is by definition.

 Each fit iteration will display information which can be used to evaluate
 the progress of the fit.  (An '*' indicates that it did not find a smaller
 WSSR and is trying again.)  The 'sum of squares of residuals', also called
 'chisquare', is the WSSR between the data and your fitted function; `fit`
 has minimized that.  At this stage, with weighted data, chisquare is expected
 to approach the number of degrees of freedom (data points minus parameters).
 The WSSR can be used to calculate the reduced chisquare (WSSR/ndf) or stdfit,
 the standard deviation of the fit, sqrt(WSSR/ndf).  Both of these are
 reported for the final WSSR.

 If the data are unweighted, stdfit is the rms value of the deviation of the
 data from the fitted function, in user units.

 If you supplied valid data errors, the number of data points is large enough,
 and the model is correct, the reduced chisquare should be about unity.  (For
 details, look up the 'chi-squared distribution' in your favourite statistics
 reference.)  If so, there are additional tests, beyond the scope of this
 overview, for determining how well the model fits the data.

 A reduced chisquare much larger than 1.0 may be due to incorrect data error
 estimates, data errors not normally distributed, systematic measurement
 errors, 'outliers', or an incorrect model function.  A plot of the residuals,
 e.g., `plot 'datafile' using 1:($2-f($1))`, may help to show any systematic
 trends.  Plotting both the data points and the function may help to suggest
 another model.

 Similarly, a reduced chisquare less than 1.0 indicates WSSR is less than that
 expected for a random sample from the function with normally distributed
 errors.  The data error estimates may be too large, the statistical
 assumptions may not be justified, or the model function may be too general,
 fitting fluctuations in a particular sample in addition to the underlying
 trends.  In the latter case, a simpler function may be more appropriate.

 You'll have to get used to both `fit` and the kind of problems you apply it
 to before you can relate the standard errors to some more practical estimates
 of parameter uncertainties or evaluate the significance of the correlation
 matrix.

 Note that `fit`, in common with most NLLS implementations, minimizes the
 weighted sum of squared distances (y-f(x))**2.  It does not provide any means
 to account for "errors" in the values of x, only in y.  Also, any "outliers"
 (data points outside the normal distribution of the model) will have an
 exaggerated effect on the solution.
3 control
?commands fit control
?fit control
 There are a number of `gnuplot` variables that can be defined to affect
 `fit`.  Those which can be defined once `gnuplot` is running are listed
 under 'control_variables' while those defined before starting `gnuplot`
 are listed under 'environment_variables'.
4 control variables
?commands fit control variables
?fit control variables
 The default epsilon limit (1e-5) may be changed by declaring a value for
       FIT_LIMIT
 When the sum of squared residuals changes between two iteration steps by
 a factor less than this number (epsilon), the fit is considered to have
 'converged'.

 The maximum number of iterations may be limited by declaring a value for
       FIT_MAXITER
 A value of 0 (or not defining it at all)  means that there is no limit.

 If you need even more control about the algorithm, and know the
 Marquardt-Levenberg algorithm well, there are some more variables to
 influence it. The startup value of `lambda` is normally calculated
 automatically from the ML-matrix, but if you want to, you may provide
 your own one with
       FIT_START_LAMBDA
 Specifying FIT_START_LAMBDA as zero or less will re-enable the automatic
 selection. The variable
       FIT_LAMBDA_FACTOR
 gives the factor by which `lambda` is increased or decreased whenever
 the chi-squared target function increased or decreased significantly.
 Setting FIT_LAMBDA_FACTOR to zero re-enables the default factor of
 10.0.

 Other variables with the FIT_ prefix may be added to `fit`, so it is safer
 not to use that prefix for user-defined variables.

 The variables FIT_SKIP and FIT_INDEX were used by earlier releases of
 `gnuplot` with a 'fit' patch called `gnufit` and are no longer available.
 The datafile `every` modifier provides the functionality of FIT_SKIP.
 FIT_INDEX was used for multi-branch fitting, but multi-branch fitting of
 one independent variable is now done as a pseudo-3D fit in which the
 second independent variable and `using` are used to specify the branch.
 See `fit multi-branch`.
4 environment variables
?commands fit control environment
?fit control environment
 The environment variables must be defined before `gnuplot` is executed; how
 to do so depends on your operating system.

       FIT_LOG
 changes the name (and/or path) of the file to which the fit log will be
 written from the default of "fit.log" in the working directory. The default
 value can be overwritten using the command `set fit logfile`.

       FIT_SCRIPT
 specifies a command that may be executed after an user interrupt. The default
 is `replot`, but a `plot` or `load` command may be useful to display a plot
 customized to highlight the progress of the fit.
3 multi-branch
?commands fit multi-branch
?fit multi-branch
?multi-branch
?branch
 In multi-branch fitting, multiple data sets can be simultaneously fit with
 functions of one independent variable having common parameters by minimizing
 the total WSSR.  The function and parameters (branch) for each data set are
 selected by using a 'pseudo-variable', e.g., either the dataline number (a
 'column' index of -1) or the datafile index (-2), as the second independent
 variable.

 Example:  Given two exponential decays of the form, z=f(x), each describing
 a different data set but having a common decay time, estimate the values of
 the parameters.  If the datafile has the format x:z:s, then
      f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
      fit f(x,y) 'datafile' using  1:-1:2:3  via a, b, tau

 For a more complicated example, see the file "hexa.fnc" used by the
 "fit.dem" demo.

 Appropriate weighting may be required since unit weights may cause one
 branch to predominate if there is a difference in the scale of the dependent
 variable.  Fitting each branch separately, using the multi-branch solution
 as initial values, may give an indication as to the relative effect of each
 branch on the joint solution.
3 starting values
?commands fit starting_values
?fit starting_values
?starting_values
 Nonlinear fitting is not guaranteed to converge to the global optimum (the
 solution with the smallest sum of squared residuals, SSR), and can get stuck
 at a local minimum.  The routine has no way to determine that;  it is up to
 you to judge whether this has happened.

 `fit` may, and often will get "lost" if started far from a solution, where
 SSR is large and changing slowly as the parameters are varied, or it may
 reach a numerically unstable region (e.g., too large a number causing a
 floating point overflow) which results in an "undefined value" message
 or `gnuplot` halting.

 To improve the chances of finding the global optimum, you should set the
 starting values at least roughly in the vicinity of the solution, e.g.,
 within an order of magnitude, if possible.  The closer your starting values
 are to the solution, the less chance of stopping at another minimum.  One way
 to find starting values is to plot data and the fitting function on the same
 graph and change parameter values and `replot` until reasonable similarity
 is reached.  The same plot is also useful to check whether the fit stopped at
 a minimum with a poor fit.

 Of course, a reasonably good fit is not proof there is not a "better" fit (in
 either a statistical sense, characterized by an improved goodness-of-fit
 criterion, or a physical sense, with a solution more consistent with the
 model.)  Depending on the problem, it may be desirable to `fit` with various
 sets of starting values, covering a reasonable range for each parameter.
3 tips
?commands fit tips
?fit tips
?tips
 Here are some tips to keep in mind to get the most out of `fit`.  They're not
 very organized, so you'll have to read them several times until their essence
 has sunk in.

 The two forms of the `via` argument to `fit` serve two largely distinct
 purposes.  The `via "file"` form is best used for (possibly unattended) batch
 operation, where you just supply the startup values in a file and can later
 use `update` to copy the results back into another (or the same) parameter
 file.

 The `via var1, var2, ...` form is best used interactively, where the command
 history mechanism may be used to edit the list of parameters to be fitted or
 to supply new startup values for the next try.  This is particularly useful
 for hard problems, where a direct fit to all parameters at once won't work
 without good starting values.  To find such, you can iterate several times,
 fitting only some of the parameters, until the values are close enough to the
 goal that the final fit to all parameters at once will work.

 Make sure that there is no mutual dependency among parameters of the function
 you are fitting.  For example, don't try to fit a*exp(x+b), because
 a*exp(x+b)=a*exp(b)*exp(x).  Instead, fit either a*exp(x) or exp(x+b).

 A technical issue:  the parameters must not be too different in magnitude.
 The larger the ratio of the largest and the smallest absolute parameter
 values, the slower the fit will converge.  If the ratio is close to or above
 the inverse of the machine floating point precision, it may take next to
 forever to converge, or refuse to converge at all.  You will have to adapt
 your function to avoid this, e.g., replace 'parameter' by '1e9*parameter' in
 the function definition, and divide the starting value by 1e9.

 If you can write your function as a linear combination of simple functions
 weighted by the parameters to be fitted, by all means do so.  That helps a
 lot, because the problem is no longer nonlinear and should converge with only
 a small number of iterations, perhaps just one.

 Some prescriptions for analysing data, given in practical experimentation
 courses, may have you first fit some functions to your data, perhaps in a
 multi-step process of accounting for several aspects of the underlying
 theory one by one, and then extract the information you really wanted from
 the fitting parameters of those functions.  With `fit`, this may often be
 done in one step by writing the model function directly in terms of the
 desired parameters.  Transforming data can also quite often be avoided,
 though sometimes at the cost of a more difficult fit problem.  If you think
 this contradicts the previous paragraph about simplifying the fit function,
 you are correct.

 A "singular matrix" message indicates that this implementation of the
 Marquardt-Levenberg algorithm can't calculate parameter values for the next
 iteration.  Try different starting values, writing the function in another
 form, or a simpler function.

 Finally, a nice quote from the manual of another fitting package (fudgit),
 that kind of summarizes all these issues:  "Nonlinear fitting is an art!"
2 help
?commands help
?help
 The `help` command displays on-line help. To specify information on a
 particular topic use the syntax:

       help {<topic>}

 If <topic> is not specified, a short message is printed about `gnuplot`.
 After help for the requested topic is given, a menu of subtopics is given;
 help for a subtopic may be requested by typing its name, extending the help
 request.  After that subtopic has been printed, the request may be extended
 again or you may go back one level to the previous topic.  Eventually, the
 `gnuplot` command line will return.

 If a question mark (?) is given as the topic, the list of topics currently
 available is printed on the screen.
2 history
?commands history
?history
 `history` command lists or saves previous entries in the history of the
 command line editing, or executes an entry.

 Here you find 'usage by examples':

       history               # show the complete history
       history 5             # show last 5 entries in the history
       history quiet 5       # show last 5 entries without entry numbers
       history "hist.gp"     # write the complete history to file hist.gp
       history "hist.gp" append # append the complete history to file hist.gp
       history 10 "hist.gp"  # write last 10 commands to file hist.gp
       history 10 "|head -5 >>diary.gp" # write 5 history commands using pipe
       history ?load         # show all history entries starting with "load"
       history ?"set c"      # like above, several words enclosed in quotes
       hi !reread            # execute last entry starting with "reread"
       hist !"set xr"        # like above, several words enclosed in quotes
       hi !hi                # guess yourself :-))

 On systems which support a popen function (Unix), the output of history can be
 piped through an external program by starting the file name with a '|', as one
 of the above examples demonstrates.
2 if
?commands if
?if
 The `if` command allows commands to be executed conditionally.

 Syntax:
       if (<condition>) <command-line> [; else if (<condition>) ...; else ...]

 <condition> will be evaluated.  If it is true (non-zero), then the command(s)
 of the <command-line> will be executed.  If <condition> is false (zero), then
 the entire <command-line> is ignored until the next occurrence of `else`.
 Note that use of `;` to allow multiple commands on the same line will
 _not_ end the conditionalized commands.

 Examples:
       pi=3
       if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi
 will display:
       ?Fixing pi!
       3.14159265358979
 but
       if (1==2) print "Never see this"; print "Or this either"
 will not display anything.

 else:
       v=0
       v=v+1; if (v%2) print "2" ; else if (v%3) print "3"; else print "fred"
 (repeat the last line repeatedly!)

 See `reread` for an example of how `if` and `reread` can be used together to
 perform a loop.
2 load
?commands load
?load
 The `load` command executes each line of the specified input file as if it
 had been typed in interactively.  Files created by the `save` command can
 later be `load`ed.  Any text file containing valid commands can be created
 and then executed by the `load` command.  Files being `load`ed may themselves
 contain `load` or `call` commands.  See `comments` for information about
 comments in commands.  To `load` with arguments, see `call`.

 The `load` command _must_ be the last command on a multi-command line.

 Syntax:
       load "<input-file>"

 The name of the input file must be enclosed in quotes.

 The special filename "-" may be used to `load` commands from standard input.
 This allows a `gnuplot` command file to accept some commands from standard
 input.  Please see help for `batch/interactive` for more details.

 On some systems which support a popen function (Unix), the load file can be
 read from a pipe by starting the file name with a '<'.

 Examples:
       load 'work.gnu'
       load "func.dat"
       load "< loadfile_generator.sh"

 The `load` command is performed implicitly on any file names given as
 arguments to `gnuplot`.  These are loaded in the order specified, and
 then `gnuplot` exits.
2 lower
?commands lower
?lower
 Syntax:
       lower {plot_window_nb}

 The `lower` command lowers (opposite to `raise`) plot window(s) associated
 with the interactive terminal of your gnuplot session, i.e. `pm`, `win`, `wxt`
 or `x11`. It puts the plot window to bottom in the z-order windows stack of
 the window manager of your desktop.

 As `x11` and `wxt` support multiple plot windows, then by default they lower
 these windows in descending order of most recently created on top to the least
 recently created on bottom. If a plot number is supplied as an optional
 parameter, only the associated plot window will be lowered if it exists.

 The optional parameter is ignored for single plot-window terminals, i.e. `pm`
 and `win`.
2 pause
?commands pause
?pause
?pause mouse
 The `pause` command displays any text associated with the command and then
 waits a specified amount of time or until the carriage return is pressed.
 `pause` is especially useful in conjunction with `load` files.

 Syntax:
       pause <time> {"<string>"}
       pause mouse {<endcondition>}{, <endcondition>} {"<string>"}

 <time> may be any constant or expression.  Choosing -1 will wait until a
 carriage return is hit, zero (0) won't pause at all, and a positive number
 will wait the specified number of seconds.  The time is rounded to an integer
 number of seconds if subsecond time resolution is not supported by the given
 platform.  `pause 0` is synonymous with `print`.

 If the current terminal supports mousing, then `pause mouse` will terminate
 on either a mouse click or on ctrl-C.  For all other terminals, or if mousing
 is not active, `pause mouse` is equivalent to `pause -1`.

 If one or more end conditions are given after `pause mouse`, then any one of
 the conditions will terminate the pause. The possible end conditions are
 `keypress`, `button1`, `button2`, `button3`, and `any`.
 If the pause terminates on a keypress, then the ascii value of the key pressed
 is returned in MOUSE_KEY.  The character itself is returned as a one character
 string in MOUSE_CHAR.

 In all cases the coordinates of the mouse are returned in variables MOUSE_X,
 MOUSE_Y, MOUSE_X2, MOUSE_Y2.
 See `mouse variables`.

 Note: Since `pause` communicates with the operating system rather than the
 graphics, it may behave differently with different device drivers (depending
 upon how text and graphics are mixed).

 Examples:
       pause -1    # Wait until a carriage return is hit
       pause 3     # Wait three seconds
       pause -1  "Hit return to continue"
       pause 10  "Isn't this pretty?  It's a cubic spline."
       pause mouse "Click any mouse button on selected data point"
       pause mouse keypress "Type a letter from A-F in the active window"
       pause mouse button1,keypress
       pause mouse any "Any key or button will terminate"

 The variant "pause mouse key" will resume after any keypress in the active
 plot window. If you want to wait for a particular key to be pressed, you can
 use a reread loop such as:

       printf "I will resume after you hit the Tab key in the plot window"
       load "wait_for_tab"

 File "wait_for_tab" contains the lines

       pause mouse key
       if (MOUSE_KEY != 9) reread

2 plot
?commands plot
?plot
 `plot` is the primary command for drawing plots with `gnuplot`.  It creates
 plots of functions and data in many, many ways.  `plot` is used to draw 2-d
 functions and data; `splot` draws 2-d projections of 3-d surfaces and data.
 `plot` and `splot` contain many common features; see `splot` for differences.
 Note specifically that although the `binary <binary list>` variation does
 work for both `plot` and `splot`, there are small differences between these
 modes.  Furthermore, `plot`'s `axes` option does not exist for `splot`.

 Syntax:
       plot {<ranges>}
            {<iteration>}
            {<function> | {"<datafile>" {datafile-modifiers}}}
            {axes <axes>} {<title-spec>} {with <style>}
            {, {definitions,} <function> ...}

 where either a <function> or the name of a data file enclosed in quotes is
 supplied.  A function is a mathematical expression or a pair of mathematical
 expressions in parametric mode.  The expressions may be defined completely or
 in part earlier in the stream of `gnuplot` commands (see `user-defined`).

 It is also possible to define functions and parameters on the `plot` command
 itself.  This is done merely by isolating them from other items with commas.

 There are four possible sets of axes available; the keyword <axes> is used to
 select the axes for which a particular line should be scaled.  `x1y1` refers
 to the axes on the bottom and left; `x2y2` to those on the top and right;
 `x1y2` to those on the bottom and right; and `x2y1` to those on the top and
 left.  Ranges specified on the `plot` command apply only to the first set of
 axes (bottom left).

 Examples:
       plot sin(x)
       plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
       plot [t=1:10] [-pi:pi*2] tan(t), \
            "data.1" using (tan($2)):($3/$4) smooth csplines \
                     axes x1y2 notitle with lines 5

 See also `show plot`.
3 data
?commands plot datafile
?plot datafile
?data-file
?datafile
?data
?file
 Discrete data contained in a file can be displayed by specifying the name of
 the data file (enclosed in single or double quotes) on the `plot` command line.

 Syntax:
       plot '<file_name>' {binary <binary list>}
                          {matrix}
                          {index <index list> | index "<name>"}
                          {every <every list>}
                          {thru <thru expression>}
                          {using <using list>}
                          {smooth <option>}

 The modifiers `binary`, `index`, `every`, `thru`, `using`, and `smooth` are
 discussed separately.  In brief, `binary` allows data entry from a binary
 file (default is ASCII), `index` selects which data sets in a multi-data-set
 file are to be plotted, `every` specifies which points within a single data
 set are to be plotted, `using` determines how the columns within a single
 record are to be interpreted (`thru` is a special case of `using`), and
 `smooth` allows for simple interpolation and approximation.  (`splot` has a
 similar syntax, but does not support the `smooth` and `thru` options.)


 ASCII DATA FILES:

 Data files should contain at least one data point per record (`using`
 can select one data point from the record). Records beginning with `#`
 (and also with `!` on VMS) will be treated as comments and ignored.
 Each data point represents an (x,y) pair. For `plot`s with error bars or
 error bars with lines (see `set style errorbars` or `set style errorlines`),
 each data point is (x,y,ydelta), (x,y,ylow,yhigh),
 (x,y,xdelta), (x,y,xlow,xhigh), or (x,y,xlow,xhigh,ylow,yhigh).

 In all cases, the numbers of each record of a data file must be separated
 by white space (one or more blanks or tabs) unless a format specifier is
 provided by the `using` option. This white space divides each record into
 columns. However, whitespace inside a pair of double quotes is ignored when
 counting columns, so the following datafile line has three columns:
       1.0 "second column" 3.0

 Data may be written in exponential format with the exponent preceded by the
 letter e or E.  The fortran exponential specificiers d, D, q, and Q may also
 be used if the command `set datafile fortran` is in effect.

 Only one column (the y value) need be provided.  If x is omitted, `gnuplot`
 provides integer values starting at 0.

 In datafiles, blank records (records with no characters other than blanks and
 a newline and/or carriage return) are significant---pairs of blank records
 separate `index`es (see `plot datafile index`).  Data separated by double
 blank records are treated as if they were in separate data files.

 Single blank records designate discontinuities in a `plot`; no line will join
 points separated by a blank records (if they are plotted with a line style).

 If autoscaling has been enabled (`set autoscale`), the axes are automatically
 extended to include all datapoints, with a whole number of tic marks if tics
 are being drawn.  This has two consequences: i) For `splot`, the corner of
 the surface may not coincide with the corner of the base.  In this case, no
 vertical line is drawn.  ii) When plotting data with the same x range on a
 dual-axis graph, the x coordinates may not coincide if the x2tics are not
 being drawn.  This is because the x axis has been autoextended to a whole
 number of tics, but the x2 axis has not.  The following example illustrates
 the problem:

       reset; plot '-', '-' axes x2y1
       1 1
       19 19
       e
       1 1
       19 19
       e

 To avoid this, you can use the `fixmin`/`fixmax` feature of the
 `set autoscale` command, which turns off the automatic extension of the
 axis range upto the next tic mark.


 BINARY DATA FILES:

 Gnuplot can read binary data files.  However, adequate information about
 details of the file format must be given on the command line or extracted
 from the file itself for a supported binary `filetype`.  In particular,
 there are two structures for binary files, a matrix binary format and a
 general binary format.

 The matrix binary format contains a two dimensional array of 32 bit IEEE
 float values with an additional column and row of coordinate values.  As
 with ASCII matrix, in the using list, repetition of the coordinate row
 constitutes column 1, repetition of the coordinate column constitutes
 column 2, and the array of values constitutes column 3.

 The general binary format contains an arbitrary number of columns for which
 information must be specified at the command line.  For example, `array`,
 `record`, `format` and `using` can indicate the size, format and dimension
 of data.  There are a variety of useful commands for skipping file headers
 and changing endianess.  There are a set of commands for positioning and
 translating data since often coordinates are not part of the file when
 uniform sampling is inherent in the data.  Different from matrix binary or
 ASCII, general binary does not treat the generated columns as 1, 2 or 3 in
 the using list.  Rather, column 1 begins with column 1 of the file, or as
 specified in the `format` list.

 There are global default settings for the various binary options which may
 be set using the same syntax as the options when used as part of the `(s)plot
 <filename> binary ...` command.  This syntax is `set datafile binary ...`.
 The general rule is that common command-line specified parameters override
 file-extracted parameters which override default parameters.

 Matrix binary is the default binary format when no keywords specific to
 general binary are given, i.e., `array`, `record`, `format`, `filetype`.

 General binary data can be entered at the command line via the special file
 name '-'.  However, this is intended for use through a pipe where programs
 can exchange binary data, not for keyboards.  There is no "end of record"
 character for binary data.  Gnuplot continues reading from a pipe until it
 has read the number of points declared in the `array` qualifier.

 See `datafile binary` for more details.
4 binary
?commands plot datafile binary
?plot datafile binary
?splot datafile binary
?plot binary
?splot binary
?data-file binary
?datafile binary
?binary
 The `binary` keyword allows a data file to be binary as opposed to ASCII.
 There are two formats for binary--matrix binary and general binary.  Matrix
 binary is a fixed format in which data appears in a 2D array with an extra
 row and column for coordinate values.  General binary is a flexible format
 for which details about the file must be given at the command line.

 See `binary matrix` or `binary general` for more details.
4 binary general
?commands plot datafile binary general
?commands splot datafile binary general
?plot binary general
?splot binary general
?binary general
 General binary data in which format information is not necessarily part of
 the file can be read by giving further details about the file format at the
 command line.  Although the syntax is slightly arcane to the casual user,
 general binary is particularly useful for application programs using gnuplot
 and sending large amounts of data.

 Syntax:
       plot '<file_name>' {binary <binary list>} ...
       splot '<file_name>' {binary <binary list>} ...

 General binary format is activated by keywords in <binary list> pertaining
 to information about file structure, i.e., `array`, `record`, `format` or
 `filetype`.  Otherwise, matrix binary format is assumed.  (See `binary matrix`
 for more details.)

 There are some standard file types that may be read for which details about
 the binary format may be extracted automatically.  (Type `show datafile
 binary` at the command line for a list.)  Otherwise, details must be
 specified at the command line or set in the defaults.  Keywords are described
 below.

 The keyword `filetype` in <binary list> controls the routine used to
 read the file, i.e., the format of the data.  For a list of the supported
 file types, type `show datafile binary filetypes`.  If no file type is
 given, the rule is that traditional gnuplot binary is assumed for `splot`
 if the `binary` keyword stands alone.  In all other circumstances, for
 `plot` or when one of the <binary list> keywords appears, a raw binary
 file is assumed whereby the keywords specify the binary format.

 General binary data files fall into two basic classes, and some files may
 be of both classes depending upon how they are treated.  There is that
 class for which uniform sampling is assumed and point coordinates must be
 generated.  This is the class for which full control via the <binary
 list> keywords applies.  For this class, the settings precedence is that
 command line parameters override in-file parameters, which override
 default settings.  The other class is that set of files for which
 coordinate information is contained within the file or there is possibly
 a non-uniform sampling such as gnuplot binary.

 Other than for the unique data files such as gnuplot binary, one should
 think of binary data as conceptually the same as ASCII data.  Each point
 has columns of information which are selected via the `<using list>`
 associated with `using`.  When no `format` string is specified, gnuplot
 will retrieve a number of binary variables equal to the largest column
 given in the `<using list>`.  For example, `using 1:3` will result in
 three columns being read, of which the second will be ignored.  There are
 default using lists based upon the typical number of parameters associated
 with a certain plot type.  For example, `with image` has a default of
 `using 1`, while `with rgbimage` has a default of `using 1:2:3`.  Note
 that the special characters for `using` representing point/line/index
 generally should not be used for binary data.  There are keywords in
 <binary list> that control this.
5 array
?binary general array
 Describes the sampling array dimensions associated with the binary file.
 The coordinates will be generated by gnuplot.  A number must be specified
 for each dimension, thereby calling out the size of the array.  For example,
 `array=10x20` means the underlying sampling structure is two-dimensional with
 10 points along the first (x) dimension and 20 points along the second (y)
 dimension.  A special "number", `Inf`, can be used to indicate that data should
 be read until the end of file.  A colon can be used to separate the dimensions
 for multiple records.  For example, `array=25:35` indicates there are two
 one-dimensional records within the file.  The colon behavior applies to the
 remaining keywords in this list for which it makes sense to be associated with
 individual records.

 Currently, syntax allows for up to three-dimensional arrays.  However, no
 conventions have yet been made for handling three-dimensional coordinates.
5 record
?binary general record
 This keyword serves the same function as `array`, having the same syntax.
 However, `record` causes gnuplot to not generate coordinate information.
 This is for the case where such information may be included in one of the
 columns of the binary data file.
5 format
?binary general format
 The default binary format is a float.  For more flexibility, the format can
 include details about variable sizes.  For example, `format="%uchar%int%float"`
 associates an unsigned character with the first using column, an int with the
 second column and a float with the third column.  If the number of size
 specifications is less than the greatest column number, the size is implicitly
 taken to be similar to the last given variable size.

 Furthermore, the format specification can include "discarded" terms via the `*`
 character.  For example, to skip the middle column of the previous example, one
 could write `format="%uchar%*int%float"` and gnuplot will discard the middle
 integer.  To list variable sizes, type `show datafile binary datasizes`.  There
 are a group of names that are machine dependent along with their sizes in bytes
 for the particular compilation.  There is also a group of names which attempt
 to be machine independent.
5 endian
?binary general endian
 Often the endianess of binary data in the file does not agree with the
 endianess used by the platform on which gnuplot is running.  Several words can
 direct gnuplot how to arrange bytes.  For example `endian=little` means treat
 the binary file as having byte significance from least to greatest. The options
 are

               little:  least significant to greatest significance
                  big:  greatest significance to least significance
              default:  assume file endianess is the same as compiler
          swap (swab):  Interchange the significance.  (If things
                        don't look right, try this.)

 Gnuplot can support "middle" ("pdp") endian if it is compiled with that option.
5 filetype
?binary general filetype
 For some standard binary file formats gnuplot can extract all the necessary
 information from the file in question.  As an example, "format=edf" will read
 ESRF Header File format files.  For a list of the currently supported file
 formats, type `show datafile binary filetypes`.

 There is a special file type called `auto` for which gnuplot will check if the
 binary file's extension is a quasi-standard extension for a supported format.

 Command line keywords may be used to override settings extracted from the file.
 The settings from the file override any defaults.  (See `set datafile binary`
 for details.)
6 avs
?binary general filetype avs
?filetype avs
?avs
 `avs` is one of the automatically recognized binary file types for images.
 AVS is an extremely simple format, suitable mostly for streaming between
 applications. It consists of 2 longs (xwidth, ywidth) followed by a stream
 of pixels, each with four bytes of information alpha/red/green/blue.
6 edf
?binary general filetype edf
?filetype edf
?edf
?filetype ehf
?ehf
 `edf` is one of the automatically recognized binary file types for images.
 EDF stands for ESRF Data Format, and it supports both edf and ehf formats
 (the latter means ESRF Header Format).  More information on specifications
 can be found at

   http://www.esrf.fr/computing/expg/subgroups/general/format/Format.html

 See also `binary`.
5 keywords
?binary general keywords
?filetype keywords
 The following keywords apply only when generating coordinates.  That is, when
 the keyword `array` is used.
6 scan
?binary general keywords scan
 A great deal of confusion can arise concerning the relationship between how
 gnuplot scans a binary file and the dimensions seen on the plot.  To lessen
 the confusion, conceptually think of gnuplot _always_ scanning the binary file
 point/line/plane or fast/medium/slow.  Then this keyword is used to tell
 gnuplot how to map this scanning convention to the Cartesian convention shown
 in plots, i.e., x/y/z.  The qualifier for scan is a two or three letter code
 representing where point is assigned (first letter), line is assigned (second
 letter), and plane is assigned (third letter).  For example, `scan=yx` means
 the fastest, point-by-point, increment should be mapped along the Cartesian
 y dimension and the middle, line-by-line, increment should be mapped along the
 x dimension.

 When the plotting mode is `plot`, the qualifier code can include the two
 letters x and y.  For `splot`, it can include the three letters x, y and z.

 There is nothing restricting the inherent mapping from point/line/plane to
 apply only to Cartesian coordinates.  For this reason there are cylindrical
 coordinate synonyms for the qualifier codes where t (theta), r and z are
 analogous to the x, y and z of Cartesian coordinates.
6 transpose
?binary general keywords transpose
 Shorthand notation for `scan=yx` or `scan=yxz`.
6 dx, dy, dz
?binary general keywords dx
 When gnuplot generates coordinates, it uses the spacing described by these
 keywords.  For example `dx=10 dy=20` would mean space samples along the
 x dimension by 10 and space samples along the y dimension by 20.  `dy` cannot
 appear if `dx` does not appear.  Similarly, `dz` cannot appear if `dy` does not
 appear.  If the underlying dimensions are greater than the keywords specified,
 the spacing of the highest dimension given is extended to the other dimensions.
 For example, if an image is being read from a file and only `dx=3.5` is given
 gnuplot uses a delta x and delta y of 3.5.

 The following keywords also apply only when generating coordinates.  However
 they may also be used with matrix binary files.
6 flipx, flipy, flipz
?binary general keywords flipx
 Sometimes the scanning directions in a binary datafile are not consistent with
 that assumed by gnuplot.  These keywords can flip the scanning direction along
 dimensions x, y, z.
6 origin 
?binary general keywords origin
 When gnuplot generates coordinates based upon transposition and flip, it
 attempts to always position the lower left point in the array at the origin,
 i.e., the data lies in the first quadrant of a Cartesian system after transpose
 and flip.

 To position the array somewhere else on the graph, the `origin` keyword directs
 gnuplot to position the lower left point of the array at a point specified by a
 tuple.  The tuple should be a double for `plot` and a triple for `splot`.
 For example, `origin=(100,100):(100,200)` is for two records in the file and
 intended for plotting in two dimensions. A second example, `origin=(0,0,3.5)`,
 is for plotting in three dimensions.
6 center
?binary general keywords center
 Similar to `origin`, this keyword will position the array such that its center
 lies at the point given by the tuple.  For example, `center=(0,0)`.  Center
 does not apply when the size of the array is `Inf`.
6 rotate
?binary general keywords rotate
 The transpose and flip commands provide some flexibility in generating and
 orienting coordinates.  However, for full degrees of freedom, it is possible to
 apply a rotational vector described by a rotational angle in two dimensions.

 The `rotate` keyword applies to the two-dimensional plane, whether it be `plot`
 or `splot`.  The rotation is done with respect to the positive angle of the
 Cartesian plane.

 The angle can be expressed in radians, radians as a multiple of pi, or degrees.
 For example, `rotate=1.5708`, `rotate=0.5pi` and `rotate=90deg` are equivalent.

 If `origin` is specified, the rotation is done about the lower left sample
 point before translation.  Otherwise, the rotation is done about the array
 `center`.
6 perpendicular
?binary general keywords perpendicular
 For `splot`, the concept of a rotational vector is implemented by a triple
 representing the vector to be oriented normal to the two-dimensional x-y plane.
 Naturally, the default is (0,0,1).  Thus specifying both rotate and
 perpendicular together can orient data myriad ways in three-space.

 The two-dimensional rotation is done first, followed by the three-dimensional
 rotation.  That is, if R' is the rotational 2 x 2 matrix described by an angle,
 and P is the 3 x 3 matrix projecting (0,0,1) to (xp,yp,zp), let R be
 constructed from R' at the upper left sub-matrix, 1 at element 3,3 and zeros
 elsewhere.  Then the matrix formula for translating data is v' = P R v, where v
 is the 3 x 1 vector of data extracted from the data file.  In cases where the
 data of the file is inherently not three-dimensional, logical rules are used to
 place the data in three-space.  (E.g., usually setting the z-dimension value to
 zero and placing 2D data in the x-y plane.)
5 binary examples
?binary_examples
?binary examples
?binary general examples
 Examples:

       # Selects two float values (second one implicit) with a float value
       # discarded between them for an indefinite length of 1D data.
       plot '<file_name>' binary format="%float%*float" using 1:2 with lines

       # The data file header contains all details necessary for creating
       # coordinates from an EDF file.
       plot '<file_name>' binary filetype=edf with image
       plot '<file_name>.edf' binary filetype=auto with image

       # Selects three unsigned characters for components of a raw RGB image
       # and flips the y-dimension so that typical image orientation (start
       # at top left corner) translates to the Cartesian plane.  Pixel
       # spacing is given and there are two images in the file.  One of them
       # is translated via origin.
       plot '<file_name>' binary array=512x1024:1024x512 format='%uchar' \
            dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage

       # Four separate records in which the coordinates are part of the
       # data file.  The file was created with a endianess different from
       # the system on which gnuplot is running.
       splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3

 See also `binary matrix`.
4 every
?commands plot datafile every
?plot datafile every
?plot every
?data-file every
?datafile every
?every
 The `every` keyword allows a periodic sampling of a data set to be plotted.

 In the discussion a "point" is a datum defined by a single record in the
 file; "block" here will mean the same thing as "datablock" (see `glossary`).

 Syntax:
       plot 'file' every {<point_incr>}
                           {:{<block_incr>}
                             {:{<start_point>}
                               {:{<start_block>}
                                 {:{<end_point>}
                                   {:<end_block>}}}}}

 The data points to be plotted are selected according to a loop from
 <`start_point`> to <`end_point`> with increment <`point_incr`> and the
 blocks according to a loop from <`start_block`> to <`end_block`> with
 increment <`block_incr`>.

 The first datum in each block is numbered '0', as is the first block in the
 file.

 Note that records containing unplottable information are counted.

 Any of the numbers can be omitted; the increments default to unity, the start
 values to the first point or block, and the end values to the last point or
 block.  If `every` is not specified, all points in all lines are plotted.

 Examples:
       every :::3::3    # selects just the fourth block ('0' is first)
       every :::::9     # selects the first 10 blocks
       every 2:2        # selects every other point in every other block
       every ::5::15    # selects points 5 through 15 in each block

 See
^ <a href="http://www.gnuplot.info/demo/simple.html">
 simple plot demos (simple.dem)
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface1.html">
 Non-parametric splot demos
^ </a>
 , and
^ <a href="http://gnuplot.sourceforge.net/demo/surface2.html">
 Parametric splot demos
^ </a>
 .
4 example datafile
?commands plot datafile example
?plot datafile example
?plot example
?datafile example
?data-file example
?example
 This example plots the data in the file "population.dat" and a theoretical
 curve:

       pop(x) = 103*exp((1965-x)/10)
       plot [1960:1990] 'population.dat', pop(x)

 The file "population.dat" might contain:

       # Gnu population in Antarctica since 1965
          1965   103
          1970   55
          1975   34
          1980   24
          1985   10

^ <img align=bottom src="http://www.gnuplot.info/doc/population.gif" alt="[population.gif]" width=640 height=480>
4 index
?commands plot datafile index
?plot datafile index
?plot index
?data-file index
?datafile index
?index
 The `index` keyword allows only some of the data sets in a multi-data-set
 file to be plotted.

 Syntax:
       plot 'file' index { <m>{{:<n>}:<p>} | "<name>" }

 Data sets are separated by pairs of blank records.  `index <m>` selects only
 set <m>; `index <m>:<n>` selects sets in the range <m> to <n>; and `index
 <m>:<n>:<p>` selects indices <m>, <m>+<p>, <m>+2<p>, etc., but stopping at
 <n>.  Following C indexing, the index 0 is assigned to the first data set in
 the file.  Specifying too large an index results in an error message.  If
 `index` is not specified, all sets are plotted as a single data set.

 Example:
       plot 'file' index 4:5

 `index '<name>'` selects the data set with name '<name>'.  Names are assigned
 to data sets in comment lines.  The comment character and leading white space
 are removed from the comment line.  If the resulting line starts with <name>,
 the following data set is now named <name> and can be selected.

 Example:
       plot 'file' index 'Population'

 Please note that every comment that starts with <name> will name the following
 data set.  To avoid problems use a naming scheme like e.g. '== Popolation =='
 or '[Population]'.

^ See also web page
^ <a href="http://www.gnuplot.info/demo/multimsh.html">
^ splot with indices demo.
^ </a>
4 smooth
?commands plot datafile smooth
?plot datafile smooth
?plot smooth
?data-file smooth
?datafile smooth
?smooth
 `gnuplot` includes a few general-purpose routines for interpolation and
 approximation of data; these are grouped under the `smooth` option.  More
 sophisticated data processing may be performed by preprocessing the data
 externally or by using `fit` with an appropriate model.

 Syntax:
       smooth {unique | frequency | csplines | acsplines | bezier | sbezier}

 `unique` and `frequency` plot the data after making them monotonic.  Each of
 the other routines uses the data to determine the coefficients of a
 continuous curve between the endpoints of the data.  This curve is then
 plotted in the same manner as a function, that is, by finding its value at
 uniform intervals along the abscissa (see `set samples`) and connecting these
 points with straight line segments (if a line style is chosen).

 If `autoscale` is in effect, the ranges will be computed such that the
 plotted curve lies within the borders of the graph.

 If `autoscale` is not in effect, and the smooth option is either `acspline`
 or `cspline`, the sampling of the generated curve is
 done across the intersection of the x range covered by the input data and
 the fixed abscissa range as defined by `set xrange`.

 If too few points are available to allow the selected option to be applied,
 an error message is produced.  The minimum number is one for `unique` and
 `frequency`, four for `acsplines`, and three for the others.

 The `smooth` options have no effect on function plots.
5 acsplines
?commands plot datafile smooth acsplines
?plot datafile smooth acsplines
?data-file smooth acsplines
?datafile smooth acsplines
?plot smooth acsplines
?plot acsplines
?smooth acsplines
?acsplines
 The `acsplines` option approximates the data with a "natural smoothing spline".
 After the data are made monotonic in x (see `smooth unique`), a curve is
 piecewise constructed from segments of cubic polynomials whose coefficients
 are found by the weighting the data points; the weights are taken from the
 third column in the data file.  That default can be modified by the third
 entry in the `using` list, e.g.,
       plot 'data-file' using 1:2:(1.0) smooth acsplines

 Qualitatively, the absolute magnitude of the weights determines the number
 of segments used to construct the curve.  If the weights are large, the
 effect of each datum is large and the curve approaches that produced by
 connecting consecutive points with natural cubic splines.  If the weights are
 small, the curve is composed of fewer segments and thus is smoother; the
 limiting case is the single segment produced by a weighted linear least
 squares fit to all the data.  The smoothing weight can be expressed in terms
 of errors as a statistical weight for a point divided by a "smoothing factor"
 for the curve so that (standard) errors in the file can be used as smoothing
 weights.

 Example:
       sw(x,S)=1/(x*x*S)
       plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines
5 bezier
?commands plot datafile smooth bezier
?plot datafile smooth bezier
?plot smooth bezier
?data-file smooth bezier
?datafile smooth bezier
?plot bezier
?smooth bezier
?bezier
 The `bezier` option approximates the data with a Bezier curve of degree n
 (the number of data points) that connects the endpoints.
5 csplines
?commands plot datafile smooth csplines
?plot datafile smooth csplines
?plot smooth csplines
?data-file smooth csplines
?datafile smooth csplines
?plot csplines
?smooth csplines
?csplines
 The `csplines` option connects consecutive points by natural cubic splines
 after rendering the data monotonic (see `smooth unique`).
5 sbezier
?commands plot datafile smooth sbezier
?plot datafile smooth sbezier
?plot smooth sbezier
?data-file smooth sbezier
?datafile smooth sbezier
?plot sbezier
?smooth sbezier
?sbezier
 The `sbezier` option first renders the data monotonic (`unique`) and then
 applies the `bezier` algorithm.
5 unique
?commands plot datafile smooth unique
?plot datafile smooth unique
?plot smooth unique
?data-file smooth unique
?datafile smooth unique
?plot unique
?smooth unique
?unique
 The `unique` option makes the data monotonic in x; points with the same
 x-value are replaced by a single point having the average y-value.  The
 resulting points are then connected by straight line segments.
^ See this
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 demos
^ </a>
^ web page.
5 frequency
?commands plot datafile smooth frequency
?plot datafile smooth frequency
?plot smooth frequency
?data-file smooth frequency
?datafile smooth frequency
?plot frequency
?smooth frequency
?frequency
 The `frequency` option makes the data monotonic in x; points with the same
 x-value are replaced by a single point having the summed y-values.  The
 resulting points are then connected by straight line segments.
4 special-filenames
?commands plot datafile special-filenames
?plot datafile special-filenames
?plot special-filenames
?datafile special-filenames
?special-filenames
 There are three filenames that have a special meaning:  '', '-', and '+'.

 The empty filename '' tells gnuplot to re-use the previous input file in the
 same plot command. So to plot two columns from the same input file:

       plot 'filename' using 1:2, '' using 1:3

 The special filename '+' is a mechanism to allow the full range of 
 `using` specifiers and plot styles with in-line functions.  Normally a 
 function plot can only have a single y (or z) value associated with each
 sampled point.  The pseudo-file '+' treats the sampled points as columns
 1 (plot) or 1 and 2 (splot), and allows additional column values to be
 specified via a `using` specification, just as for a true input file.
 Example:

       plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves

 The special filename `'-'` specifies that the data are inline; i.e., they
 follow the command.  Only the data follow the command; `plot` options like
 filters, titles, and line styles remain on the `plot` command line.  This is
 similar to << in unix shell script, and $DECK in VMS DCL.  The data are
 entered as though they are being read from a file, one data point per record.
 The letter "e" at the start of the first column terminates data entry.  The
 `using` option can be applied to these data---using it to filter them through
 a function might make sense, but selecting columns probably doesn't!

 `'-'` is intended for situations where it is useful to have data and commands
 together, e.g., when `gnuplot` is run as a sub-process of some front-end
 application.  Some of the demos, for example, might use this feature.  While
 `plot` options such as `index` and `every` are recognized, their use forces
 you to enter data that won't be used.  For example, while

       plot '-' index 0, '-' index 1
       2
       4
       6


       10
       12
       14
       e
       2
       4
       6


       10
       12
       14
       e

 does indeed work,

       plot '-', '-'
       2
       4
       6
       e
       10
       12
       14
       e

 is a lot easier to type.

 If you use `'-'` with `replot`, you may need to enter the data more than once
 (see `replot`).

 A blank filename ('') specifies that the previous filename should be reused.
 This can be useful with things like

       plot 'a/very/long/filename' using 1:2, '' using 1:3, '' using 1:4

 (If you use both `'-'` and `''` on the same `plot` command, you'll need to
 have two sets of inline data, as in the example above.)

 On some computer systems with a popen function (Unix), the datafile can be
 piped through a shell command by starting the file name with a '<'.  For
 example,

       pop(x) = 103*exp(-x/10)
       plot "< awk '{print $1-1965, $2}' population.dat", pop(x)

 would plot the same information as the first population example but with
 years since 1965 as the x axis.  If you want to execute this example, you
 have to delete all comments from the data file above or substitute the
 following command for the first part of the command above (the part up to
 the comma):

       plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"

 While this approach is most flexible, it is possible to achieve simple
 filtering with the `using` or `thru` keywords.
4 thru
?commands plot datafile thru
?plot datafile thru
?plot thru
?data-file thru
?datafile thru
?thru
 The `thru` function is provided for backward compatibility.

 Syntax:
       plot 'file' thru f(x)

 It is equivalent to:

       plot 'file' using 1:(f($2))

 While the latter appears more complex, it is much more flexible.  The more
 natural

       plot 'file' thru f(y)

 also works (i.e. you can use y as the dummy variable).

 `thru` is parsed for `splot` and `fit` but has no effect.
4 using
?commands plot datafile using
?plot datafile using
?plot using
?data-file using
?datafile using
?using
 The most common datafile modifier is `using`.

 Syntax:
       plot 'file' using {<entry> {:<entry> {:<entry> ...}}} {'format'}

 If a format is specified, each datafile record is read using the C library's
 'scanf' function, with the specified format string.  Otherwise the record is
 read and broken into columns at spaces or tabs.  A format cannot be specified
 this way for time-format data (instead use `set xdata time`).

 The resulting array of data is then sorted into columns according to the
 entries.  Each <entry> may be a simple column number, which selects the
 datum, an expression enclosed in parentheses, or empty.  The expression can
 use $1 to access the first item read, $2 for the second item, and so on.  It
 can also use `column(x)` and `valid(x)` where x is an arbitrary expression
 resulting in an integer.  `column(x)` returns the x'th datum; `valid(x)`
 tests that the datum in the x'th column is a valid number.  A column number
 of 0 generates a number increasing (from zero) with each point, and is reset
 upon encountering two blank records.  A column number of -1 gives the
 dataline number, which starts at 0, increments at single blank records, and
 is reset at double blank records.  A column number of -2 gives the index
 number, which is incremented only when two blank records are found.  An empty
 <entry> will default to its order in the list of entries.  For example,
 `using ::4` is interpreted as `using 1:2:4`.

 N.B.---the `call` command also uses $'s as a special character.  See `call`
 for details about how to include a column number in a `call` argument list.

 If the `using` list has but a single entry, that <entry> will be used for y
 and the data point number is used for x; for example, "`plot 'file' using 1`"
 is identical to "`plot 'file' using 0:1`".  If the `using` list has two
 entries, these will be used for x and y.  Additional entries are usually
 errors in x and/or y.  See `set style` for details about plotting styles that
 make use of error information, and `fit` for use of error information in
 curve fitting.

 'scanf' accepts several numerical specifications but `gnuplot`
 requires all inputs to be double-precision floating-point variables,
 so "%lf" is essentially the only permissible specifier.
 A format string given by the user must contain at least one such
 input specifier, and no more than seven of them.
 'scanf' expects to see white space---a blank, tab
 ("\t"), newline ("\n"), or formfeed ("\f")---between numbers; anything else
 in the input stream must be explicitly skipped.

 Note that the use of "\t", "\n", or "\f" requires use of double-quotes
 rather than single-quotes.

 Examples:

 This creates a plot of the sum of the 2nd and 3rd data against the first:
 The format string specifies comma- rather than space-separated columns.
 The same result could be achieved by specifying `set datafile separator ","`.
       plot 'file' using 1:($2+$3) '%lf,%lf,%lf'

 In this example the data are read from the file "MyData" using a more
 complicated format:
       plot 'MyData' using "%*lf%lf%*20[^\n]%lf"

 The meaning of this format is:

       %*lf        ignore a number
       %lf         read a double-precision number (x by default)
       %*20[^\n]   ignore 20 non-newline characters
       %lf         read a double-precision number (y by default)

 One trick is to use the ternary `?:` operator to filter data:

       plot 'file' using 1:($3>10 ? $2 : 1/0)

 which plots the datum in column two against that in column one provided
 the datum in column three exceeds ten.  `1/0` is undefined; `gnuplot`
 quietly ignores undefined points, so unsuitable points are suppressed.

 In fact, you can use a constant expression for the column number, provided it
 doesn't start with an opening parenthesis; constructs like `using
 0+(complicated expression)` can be used.  The crucial point is that the
 expression is evaluated once if it doesn't start with a left parenthesis, or
 once for each data point read if it does.

 If timeseries data are being used, the time can span multiple columns.  The
 starting column should be specified.  Note that the spaces within the time
 must be included when calculating starting columns for other data.  E.g., if
 the first element on a line is a time with an embedded space, the y value
 should be specified as column three.

 It should be noted that `plot 'file'`, `plot 'file' using 1:2`, and `plot
 'file' using ($1):($2)` can be subtly different: 1) if `file` has some lines
 with one column and some with two, the first will invent x values when they
 are missing, the second will quietly ignore the lines with one column, and
 the third will store an undefined value for lines with one point (so that in
 a plot with lines, no line joins points across the bad point); 2) if a line
 contains text at the first column, the first will abort the plot on an error,
 but the second and third should quietly skip the garbage.

 In fact, it is often possible to plot a file with lots of lines of garbage at
 the top simply by specifying

       plot 'file' using 1:2

 However, if you want to leave text in your data files, it is safer to put the
 comment character (#) in the first column of the text lines.
^ See also the web page
^ <a href="http://www.gnuplot.info/demo/using.html">
 Feeble using demos.
^ </a>

 If gnuplot is built with configuration option --enable-datastrings, then
 additional modifiers to `using` can specify handling of text fields in the
 datafile. See `datastrings`, `using xticlabels`, `using title`.
5 using title
?using title
?plot using title
 If gnuplot is built with configuration option --enable-datastrings, then
 the first entry of a column of the input data file can be used as a string
 to provide the plot title in the key box.  The column containing specified
 is independent of the column[s] used for the plot itself.

    plot 'data' using 1:($2/$3) title column(N)

 In this case the entry in the first row of column N will be used for the
 key entry of the plot constructed from dividing column 2 by column 3.
 The entry in the first row of columns 2 and 3 will be ignored.

5 xticlabels
?using xticlabels
?plot using xticlabels
 If gnuplot is built with configuration option --enable-datastrings, then
 a column of the input data file can be used to label axis tic marks.
 The format of such a plot command is

   plot 'datafile' using <xcol>:<ycol>:xticlabels(<labelcol>) with <plotstyle>

 Tic labels may be read for any of the plot axes: x x2 y y2 z.
 The `ticlabels(<labelcol>)` specifiers must come after all of the data
 coordinate specifiers in the `using` portion of the command.
 For each data point which has a valid set of X,Y[,Z] coordinates,
 the text field found in column <labelcol> is added to the list of xtic labels
 at the same X coordinate as the point it belongs to. `xticlabels(<labelcol>)`
 may be shortened to `xtic(<labelcol>)`.

 Example:

       splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)

 In this example the x and y axis tic labels are taken from different columns
 than the x and y coordinate values. The z axis tics, however, are generated
 from the z coordinate of the corresponding point.
5 x2ticlabels
?using x2ticlabels
?plot using x2ticlabels
 See `plot using xticlabels`.
5 yticlabels
?using yticlabels
?plot using yticlabels
 See `plot using xticlabels`.
5 y2ticlabels
?using y2ticlabels
?plot using y2ticlabels
 See `plot using xticlabels`.
5 zticlabels
?using zticlabels
?plot using zticlabels
 See `plot using xticlabels`.
3 errorbars
?commands plot errorbars
?commands splot errorbars
?plot errorbars
?splot errorbars
?errorbars
 Error bars are supported for 2-d data file plots by reading one to four
 additional columns (or `using` entries); these additional values are used in
 different ways by the various errorbar styles.

 In the default situation, `gnuplot` expects to see three, four, or six
 numbers on each line of the data file---either

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta), or
       (x, y, xlow, xhigh, ylow, yhigh).

 The x coordinate must be specified.  The order of the numbers must be
 exactly as given above, though the `using` qualifier can manipulate the order
 and provide values for missing columns.  For example,

       plot 'file' with errorbars
       plot 'file' using 1:2:(sqrt($1)) with xerrorbars
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 The last example is for a file containing an unsupported combination of
 relative x and absolute y errors.  The `using` entry generates absolute x min
 and max from the relative error.

 The y error bar is a vertical line plotted from (x, ylow) to (x,
 yhigh). If ydelta is specified instead of ylow and yhigh, ylow = y -
 ydelta and yhigh = y + ydelta are derived. If there are only two
 numbers on the record, yhigh and ylow are both set to y. The x error
 bar is a horizontal line computed in the same fashion. To get lines
 plotted between the data points, `plot` the data file twice, once with
 errorbars and once with lines (but remember to use the `notitle`
 option on one to avoid two entries in the key). Alternately, use the
 errorlines command (see `errorlines`).

 The error bars have crossbars at each end unless `set bars` is used
 (see `set bars` for details).

 If autoscaling is on, the ranges will be adjusted to include the error bars.

 See also
^ <a href="http://gnuplot.sourceforge.net/demo/mgr.html">
 errorbar demos.
^ </a>

 See `plot using`, `plot with`, and `set style` for more information.
3 errorlines
?commands plot errorlines
?commands splot errorlines
?plot errorlines
?splot errorlines
?errorlines
 Lines with error bars are supported for 2-d data file plots by reading
 one to four additional columns (or `using` entries); these additional
 values are used in different ways by the various errorlines styles.

 In the default situation, `gnuplot` expects to see three, four, or six
 numbers on each line of the data file---either

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta), or
       (x, y, xlow, xhigh, ylow, yhigh).

 The x coordinate must be specified. The order of the numbers must be
 exactly as given above, though the `using` qualifier can manipulate
 the order and provide values for missing columns. For example,

       plot 'file' with errorlines
       plot 'file' using 1:2:(sqrt($1)) with xerrorlines
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 The last example is for a file containing an unsupported combination
 of relative x and absolute y errors. The `using` entry generates
 absolute x min and max from the relative error.

 The y error bar is a vertical line plotted from (x, ylow) to (x,
 yhigh). If ydelta is specified instead of ylow and yhigh, ylow = y -
 ydelta and yhigh = y + ydelta are derived. If there are only two
 numbers on the record, yhigh and ylow are both set to y. The x error
 bar is a horizontal line computed in the same fashion.

 The error bars have crossbars at each end unless `set bars` is used
 (see `set bars` for details).

 If autoscaling is on, the ranges will be adjusted to include the error bars.

 See `plot using`, `plot with`, and `set style` for more information.
3 parametric
?commands plot parametric
?commands splot parametric
?plot parametric
?splot parametric
 When in parametric mode (`set parametric`) mathematical expressions must be
 given in pairs for `plot` and in triplets for `splot`.

 Examples:
       plot sin(t),t**2
       splot cos(u)*cos(v),cos(u)*sin(v),sin(u)

 Data files are plotted as before, except any preceding parametric function
 must be fully specified before a data file is given as a plot.  In other
 words, the x parametric function (`sin(t)` above) and the y parametric
 function (`t**2` above) must not be interrupted with any modifiers or data
 functions; doing so will generate a syntax error stating that the parametric
 function is not fully specified.

 Other modifiers, such as `with` and `title`, may be specified only after the
 parametric function has been completed:

       plot sin(t),t**2 title 'Parametric example' with linespoints

 See also
^ <a href="http://www.gnuplot.info/demo/param.html">
 Parametric Mode Demos.
^ </a>
3 ranges
?commands plot ranges
?commands splot ranges
?plot ranges
?splot ranges
?ranges
 The optional ranges specify the region of the graph that will be displayed.

 Syntax:
       [{<dummy-var>=}{{<min>}:{<max>}}]
       [{{<min>}:{<max>}}]

 The first form applies to the independent variable (`xrange` or `trange`, if
 in parametric mode).  The second form applies to the dependent variable
 `yrange` (and `xrange`, too, if in parametric mode).  <dummy-var> is a new
 name for the independent variable.  (The defaults may be changed with `set
 dummy`.)  The optional <min> and <max> terms can be constant expressions or *.

 In non-parametric mode, the order in which ranges must be given is `xrange`
 and `yrange`.

 In parametric mode, the order for the `plot` command is `trange`, `xrange`,
 and `yrange`.  The following `plot` command shows setting the `trange` to
 [-pi:pi], the `xrange` to [-1.3:1.3] and the `yrange` to [-1:1] for the
 duration of the graph:

       plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2

 Note that the x2range and y2range cannot be specified here---`set x2range`
 and `set y2range` must be used.

 Ranges are interpreted in the order listed above for the appropriate mode.
 Once all those needed are specified, no further ones must be listed, but
 unneeded ones cannot be skipped---use an empty range `[]` as a placeholder.

 `*` can be used to allow autoscaling of either of min and max.  See also
 `set autoscale`.

 Ranges specified on the `plot` or `splot` command line affect only that
 graph; use the `set xrange`, `set yrange`, etc., commands to change the
 default ranges for future graphs.

 With time data, you must provide the range (in the same manner as the time
 appears in the datafile) within quotes.  `gnuplot` uses the `timefmt` string
 to read the value---see `set timefmt`.

 Examples:

 This uses the current ranges:
       plot cos(x)

 This sets the x range only:
       plot [-10:30] sin(pi*x)/(pi*x)

 This is the same, but uses t as the dummy-variable:
       plot [t = -10 :30]  sin(pi*t)/(pi*t)

 This sets both the x and y ranges:
       plot [-pi:pi] [-3:3]  tan(x), 1/x

 This sets only the y range, and turns off autoscaling on both axes:
       plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)

 This sets xmax and ymin only:
       plot [:200] [-pi:]  exp(sin(x))

 This sets the x range for a timeseries:
       set timefmt "%d/%m/%y %H:%M"
       plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'

3 iteration
?commands plot iteration
?commands splot iteration
?plot iteration
?splot iteration
?iteration
 If many similar files or functions are to be plotted together, it may be
 convenient to do so by iterating over a shared plot command.

 Syntax:
       plot for [<variable>=<start>:<end>{:<increment>}]
       splot for [<variable>=<start>:<end>{:<increment>}]

 Example:
       file(n) = sprintf("dataset_%d.dat",n)
       plot for [i=1:10] file(i) title sprintf("dataset %d",i)

 This example defines a string-valued function that generates file names,
 and plots ten such files together. The iteration variable ('i' in this
 example) is treated as an integer, and may be used more than once. In this
 example it is used both to generate a file name and a corresponding title.

 Example:
       list = "a b c foo baz"
       item(n) = word(list,n)
       plot for [i=1:words(list)] item[i].".dat" title item(i)
       list = "new stuff"
       replot

 This example steps through a list and plots once per item.
 Because the items are retrieved dynamically, you can change the list
 and then replot.

3 title
?commands plot title
?commands splot title
?plot title
?splot title
 A line title for each function and data set appears in the key, accompanied
 by a sample of the line and/or symbol used to represent it.  It can be
 changed by using the `title` option.

 Syntax:
       title "<title>" | notitle ["<ignored title>"]

 where <title> is the new title of the line and must be enclosed in quotes.
 The quotes will not be shown in the key.  A special character may be given as
 a backslash followed by its octal value ("\345").  The tab character "\t" is
 understood.  Note that backslash processing occurs only for strings enclosed
 in double quotes---use single quotes to prevent such processing.  The newline
 character "\n" is not processed in key entries in either type of string.

 The line title and sample can be omitted from the key by using the keyword
 `notitle`.  A null title (`title ''`) is equivalent to `notitle`.  If only
 the sample is wanted, use one or more blanks (`title ' '`).  If `notitle`
 is followed by a string this string is ignored.

 If `key autotitles` is set (which is the default) and neither `title` nor
 `notitle` are specified the line title is the function name or the file name as
 it appears on the `plot` command.  If it is a file name, any datafile modifiers
 specified will be included in the default title.

 The layout of the key itself (position, title justification, etc.) can be
 controlled by `set key`.  Please see `set key` for details.

 Examples:

 This plots y=x with the title 'x':
       plot x

 This plots x squared with title "x^2" and file "data.1" with title
 "measured data":
       plot x**2 title "x^2", 'data.1' t "measured data"

 This puts an untitled circular border around a polar graph:
       set polar; plot my_function(t), 1 notitle
3 with
?commands plot with
?commands splot with
?commands plot style
?commands splot style
?plot with
?plot style
?splot with
?splot style
?style
?with
 Functions and data may be displayed in one of a large number of styles.
 The `with` keyword provides the means of selection.

 Syntax:
       with <style> { {linestyle | ls <line_style>}
                      | {{linetype  | lt <line_type>}
                         {linewidth | lw <line_width>}
                         {linecolor | lc <colorspec>}
                         {pointtype | pt <point_type>}
                         {pointsize | ps <point_size>}
                         {fill | fs <fillstyle>}
                         {nohidden3d}
                         {palette}}
                    }

 where <style> is either `lines`, `points`, `linespoints`, `impulses`,
 `dots`, `steps`, `fsteps`, `histeps`, `errorbars`, `labels`, `xerrorbars`,
 `yerrorbars`, `xyerrorbars`, `errorlines`, `xerrorlines`, `yerrorlines`,
 `xyerrorlines`, `boxes`, `histograms`, `filledcurves`, `boxerrorbars`,
 `boxxyerrorbars`, `financebars`, `candlesticks`, `vectors`, `image`,
 `rgbimage` or `pm3d`. Some of these styles require additional information.
 See `plotting styles` for details of each style.  `fill` is relevant only
 to certain 2D plots (currently `boxes` `boxxyerrorbars` and `candlesticks`).
 Note that `filledcurves` and `pm3d` can take an additional option not
 listed above (the latter only when used in the `splot` command)---see
 their help or examples below for more details.

 Default styles are chosen with the `set style function` and `set style data`
 commands.

 By default, each function and data file will use a different line type and
 point type, up to the maximum number of available types.  All terminal
 drivers support at least six different point types, and re-use them, in
 order, if more are required.  The LaTeX driver supplies an additional six
 point types (all variants of a circle), and thus will only repeat after 12
 curves are plotted with points.  The PostScript drivers (`postscript`)
 supplies a total of 64.

 If you wish to choose the line or point type for a single plot, <line_type>
 and <point_type> may be specified.  These are positive integer constants (or
 expressions) that specify the line type and point type to be used for the
 plot.  Use `test` to display the types available for your terminal.

 You may also scale the line width and point size for a plot by using
 <line_width> and <point_size>, which are specified relative to the default
 values for each terminal.  The pointsize may also be altered
 globally---see `set pointsize` for details.  But note that both <point_size>
 as set here and  as set by `set pointsize` multiply the default point
 size---their effects are  not cumulative.  That is,
 `set pointsize 2; plot x w p ps 3` will use points three times default size,
 not six.

 It is also possible to specify `pointsize variable` either as part of a
 line style or for an individual plot. In this case one extra column of input
 is required, i.e. 3 columns for a 2D plot and 4 columns for a 3D splot. The
 size of each individual point is determined by multiplying the global
 pointsize by the value read from the data file.

 If you have defined specific line type/width and point type/size combinations
 with `set style line`, one of these may be selected by setting <line_style> to
 the index of the desired style.

 If gnuplot was built with `pm3d` support, the special keyword `palette` is
 allowed for smooth color change of lines, points and dots in `splots`. The
 color is chosen from a smooth palette which was set previously with the
 command `set palette`. The color value corresponds to the z-value of the
 point coordinates or to the color coordinate if specified by the 4th parameter
 in `using`. Both 2d and 3d plots (`plot` and `splot` commands) can use palette
 colors as specified by either their fractional value or the corresponding value
 mapped to the colorbox range. 2d plots can not use palette colors mapped by
 Z value. See `colors`, `set palette`, `linetype`.

 The keyword `nohidden3d` applies only to plots made with the `splot` command.
 Normally the global option `set hidden3d` applies to all plots in the graph.
 You can attach the `nohidden3d` option to any individual plots that you want
 to exclude from the hidden3d processing.  The individual elements other than
 surfaces (i.e. lines, dots, labels, ...) of a plot marked `nohidden3d` will all
 be drawn, even if they would normally be obscured by other plot elements.

 The keywords may be abbreviated as indicated.

 Note that the `linewidth`, `pointsize` and `palette` options are not supported
 by all terminals.

 Examples:

 This plots sin(x) with impulses:
       plot sin(x) with impulses

 This plots x with points, x**2 with the default:
       plot x w points, x**2

 This plots tan(x) with the default function style, file "data.1" with lines:
       plot [ ] [-2:5] tan(x), 'data.1' with l

 This plots "leastsq.dat" with impulses:
       plot 'leastsq.dat' w i

 This plots the data file "population" with boxes:
       plot 'population' with boxes

 This plots "exper.dat" with errorbars and lines connecting the points
 (errorbars require three or four columns):
       plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars

 Another way to plot "exper.dat" with errorlines (errorbars require three
 or four columns):
       plot 'exper.dat' w errorlines

 This plots sin(x) and cos(x) with linespoints, using the same line type but
 different point types:
       plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4

 This plots file "data" with points of type 3 and twice usual size:
       plot 'data' with points pointtype 3 pointsize 2

 This plots file "data" with variable pointsize read from column 4
       plot 'data' using 1:2:4 with points pt 5 pointsize variable

 This plots two data sets with lines differing only by weight:
       plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1

 This plots filled curve of x*x and a color stripe:
       plot x*x with filledcurve closed, 40 with filledcurve y1=10

 This plots x*x and a color box:
       plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y1=10 lt 8

 This plots a surface with color lines:
       splot x*x-y*y with line palette

 This plots two color surfaces at different altitudes:
       splot x*x-y*y with pm3d, x*x+y*y with pm3d at t

2 print
?commands print
?print
 The `print` command prints the value of <expression> to the screen.  It is
 synonymous with `pause 0`.  <expression> may be anything that `gnuplot` can
 evaluate that produces a number, or it can be a string.

 Syntax:
       print <expression> {, <expression>, ...}

 See `expressions`.  The output file can be set with `set print`.
2 pwd
?commands pwd
?pwd
 The `pwd` command prints the name of the working directory to the screen.
2 quit
?commands quit
?quit
 The `exit` and `quit` commands and END-OF-FILE character will exit `gnuplot`.
 Each of these commands will clear the output device (as does the `clear`
 command) before exiting.
2 raise
?commands raise
?raise
 Syntax:
       raise {plot_window_nb}

 The `raise` command raises (opposite to `lower`) plot window(s) associated
 with the interactive terminal of your gnuplot session, i.e. `pm`, `win`, `wxt`
 or `x11`. It puts the plot window to front (top) in the z-order windows stack
 of the window manager of your desktop.

 As `x11` and `wxt` support multiple plot windows, then by default they raise
 these windows in descending order of most recently created on top to the least
 recently created on bottom. If a plot number is supplied as an optional
 parameter, only the associated plot window will be raised if it exists.

 The optional parameter is ignored for single plot-windows terminal, i.e. `pm`
 and `win`.

  If the window is not raised under X11, then (1) they don't run in the same
  X11 session (telnet or ssh session, for example), or (2) raising is blocked
  by your window manager. On KDE, you may like to go to the KDE Control Center
  => Desktop => Window Behaviour => Advanced and set the "Focus stealing
  prevention level" to None (default is Low).
2 replot
?commands replot
?replot
 The `replot` command without arguments repeats the last `plot` or `splot`
 command.  This can be useful for viewing a plot with different `set` options,
 or when generating the same plot for several devices.

 Arguments specified after a `replot` command will be added onto the last
 `plot` or `splot` command (with an implied ',' separator) before it is
 repeated.  `replot` accepts the same arguments as the `plot` and `splot`
 commands except that ranges cannot be specified.  Thus you can use `replot`
 to plot a function against the second axes if the previous command was `plot`
 but not if it was `splot`.

 N.B.---use of

       plot '-' ; ... ; replot

 is not recommended.  `gnuplot` does not store the inline data internally, so
 since `replot` appends new information to the previous `plot` and then
 executes the modified command, the `'-'` from the initial `plot` will expect
 to read inline data again.

 Note that `replot` does not work in `multiplot` mode, since it reproduces
 only the last plot rather than the entire screen.

 See also `command-line-editing` for ways to edit the last `plot` (`splot`)
 command.

 See also `show plot` to show the whole current plotting command, and the
 possibility to copy it into the `history`.
2 reread
?commands reread
?reread
 The `reread` command causes the current `gnuplot` command file, as specified
 by a `load` command or on the command line, to be reset to its starting
 point before further commands are read from it.  This essentially implements
 an endless loop of the commands from the beginning of the command file to
 the `reread` command.  (But this is not necessarily a disaster---`reread` can
 be very useful when used in conjunction with `if`.  See `if` for details.)
 The `reread` command has no effect if input from standard input.

 Examples:

 Suppose the file "looper" contains the commands
       a=a+1
       plot sin(x*a)
       pause -1
       if(a<5) reread
 and from within `gnuplot` you submit the commands
       a=0
       load 'looper'
 The result will be four plots (separated by the `pause` message).

 Suppose the file "data" contains six columns of numbers with a total yrange
 from 0 to 10; the first is x and the next are five different functions of x.
 Suppose also that the file "plotter" contains the commands
       c_p = c_p+1
       plot "$0" using 1:c_p with lines linetype c_p
       if(c_p <  n_p) reread
 and from within `gnuplot` you submit the commands
       n_p=6
       c_p=1
       unset key
       set yrange [0:10]
       set multiplot
       call 'plotter' 'data'
       unset multiplot
 The result is a single graph consisting of five plots.  The yrange must be
 set explicitly to guarantee that the five separate graphs (drawn on top of
 each other in multiplot mode) will have exactly the same axes.  The linetype
 must be specified; otherwise all the plots would be drawn with the same type.
 See animate.dem in demo directory for an animated example.

2 reset
?commands reset
?reset
 The `reset` command causes all graph-related options that can be set with the
 `set` command to take on their default values.  This command is useful, e.g.,
 to restore the default graph settings at the end of a command file, or to
 return to a defined state after lots of settings have been changed within a
 command file.  Please refer to the `set` command to see the default values
 that the various options take.

 The following `set` commands do not change the graph status and are thus left
 unchanged: the terminal set with `set term`, the output file set with `set
 output` and directory paths set with `set loadpath` and `set fontpath`.
2 save
^ <a name="save set"></a>
?commands save
?save
 The `save` command saves user-defined functions, variables, the `set
 term` status, all `set` options, or all of these, plus the last `plot`
 (`splot`) command to the specified file.

 Syntax:
       save  {<option>} '<filename>'

 where <option> is `functions`, `variables`, `terminal` or `set`. If
 no option is used, `gnuplot` saves functions, variables, `set`
 options and the last `plot` (`splot`) command.

 `save`d files are written in text format and may be read by the
 `load` command. For `save` with the `set` option or without any
 option, the `terminal` choice and the `output` filename are written
 out as a comment, to get an output file that works in other
 installations of gnuplot, without changes and without risk of
 unwillingly overwriting files.

 `save terminal` will write out just the `terminal` status, without
 the comment marker in front of it. This is mainly useful for
 switching the `terminal` setting for a short while, and getting back
 to the previously set terminal, afterwards, by loading the saved
 `terminal` status. Note that for a single gnuplot session you may
 rather use the other method of saving and restoring current terminal
 by the commands `set term push` and `set term pop`, see `set term`.

 The filename must be enclosed in quotes.

 The special filename "-" may be used to `save` commands to standard output.
 On systems which support a popen function (Unix), the output of save can be
 piped through an external program by starting the file name with a '|'.
 This provides a consistent interface to `gnuplot`'s internal settings to
 programs which communicate with `gnuplot` through a pipe.  Please see
 help for `batch/interactive` for more details.

 Examples:
       save 'work.gnu'
       save functions 'func.dat'
       save var 'var.dat'
       save set 'options.dat'
       save term 'myterm.gnu'
       save '-'
       save '|grep title >t.gp'
2 set-show
?commands set
?commands show
?set
?show
?show all
 The `set` command can be used to set _lots_ of options.  No screen is
 drawn, however, until a `plot`, `splot`, or `replot` command is given.

 The `show` command shows their settings;  `show all` shows all the
 settings.

 Options changed using `set` can be returned to the default state by giving the
 corresponding `unset` command.  See also the `reset` command, which returns
 all settable parameters to default values.

 If a variable contains time/date data, `show` will display it according to
 the format currently defined by `set timefmt`, even if that was not in effect
 when the variable was initially defined.
3 angles
?commands set angles
?commands show angles
?set angles
?show angles
?angles
?commands set angles degrees
?set angles degrees
?angles degrees
?degrees
 By default, `gnuplot` assumes the independent variable in polar graphs is in
 units of radians.  If `set angles degrees` is specified before `set polar`,
 then the default range is [0:360] and the independent variable has units of
 degrees.  This is particularly useful for plots of data files.  The angle
 setting also applies to 3-d mapping as set via the `set mapping` command.

 Syntax:
       set angles {degrees | radians}
       show angles

 The angle specified in `set grid polar` is also read and displayed in the
 units specified by `set angles`.

 `set angles` also affects the arguments of the machine-defined functions
 sin(x), cos(x) and tan(x), and the outputs of asin(x), acos(x), atan(x),
 atan2(x), and arg(x).  It has no effect on the arguments of hyperbolic
 functions or Bessel functions.  However, the output arguments of inverse
 hyperbolic functions of complex arguments are affected; if these functions
 are used, `set angles radians` must be in effect to maintain consistency
 between input and output arguments.

       x={1.0,0.1}
       set angles radians
       y=sinh(x)
       print y         #prints {1.16933, 0.154051}
       print asinh(y)  #prints {1.0, 0.1}
 but
       set angles degrees
       y=sinh(x)
       print y         #prints {1.16933, 0.154051}
       print asinh(y)  #prints {57.29578, 5.729578}
 See also
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 poldat.dem: polar plot using `set angles` demo.
^ </a>
3 arrow
?commands set arrow
?commands unset arrow
?commands show arrow
?set arrow
?unset arrow
?show arrow
?arrow
?noarrow
 Arbitrary arrows can be placed on a plot using the `set arrow` command.

 Syntax:
       set arrow {<tag>} {from <position>} {to|rto <position>}
                 { {arrowstyle | as <arrow_style>}
                   | { {nohead | head | backhead | heads}
                       {size <length>,<angle>{,<backangle>}}
                       {filled | empty | nofilled}
                       {front | back}
                       { {linestyle | ls <line_style>}
                         | {linetype | lt <line_type>}
                           {linewidth | lw <line_width} } } }

       unset arrow {<tag>}
       show arrow {<tag>}

 <tag> is an integer that identifies the arrow.  If no tag is given, the
 lowest unused tag value is assigned automatically.  The tag can be used to
 delete or change a specific arrow.  To change any attribute of an existing
 arrow, use the `set arrow` command with the appropriate tag and specify the
 parts of the arrow to be changed.

 The <position>s are specified by either x,y or x,y,z, and may be preceded by
 `first`, `second`, `graph`, `screen`, or `character` to select the coordinate
 system.  Unspecified coordinates default to 0.  The end points can be
 specified in one of five coordinate systems---`first` or `second` axes,
 `graph`, `screen`, or `character`.  See `coordinates` for details.  A
 coordinate system specifier does not carry over from the "from" position to
 the "to" position.  Arrows outside the screen boundaries are permitted but
 may cause device errors.  If the end point is specified by "rto" instead of
 "to" it is drawn relatively to the start point.  For linear axes, `graph`
 and `screen` coordinates, the distance between the start and the end point
 corresponds to the given relative coordinate.  For logarithmic axes, the
 relative given coordinate corresponds to the factor of the coordinate
 between start and end point.  Thus, a negative relative value or zero are
 not allowed for logarithmic axes.

 Specifying `nohead` produces an arrow drawn without a head---a line segment.
 This gives you yet another way to draw a line segment on the plot.  By
 default, an arrow has a head at its end. Specifying `backhead` draws an arrow
 head at the start point of the arrow while `heads` draws arrow heads on both
 ends of the line.  Not all terminal types support double-ended arrows.

 Head size can be controlled by `size <length>,<angle>` or
 `size <length>,<angle>,<backangle>`, where `<length>` defines length of each
 branch of the arrow head and `<angle>` the angle (in degrees) they make with
 the arrow.  `<Length>` is in x-axis units; this can be changed by `first`,
 `second`, `graph`, `screen`, or `character` before the <length>;  see
 `coordinates` for details.  `<Backangle>` only takes effect when `filled`
 or `empty` is also used.  Then, `<backangle>` is the angle (in degrees) the
 back branches make with the arrow (in the same direction as `<angle>`).
 The `fig` terminal has a restricted backangle function. It supports three
 different angles. There are two thresholds: Below 70 degrees, the arrow head
 gets an indented back angle. Above 110 degrees, the arrow head has an acute
 back angle. Between these thresholds, the back line is straight.

 Specifying `filled` produces filled arrow heads (if heads are used).
 Filling is supported on filled-polygon capable terminals, see help of `pm3d`
 for their list, otherwise the arrow heads are closed but not filled.
 The same result (closed but not filled arrow head) is reached by specifying
 `empty`.  Further, filling and outline is obviously not supported on
 terminals drawing arrows by their own specific routines, like `metafont`,
 `metapost`, `latex` or `tgif`.

 The line style may be selected from a user-defined list of line styles
 (see `set style line`) or may be defined here by providing values for
 <line_type> (an index from the default list of styles) and/or <line_width>
 (which is a  multiplier for the default width).

 Note, however, that if a user-defined line style has been selected, its
 properties (type and width) cannot be altered merely by issuing another
 `set arrow` command with the appropriate index and `lt` or `lw`.

 If `front` is given, the arrow is written on top of the graphed data. If
 `back` is given (the default), the arrow is written underneath the graphed
 data.  Using `front` will prevent an arrow from being obscured by dense data.

 Examples:

 To set an arrow pointing from the origin to (1,2) with user-defined style 5,
 use:
       set arrow to 1,2 ls 5

 To set an arrow from bottom left of plotting area to (-5,5,3), and tag the
 arrow number 3, use:
       set arrow 3 from graph 0,0 to -5,5,3

 To change the preceding arrow to end at 1,1,1, without an arrow head and
 double its width, use:
       set arrow 3 to 1,1,1 nohead lw 2

 To draw a vertical line from the bottom to the top of the graph at x=3, use:
       set arrow from 3, graph 0 to 3, graph 1 nohead

 To draw a vertical arrow with T-shape ends, use:
       set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90

 To draw an arrow relatively to the start point, where the relative distances
 are given in graph coordinates, use:
       set arrow from 0,-5 rto graph 0.1,0.1

 To draw an arrow with relative end point in logarithmic x axis, use:
       set logscale x
       set arrow from 100,-5 rto 10,10
 This draws an arrow from 100,-5 to 1000,5. For the logarithmic x axis, the
 relative coordinate 10 means "factor 10" while for the linear y axis, the
 relative coordinate 10 means "difference 10".

 To delete arrow number 2, use:
       unset arrow 2

 To delete all arrows, use:
       unset arrow

 To show all arrows (in tag order), use:
       show arrow

^ <a href="http://gnuplot.sourceforge.net/demo/arrowstyle.html">
 arrows demos.
^ </a>

3 autoscale
?commands set autoscale
?commands unset autoscale
?commands show autoscale
?set autoscale
?unset autoscale
?show autoscale
?autoscale
?noautoscale
 Autoscaling may be set individually on the x, y or z axis or globally on all
 axes. The default is to autoscale all axes.

 Syntax:
       set autoscale {<axes>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
       unset autoscale {<axes>}
       show autoscale

 where <axes> is either `x`, `y`, `z`, `cb`, `x2`, `y2` or `xy`.  A keyword with
 `min` or `max` appended (this cannot be done with `xy`) tells `gnuplot` to
 autoscale just the minimum or maximum of that axis.  If no keyword is given,
 all axes are autoscaled.

 A keyword with `fixmin`, `fixmax` or `fix` appended tells gnuplot to disable
 extension of the axis range to the next tic mark position, for autoscaled
 axes using equidistant tics; `set autoscale fix` sets this for all axes.
 Command `set autoscale keepfix` autoscales all axes while keeping the fix
 settings.

 When autoscaling, the axis range is automatically computed and the dependent
 axis (y for a `plot` and z for `splot`) is scaled to include the range of the
 function or data being plotted.

 If autoscaling of the dependent axis (y or z) is not set, the current y or z
 range is used.

 Autoscaling the independent variables (x for `plot` and x,y for `splot`) is a
 request to set the domain to match any data file being plotted.  If there are
 no data files, autoscaling an independent variable has no effect.  In other
 words, in the absence of a data file, functions alone do not affect the x
 range (or the y range if plotting z = f(x,y)).

 Please see `set xrange` for additional information about ranges.

 The behavior of autoscaling remains consistent in parametric mode, (see
 `set parametric`).  However, there are more dependent variables and hence more
 control over x, y, and z axis scales.  In parametric mode, the independent or
 dummy variable is t for `plot`s and u,v for `splot`s.  `autoscale` in
 parametric mode, then, controls all ranges (t, u, v, x, y, and z) and allows
 x, y, and z to be fully autoscaled.

 Autoscaling works the same way for polar mode as it does for parametric mode
 for `plot`, with the extension that in polar mode `set dummy` can be used to
 change the independent variable from t (see `set dummy`).

 When tics are displayed on second axes but no plot has been specified for
 those axes, x2range and y2range are inherited from xrange and yrange.  This
 is done _before_ xrange and yrange are autoextended to a whole number of
 tics, which can cause unexpected results.  You can use the `fixmin`
 or `fixmax` options to avoid this.

 Examples:

 This sets autoscaling of the y axis (other axes are not affected):
       set autoscale y

 This sets autoscaling only for the minimum of the y axis (the maximum of the
 y axis and the other axes are not affected):
       set autoscale ymin

 This disables extension of the x2 axis tics to the next tic mark,
 thus keeping the exact range as found in the plotted data and functions:
       set autoscale x2fixmin
       set autoscale x2fixmax

 This sets autoscaling of the x and y axes:
       set autoscale xy

 This sets autoscaling of the x, y, z, x2 and y2 axes:
       set autoscale

 This disables autoscaling of the x, y, z, x2 and y2 axes:
       unset autoscale

 This disables autoscaling of the z axis only:
       unset autoscale z
4 parametric mode
?commands set autoscale parametric
?set autoscale parametric
?set autoscale t
 When in parametric mode (`set parametric`), the xrange is as fully scalable
 as the y range.  In other words, in parametric mode the x axis can be
 automatically scaled to fit the range of the parametric function that is
 being plotted.  Of course, the y axis can also be automatically scaled just
 as in the non-parametric case.  If autoscaling on the x axis is not set, the
 current x range is used.

 Data files are plotted the same in parametric and non-parametric mode.
 However, there is a difference in mixed function and data plots: in
 non-parametric mode with autoscaled x, the x range of the datafile controls
 the x range of the functions; in parametric mode it has no influence.

 For completeness a last command `set autoscale t` is accepted.  However, the
 effect of this "scaling" is very minor.  When `gnuplot` determines that the
 t range would be empty, it makes a small adjustment if autoscaling is true.
 Otherwise, `gnuplot` gives an error.  Such behavior may, in fact, not be very
 useful and the command `set autoscale t` is certainly questionable.

 `splot` extends the above ideas as you would expect.  If autoscaling is set,
 then x, y, and z ranges are computed and each axis scaled to fit the
 resulting data.
4 polar mode
?commands set autoscale polar
?set autoscale polar
 When in polar mode (`set polar`), the xrange and the yrange are both found
 from the polar coordinates, and thus they can both be automatically scaled.
 In other words, in polar mode both the x and y axes can be automatically
 scaled to fit the ranges of the polar function that is being plotted.

 When plotting functions in polar mode, the rrange may be autoscaled.  When
 plotting data files in polar mode, the trange may also be autoscaled.  Note
 that if the trange is contained within one quadrant, autoscaling will produce
 a polar plot of only that single quadrant.

 Explicitly setting one or two ranges but not others may lead to unexpected
 results.
 See also
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 polar demos.
^ </a>
3 bars
?commands set bars
?commands show bars
?set bars
?show bars
?bars
 The `set bars` command controls the tics at the ends of error bars,
 and also the width of the boxes in plot styles candlesticks and
 financebars.

 Syntax:
       set bars {small | large | fullwidth | <size>}
       unset bars
       show bars

 `small` is a synonym for 0.0, and `large` for 1.0.
 The default is 1.0 if no size is given.

 The keyword `fullwidth` is relevant only to histograms with errorbars.
 It sets the width of the errorbar ends to be the same as the width of the
 associated box in the histogram.  It does not change the width of the box
 itself.
3 bmargin
?commands set bmargin
?set bmargin
?bmargin
 The command `set bmargin` sets the size of the bottom margin.
 Please see `set margin` for details.
3 border
?commands set border
?commands unset border
?commands show border
?set border
?unset border
?show border
?border
?noborder
 The `set border` and `unset border` commands control the display of the graph
 borders for the `plot` and `splot` commands.  Note that the borders do not
 necessarily coincide with the axes; with `plot` they often do, but with
 `splot` they usually do not.

 Syntax:
       set border {<integer>} {front | back} {linewidth | lw <line_width>}
                  {{linestyle | ls <line_style>} | {linetype | lt <line_type>}}
       unset border
       show border

 With a `splot` displayed in an arbitrary orientation, like `set view 56,103`,
 the four corners of the x-y plane can be referred to as "front", "back",
 "left" and "right".  A similar set of four corners exist for the top surface,
 of course.  Thus the border connecting, say, the back and right corners of the
 x-y plane is the "bottom right back" border, and the border connecting the top
 and bottom front corners is the "front vertical".  (This nomenclature is
 defined solely to allow the reader to figure out the table that follows.)

 The borders are encoded in a 12-bit integer: the bottom four bits control the
 border for `plot` and the sides of the base for `splot`; the next four bits
 control the verticals in `splot`; the top four bits control the edges on top
 of the `splot`.  In detail, `<integer>` should be the sum of the appropriate
 entries from the following table:

@start table - first is interactive cleartext form
             Bit     plot        splot
               1   bottom      bottom left front
               2   left        bottom left back
               4   top         bottom right front
               8   right       bottom right back
              16   no effect   left vertical
              32   no effect   back vertical
              64   no effect   right vertical
             128   no effect   front vertical
             256   no effect   top left back
             512   no effect   top right back
            1024   no effect   top left front
            2048   no effect   top right front
#\begin{tabular}{|c|c|c|} \hline
#\multicolumn{3}{|c|}{Graph Border Encoding} \\ \hline \hline
#Bit & plot & splot \\ \hline
#1 & bottom & bottom left front \\
#2 & left & bottom left back \\
#4 & top & bottom right front \\
#8 & right & bottom right back \\
#16 & no effect & left vertical \\
#32 & no effect & back vertical \\
#64 & no effect & right vertical \\
#128 & no effect & front vertical \\
#256 & no effect & top left back \\
#512 & no effect & top right back \\
#1024 & no effect & top left front \\
#2048 & no effect & top right front \\
%c c c .
%Bit@plot@splot
%_
%1@bottom@bottom left front
%2@left@bottom left back
%4@top@bottom right front
%8@right@bottom right back
%16@no effect@left vertical
%32@no effect@back vertical
%64@no effect@right vertical
%128@no effect@front vertical
%256@no effect@top left back
%512@no effect@top right back
%1024@no effect@top left front
%2048@no effect@top right front
@end table

 Various bits or combinations of bits may be added together in the command.

 The default is 31, which is all four sides for `plot`, and base and z axis
 for `splot`.

 In 2D plots the border is normally drawn on top of all plots elements
 (`front`). If you want the border to be drawn behind the plot elements,
 use `set border back`.

 Using the optional <line_style>, <line_type> and <line_width> specifiers, the
 way the border lines are drawn can be influenced (limited by what the current
 terminal driver supports).

 For `plot`, tics may be drawn on edges other than bottom and left by enabling
 the second axes -- see `set xtics` for details.

 If a `splot` draws only on the base, as is the case with "`unset surface; set
 contour base`", then the verticals and the top are not drawn even if they are
 specified.

 The `set grid` options 'back', 'front' and 'layerdefault' also
 control the order in which the border lines are drawn with respect to
 the output of the plotted data.

 Examples:

 Draw default borders:
       set border

 Draw only the left and bottom (`plot`) or both front and back bottom left
 (`splot`) borders:
       set border 3

 Draw a complete box around a `splot`:
       set border 4095

 Draw a topless box around a `splot`, omitting the front vertical:
       set border 127+256+512 # or set border 1023-128

 Draw only the top and right borders for a `plot` and label them as axes:
       unset xtics; unset ytics; set x2tics; set y2tics; set border 12

3 boxwidth
?commands set boxwidth
?commands show boxwidth
?set boxwidth
?show boxwidth
?boxwidth
 The `set boxwidth` command is used to set the default width of boxes in the
 `boxes`, `boxerrorbars`, `candlesticks` and `histograms` styles.

 Syntax:
       set boxwidth {<width>} {absolute|relative}
       show boxwidth

 By default, adjacent boxes are extended in width until they touch each other.
 A different default width may be specified using the `set boxwidth` command.
 `Relative` widths are interpreted as being a fraction of this default width.

 An explicit value for the boxwidth is interpreted as being a number of units
 along the current x axis (`absolute`) unless the modifier `relative` is given.
 If the x axis is a log-scale (see `set log`) then the value of boxwidth is
 truly "absolute" only at x=1; this physical width is maintained everywhere
 along the axis (i.e. the boxes do not become narrower the value of x
 increases). If the range spanned by a log scale x axis is far from x=1,
 some experimentation may be required to find a useful value of boxwidth.

 The default is superseded by explicit width information taken from an extra
 data column in styles `boxes` or `boxerrorbars`.  In a four-column data set,
 the fourth column will be interpreted as the box width unless the width is set
 to -2.0, in which case the width will be calculated automatically.
 See `style boxes` and `style boxerrorbars` for more details.

 To set the box width to automatic use the command
       set boxwidth

 or, for four-column data,
       set boxwidth -2

 The same effect can be achieved with the `using` keyword in `plot`:
       plot 'file' using 1:2:3:4:(-2)

 To set the box width to half of the automatic size use
       set boxwidth 0.5 relative

 To set the box width to an absolute value of 2 use
       set boxwidth 2 absolute
3 clabel
?commands set clabel
?commands unset clabel
?commands show clabel
?set clabel
?unset clabel
?show clabel
?clabel
 `gnuplot` will vary the linetype used for each contour level when clabel is
 set.  When this option on (the default), a legend labels each linestyle with
 the z level it represents.  It is not possible at present to separate the
 contour labels from the surface key.

 Syntax:
       set clabel {'<format>'}
       unset clabel
       show clabel

 The default for the format string is %8.3g, which gives three decimal places.
 This may produce poor label alignment if the key is altered from its default
 configuration.

 The first contour linetype, or only contour linetype when clabel is off, is
 the surface linetype +1; contour points are the same style as surface points.

 See also `set contour`.
3 clip
?commands set clip
?commands unset clip
?commands show clip
?set clip
?unset clip
?show clip
?clip
?noclip
 `gnuplot` can clip data points and lines that are near the boundaries of a
 graph.

 Syntax:
       set clip <clip-type>
       unset clip <clip-type>
       show clip

 Three clip types for points and lines are supported by `gnuplot`: `points`,
 `one`, and `two`. One, two, or all three clip types may be active for a
 single graph.
 Note that clipping of color filled quadrangles drawn by `pm3d` maps and
 surfaces is not controlled by this command, but by `set pm3d clip1in` and
 `set pm3d clip4in`.

 The `points` clip type forces `gnuplot` to clip (actually, not plot at all)
 data points that fall within but too close to the boundaries.  This is done
 so that large symbols used for points will not extend outside the boundary
 lines.  Without clipping points near the boundaries, the plot may look bad.
 Adjusting the x and y ranges may give similar results.

 Setting the `one` clip type causes `gnuplot` to draw a line segment which has
 only one of its two endpoints within the graph.  Only the in-range portion of
 the line is drawn.  The alternative is to not draw any portion of the line
 segment.

 Some lines may have both endpoints out of range, but pass through the graph.
 Setting the `two` clip-type allows the visible portion of these lines to be
 drawn.

 In no case is a line drawn outside the graph.

 The defaults are `noclip points`, `clip one`, and `noclip two`.

 To check the state of all forms of clipping, use
       show clip

 For backward compatibility with older versions, the following forms are also
 permitted:
       set clip
       unset clip

 `set clip` is synonymous with `set clip points`; `unset clip` turns off all
 three types of clipping.
3 cntrparam
?commands set cntrparam
?commands show cntrparam
?set cntrparam
?show cntrparam
?cntrparam
 `set cntrparam` controls the generation of contours and their smoothness for
 a contour plot. `show contour` displays current settings of `cntrparam` as
 well as `contour`.

 Syntax:
       set cntrparam { { linear
                       | cubicspline
                       | bspline
                       | points <n>
                       | order <n>
                       | levels { auto {<n>} | <n>
                                  | discrete <z1> {,<z2>{,<z3>...}}
                                  | incremental <start>, <incr> {,<end>}
                                }
                       }
                     }
       show contour

 This command has two functions.  First, it sets the values of z for which
 contour points are to be determined (by linear interpolation between data
 points or function isosamples.)  Second, it controls the way contours are
 drawn between the points determined to be of equal z.  <n> should be an
 integral constant expression and <z1>, <z2> ... any constant expressions.
 The parameters are:

 `linear`, `cubicspline`, `bspline`---Controls type of approximation or
 interpolation.  If `linear`, then straight line segments connect points of
 equal z magnitude.  If `cubicspline`, then piecewise-linear contours are
 interpolated between the same equal z points to form somewhat smoother
 contours, but which may undulate.  If `bspline`, a guaranteed-smoother curve
 is drawn, which only approximates the position of the points of equal-z.

 `points`---Eventually all drawings are done with piecewise-linear strokes.
 This number controls the number of line segments used to approximate the
 `bspline` or `cubicspline` curve.  Number of cubicspline or bspline
 segments (strokes) = `points` * number of linear segments.

 `order`---Order of the bspline approximation to be used.  The bigger this
 order is, the smoother the resulting contour.  (Of course, higher order
 bspline curves will move further away from the original piecewise linear
 data.)  This option is relevant for `bspline` mode only.  Allowed values are
 integers in the range from 2 (linear) to 10.

 `levels`--- Selection of contour levels,  controlled by `auto` (default),
 `discrete`, `incremental`, and <n>, number of contour levels.

 For `auto`, <n> specifies a nominal number of levels; the actual number will
 be adjusted to give simple labels. If the surface is bounded by zmin and zmax,
 contours will be generated at integer multiples of dz between zmin and zmax,
 where dz is 1, 2, or 5 times some power of ten (like the step between two
 tic marks).

 For `levels discrete`, contours will be generated at z = <z1>, <z2> ... as
 specified; the number of discrete levels sets the number of contour levels.
 In `discrete` mode, any `set cntrparam levels <n>` are ignored.

 For `incremental`, contours are generated at values of z beginning at <start>
 and increasing by <increment>, until the number of contours is reached. <end>
 is used to determine the number of contour levels, which will be changed by
 any subsequent `set cntrparam levels <n>`.  If the z axis is logarithmic,
 <increment> will be interpreted as a factor, just like in `set ztics`.

 If the command `set cntrparam` is given without any arguments specified,  the
 defaults are used: linear, 5 points, order 4, 5 auto levels.

 Examples:
       set cntrparam bspline
       set cntrparam points 7
       set cntrparam order 10

 To select levels automatically, 5 if the level increment criteria are met:
       set cntrparam levels auto 5

 To specify discrete levels at .1, .37, and .9:
       set cntrparam levels discrete .1,1/exp(1),.9

 To specify levels from 0 to 4 with increment 1:
       set cntrparam levels incremental  0,1,4

 To set the number of levels to 10 (changing an incremental end or possibly
 the number of auto levels):
       set cntrparam levels 10

 To set the start and increment while retaining the number of levels:
       set cntrparam levels incremental 100,50

 See also `set contour` for control of where the contours are drawn, and
 `set clabel` for control of the format of the contour labels and linetypes.

 See also
^ <a href="http://www.gnuplot.info/demo/contours.html">
 contours demo (contours.dem)
^ </a>
 and
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 contours with user defined levels demo (discrete.dem).
^ </a>
3 color box
?commands set colorbox
?commands show colorbox
?commands unset colorbox
?set colorbox
?show colorbox
?unset colorbox
?colorbox

 The color scheme, i.e. the gradient of the smooth color with min_z and
 max_z values of `pm3d`'s `palette`, is drawn in a color box unless `unset
 colorbox`.

       set colorbox
       set colorbox {
                  { vertical | horizontal }
                  { default | user }
                  { origin x, y }
                  { size x, y }
                  { noborder | bdefault | border [line style] }
                }
       show colorbox
       unset colorbox

 Colorbox position can be `default` or `user`.  If the latter is specified the
 values as given with the `origin` and `size` subcommands are used.

 `vertical` and `horizontal` switches the orientation of the color
 gradient.

 `origin x, y` and `size x, y` are used only in combination with the `user`
 option. The x and y values are interpreted as screen coordinates by default,
 and this is the only legal option for 3D plots. 2D plots, including splot with
 `set view map`, allow any coordinate system to be specified.  Try for example:
     set colorbox horiz user origin .1,.02 size .8,.04
 which will draw a horizontal gradient somewhere at the bottom of the graph.

 `border` turns the border on (this is the default). `noborder` turns the border
 off. If an positive integer argument is given after `border`, it is used as a
 line style tag which is used for drawing the border, e.g.:
     set style line 2604 linetype -1 linewidth .4
     set colorbox border 2604
 will use line style `2604`, a thin line with the default border color (-1)
 for drawing the border. `bdefault` (which is the default) will use the default
 border line style for drawing the border of the color box.

 The axis of the color box is called `cb` and it is controlled by means of the
 usual axes commands, i.e. `set/unset/show` with `cbrange`, `[m]cbtics`,
 `format cb`, `grid [m]cb`, `cblabel`, and perhaps even `cbdata`, `[no]cbdtics`,
 `[no]cbmtics`.

 `set colorbox` without any parameter switches the position to default.
 `unset colorbox` resets the default parameters for the colorbox and switches
 the colorbox off.

 See also help for `set pm3d`, `set palette`, `x11 pm3d`, and `set style line`.

3 contour
?commands set contour
?commands unset contour
?commands show contour
?set contour
?unset contour
?show contour
?contour
?nocontour
 `set contour` enables contour drawing for surfaces.  This option is available
 for `splot` only.  It requires grid data, see `grid_data` for more details.
 If contours are desired from non-grid data, `set dgrid3d` can be used to
 create an appropriate grid.

 Syntax:
       set contour {base | surface | both}
       unset contour
       show contour

 The three options specify where to draw the contours: `base` draws the
 contours on the grid base where the x/ytics are placed, `surface` draws the
 contours on the surfaces themselves, and `both` draws the contours on both
 the base and the surface.  If no option is provided, the default is `base`.

 See also `set cntrparam` for the parameters that affect the drawing of
 contours, and `set clabel` for control of labelling of the contours.

 The surface can be switched off (see `set surface`), giving a contour-only
 graph.  Though it is possible to use `set size` to enlarge the plot to fill
 the screen, more control over the output format can be obtained by writing
 the contour information to a file, and rereading it as a 2-d datafile plot:

       unset surface
       set contour
       set cntrparam ...
       set table 'filename'
       splot ...
       unset table
       # contour info now in filename
       set term <whatever>
       plot 'filename'

 In order to draw contours, the data should be organized as "grid data".  In
 such a file all the points for a single y-isoline are listed, then all the
 points for the next y-isoline, and so on.  A single blank line (a line
 containing no characters other than blank spaces and a carriage return and/or
 a line feed) separates one y-isoline from the next.
 See also `splot datafile`.

 See also
^ <a href="http://www.gnuplot.info/demo/contours.html">
 contours demo (contours.dem)
^ </a>
 and
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 contours with user defined levels demo (discrete.dem).
^ </a>
3 data style
?DUMMYLABEL set style data
 This form of the command is deprecated. Please see `set style data`.
3 datafile
?set datafile
?show datafile
 The `set datafile` command options control interpretation of fields read from
 input data files by the `plot`, `splot`, and `fit` commands.  Four such
 options are currently implemented.
4 set datafile fortran
?set datafile fortran
?fortran
 The `set datafile fortran` command enables a special check for values in the
 input file expressed as Fortran D or Q constants. This extra check slows down
 the input process, and should only be selected if you do in fact have datafiles
 containing Fortran D or Q constants. The option can be disabled again using
 `unset datafile fortran`.
4 set datafile missing
?set datafile missing
?set missing
?missing
 The `set datafile missing` command allows you to tell `gnuplot` what character
 string is used in a data file to denote missing data.  Exactly how this missing
 value will be treated depends on the `using` specifier of the `plot` or `splot`
 command.

 Syntax:
       set datafile missing {"<string>"}
       show datafile missing
       unset datafile

 Example:
       # Ignore entries containing IEEE NaN ("Not a Number") code
       set datafile missing "NaN"

 Example:
       set datafile missing "?"
       set style data lines
       plot '-'
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:2
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:($2)
          1 10
          2 20
          3 ?
          4 40
          5 50
          e

 The first `plot` will recognize only the first datum in the "3 ?" line.  It
 will use the single-datum-on-a-line convention that the line number is "x"
 and the datum is "y", so the point will be plotted (in this case erroneously)
 at (2,3).

 The second `plot` will correctly ignore the middle line.  The plotted line
 will connect the points at (2,20) and (4,40).

 The third `plot` will also correctly ignore the middle line, but the plotted
 line will not connect the points at (2,20) and (4,40).

 There is no default character for `missing`, but in many cases any
 non-parsible string of characters found where a numerical value is expected
 will be treated as missing data.

4 set datafile separator
?set datafile separator
?separator
 The command `set datafile separator "<char>"` tells `gnuplot` that data fields
 in subsequent input files are separated by <char> rather than by whitespace.
 The most common use is to read in csv (comma-separated value) files written
 by spreadsheet or database programs. By default data fields are separated by
 whitespace.

 Syntax:
       set datafile separator {"<char>" | whitespace}

 Examples:
       # Input file contains tab-separated fields
       set datafile separator "\t"

       # Input file contains comma-separated values fields
       set datafile separator ","
4 set datafile commentschars
?set datafile commentschars
?commentschars
 The `set datafile commentschars` command allows you to tell `gnuplot` what
 characters are used in a data file to denote comments.  Gnuplot will ignore
 rest of the line behind the specified characters if either of them is the
 first non-blank character on the line.

 Syntax:
       set datafile commentschars {"<string>"}
       show datafile commentschars
       unset commentschars

 Default value of the string is "#!" on VMS and "#" otherwise.

 Then, the following line in a data file is completely ignored
     # 1 2 3 4
 but the following
     1 # 3 4
 produces rather unexpected plot unless
     set datafile missing '#'
 is specified as well.

 Example:
       set datafile commentschars "#!%"
4 set datafile binary
?set datafile binary
 The `set datafile binary` command is used to set the defaults when reading
 binary data files.  The syntax matches precisely that used for commands
 `plot` and `splot`.  See `binary` for details about <binary list>.

 Syntax:
       set datafile binary <binary list>
       show datafile binary
       show datafile
       unset datafile

 Examples:
       set datafile binary filetype=auto
       set datafile binary array=512x512 format="%uchar"
3 decimalsign
?commands set decimalsign
?commands show decimalsign
?commands unset decimalsign
?set decimalsign
?show decimalsign
?unset decimalsign
?decimalsign
=locale
 The `set decimalsign` command selects a decimal sign for numbers printed
 into tic labels or `set label` strings.

 Syntax:
       set decimalsign {<value> | locale {"<locale>"}}
       unset decimalsign
       show decimalsign

 The argument <value> is a string to be used in place of the usual
 decimal point. Typical choices include the period, '.', and the comma,
 ',', but others may be useful, too.  If you omit the <value> argument,
 the decimal separator is not modified from the usual default, which is
 a period.  Unsetting decimalsign has the same effect as omitting <value>.

 Example:

 Correct typesetting in most European countries requires:
       set decimalsign ','

 Please note: If you set an explicit string, this affects only numbers that
 are printed using gnuplot's gprintf() formatting routine, include axis tics.
 It does not affect the format expected for input data, and it does not affect
 numbers printed with the sprintf() formatting routine. To change the behavior
 of both input and output formatting, instead use the form

       set decimalsign locale

 This instructs the program to use both input and output formats in accordance
 with the current setting of the LC_ALL, LC_NUMERIC, or LANG environmental
 variables.

       set decimalsign locale "foo"

 This instructs the program to format all input and output in accordance with
 locale "foo", which must be installed.  If locale "foo" is not found then an
 error message is printed and the decimal sign setting is unchanged.
 On linux systems you can get a list of the locales installed on your machine by
 typing "locale -a". A typical linux locale string is of the form "sl_SI.UTF-8".
 A typical Windows locale string is of the form "Slovenian_Slovenia.1250" or
 "slovenian". Please note that interpretation of the locale settings is done by
 the C library at runtime. Older C libraries may offer only partial support for
 locale settings such as the thousands grouping separator character.

       set decimalsign locale; set decimalsign "."

 This sets all input and output to use whatever decimal sign is correct for
 the current locale, but over-rides this with an explicit '.' in numbers
 formatted using gnuplot's internal gprintf() function.
3 dgrid3d
?commands set dgrid3d
?commands unset dgrid3d
?commands show dgrid3d
?set dgrid3d
?unset dgrid3d
?show dgrid3d
?dgrid3d
?nodgrid3d
 The `set dgrid3d` command enables, and can set parameters for, non-grid to
 grid data mapping.  See `splot grid_data` for more details about the grid data
 structure.

 Syntax:
       set dgrid3d {<row_size>} {,{<col_size>} {,<norm>}}
       unset dgrid3d
       show dgrid3d

 By default `dgrid3d` is disabled.  When enabled, 3-d data read from a file
 are always treated as a scattered data set.  A grid with dimensions derived
 from a bounding box of the scattered data and size as specified by the
 row/col_size parameters is created for plotting and contouring.  The grid
 is equally spaced in x (rows) and in y (columns); the z values are computed
 as weighted averages of the scattered points' z values.

 The third parameter, norm, controls the weighting:  Each data point is
 weighted inversely by its distance from the grid point raised to the norm
 power.  (Actually, the weights are given by the inverse of dx^norm + dy^norm,
 where dx and dy are the components of the separation of the grid point from
 each data point.  For some norms that are powers of two, specifically 4, 8,
 and 16, the computation is optimized by using the Euclidean distance in the
 weight calculation, (dx^2+dy^2)^norm/2.  However, any non-negative integer
 can be used.)

 The closer the data point is to a grid point, the more effect it has on
 that grid point and the larger the value of norm the less effect more
 distant data points have on that grid point.

 The `dgrid3d` option is a simple low pass filter that converts scattered
 data to a grid data set.  More sophisticated approaches to this problem
 exist and should be used to preprocess the data outside `gnuplot` if this
 simple solution is found inadequate.

 (The z values are found by weighting all data points, not by interpolating
 between nearby data points;  also edge effects may produce unexpected and/or
 undesired results.  In some cases, small norm values produce a grid point
 reflecting the average of distant data points rather than a local average,
 while large values of norm may produce "steps" with several grid points
 having the same value as the closest data point, rather than making a smooth
 transition between adjacent data points.  Some areas of a grid may be filled
 by extrapolation, to an arbitrary boundary condition.  The variables are
 not normalized; consequently the units used for x and y will affect the
 relative weights of points in the x and y directions.)

 Examples:
       set dgrid3d 10,10,1     # defaults
       set dgrid3d ,,4

 The first specifies that a grid of size 10 by 10 is to be constructed using
 a norm value of 1 in the weight computation.  The second only modifies the
 norm, changing it to 4.
 See also
^ <a href="http://www.gnuplot.info/demo/scatter.html">
 scatter.dem: dgrid3d demo.
^ </a>

3 dummy
?commands set dummy
?commands show dummy
?set dummy
?show dummy
?dummy
 The `set dummy` command changes the default dummy variable names.

 Syntax:
       set dummy {<dummy-var>} {,<dummy-var>}
       show dummy

 By default, `gnuplot` assumes that the independent, or "dummy", variable for
 the `plot` command is "t" if in parametric or polar mode, or "x" otherwise.
 Similarly the independent variables for the `splot` command are "u" and "v"
 in parametric mode (`splot` cannot be used in polar mode), or "x" and "y"
 otherwise.

 It may be more convenient to call a dummy variable by a more physically
 meaningful or conventional name.  For example, when plotting time functions:

       set dummy t
       plot sin(t), cos(t)

 At least one dummy variable must be set on the command; `set dummy` by itself
 will generate an error message.

 Examples:
       set dummy u,v
       set dummy ,s

 The second example sets the second variable to s.
3 encoding
?commands set encoding
?commands show encoding
?set encoding
?show encoding
?encoding
?encodings
 The `set encoding` command selects a character encoding.
 Syntax:
       set encoding {<value>}
       show encoding

 Valid values are
    default     - tells a terminal to use its default encoding
    iso_8859_1  - the most common Western European font used by many
                  Unix workstations and by MS-Windows. This encoding is
                  known in the PostScript world as 'ISO-Latin1'.
    iso_8859_2  - used in Central and Eastern Europe
    iso_8859_15 - a variant of iso_8859_1 that includes the Euro symbol
    koi8r       - popular Unix cyrillic encoding
    koi8u       - ukrainian Unix cyrillic encoding
    cp437       - codepage for MS-DOS
    cp850       - codepage for OS/2, Western Europe
    cp852       - codepage for OS/2, Central and Eastern Europe
    cp1250      - codepage for MS Windows, Central and Eastern Europe

 Generally you must set the encoding before setting the terminal type.
 Note that encoding is not supported by all terminal drivers and that
 the device must be able to produce the desired non-standard characters.
 The PostScript, X11 and wxt terminals support all encodings. OS/2 Presentation
 Manager switches automatically to codepage 912 for `iso_8859_2`.
3 fit
?commands set fit
?commands show fit
?set fit
?show fit
 The `fit` setting defines where the `fit` command writes its output.
 If this option was built into your version of gnuplot, it also controls
 whether parameter errors from the fit will be written into variables.

 Syntax:
       set fit {logfile {"<filename>"}} {{no}errorvariables}
       unset fit
       show fit

 The <filename> argument must be enclosed in single or double quotes.

 If no filename is given or `unset fit` is used the log file is
 reset to its default value "fit.log" or the value of the environmental
 variable `FIT_LOG`.

 Users of DOS-like platforms should note that the \ character has
 special significance in double-quoted strings, so single-quotes
 should be used for filenames in different directories, or you have
 to write \\ for each \.  Or you can just use forward slashes,
 even though this is DOS.

 If the given logfile name ends with a / or \, it is interpreted to be
 a directory name, and the actual filename will be "fit.log" in that
 directory.

 If the `errorvariables` option is turned on, the error of each fitted
 parameter computed by `fit` will be copied to a user-defined variable
 whose name is formed by appending "_err" to the name of the parameter
 itself.  This is useful mainly to put the parameter and its error onto
 a plot of the data and the fitted function, for reference, as in:

        set fit errorvariables
        fit f(x) 'datafile' using 1:2 via a, b
        print "error of a is:", a_err
        set label 'a=%6.2f', a, '+/- %6.2f', a_err
        plot 'datafile' using 1:2, f(x)
3 fontpath
?commands set fontpath
?commands show fontpath
?set fontpath
?show fontpath
?fontpath
 The `fontpath` setting defines additional locations for font files
 searched when including font files. Currently only the postscript terminal
 supports `fontpath`. If a file cannot be found in the current directory,
 the directories in `fontpath` are tried. Further documentation concerning
 the supported file formats is included in the `terminal postscript` section
 of the documentation.

 Syntax:
       set fontpath {"pathlist1" {"pathlist2"...}}
       show fontpath

 Path names may be entered as single directory names, or as a list of
 path names separated by a platform-specific path separator, eg. colon
 (':') on Unix, semicolon (';') on DOS/Windows/OS/2/Amiga platforms.
 The `show fontpath`, `save` and `save set` commands replace the
 platform-specific separator with a space character (' ') for maximum
 portability. If a directory name ends with an exclamation mark ('!') also
 the subdirectories of this directory are searched for font files.

 If the environmental variable GNUPLOT_FONTPATH is set, its contents are
 appended to `fontpath`.  If it is not set, a system dependent default value
 is used. It is set by testing several directories for existence when using
 the fontpath the first time. Thus, the first call of `set fontpath`,
 `show fontpath`, `save fontpath`, `plot`, or `splot` with embedded font
 files takes a little more time. If you want to save this time you may
 set the environmental variable GNUPLOT_FONTPATH since probing is switched
 off, then. You can find out which is the default fontpath by using
 `show fontpath`.

 However, `show fontpath` prints the contents of user defined fontpath and
 system fontpath separately.  Also, the `save` and `save set` commands save
 only the user specified parts of `fontpath`, for portability reasons.

 Many other terminal drivers access TrueType fonts via the gd library.
 For these drivers the font search path is controlled by the environmental
 variable GDFONTPATH.
3 format
?commands set format
?commands show format
?set format
?show format
?format
?format cb
 The format of the tic-mark labels can be set with the `set format` command.

 Syntax:
       set format {<axes>} {"<format-string>"}
       set format {<axes>} {'<format-string>'}
       show format

 where <axes> is either `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb` or
 nothing (which refers to all axes at once).  The length of the string
 representing a tic mark (after formatting with 'printf') is restricted
 to 100 characters.  If the format string is omitted, the format will
 be returned to the default "% g".  For LaTeX users, the format "$%g$"
 is often desirable.  If the empty string "" is used, no label will be
 plotted with each tic, though the tic mark will still be plotted.  To
 eliminate all tic marks, use `unset xtics` or `unset ytics`.

 Newline (\n) is accepted in the format string.  Use double-quotes rather than
 single-quotes to enable such interpretation.  See also `syntax`.

 The default format for both axes is "% g", but other formats such as "%.2f" or
 "%3.0em" are often desirable.  Anything accepted by 'printf' when given a
 double precision number, and accepted by the terminal, will work.  Some other
 options have been added.  If the format string looks like a floating point
 format, then `gnuplot` tries to construct a reasonable format.

 Characters not preceded by "%" are printed verbatim.  Thus you can include
 spaces and labels in your format string, such as "%g m", which will put " m"
 after each number.  If you want "%" itself, double it: "%g %%".

 See also `set xtics` for more information about tic labels, and
 `set decimalsign` for how to use non-default decimal separators in numbers
 printed this way.
 See also
^ <a href="http://www.gnuplot.info/demo/electron.html">
 electron demo (electron.dem).
^ </a>
4 gprintf
?gprintf
 The string function gprintf("format",x) uses gnuplot's own format specifiers,
 as do the gnuplot commands `set format`, `set timestamp`, and others. These
 format specifiers are not the same as those used by the standard C-language
 routine sprintf(). Gnuplot also provides an sprintf("format",x,...) routine
 if you prefer. For a list of gnuplot's format options, see `format specifiers`.
4 format specifiers
?commands set format specifiers
?set format specifiers
?format specifiers
?format_specifiers
 The acceptable formats (if not in time/date mode) are:

@start table - first is interactive cleartext form
       Format       Explanation
       %f           floating point notation
       %e or %E     exponential notation; an "e" or "E" before the power
       %g or %G     the shorter of %e (or %E) and %f
       %x or %X     hex
       %o or %O     octal
       %t           mantissa to base 10
       %l           mantissa to base of current logscale
       %s           mantissa to base of current logscale; scientific power
       %T           power to base 10
       %L           power to base of current logscale
       %S           scientific power
       %c           character replacement for scientific power
       %P           multiple of pi
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{Tic-mark label numerical format specifiers}\\
#\hline \hline
#Format & Explanation \\ \hline
#\verb@%f@ & floating point notation \\
#\verb@%e@ or \verb@%E@ & exponential notation; an "e" or "E" before the power \\
#\verb@%g@ or \verb@%G@ & the shorter of \verb@%e@ (or \verb@%E@) and \verb@%f@ \\
#\verb@%x@ or \verb@%X@ & hex \\
#\verb@%o@ or \verb@%O@ & octal \\
#\verb@%t@ & mantissa to base 10 \\
#\verb@%l@ & mantissa to base of current logscale \\
#\verb@%s@ & mantissa to base of current logscale; scientific power \\
#\verb@%T@ & power to base 10 \\
#\verb@%L@ & power to base of current logscale \\
#\verb@%S@ & scientific power \\
#\verb@%c@ & character replacement for scientific power \\
#\verb@%P@ & multiple of pi \\
%c l .
%Format@Explanation
%_
%%f@floating point notation
%%e or %E@exponential notation; an "e" or "E" before the power
%%g or %G@the shorter of %e (or %E) and %f
%%x or %X@hex
%%o or %O@octal
%%t@mantissa to base 10
%%l@mantissa to base of current logscale
%%s@mantissa to base of current logscale; scientific power
%%T@power to base 10
%%L@power to base of current logscale
%%S@scientific power
%%c@character replacement for scientific power
%%P@multiple of pi
%_
@end table

 A 'scientific' power is one such that the exponent is a multiple of three.
 Character replacement of scientific powers (`"%c"`) has been implemented
 for powers in the range -18 to +18.  For numbers outside of this range the
 format reverts to exponential.

 Other acceptable modifiers (which come after the "%" but before the format
 specifier) are "-", which left-justifies the number; "+", which forces all
 numbers to be explicitly signed; " " (a space), which makes positive numbers
 have a space in front of them where negative numbers have "-";
 "#", which places a decimal point after
 floats that have only zeroes following the decimal point; a positive integer,
 which defines the field width; "0" (the digit, not the letter) immediately
 preceding the field width, which indicates that leading zeroes are to be used
 instead of leading blanks; and a decimal point followed by a non-negative
 integer, which defines the precision (the minimum number of digits of an
 integer, or the number of digits following the decimal point of a float).

 Some systems may not support all of these modifiers but may also support
 others; in case of doubt, check the appropriate documentation and
 then experiment.

 Examples:
       set format y "%t"; set ytics (5,10)          # "5.0" and "1.0"
       set format y "%s"; set ytics (500,1000)      # "500" and "1.0"
       set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
       set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
       set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
       set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
       set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
       set format y "%.0f%%"; set ytic(50)          # "50%"

       set log y 2; set format y '%l'; set ytics (1,2,3)
       #displays "1.0", "1.0" and "1.5" (since 3 is 1.5 * 2^1)

 There are some problem cases that arise when numbers like 9.999 are printed
 with a format that requires both rounding and a power.

 If the data type for the axis is time/date, the format string must contain
 valid codes for the 'strftime' function (outside of `gnuplot`, type "man
 strftime").  See `set timefmt` for a list of the allowed input format codes.
4 time/date specifiers
?commands set format date_specifiers
?commands set format time_specifiers
?set format date_specifiers
?set format time_specifiers
?set date_specifiers
?set time_specifiers
?date_specifiers
?time_specifiers
 In time/date mode, the acceptable formats are:

@start table - first is interactive cleartext form
       Format       Explanation
       %a           abbreviated name of day of the week
       %A           full name of day of the week
       %b or %h     abbreviated name of the month
       %B           full name of the month
       %d           day of the month, 1--31
       %D           shorthand for "%m/%d/%y"
       %k           hour, 0--23 (one or two digits)
       %H           hour, 00--23 (always two digits)
       *l           hour, 1--12 (one or two digits)
       %I           hour, 01--12 (always two digits)
       %j           day of the year, 1--366
       %m           month, 1--12
       %M           minute, 0--60
       %p           "am" or "pm"
       %r           shorthand for "%I:%M:%S %p"
       %R           shorthand for "%H:%M"
       %S           second, 0--60
       %T           shorthand for "%H:%M:%S"
       %U           week of the year (week starts on Sunday)
       %w           day of the week, 0--6 (Sunday = 0)
       %W           week of the year (week starts on Monday)
       %y           year, 0-99
       %Y           year, 4-digit
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{Tic-mark label Date/Time Format Specifiers}\\
#\hline \hline
#Format & Explanation \\ \hline
#\verb@%a@ & abbreviated name of day of the week \\
#\verb@%A@ & full name of day of the week \\
#\verb@%b@ or \verb@%h@ & abbreviated name of the month \\
#\verb@%B@ & full name of the month \\
#\verb@%d@ & day of the month, 1--31 \\
#\verb@%D@ & shorthand for \verb@"%m/%d/%y"@ \\
#\verb@%k@ & hour, 0--23 (one or two digits)\\
#\verb@%H@ & hour, 00--23 (always two digits)\\
#\verb@%l@ & hour, 1--12  (one or two digits)\\
#\verb@%I@ & hour, 01--12 (always two digits)\\
#\verb@%j@ & day of the year, 1--366 \\
#\verb@%m@ & month, 1--12 \\
#\verb@%M@ & minute, 0--60 \\
#\verb@%p@ & "am" or "pm" \\
#\verb@%r@ & shorthand for \verb@"%I:%M:%S %p"@ \\
#\verb@%R@ & shorthand for \verb@%H:%M"@ \\
#\verb@%S@ & second, 0--60 \\
#\verb@%T@ & shorthand for \verb@"%H:%M:%S"@ \\
#\verb@%U@ & week of the year (week starts on Sunday) \\
#\verb@%w@ & day of the week, 0--6 (Sunday = 0) \\
#\verb@%W@ & week of the year (week starts on Monday) \\
#\verb@%y@ & year, 0-99 \\
#\verb@%Y@ & year, 4-digit \\
%c l .
%Format@Explanation
%_
%%a@abbreviated name of day of the week
%%A@full name of day of the week
%%b or %h@abbreviated name of the month
%%B@full name of the month
%%d@day of the month, 1--31
%%D@shorthand for "%m/%d/%y"
%%k@hour, 0--23 (one or two digits)
%%H@hour, 00--23 (always two digits)
%%l@hour, 1--12 (one or two digits)
%%I@hour, 01--12 (always two digits)
%%j@day of the year, 1--366
%%m@month, 1--12
%%M@minute, 0--60
%%p@"am" or "pm"
%%r@shorthand for "%I:%M:%S %p"
%%R@shorthand for %H:%M"
%%S@second, 0--60
%%T@shorthand for "%H:%M:%S"
%%U@week of the year (week starts on Sunday)
%%w@day of the week, 0--6 (Sunday = 0)
%%W@week of the year (week starts on Monday)
%%y@year, 0-99
%%Y@year, 4-digit
%_
@end table

 Except for the non-numerical formats, these may be preceded by a "0" ("zero",
 not "oh") to pad the field length with leading zeroes, and a positive digit,
 to define the minimum field width (which will be overridden if the specified
 width is not large enough to contain the number).  There is a 24-character
 limit to the length of the printed text; longer strings will be truncated.

 Examples:

 Suppose the text is "76/12/25 23:11:11".  Then
       set format x                 # defaults to "12/25/76" \n "23:11"
       set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
       set format x "%r %D"         # "11:11:11 pm 12/25/76"

 Suppose the text is "98/07/06 05:04:03".  Then
       set format x "%1y/%2m/%3d %01H:%02M:%03S"  # "98/ 7/  6 5:04:003"
3 function style
 This form of the command is deprecated. Please see `set style function`.
3 functions
?commands show functions
?show functions
 The `show functions` command lists all user-defined functions and their
 definitions.

 Syntax:
       show functions

 For information about the definition and usage of functions in `gnuplot`,
 please see `expressions`.
 See also
^ <a href="http://www.gnuplot.info/demo/spline.html">
 splines as user defined functions (spline.dem)
^ </a>
 and
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 use of functions and complex variables for airfoils (airfoil.dem).
^ </a>
3 grid
?commands set grid
?commands unset grid
?commands show grid
?set grid
?unset grid
?show grid
?grid
?nogrid
 The `set grid` command allows grid lines to be drawn on the plot.

 Syntax:
       set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                {{no}{m}x2tics} {{no}{m}y2tics}
                {{no}{m}cbtics}
                {polar {<angle>}}
                {layerdefault | front | back}
                { {linestyle <major_linestyle>}
                  | {linetype | lt <major_linetype>}
                    {linewidth | lw <major_linewidth>}
                  { , {linestyle | ls <minor_linestyle>}
                      | {linetype | lt <minor_linetype>}
                        {linewidth | lw <minor_linewidth>} } }
       unset grid
       show grid

 The grid can be enabled and disabled for the major and/or minor tic
 marks on any axis, and the linetype and linewidth can be specified
 for major and minor grid lines, also via a predefined linestyle, as
 far as the active terminal driver supports this.

 Additionally, a polar grid can be selected for 2-d plots---circles are drawn
 to intersect the selected tics, and radial lines are drawn at definable
 intervals.  (The interval is given in degrees or radians, depending on the
 `set angles` setting.)  Note that a polar grid is no longer automatically
 generated in polar mode.

 The pertinent tics must be enabled before `set grid` can draw them; `gnuplot`
 will quietly ignore instructions to draw grid lines at non-existent tics, but
 they will appear if the tics are subsequently enabled.

 If no linetype is specified for the minor gridlines, the same linetype as the
 major gridlines is used.  The default polar angle is 30 degrees.

 If `front` is given, the grid is drawn on top of the graphed data. If
 `back` is given, the grid is drawn underneath the graphed data. Using
 `front` will prevent the grid from being obscured by dense data. The
 default setup, `layerdefault`, is equivalent to `back` for 2d plots.
 In 3D plots the default is to split up the grid and the graph box into
 two layers: one behind, the other in front of the plotted data and
 functions. Since `hidden3d` mode does its own sorting, it ignores
 all grid drawing order options and passes the grid lines through the
 hidden line removal machinery instead. These options actually affect
 not only the grid, but also the lines output by `set border` and the
 various ticmarks (see `set xtics`).

 Z grid lines are drawn on the bottom of the plot.  This looks better if a
 partial box is drawn around the plot---see `set border`.
3 hidden3d
?commands set hidden3d
?commands unset hidden3d
?commands show hidden3d
?set hidden3d
?unset hidden3d
?show hidden3d
?hidden3d
?nohidden3d
 The `set hidden3d` command enables hidden line removal for surface plotting
 (see `splot`).  Some optional features of the underlying algorithm can also
 be controlled using this command.

 Syntax:
       set hidden3d {defaults} |
                    { {{offset <offset>} | {nooffset}}
                      {trianglepattern <bitpattern>}
                      {{undefined <level>} | {noundefined}}
                      {{no}altdiagonal}
                      {{no}bentover} }
       unset hidden3d
       show hidden3d

 In contrast to the usual display in gnuplot, hidden line removal actually
 treats the given function or data grids as real surfaces that can't be seen
 through, so parts behind the surface will be hidden by it.  For this to be
 possible, the surface needs to have 'grid structure' (see `splot datafile`
 about this), and it has to be drawn `with lines` or `with linespoints`.

 When `hidden3d` is set, both the hidden portion of the surface and possibly
 its contours drawn on the base (see `set contour`) as well as the grid will
 be hidden.  Each surface has its hidden parts removed with respect to itself
 and to other surfaces, if more than one surface is plotted.  Contours drawn
 on the surface (`set contour surface`) don't work.

 Labels and arrows are always visible and are unaffected.  The key box is
 never hidden by the surface. As of gnuplot version 4.2, `set hidden3d` also
 affects 3D plotting styles `with points`, `with labels`, and `with vectors`,
 even if no surface is present in the graph.  Individual plots within the
 graph may be explicitly excluded from this processing by appending the extra
 option `nohidden3d` to the `with` specifier.

 Hidden3d does not affect solid surfaces drawn using the pm3d mode. To
 achieve a similar effect for pm3d surfaces, use instead set `pm3d depthorder`.

 Functions are evaluated at isoline intersections.  The algorithm interpolates
 linearly between function points or data points when determining the visible
 line segments.  This means that the appearance of a function may be different
 when plotted with `hidden3d` than when plotted with `nohidden3d` because in
 the latter case functions are evaluated at each sample.  Please see
 `set samples` and `set isosamples` for discussion of the difference.

 The algorithm used to remove the hidden parts of the surfaces has some
 additional features controllable by this command.  Specifying `defaults` will
 set them all to their default settings, as detailed below.  If `defaults` is
 not given, only explicitly specified options will be influenced: all others
 will keep their previous values, so you can turn on/off hidden line removal
 via `set {no}hidden3d`, without modifying the set of options you chose.

 The first option, `offset`, influences the linestyle used for lines on the
 'back' side.  Normally, they are drawn in a linestyle one index number higher
 than the one used for the front, to make the two sides of the surface
 distinguishable.  You can specify a different line style offset to add
 instead of the default 1, by `offset <offset>`.  Option `nooffset` stands for
 `offset 0`, making the two sides of the surface use the same linestyle.

 Next comes the option `trianglepattern <bitpattern>`.  <bitpattern> must be
 a number between 0 and 7, interpreted as a bit pattern.  Each bit determines
 the visibility of one edge of the triangles each surface is split up into.
 Bit 0 is for the 'horizontal' edges of the grid, Bit 1 for the 'vertical'
 ones, and Bit 2 for the diagonals that split each cell of the original grid
 into two triangles.  The default pattern is 3, making all horizontal and
 vertical lines visible, but not the diagonals.  You may want to choose 7 to
 see those diagonals as well.

 The `undefined <level>` option lets you decide what the algorithm is to do
 with data points that are undefined (missing data, or undefined function
 values), or exceed the given x-, y- or z-ranges.  Such points can either be
 plotted nevertheless, or taken out of the input data set.  All surface
 elements touching a point that is taken out will be taken out as well, thus
 creating a hole in the surface.  If <level> = 3, equivalent to option
 `noundefined`, no points will be thrown away at all.  This may produce all
 kinds of problems elsewhere, so you should avoid this.  <level> = 2 will
 throw away undefined points, but keep the out-of-range ones.  <level> = 1,
 the default, will get rid of out-of-range points as well.

 By specifying `noaltdiagonal`, you can override the default handling of a
 special case can occur if `undefined` is active (i.e. <level> is not 3).
 Each cell of the grid-structured input surface will be divided in two
 triangles along one of its diagonals.  Normally, all these diagonals have
 the same orientation relative to the grid.  If exactly one of the four cell
 corners is excluded by the `undefined` handler, and this is on the usual
 diagonal, both triangles will be excluded.  However if the default setting
 of `altdiagonal` is active, the other diagonal will be chosen for this cell
 instead, minimizing the size of the hole in the surface.

 The `bentover` option controls what happens to another special case, this
 time in conjunction with the `trianglepattern`.  For rather crumply surfaces,
 it can happen that the two triangles a surface cell is divided into are seen
 from opposite sides (i.e. the original quadrangle is 'bent over'), as
 illustrated in the following ASCII art:

                                                               C----B
     original quadrangle:  A--B      displayed quadrangle:     |\   |
       ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                           |/ |                                |  \ |
                           C--D                                |   \|
                                                               A    D

 If the diagonal edges of the surface cells aren't generally made visible by
 bit 2 of the <bitpattern> there, the edge CB above wouldn't be drawn at all,
 normally, making the resulting display hard to understand.  Therefore, the
 default option of `bentover` will turn it visible in this case.  If you don't
 want that, you may choose `nobentover` instead.
 See also
^ <a href="http://www.gnuplot.info/demo/hidden.html">
 hidden line removal demo (hidden.dem)
^ </a>
 and
^ <a href="http://www.gnuplot.info/demo/singulr.html">
 complex hidden line demo (singulr.dem).
^ </a>
3 historysize
?commands set historysize
?set historysize
?unset historysize
?historysize
?nohistorysize
 Note: the command `set historysize` is only available when
 gnuplot has been configured with the GNU readline.

 Syntax:
       set historysize <int>
       unset historysize

 When leaving gnuplot, the value of historysize is used for
 truncating the history to at most that much lines. The default
 is 500.
 `unset historysize` will disable history truncation and thus
 allow an infinite number of lines to be written to the history
 file.
3 isosamples
?commands set isosamples
?commands show isosamples
?set isosamples
?show isosamples
?isosamples
 The isoline density (grid) for plotting functions as surfaces may be changed
 by the `set isosamples` command.

 Syntax:
       set isosamples <iso_1> {,<iso_2>}
       show isosamples

 Each function surface plot will have <iso_1> iso-u lines and <iso_2> iso-v
 lines.  If you only specify <iso_1>, <iso_2> will be set to the same value
 as <iso_1>.  By default, sampling is set to 10 isolines per u or v axis.
 A higher sampling rate will produce more accurate plots, but will take longer.
 These parameters have no effect on data file plotting.

 An isoline is a curve parameterized by one of the surface parameters while
 the other surface parameter is fixed.  Isolines provide a simple means to
 display a surface.  By fixing the u parameter of surface s(u,v), the iso-u
 lines of the form c(v) = s(u0,v) are produced, and by fixing the v parameter,
 the iso-v lines of the form c(u) = s(u,v0) are produced.

 When a function surface plot is being done without the removal of hidden
 lines, `set samples`  controls the number of points sampled along each
 isoline;  see `set samples` and `set hidden3d`. The contour algorithm
 assumes that a function sample occurs at each isoline intersection, so
 change in `samples` as well as `isosamples` may be desired when changing
 the resolution of a function surface/contour.
3 key
?commands set key
?commands unset key
?commands show key
?set key
?unset key
?show key
?key
?nokey
?legend
 The `set key` command enables a key (or legend) describing plots on a plot.

 The contents of the key, i.e., the names given to each plotted data set and
 function and samples of the lines and/or symbols used to represent them, are
 determined by the `title` and `with` options of the {`s`}`plot` command.
 Please see `plot title` and `plot with` for more information.

 Syntax:
       set key {on|off} {default}
               {{inside | outside} | {lmargin | rmargin | tmargin | bmargin}
                 | {at <position>}}
               {left | right | center} {top | bottom | center}
               {vertical | horizontal} {Left | Right}
               {{no}reverse} {{no}invert}
               {samplen <sample_length>} {spacing <vertical_spacing>}
               {width <width_increment>}
               {height <height_increment>}
               {{no}autotitle {columnheader}}
               {title "<text>"} {{no}enhanced}
               {font "<face>,<size>"} {textcolor <colorspec>}
               {{no}box { {linestyle | ls <line_style>}
                          | {linetype | lt <line_type>}
                            {linewidth | lw <line_width>}}}
       unset key
       show key

 The key contains a title and a sample (line, point, box) for each plot
 in the graph. The key may be turned off by requesting `set key off` or
 `unset key`.  Individual key entries may be turned off by using the
 `notitle` keyword in the corresponding plot command.

 Elements within the key are stacked according to `vertical` or `horizontal`.
 In the case of `vertical`, the key occupies as few columns as possible.  That
 is, elements are aligned in a column until running out of vertical space at
 which point a new column is started.  In the case of `horizontal`, the key
 occupies as few rows as possible.

 By default the key is placed in the upper right inside corner of the graph.
 The keywords `left`, `right`, `top`, `bottom`, `center`, `inside`, `outside`,
 `lmargin`, `rmargin`, `tmargin`, `bmargin` (, `above`, `over`, `below` and
 `under`) may be used to automatically place the key in other positions of the
 graph.  Also an `at <position>` may be given to indicate precisely where the
 plot should be placed.  In this case, the keywords `left`, `right`, `top`,
 `bottom` and `center` serve an analogous purpose for alignment.
 For more information, see `key placement`.

 Justification of the plot titles within the key is controlled by `Left` or
 `Right` (default).  The text and sample can be reversed (`reverse`) and a
 box can be drawn around the key (`box {...}`) in a specified `linetype`
 and `linewidth`, or a user-defined `linestyle`. 

 By default the first plot label is at the top of the key and successive labels
 are entered below it. The `invert` option causes the first label to be placed
 at the bottom of the key, with successive labels entered above it. This option
 is useful to force the vertical ordering of labels in the key to match the
 order of box types in a stacked histogram.

 The <height_increment> is a number of character heights to be added to or
 subtracted from the height of the key box.  This is useful mainly when you are
 putting a box around the key, otherwise it can be used to adjust the vertical
 shift of automatically chosen key position by <height_increment>/2.

 All plotted curves of `plot`s and `splot`s are titled according to the
 default option `autotitles`. The automatic generation of titles can be
 suppressed by `noautotitles`; then only those titles explicitly defined
 by `(s)plot ... title ...` will be drawn.

 The `set key autotitle columnheader` command causes the first entry in each
 column of input data to be interpreted as a text string and used as a title for
 the corresponding plot. If the quantity being plotted is a function of data
 from several columns, gnuplot may be confused as to which column to draw the
 title from. In this case it is necessary to specify the column explicitly in
 the plot command, e.g. `plot "datafile" using (($2+$3)/$4) title 3 with lines`.

 An overall title can be put on the key (`title "<text>"`)---see also `syntax`
 for the distinction between text in single- or double-quotes.  The key title
 uses the same justification as do the plot titles.

 The defaults for `set key` are `on`, `right`, `top`, `vertical`, `Right`,
 `noreverse`, `noinvert`, `samplen 4`, `spacing 1.25`, `title ""`, and
 `nobox`.  The default <linetype> is the same as that used for the plot
 borders.  Entering `set key default` returns the key to its default
 configuration.

 The key is drawn as a sequence of lines, with one plot described on each
 line.  On the right-hand side (or the left-hand side, if `reverse` is
 selected) of each line is a representation that attempts to mimic the way the
 curve is plotted.  On the other side of each line is the text description
 (the line title), obtained from the `plot` command.  The lines are vertically
 arranged so that an imaginary straight line divides the left- and right-hand
 sides of the key.  It is the coordinates of the top of this line that are
 specified with the `set key` command.  In a `plot`, only the x and y
 coordinates are used to specify the line position.  For a `splot`, x, y and
 z are all used as a 3-d location mapped using the same mapping as the graph
 itself to form the required 2-d screen position of the imaginary line.

 When using the TeX or PostScript drivers, or similar drivers where formatting
 information is embedded in the string, `gnuplot` is unable to calculate
 correctly the width of the string for key positioning.  If the key is to be
 positioned at the left, it may be convenient to use the combination  `set key
 left Left reverse`.  The box and gap in the grid will be the width of the
 literal string.

 If `splot` is being used to draw contours, the contour labels will be listed
 in the key.  If the alignment of these labels is poor or a different number
 of decimal places is desired, the label format can be specified.  See
 `set clabel` for details.

 Examples:

 This places the key at the default location:
       set key default

 This disables the key:
       unset key

 This places a key at coordinates 2,3.5,2 in the default (first) coordinate
 system:
       set key at 2,3.5,2

 This places the key below the graph:
       set key below

 This places the key in the bottom left corner, left-justifies the text,
 gives it a title, and draws a box around it in linetype 3:
       set key left bottom Left title 'Legend' box 3
4 key placement
?commands set key placement
?set key placement
?key placement
 To understand positioning, the best concept is to think of a region, i.e.,
 inside/outside, or one of the margins.  Along with the region, keywords
 `left/center/right` (l/c/r) and `top/center/bottom` (t/c/b) control where
 within the particular region the key should be placed.

 When in `inside` mode, the keywords `left` (l), `right` (r), `top` (t),
 `bottom` (b), and `center` (c) push the key out toward the plot boundary as
 illustrated:

      t/l   t/c   t/r

      c/l    c    c/r

      b/l   b/c   b/r


 When in `outside` mode, automatic placement is similar to the above
 illustration, but with respect to the view, rather than the graph boundary.
 That is, a border is moved inward to make room for the key outside of
 the plotting area, although this may interfere with other labels and may
 cause an error on some devices.  The particular plot border that is moved
 depends upon the position described above and the stacking direction.  For
 options centered in one of the dimensions, there is no ambiguity about which
 border to move.  For the corners, when the stack direction is `vertical`, the
 left or right border is moved inward appropriately.  When the stack direction
 is `horizontal`, the top or bottom border is moved inward appropriately.

 The margin syntax allows automatic placement of key regardless of stack
 direction.  When one of the margins `lmargin` (lm), `rmargin` (rm),
 `tmargin` (tm), and `bmargin` (bm) is combined with a single, non-conflicting
 direction keyword, the following illustrated positions may contain the key:

           l/tm  c/tm  r/tm

      t/lm                  t/rm

      c/lm                  c/rm

      b/lm                  b/rm

           l/bm  c/bm  r/bm


 Keywords `above` and `over` are synonymous with `tmargin`.  For version
 compatibility, `above` or `over` without an additional l/c/r or stack direction
 keyword uses `center` and `horizontal`.  Keywords `below` and `under` are
 synonymous with `bmargin`.  For compatibility, `below` or `under` without an
 additional l/c/r or stack  direction keyword uses `center` and `horizontal`.  A
 further compatibility issue is that `outside` appearing without an additional
 t/b/c or stack direction keyword uses `top`, `right` and `vertical` (i.e., the
 same as t/rm above).

 The <position> can be a simple x,y,z as in previous versions, but these can
 be preceded by one of five keywords (`first`, `second`, `graph`, `screen`,
 `character`) which selects the coordinate system in which the position of
 the first sample line is specified.  See `coordinates` for more details.
 The effect of `left`, `right`, `top`, `bottom`, and `center` when <position>
 is given is to align the key as though it were text positioned using the
 label command, i.e., `left` means left align with key to the right of
 <position>, etc.
4 key samples
?commands set key samples
?set key samples
?key samples
 By default, each plot on the graph generates a corresponding entry in the
 key. This entry contains a plot title and a sample line/point/box of the
 same color and fill properties as used in the plot itself.  The font and
 textcolor properties control the appearance of the individual plot titles
 that appear in the key. Setting the textcolor to "rgb variable" causes
 the text for each key entry to be the same color as the line or fill 
 color for that plot.  This was the default in some earlier versions of
 gnuplot.

 The length of the sample line can be controlled by `samplen`.  The sample
 length is computed as the sum of the tic length and <sample_length> times the
 character width.  `samplen` also affects the positions of point samples in
 the key since these are drawn at the midpoint of the sample line, even if
 the sample line itself is not drawn.

 The vertical spacing between lines is controlled by `spacing`.  The spacing
 is set equal to the product of the pointsize, the vertical tic size, and
 <vertical_spacing>.  The program will guarantee that the vertical spacing is
 no smaller than the character height.

 The <width_increment> is a number of character widths to be added to or
 subtracted from the length of the string.  This is useful only when you are
 putting a box around the key and you are using control characters in the text.
 `gnuplot` simply counts the number of characters in the string when computing
 the box width; this allows you to correct it.
3 label
?commands set label
?commands unset label
?commands show label
?set label
?unset label
?show label
?label
?nolabel
 Arbitrary labels can be placed on the plot using the `set label` command.

 Syntax:
       set label {<tag>} {"<label text>"} {at <position>}
                 {left | center | right}
                 {norotate | rotate {by <degrees>}}
                 {font "<name>{,<size>}"}
                 {noenhanced}
                 {front | back}
                 {textcolor <colorspec>}
                 {point <pointstyle> | nopoint}
                 {offset <offset>}
       unset label {<tag>}
       show label

 The <position> is specified by either x,y or x,y,z, and may be preceded by
 `first`, `second`, `graph`, `screen`, or `character` to select the coordinate
 system.  See `coordinates` for details.

 The tag is an integer that is used to identify the label. If no <tag>
 is given, the lowest unused tag value is assigned automatically.  The
 tag can be used to delete or modify a specific label.  To change any
 attribute of an existing label, use the `set label` command with the
 appropriate tag, and specify the parts of the label to be changed.

 The <label text> can be a string constant, a string variable, or a string-
 valued expression. See `strings`, `sprintf`, and `gprintf`.

 By default, the text is placed flush left against the point x,y,z.  To adjust
 the way the label is positioned with respect to the point x,y,z, add the
 justification parameter, which may be `left`, `right` or `center`,
 indicating that the point is to be at the left, right or center of the text.
 Labels outside the plotted boundaries are permitted but may interfere with
 axis labels or other text.

 If `rotate` is given, the label is written vertically (if the terminal can do
 so, of course).  If `rotate by <degrees>` is given, conforming terminals will
 try to write the text at the specified angle; non-conforming terminals will
 treat this as vertical text.

 Font and its size can be chosen explicitly by `font "<name>{,<size>}"` if the
 terminal supports font settings.  Otherwise the default font of the terminal
 will be used.

 Normally the enhanced text mode string interpretation, if enabled for the
 current terminal, is applied to all text strings including label text.
 The `noenhanced` property can be used to exempt a specific label from the
 enhanced text mode processing.  The can be useful if the label contains
 underscores, for example. See `enhanced text`.

 If `front` is given, the label is written on top of the graphed data. If
 `back` is given (the default), the label is written underneath the graphed
 data.  Using `front` will prevent a label from being obscured by dense data.

 `textcolor <colorspec>` changes the color of the label text. <colorspec> can be
 a linetype, an rgb color, or a palette mapping. See help for `colorspec` and
 `palette`.  `textcolor` may be abbreviated `tc`.
    `tc default` resets the text color to its default state.
    `tc lt <n>` sets the text color to that of line type <n>.
    `tc ls <n>` sets the text color to that of line style <n>.
    `tc palette z` selects a palette color corresponding to the label z position.
    `tc palette cb <val>` selects a color corresponding to <val> on the colorbar.
    `tc palette fraction <val>`, with 0<=val<=1, selects a color corresponding to
        the mapping [0:1] to grays/colors of the `palette`.
    `tc rgb "#RRGGBB"` selects an arbitrary 24-bit RGB color.

 If a <pointstyle> is given, using keywords `lt`, `pt` and `ps`, see `style`,
 a point with the given style and color of the given line type is plotted at
 the label position and the text of the label is displaced slightly.
 This option is used by default for placing labels in `mouse` enhanced
 terminals.  Use `nopoint` to turn off the drawing of a point near
 the label (this is the default).

 The displacement defaults to 1,1 in `pointsize` units if a <pointstyle> is
 given, 0,0 if no <pointstyle> is given.  The displacement can be controlled
 by the optional `offset <offset>` where <offset> is specified by either x,y
 or x,y,z, and may be preceded by `first`, `second`, `graph`, `screen`, or
 `character` to select the coordinate system.  See `coordinates` for details.

 If one (or more) axis is timeseries, the appropriate coordinate should be
 given as a quoted time string according to the `timefmt` format string.
 See `set xdata` and `set timefmt`.

 The EEPIC, Imagen, LaTeX, and TPIC drivers allow \\ in a string to specify
 a newline.

 Examples:

 To set a label at (1,2) to "y=x", use:
       set label "y=x" at 1,2

 To set a Sigma of size 24, from the Symbol font set, at the center of
 the graph, use:
       set label "S" at graph 0.5,0.5 center font "Symbol,24"

 To set a label "y=x^2" with the right of the text at (2,3,4), and tag the
 label as number 3, use:
       set label 3 "y=x^2" at 2,3,4 right

 To change the preceding label to center justification, use:
       set label 3 center

 To delete label number 2, use:
       unset label 2

 To delete all labels, use:
       unset label

 To show all labels (in tag order), use:
       show label

 To set a label on a graph with a timeseries on the x axis, use, for example:
       set timefmt "%d/%m/%y,%H:%M"
       set label "Harvest" at "25/8/93",1

 To display a freshly fitted parameter on the plot with the data and the
 fitted function, do this after the `fit`, but before the `plot`:
       set label sprintf("a = %3.5g",par_a) at 30,15
       bfit = gprintf("b = %s*10^%S",par_b)
       set label bfit at 30,20

 To set a label displaced a little bit from a small point:
       set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1

 To set a label whose color matches the z value (in this case 5.5) of some
 point on a 3D splot colored using pm3d:
       set label 'text' at 0,0,5.5 tc palette z

3 lmargin
?commands set lmargin
?set lmargin
?lmargin
 The command `set lmargin` sets the size of the left margin.
 Please see `set margin` for details.
3 loadpath
?commands set loadpath
?commands show loadpath
?set loadpath
?show loadpath
?loadpath
 The `loadpath` setting defines additional locations for data and command
 files searched by the `call`, `load`, `plot` and `splot` commands.  If a
 file cannot be found in the current directory, the directories in
 `loadpath` are tried.

 Syntax:
       set loadpath {"pathlist1" {"pathlist2"...}}
       show loadpath

 Path names may be entered as single directory names, or as a list of
 path names separated by a platform-specific path separator, eg. colon
 (':') on Unix, semicolon (';') on DOS/Windows/OS/2/Amiga platforms.
 The `show loadpath`, `save` and `save set` commands replace the
 platform-specific separator with a space character (' ') for maximum
 portability.

 If the environment variable GNUPLOT_LIB is set, its contents are
 appended to `loadpath`.  However, `show loadpath` prints the contents
 of user defined loadpath and system loadpath separately.  Also, the
 `save` and `save set` commands save only the user specified parts of
 `loadpath`, for portability reasons.
3 locale
?commands set locale
?set locale
?locale
 The `locale` setting determines the language with which `{x,y,z}{d,m}tics`
 will write the days and months.

 Syntax:
       set locale {"<locale>"}

 <locale> may be any language designation acceptable to your installation.
 See your system documentation for the available options.  The default value
 is determined from the LC_TIME, LC_ALL, or LANG environment variables.

 To change the decimal point locale, see `set decimalsign`.
3 logscale
?commands set logscale
?commands unset logscale
?commands show logscale
?set logscale
?unset logscale
?show logscale
?set log
?logscale
?nologscale
 Syntax:
       set logscale <axes> <base>
       unset logscale <axes>
       show logscale

 where <axes> may be any combinations of `x`, `x2`, `y`, `y2`, `z`, and `cb` in
 any order, and where <base> is the base of the log scaling.  If <base> is not
 given, then 10 is assumed.  If <axes> is not given, then all axes are assumed.
 The command `unset logscale` turns off log scaling for the specified axes.

 Examples:

 To enable log scaling in both x and z axes:
       set logscale xz

 To enable scaling log base 2 of the y axis:
       set logscale y 2

 To enable z and color log axes for a pm3d plot:
       set logscale zcb

 To disable z axis log scaling:
       unset logscale z
3 macros
?commands set macros
?commands show macros
?set macros
?show macros
 If command line macro substitution is enabled, then tokens in the command line
 of the form @<stringvariablename> will be replaced by the text string contained
 in <stringvariablename>. See `substitution`.

 Syntax:
      set macros

3 mapping
?commands set mapping
?commands show mapping
?set mapping
?show mapping
?mapping
 If data are provided to `splot` in spherical or cylindrical coordinates,
 the `set mapping` command should be used to instruct `gnuplot` how to
 interpret them.

 Syntax:
       set mapping {cartesian | spherical | cylindrical}

 A cartesian coordinate system is used by default.

 For a spherical coordinate system, the data occupy two or three columns
 (or `using` entries).  The first two are interpreted as the azimuthal
 and polar angles theta and phi (or "longitude" and "latitude"), in the
 units specified by `set angles`.  The radius r is taken from the third
 column if there is one, or is set to unity if there is no third column.
 The mapping is:

       x = r * cos(theta) * cos(phi)
       y = r * sin(theta) * cos(phi)
       z = r * sin(phi)

 Note that this is a "geographic" spherical system, rather than a "polar"
 one (that is, phi is measured from the equator, rather than the pole).

 For a cylindrical coordinate system, the data again occupy two or three
 columns.  The first two are interpreted as theta (in the units specified by
 `set angles`) and z.  The radius is either taken from the third column or set
 to unity, as in the spherical case.  The mapping is:

       x = r * cos(theta)
       y = r * sin(theta)
       z = z

 The effects of `mapping` can be duplicated with the `using` filter on the
 `splot` command, but `mapping` may be more convenient if many data files are
 to be processed.  However even if `mapping` is used, `using` may still be
 necessary if the data in the file are not in the required order.

 `mapping` has no effect on `plot`.
^ See also
^ <a href="http://www.gnuplot.info/demo/world.html">
 world.dem: mapping demos.
^ </a>
3 margin
?commands set margin
?commands show margin
?set margin
?show margin
?margin
 The computed margins can be overridden by the `set margin` commands.  `show
 margin` shows the current settings.

 Syntax:
       set bmargin {{screen} <margin>}
       set lmargin {{screen} <margin>}
       set rmargin {{screen} <margin>}
       set tmargin {{screen} <margin>}
       show margin

 The default units of <margin> are character heights or widths, as appropriate.
 A positive value defines the absolute size of the margin.  A negative value
 (or none) causes `gnuplot` to revert to the computed value.  For 3D plots,
 only the left margin can be set using character units.

 The keyword `screen` indicates that the margin is specified as a fraction of
 the full drawing area. This can be used to precisely line up the corners of
 individual 2D and 3D graphs in a multiplot.

 Normally the margins of a plot are automatically calculated based on tics,
 tic labels, axis labels, the plot title, the timestamp and the size of the
 key if it is outside the borders.  If, however, tics are attached to the
 axes (`set xtics axis`, for example), neither the tics themselves nor their
 labels will be included in either the margin calculation or the calculation
 of the positions of other text to be written in the margin.  This can lead
 to tic labels overwriting other text if the axis is very close to the border.
3 mouse
?commands set mouse
?commands unset mouse
?set mouse
?unset mouse
?mouse
?nomouse
 The command `set mouse` enables mouse actions. Currently the pm, x11, ggi,
 windows and wxt terminals are mouse enhanced. There are two mouse modes. The
 2d-graph mode works for 2d graphs and for maps (i.e. splots with `set view`
 having z-rotation 0, 90, 180, 270 or 360 degrees, including `set view map`)
 and it allows tracing the position over graph, zooming, annotating graph etc.
 For 3d graphs `splot`, the view and scaling of the graph can be changed with
 mouse buttons 1 and 2. If additionally to these buttons the modifier <ctrl> is
 hold down, the coordinate system only is rotated which is useful for large
 data sets. A vertical motion of Button 2 with the shift key hold down changes
 the `ticslevel`.

 Mousing is not available in multiplot mode. When multiplot is finished using
 `unset multiplot`, then the mouse will be turned on again and acts on the
 last plot (like replot does).

 Syntax:
       set mouse {doubleclick <ms>} {nodoubleclick} \
                 {{no}zoomcoordinates} \
                 {noruler | ruler {at x,y}} \
                 {polardistance{deg|tan} | nopolardistance} \
                 {format <string>} \
                 {clipboardformat <int>/<string>} \
                 {mouseformat <int>/<string>} \
                 {{no}labels} {labeloptions <string>} \
                 {{no}zoomjump} {{no}verbose}
       unset mouse

 The doubleclick resolution is given in milliseconds and used for Button 1
 which copies the current mouse position to the `clipboard`. If you want that
 to be done by single clicking a value of 0 ms can be used. The default value
 is 300 ms.

 The option `zoomcoordinates` determines if the coordinates of the zoom box are
 drawn at the edges while zooming. This is on by default.

 The options `noruler` and `ruler` switch the ruler off and on, the latter
 optionally at given `coordinates`. This corresponds to the default key binding
 'r'.

 The option `polardistance` determines if the distance between the mouse cursor
 and the ruler is also shown in polar coordinates (distance and angle in
 degrees or tangent (slope)). This corresponds to the default key binding '5'.

 The `format` option takes a fprintf like format string which determines how
 floating point numbers are printed to the drivers window and the clipboard.
 The default is "% #g".

 `clipboardformat` and `mouseformat` are used for formatting the text on
 Button1 and Button2 actions -- copying the coordinates to the clipboard and
 temporarily annotating the mouse position. This corresponds to the key
 bindings '1', '2', '3', '4' (see the drivers's help window). If the argument
 is a string this string is used as c format specifier and should contain two
 float specifiers, e.g. `set mouse mouseformat "mouse = %5.2g, %10.2f"`. Use
 `set mouse mouseformat ""` to turn this string off again.

 The following formats are available (format 6 may only be selected if the
 format string was specified already):

  0   real coordinates in  brackets e.g. [1.23, 2.45]
  1   real coordinates w/o brackets e.g.  1.23, 2.45
  2   x == timefmt                       [(as set by `set timefmt`), 2.45]
  3   x == date                          [31. 12. 1999, 2.45]
  4   x == time                          [23:59, 2.45]
  5   x == date / time                   [31. 12. 1999 23:59, 2.45]
  6   alt. format, specified as string   ""

 Choose the option `labels` to get real gnuplot labels on Button 2. (The
 default is `nolabels` which makes Button 2 drawing only temporary annotations
 at the mouse positions). The labels are drawn with the current setting of
 `mouseformat`. `labeloptions` controls which options are passed to the
 `set label` command. The default is "pointstyle 1" which will plot a small
 plus at the label position.  Note that the pointsize is taken from the
 `set pointsize` command.
 Labels can be removed by holding the Ctrl-Key down while clicking with
 Button 2 on the label's point. The threshold for how close you must be to the
 label is also determined by the `pointsize`.

 If the option `zoomjump` is on, the mouse pointer will be automatically
 offset a small distance after starting a zoom region with button 3. This can
 be useful to avoid a tiny (or even empty) zoom region. `zoomjump` is off by
 default.

 If the option `verbose` is turned on the communication commands are shown
 during execution. This option can also be toggled by hitting `6` in the
 driver's window. `verbose` is off by default.

 Press 'h' in the driver's window for a short summary of the mouse and key
 bindings.  This will also display user defined bindings or `hotkeys` which
 can be defined using the `bind` command, see help for `bind`.  Note, that user
 defined `hotkeys` may override the default bindings.

 Press 'q' in the driver's window to close the window. This key cannot be
 overridden with the `bind` command.

 See also help for `bind` and `label`.
4 X11 mouse
?mouse x11_mouse
?x11_mouse
?x11 mouse
 If multiple X11 plot windows have been opened using the `set term x11 <n>`
 terminal option, then only the current plot window supports the entire
 range of mouse commands and hotkeys.  The other windows will, however,
 continue to display mouse coordinates at the lower left.

 For consistency with other screen terminals, X11 mouse support is turned on by
 default, wherever the standard input comes from. However, on some UNIX
 flavors, special input devices as /dev/null might not be `select-able`; using
 such devices with the mouse turned on will hang gnuplot. Please turn off
 mousing with `unset mouse` if you are in this situation.
3 multiplot
?commands set multiplot
?commands unset multiplot
?set multiplot
?unset multiplot
?multiplot
?nomultiplot
 The command `set multiplot` places `gnuplot` in the multiplot mode, in which
 several plots are placed on the same page, window, or screen.

 Syntax:
       set multiplot { layout <rows>,<cols>
                       {rowsfirst|columnsfirst} {downwards|upwards}
                       {title <page title>}
                       {scale <xscale>{,<yscale>}} {offset <xoff>{,<yoff>}}
                     }
       unset multiplot

 For some terminals, no plot is displayed until the command `unset multiplot`
 is given, which causes the entire page to be drawn and then returns gnuplot
 to its normal single-plot mode.  For other terminals, each separate `plot`
 command produces an updated display, either by redrawing all previous ones
 and the newly added plot, or by just adding the new plot to the existing
 display.

 The area to be used by the next plot is not erased before doing the
 new plot.  The `clear` command can be used to do this if wanted, as is
 typically the case for "inset" plots.

 Any labels or arrows that have been defined will be drawn for each plot
 according to the current size and origin (unless their coordinates are
 defined in the `screen` system).  Just about everything else that can be
 `set` is applied to each plot, too.  If you want something to appear only
 once on the page, for instance a single time stamp, you'll need to put a `set
 time`/`unset time` pair around one of the `plot`, `splot` or `replot`
 commands within the `set multiplot`/`unset multiplot` block.

 The multiplot title is separate from the individual plot titles, if any.
 Space is reserved for it at the top of the page, spanning the full width
 of the canvas.

 The commands `set origin` and `set size` must be used to correctly position
 each plot if no layout is specified or if fine tuning is desired.  See
 `set origin` and `set size` for details of their usage.

 Example:
       set multiplot
       set size 0.4,0.4
       set origin 0.1,0.1
       plot sin(x)
       set size 0.2,0.2
       set origin 0.5,0.5
       plot cos(x)
       unset multiplot

 This displays a plot of cos(x) stacked above a plot of sin(x).

 `set size` and `set origin` refer to the entire plotting area used for each
 plot.  Please also see `set term size`.  If you want to have the axes
 themselves line up, you can guarantee that the margins are the same size with
 the `set margin` commands.  See `set margin` for their use.  Note that the
 margin settings are absolute, in character units, so the appearance of the
 graph in the remaining space will depend on the screen size of the display
 device, e.g., perhaps quite different on a video display and a printer.

 With the `layout` option you can generate simple multiplots without having
 to give the `set size` and `set origin` commands before each plot:  Those
 are generated automatically, but can be overridden at any time.  With
 `layout` the display will be divided by a grid with <rows> rows and
 <cols> columns.  This grid is filled rows first or columns first depending on
 whether the corresponding option is given in the multiplot command.  The stack
 of plots can grow `downwards` or `upwards`.
 Default is `rowsfirst` and `downwards`.

 Each plot can be scaled by `scale` and shifted with `offset`; if the y-values
 for scale or offset are omitted, the x-value will be used.  `unset multiplot`
 will turn off the automatic layout and restore the values of `set size` and
 `set origin` as they were before `set multiplot layout`.

 Example:
       set size 1,1
       set origin 0,0
       set multiplot layout 3,2 columnsfirst scale 1.1,0.9
       [ up to 6 plot commands here ]
       unset multiplot

 The above example will produce 6 plots in 2 columns filled top to bottom,
 left to right.  Each plot will have a horizontal size of 1.1/2 and a vertical
 size of 0.9/3.

 See also
^ <a href="http://gnuplot.sourceforge.net/demo/multiplt.html">
 multiplot demo (multiplt.dem)
^ </a>
3 mx2tics
?commands set mx2tics
?commands unset mx2tics
?commands show mx2tics
?set mx2tics
?unset mx2tics
?show mx2tics
?mx2tics
?nomx2tics
 Minor tic marks along the x2 (top) axis are controlled by `set mx2tics`.
 Please see `set mxtics`.
3 mxtics
?commands set mxtics
?commands unset mxtics
?commands show mxtics
?set mxtics
?unset mxtics
?show mxtics
?mxtics
?nomxtics
 Minor tic marks along the x axis are controlled by `set mxtics`.  They can be
 turned off with `unset mxtics`.  Similar commands control minor tics along
 the other axes.

 Syntax:
       set mxtics {<freq> | default}
       unset mxtics
       show mxtics

 The same syntax applies to `mytics`, `mztics`, `mx2tics`, `my2tics` and
 `mcbtics`.

 <freq> is the number of sub-intervals (NOT the number of minor tics) between
 major tics (the default for a linear axis is either two or five
 depending on the major tics, so there are one or four minor
 tics between major tics). Selecting `default` will return the number of minor
 ticks to its default value.

 If the axis is logarithmic, the number of sub-intervals will be set to a
 reasonable number by default (based upon the length of a decade).  This will
 be overridden if <freq> is given.  However the usual minor tics (2, 3, ...,
 8, 9 between 1 and 10, for example) are obtained by setting <freq> to 10,
 even though there are but nine sub-intervals.

 To set minor tics at arbitrary positions, use the ("<label>" <pos> <level>,
 ...) form of `set {x|x2|y|y2|z}tics` with <label> empty and <level> set to 1.

 The `set m{x|x2|y|y2|z}tics` commands work only when there are uniformly
 spaced major tics.  If all major tics were placed explicitly by
 `set {x|x2|y|y2|z}tics`, then minor tic commands are ignored.  Implicit
 major tics and explicit minor tics can be combined using
 `set {x|x2|y|y2|z}tics` and `set {x|x2|y|y2|z}tics add`.

 Examples:
       set xtics 0, 5, 10
       set xtics add (7.5)
       set mxtics 5
 Major tics at 0,5,7.5,10, minor tics at 1,2,3,4,6,7,8,9
       set logscale y
       set format y ""
       set ytics 1e-6, 10, 1
       set ytics add ("1" 1, ".1" 0.1, ".01" 0.01, "10^-3" 0.001, \
                      "10^-4" 0.0001)
       set mytics 10
 Major tics with special formatting, minor tics at log positions

 By default, minor tics are off for linear axes and on for logarithmic axes.
 They inherit the settings for `axis|border` and `{no}mirror` specified for
 the major tics.  Please see `set xtics` for information about these.
3 my2tics
?commands set my2tics
?commands unset my2tics
?commands show my2tics
?set my2tics
?unset my2tics
?show my2tics
?my2tics
?nomy2tics
 Minor tic marks along the y2 (right-hand) axis are controlled by `set
 my2tics`.  Please see `set mxtics`.
3 mytics
?commands set mytics
?commands unset mytics
?commands show mytics
?set mytics
?unset mytics
?show mytics
?mytics
?nomytics
 Minor tic marks along the y axis are controlled by `set mytics`.  Please
 see `set mxtics`.
3 mztics
?commands set mztics
?commands unset mztics
?commands show mztics
?set mztics
?unset mztics
?show mztics
?mztics
?nomztics
 Minor tic marks along the z axis are controlled by `set mztics`.  Please
 see `set mxtics`.
3 offsets
?commands set offsets
?commands unset offsets
?commands show offsets
?set offsets
?unset offsets
?show offsets
?offsets
?nooffsets
 Offsets provide a mechanism to put a boundary around the data inside of an
 autoscaled graph.

 Syntax:
       set offsets <left>, <right>, <top>, <bottom>
       unset offsets
       show offsets

 Each offset may be a constant or an expression.  Each defaults to 0.  Left
 and right offsets are given in units of the x axis, top and bottom offsets in
 units of the y axis.  A positive offset expands the graph in the specified
 direction, e.g., a positive bottom offset makes ymin more negative.  Negative
 offsets, while permitted, can have unexpected interactions with autoscaling
 and clipping.

 Offsets are ignored in `splot`s.

 Example:
       set offsets 0, 0, 2, 2
       plot sin(x)

 This graph of sin(x) will have a y range [-3:3] because the function
 will be autoscaled to [-1:1] and the vertical offsets are each two.
3 origin
?commands set origin
?commands show origin
?set origin
?show origin
?origin
 The `set origin` command is used to specify the origin of a plotting surface
 (i.e., the graph and its margins) on the screen.  The coordinates are given
 in the `screen` coordinate system (see `coordinates` for information about
 this system).

 Syntax:
       set origin <x-origin>,<y-origin>
3 output
?commands set output
?commands show output
?set output
?show output
?output
?output file
 By default, screens are displayed to the standard output. The `set output`
 command redirects the display to the specified file or device.

 Syntax:
       set output {"<filename>"}
       show output

 The filename must be enclosed in quotes.  If the filename is omitted, any
 output file opened by a previous invocation of `set output` will be closed
 and new output will be sent to STDOUT.  (If you give the command `set output
 "STDOUT"`, your output may be sent to a file named "STDOUT"!  ["May be", not
 "will be", because some terminals, like `x11` or `wxt`, ignore `set output`.])

 MSDOS users should note that the \ character has special significance in
 double-quoted strings, so single-quotes should be used for filenames in
 different directories.

 When both `set terminal` and `set output` are used together, it is safest to
 give `set terminal` first, because some terminals set a flag which is needed
 in some operating systems.  This would be the case, for example, if the
 operating system needs to know whether or not a file is to be formatted in
 order to open it properly.

 On machines with popen functions (Unix), output can be piped through a shell
 command if the first non-whitespace character of the filename is '|'.
 For instance,

       set output "|lpr -Plaser filename"
       set output "|lp -dlaser filename"

 On MSDOS machines, `set output "PRN"` will direct the output to the default
 printer.  On VMS, output can be sent directly to any spooled device.  It is
 also possible to send the output to DECnet transparent tasks, which allows
 some flexibility.
3 parametric
?commands set parametric
?commands unset parametric
?commands show parametric
?set parametric
?unset parametric
?show parametric
?parametric
?noparametric
 The `set parametric` command changes the meaning of `plot` (`splot`) from
 normal functions to parametric functions.  The command `unset parametric`
 restores the plotting style to normal, single-valued expression plotting.

 Syntax:
       set parametric
       unset parametric
       show parametric

 For 2-d plotting, a parametric function is determined by a pair of parametric
 functions operating on a parameter.  An example of a 2-d parametric function
 would be `plot sin(t),cos(t)`, which draws a circle (if the aspect ratio is
 set correctly---see `set size`).  `gnuplot` will display an error message if
 both functions are not provided for a parametric `plot`.

 For 3-d plotting, the surface is described as x=f(u,v), y=g(u,v), z=h(u,v).
 Therefore a triplet of functions is required.  An example of a 3-d parametric
 function would be `cos(u)*cos(v),cos(u)*sin(v),sin(u)`, which draws a sphere.
 `gnuplot` will display an error message if all three functions are not
 provided for a parametric `splot`.

 The total set of possible plots is a superset of the simple f(x) style plots,
 since the two functions can describe the x and y values to be computed
 separately.  In fact, plots of the type t,f(t) are equivalent to those
 produced with f(x) because the x values are computed using the identity
 function.  Similarly, 3-d plots of the type u,v,f(u,v) are equivalent to
 f(x,y).

 Note that the order the parametric functions are specified is xfunction,
 yfunction (and zfunction) and that each operates over the common parametric
 domain.

 Also, the `set parametric` function implies a new range of values.  Whereas
 the normal f(x) and f(x,y) style plotting assume an xrange and yrange (and
 zrange), the parametric mode additionally specifies a trange, urange, and
 vrange.  These ranges may be set directly with `set trange`, `set urange`,
 and `set vrange`, or by specifying the range on the `plot` or `splot`
 commands.  Currently the default range for these parametric variables is
 [-5:5].  Setting the ranges to something more meaningful is expected.
3 plot
?commands show plot
?show plot
 The `show plot` command shows the current plotting command as it results
 from the last `plot` and/or `splot` and possible subsequent `replot` commands.

 In addition, the `show plot add2history` command adds this current plot
 command into the `history`. It is useful if you have used `replot` to add
 more curves to the current plot and you want to edit the whole command now.
3 pm3d
?commands set pm3d
?commands show pm3d
?set pm3d
?show pm3d
?pm3d
 pm3d is an `splot` style for drawing palette-mapped 3d and 4d data as
 color/gray maps and surfaces.  It uses a pm3d algorithm which allows plotting
 gridded as well as non-gridded data without preprocessing, even when the data
 scans do not have the same number of points.

 Drawing of color surfaces is available on terminals supporting filled colored
 polygons with color mapping specified by `palette`. Currently supported
 terminals include

   Screen terminals:
     OS/2 Presentation Manager
     X11
     Linux VGA (vgagl)
     GGI
     Windows
     AquaTerm (Mac OS X)
     wxWidgets (wxt)
   Files:
     PostScript
     pslatex, pstex, epslatex
     gif, png, jpeg
     (x)fig
     tgif
     cgm
     pdf
     svg
     emf

 Let us first describe how a map/surface is drawn.  The input data come from an
 evaluated function or from an `splot data file`.  Each surface consists of a
 sequence of separate scans (isolines).  The pm3d algorithm fills the region
 between two neighbouring points in one scan with another two points in the
 next scan by a gray (or color) according to z-values (or according to an
 additional 'color' column, see help for `using`) of these 4 corners; by default
 the 4 corner values are averaged, but this can be changed by the option
 `corners2color`.  In order to get a reasonable surface, the neighbouring scans
 should not cross and the number of points in the neighbouring scans should not
 differ too much; of course, the best plot is with scans having same number of
 points.  There are no other requirements (e.g. the data need not be gridded).
 Another advantage is that the pm3d algorithm does not draw anything outside of
 the input (measured or calculated) region.

 Surface coloring works with the following input data:

 1. splot of function or of data file with one or three data columns: The
 gray/color scale is obtained by mapping the averaged (or `corners2color`)
 z-coordinate of the four corners of the above-specified quadrangle into the
 range [min_color_z,max_color_z] of `zrange` or `cbrange` providing a gray value
 in the range [0:1].  This value can be used directly as the gray for gray maps.
 The normalized gray value can be further mapped into a color---see `set palette`
 for the complete description.

 2. splot of data file with two or four data columns: The gray/color value is
 obtained by using the last-column coordinate instead of the z-value, thus
 allowing the color and the z-coordinate be mutually independent.  This can be
 used for 4d data drawing.

 Other notes:

 1. The term 'scan' referenced above is used more among physicists than the
 term 'iso_curve' referenced in gnuplot documentation and sources.  You measure
 maps recorded one scan after another scan, that's why.

 2. The 'gray' or 'color' scale is a linear mapping of a continuous variable
 onto a smoothly varying palette of colors. The mapping is shown in a
 rectangle next to the main plot. This documentation refers to this as a
 "colorbox", and refers to the indexing variable as lying on the colorbox axis.
 See `set colorbox`, `set cbrange`.

 3. To use pm3d coloring to generate a two-dimensional plot rather than a 3D
 surface, use `set view map` or `set pm3d map`.

 Syntax (the options can be given in any order):
       set pm3d {
                  { at <bst combination> }
                  { interpolate <steps in scan>,<steps between scans> }
                  { scansautomatic | scansforward | scansbackward | depthorder }
                  { flush { begin | center | end } }
                  { ftriangles | noftriangles }
                  { clip1in | clip4in }
                  { corners2color { mean|geomean|median|min|max|c1|c2|c3|c4 } }
                  { hidden3d <linestyle> | nohidden3d }
                  { implicit | explicit }
                  { map }
                }
       show pm3d
       unset pm3d

 Color surface is drawn if data or function `style` is set to pm3d globally or
 via 'with' option, or if the option `implicit` is on---then the pm3d surface
 is combined with the line surface mesh. See bottom of this section for mode
 details.

 Color surface can be drawn at the base or top (then it is a gray/color planar
 map) or at z-coordinates of surface points (gray/color surface).  This is
 defined by the `at` option with a string of up to 6 combinations of `b`, `t`
 and `s`. For instance, `at b` plots at bottom only, `at st` plots firstly
 surface and then top map, while `at bstbst` will never by seriously used.

 Colored quadrangles are plotted one after another.  When plotting surfaces
 (`at s`), the later quadrangles overlap (overdraw) the previous ones.
 (Gnuplot is not virtual reality tool to calculate intersections of filled
 polygon meshes.)  You may try to switch between `scansforward` and
 `scansbackward` to force the first scan of the data to be plotted first or
 last.  The default is `scansautomatic` where gnuplot makes a guess about scans
 order.

 If two subsequent scans do not have same number of points, then it has to be
 decided whether to start taking points for quadrangles from the beginning of
 both scans (`flush begin`), from their ends (`flush end`) or to center them
 (`flush center`).  Note, that `flush (center|end)` are incompatible with
 `scansautomatic`: if you specify `flush center` or `flush end` and
 `scansautomatic` is set, it is silently switched to `scansforward`.

 If two subsequent scans do not have the same number of points, the option
 `ftriangles` specifies whether color triangles are drawn at the scan tail(s)
 where there are not enough points in either of the scan. This can be used to
 draw a smooth map boundary.

 Clipping with respect to x, y coordinates of quadrangles can be done in two
 ways.  `clip1in`: all 4 points of each quadrangle must be defined and at least
 1 point of the quadrangle must lie in the x and y ranges.  `clip4in`: all 4
 points of each quadrangle must lie in the x and y ranges.

 There is a single gray/color value associated to each drawn pm3d quadrangle
 (no smooth color change among vertices).  The value is calculated from
 z-coordinates from the surrounding corners according to `corners2color
 <option>`.  The options 'mean' (default), 'geomean' and 'median' produce
 various kinds of surface color smoothing, while options 'min' and 'max' choose
 minimal or maximal value, respectively. This may not be desired for pixel
 images or for maps with sharp and intense peaks, in which case the options
 'c1', 'c2', 'c3' or 'c4' can be used instead to assign the quadrangle color
 based on the z-coordinate of only one corner.  Some experimentation may be
 needed to determine which corner corresponds to 'c1', as the orientation
 depends on the drawing direction.  Because the pm3d algorithm does not extend
 the colored surface outside the range of the input data points, the 'c<j>'
 coloring options will result in pixels along two edges of the grid not
 contributing to the color of any quadrangle.  For example, applying the pm3d
 algorithm to the 4x4 grid of data points in script `demo/pm3d.dem` (please have
 a look) produces only (4-1)x(4-1)=9 colored rectangles.

 Another drawing algorithm, which would draw quadrangles around a given node
 by taking corners from averaged (x,y)-coordinates of its surrounding 4 nodes
 while using node's color, could be implemented in the future. This is already
 done for drawing images (2D grids) via `image` and `rgbimage` styles.

 Notice that ranges of z-values and color-values for surfaces are adjustable
 independently by `set zrange`, `set cbrange`, as well as `set log` for z or
 cb.  Maps can be adjusted by the cb-axis only; see also `set view map` and
 `set colorbox`.

 The option `hidden3d` takes as the argument a linestyle which must be created
 by `set style line ...`. (The style need not to be present when setting pm3d,
 but it must be present when plotting).  If set, lines are drawn using the
 specified line style, taking into account hidden line removal.  This is by
 far more efficient than using the command `set hidden3d` as it doesn't really
 calculate hidden line removal, but just draws the filled polygons in the
 correct order. So the recommended choice when using pm3d is
       set pm3d at s hidden3d 100
       set style line 100 lt 5 lw 0.5
       unset hidden3d
       unset surf
       splot x*x+y*y

 There used to be an option {transparent|solid} to this command.  Now
 you get the same effect from `set grid {front|layerdefault}`,
 respectively.

 The `set pm3d map` is an abbreviation for `set pm3d at b`; `set view map`;
 `set style data pm3d`; `set style func pm3d`;.
 It is used for backwards compatibility, when `set view map` was not available.
 Take care that you properly use `zrange` and `cbrange` for input data point
 filtering and color range scaling, respectively; and also `set (no)surface`
 seems to have a (side?) effect.

 The option `interpolate` will interpolate grid points into a finer mesh, and
 color each quadrangle appropriately. For data files, this will smoothen the
 color surface, and enhance spikes in a color surface. For functions,
 interpolation makes little sense, except to trade off precision for memory.
 It would usually make more sense to use `samples` and `isosamples` when working
 with functions.

 The coloring setup as well as the color box drawing are determined by
 `set palette`.  There can be only one palette for the current plot.  Drawing
 of several surfaces with different palettes can be achieved by `multiplot`
 with fixed `origin` and `size`; don't forget to use `set palette maxcolors`
 when your terminal is running out of available colors.

 On gnuplot start-up, mode is `explicit`. For historical and thus compatibility
 reasons, commands `set pm3d;` (i.e. no options) and `set pm3d at X ...` (i.e.
 `at` is the first option) sets mode `implicit`. Further, `set pm3d;` sets up
 the other options to their default.

 If the option `implicit` is on, all surface plots will be plotted additionally
 to the default type, e.g.
       splot 'fred.dat' with lines, 'lola.dat' with lines
 would give both plots (meshes) additionally to a pm3d surface. That's what you
 are used to after `set pm3d;`.

 If the option `explicit` is on (or `implicit` is off) only plots specified
 by the `with pm3d` attribute are plotted with a pm3d surface, e.g.:
       splot 'fred.dat' with lines, 'lola.dat' with pm3d
 would plot 'fred.dat' with lines (and only lines) and 'lola.dat' with
 a pm3d surface.

 If you set the default data or function style to `pm3d`, e.g.:
       set style data pm3d
 then the options `implicit` and `explicit` have no effect.

 Note that when plotting several plots, they are plotted in the order given
 on the command line. This can be of interest especially for filled surfaces
 which can overwrite and therefore hide part of earlier plots.

 If `with pm3d` is specified in the `splot` command line, then it accepts the
 'at' option.  The following plots draw three color surfaces at different
 altitudes:
       set border 4095
       set pm3d at s
       splot 10*x with pm3d at b, x*x-y*y, x*x+y*y with pm3d at t

 See also help for `set palette`, `set cbrange`, `set colorbox`, `x11 pm3d`
 and definitely the demo file `demo/pm3d.dem`.

3 palette
?commands set palette
?commands show palette
?set palette
?show palette
?palette
 Palette is a color storage for use by `pm3d`, filled color contours or
 polygons, color histograms, color gradient background, and whatever it is
 or it will be implemented...  Here it stands for a palette of smooth
 "continuous" colors or grays, but let's call it just a palette.

 Color palettes require terminal entries for filled color polygons and
 palettes of smooth colors, are currently available for terminals listed in
 help for `set pm3d`. The range of color values are adjustable independently by
 `set cbrange` and `set log cb`. The whole color palette is
 visualized in the `colorbox`.

 Syntax:
       set palette
       set palette {
                  { gray | color }
                  { gamma <gamma> }
                  {   rgbformulae <r>,<g>,<b>
                    | defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }
                    | file '<filename>' {datafile-modifiers}
                    | functions <R>,<G>,<B>
                  }
                  { model { RGB | HSV | CMY | YIQ | XYZ } }
                  { positive | negative }
                  { nops_allcF | ps_allcF }
                  { maxcolors <maxcolors> }
                }
       show palette
       show palette palette <n> {{float | int}}
       show palette gradient
       show palette fit2rgbformulae
       show palette rgbformulae
       show palette colornames

 `set palette` (i.e. without options) sets up the default values.
 Otherwise, the options can be given in any order.
 `show palette` shows the current palette properties.

 `show palette gradient` displays the gradient defining the palette (if
 appropriate).  `show palette rgbformulae` prints the available fixed gray -->
 color transformation formulae.  `show palette colornames` prints the
 implemented color names.

 `show palette palette <n>` prints to screen or to the file given by
 `set output` table of RGB triplets calculated for the current palette settings
 and a palette having <n> discrete colors.  The default wide table can be
 limited to 3 columns of r,g,b float values [0..1] or integer values [0..255]
 by options float or int, respectively.  This way, the current gnuplot color
 palette can be loaded into other imaging applications, for example Octave.
 Additionally to this textual list of RGB table, you can enjoy command `test
 palette` to draw graphically the R,G,B profiles for the current palette.

 The following options determine the coloring properties.

 Figure using this palette can be `gray` or `color`.  For instance, in `pm3d`
 color surfaces the gray of each small spot is obtained by mapping the averaged
 z-coordinate of the 4 corners of surface quadrangles into the range
 [min_z,max_z] providing range of grays [0:1]. This value can be used directly
 as the gray for gray maps. The color map requires a transformation gray -->
 (R,G,B), i.e. a mapping [0:1] --> ([0:1],[0:1],[0:1]).

 Basically two different types of mappings can be used:  Analytic formulae to
 convert gray to color, or discrete mapping tables which are interpolated.
 `palette rgbformulae` and `palette functions` use analytic formulae whereas
 `palette defined` and `palette file` use interpolated tables.  `palette
 rgbformulae` reduces the size of postscript output to a minimum.

 The command `show palette fit2rgbformulae` finds the best matching `set
 palette rgbformulae` for the current `set palette`. Naturally, it makes sense
 to use it for non-rgbformulae palettes. This command can be found useful
 mainly for external programs using the same rgbformulae definition of palettes
 as gnuplot, like zimg (
^ <a href="http://zimg.sourceforge.net">
           http://zimg.sourceforge.net
^ </a>
  ).

 `set palette gray` switches to a gray only palette. `set palette rgbformulae`,
 `set palette defined`, `set palette file` and `set palette functions` switch
 to a color mapping. `set palette color` is an easy way to switch back from the
 gray palette to the last color mapping.

 Automatic gamma correction via `set palette gamma <gamma>` can be done for
 gray maps only (`set palette gray`).  Linear mapping to gray is for gamma
 equals 1, see `test palette`.  Gamma is ignored for color mappings.

 Most terminals support only discrete number of colors (e.g. 256 colors in
 gif).  All entries of the palette remaining after the default gnuplot linetype
 colors declaration are allocated for pm3d by default.  Then `multiplot` could
 fail if there are no more color positions in the terminal available.  Then you
 should use `set palette maxcolors <maxcolors>` with a reasonably small value.
 This option can also be used to separate levels of z=constant in discrete
 steps, thus to emulate filled contours. Default value of 0 stays for
 allocating all remaining entries in the terminal palette or for to use exact
 mapping to RGB.

 RGB color space might not be the most useful color space to work in.  For that
 reason you may change the color space with `model` to one of `RGB`, `HSV`,
 `CMY`, `YIQ` and `XYZ`.  Using color names for `set palette defined` tables
 and a color space other than RGB will result in funny colors.  All explanation
 have been written for RGB color space, so please note, that `R` can be `H`,
 `C`, `Y`, or `X`, depending on the actual color space (`G` and `B`
 accordingly).

 All values for all color spaces are limited to [0,1].

 RGB stands for Red, Green and Blue;  CMY stands for Cyan, Magenta and Yellow;
 HSV stands for Hue, Saturation, and Value;  YIQ is the color model used by
 the U.S. Commercial Color Television Broadcasting, it is basically an RGB
 recoding with downward compatibility for black and white television;
 XYZ are the three primary colors of the color model defined by the 'Commission
 Internationale de l'Eclairage' (CIE).
 For more information on color models see:
^ <a href="http://www.cs.rit.edu/~ncs/color/glossary.htm">
           http://www.cs.rit.edu/~ncs/color/glossary.htm
^ </a>
 and
^ <a href="http://cs.fit.edu/wds/classes/cse5255/cse5255/davis/index.html">
           http://cs.fit.edu/wds/classes/cse5255/cse5255/davis/index.html
^ </a>

4 rgbformulae
?commands set palette rgbformulae
?set palette rgbformulae
?palette rgbformulae
?rgbformulae
=colors
 For `rgbformulae` three suitable mapping functions have
 to be chosen.  This is done via `rgbformulae <r>,<g>,<b>`.  The available
 mapping functions are listed by `show palette rgbformulae`.  Default is
 `7,5,15`, some other examples are `3,11,6`, `21,23,3` or `3,23,21`.  Negative
 numbers, like `3,-11,-6`, mean inverted color (i.e.  1-gray passed into the
 formula, see also `positive` and `negative` options below).

 Some nice schemes in RGB color space
    7,5,15   ... traditional pm3d (black-blue-red-yellow)
    3,11,6   ... green-red-violet
    23,28,3  ... ocean (green-blue-white); try also all other permutations
    21,22,23 ... hot (black-red-yellow-white)
    30,31,32 ... color printable on gray (black-blue-violet-yellow-white)
    33,13,10 ... rainbow (blue-green-yellow-red)
    34,35,36 ... AFM hot (black-red-yellow-white)

 A full color palette in HSV color space
    3,2,2    ... red-yellow-green-cyan-blue-magenta-red

 Please note that even if called `rgbformulae` the formulas might actually
 determine the <H>,<S>,<V> or <X>,<Y>,<Z> or ... color components as usual.

 Use `positive` and `negative` to invert the figure colors.
^ <a name="positive"></a>
^ <a name="negative"></a>

 Note that it is possible to find a set of the best matching rgbformulae for any
 other color scheme by the command
    show palette fit2rgbformulae
4 defined
?commands set palette defined
?set palette defined
?palette defined
=colors
 Gray-to-rgb mapping can be manually set by use of `palette defined`:  A color gradient
 is defined and used to give the rgb values.  Such a  gradient is a piecewise
 linear mapping from gray values in [0,1] to the RGB space [0,1]x[0,1]x[0,1].
 You have to specify the gray values and the corresponding RGB values in
 between a linear interpolation shall take place:

 Syntax:
       set palette  defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }

 <grayX> are gray values which are mapped to [0,1] and <colorX> are the
 corresponding rgb colors.  The color can be specified in three different
 ways:

      <color> :=  { <r> <g> <b> | '<color-name>' | '#rrggbb' }

 Either by three numbers (each in [0,1]) for red, green and blue, separated by
 whitespace, or the name of the color in quotes or X style color specifiers
 also in quotes.  You may freely mix the three types in a gradient definition,
 but the named color "red" will be something strange if RGB is not selected
 as color space.  Use `show palette colornames` for a list of known color
 names.

 Please note, that even if written as <r>, this might actually be the
 <H> component in HSV color space or <X> in CIE-XYZ space, or ...
 depending on the selected color model.

 The <gray> values have to form an ascending sequence of real numbers; the
 sequence will be automatically rescaled to [0,1].

 `set palette defined` (without a gradient definition in braces) switches to
 RGB color space and uses a preset full-spectrum color gradient.
 Use `show palette gradient` to display the gradient.

 Examples:

 To produce a gray palette (useless but instructive) use:
       set palette model RGB
       set palette defined ( 0 "black", 1 "white" )

 To produce a blue yellow red palette use (all equivalent):
       set palette defined ( 0 "blue", 1 "yellow", 2 "red" )
       set palette defined ( 0 0 0 1, 1 1 1 0, 2 1 0 0 )
       set palette defined ( 0 "#0000ff", 1 "#ffff00", 2 "#ff0000" )

 To produce some rainbow-like palette use:
       set palette defined ( 0 "blue", 3 "green", 6 "yellow", 10 "red" )

 Full color spectrum within HSV color space:
       set palette model HSV
       set palette defined ( 0 0 1 1, 1 1 1 1 )
       set palette defined ( 0 0 1 0, 1 0 1 1, 6 0.8333 1 1, 7 0.8333 0 1)

 To produce a palette with few colors only use:
       set palette model RGB maxcolors 4
       set palette defined ( 0 "blue", 1 "green", 2 "yellow", 3 "red" )

 'Traffic light' palette (non-smooth color jumps at gray = 1/3 and 2/3).
       set palette model RGB
       set palette defined (0 "dark-green", 1 "green", 1 "yellow", \
                            2 "dark-yellow", 2 "red", 3 "dark-red" )

4 functions
?commands set palette functions
?set palette functions
?palette functions
 Use `set palette functions <Rexpr>, <Gexpr>, <Bexpr>` to define three formulae
 for the R(gray), G(gray) and B(gray) mapping.  The three formulae may depend
 on the variable `gray` which will take values in [0,1] and should also
 produce values in [0,1].
 Please note that <Rexpr> might be a formula for the H-value if HSV color
 space has been chosen (same for all other formulae and color spaces).

 Examples:

 To produce a full color palette use:
       set palette model HSV functions gray, 1, 1

 A nice black to gold palette:
       set palette model XYZ functions gray**0.35, gray**0.5, gray**0.8

 A gamma-corrected black and white palette
       gamma = 2.2
       color(gray) = gray**(1./gamma)
       set palette model RGB functions color(gray), color(gray), color(gray)

4 file
?commands set palette file
?set palette file
?palette file
 `set palette file` is basically a `set palette defined (<gradient>)` where
 <gradient> is read from a datafile.  Either 4 columns (gray,R,G,B) or
 just three columns (R,G,B) have to be selected via the `using` data file
 modifier.  In the three column case, the line number will be used as gray.
 The gray range is automatically rescaled to [0,1].  The file is read as a
 normal data file, so all datafile modifiers can be used.
 Please note, that `R` might actually be e.g. `H` if HSV color space is
 selected.

 As usual <filename> may be `'-'` which means that the data follow the command
 inline and are terminated by a single `e` on a line of its own.

 Use `show palette gradient` to display the gradient.

 Examples:

 Read in a palette of RGB triples each in range [0,255]:
       set palette file 'some-palette' using ($1/255):($2/255):($3/255)

 Equidistant rainbow (blue-green-yellow-red) palette:
       set palette model RGB file "-"
       0 0 1
       0 1 0
       1 1 0
       1 0 0
       e

 Binary palette files are supported as well, see `binary general`. Example:
 put 64 triplets of R,G,B doubles into file palette.bin and load it by
       set palette file "palette.bin" binary record=64 using 1:2:3


4 gamma correction
?commands set palette gamma-correction
?set palette gamma-correction
?palette gamma-correction
?gamma-correction
 For gray mappings gamma correction can be turned on by `set palette gamma
 <gamma>`.  <gamma> defaults to 1.5 which is quite suitable for most
 terminals.

 For color mappings no automatic gamma correction is done by gnuplot.  However,
 you may easily implement gamma correction.  Here is an example for a gray
 scale image by use of explicit functions for the red, green and blue component
 with slightly different values of gamma

 Example:
       set palette model RGB
       set palette functions gray**0.64, gray**0.67, gray**0.70

 To use gamma correction with interpolated gradients specify intermediate
 gray values with appropriate colors.  Instead of

       set palette defined ( 0 0 0 0, 1 1 1 1 )

 use e.g.

       set palette defined ( 0 0 0 0, 0.5 .73 .73 .73, 1 1 1 1 )

 or even more intermediate points until the linear interpolation fits the
 "gamma corrected" interpolation well enough.

4 postscript
?commands set palette postscript
?set palette postscript
 In order to reduce the size of postscript files, the gray value and not all
 three calculated r,g,b values are written to the file.  Therefore the
 analytical formulae are coded directly in the postscript language as a header
 just before the pm3d drawing, see /g and /cF definitions.  Usually, it makes
 sense to write therein definitions of only the 3 formulae used.  But for
 multiplot or any other reason you may want to manually edit the
 transformations directly in the postscript file.  This is the default option
 `nops_allcF`.  Using the option `ps_allcF` writes postscript definitions of
 all formulae.  This you may find interesting if you want to edit the
 postscript file in order to have different palettes for different surfaces
 in one graph.  Well, you can achieve this functionality by `multiplot` with
 fixed `origin` and `size`.

 If pm3d map has been plotted from gridded or almost regular data with an
 output to a postscript file, then it is possible to reduce the size of this
 postscript file up to at about 50% by the enclosed awk script
 `pm3dCompress.awk`.  This you may find  interesting if you intend to keep the
 file for including it into your publication or before downloading a very large
 file into a slow printer. Usage:
     awk -f pm3dCompress.awk thefile.ps >smallerfile.ps

 If pm3d map has been plotted from rectangular gridded data with an output
 to a postscript file, then it is possible to reduce the file size even more
 by the enclosed awk script `pm3dConvertToImage.awk`.  Usage:
     awk -f pm3dConvertToImage.awk <thefile.ps >smallerfile.ps

 You may manually change the postscript output from gray to color and vice
 versa and change the definition of <maxcolors>.
4 colornames
?colornames
?show palette colornames
?show colornames
 Gnuplot knows a limited number of color names. You can use these to define
 the color range spanned by a pm3d palette, or to assign a terminal-independent
 colot to a particular linetype or linestyle. To see the list of know color
 names, use the command `show palette colornames`.
 See `set palette`, `linestyle`.
3 pointsize
?commands set pointsize
?commands show pointsize
?set pointsize
?show pointsize
?pointsize
 The `set pointsize` command scales the size of the points used in plots.

 Syntax:
       set pointsize <multiplier>
       show pointsize

 The default is a multiplier of 1.0.  Larger pointsizes may be useful to
 make points more visible in bitmapped graphics.

 The pointsize of a single plot may be changed on the `plot` command.
 See `plot with` for details.

 Please note that the pointsize setting is not supported by all terminal
 types.
3 polar
?commands set polar
?commands unset polar
?commands show polar
?set polar
?unset polar
?show polar
?polar
?nopolar
 The `set polar` command changes the meaning of the plot from rectangular
 coordinates to polar coordinates.

 Syntax:
       set polar
       unset polar
       show polar

 There have been changes made to polar mode in version 3.7, so that scripts
 for `gnuplot` versions 3.5 and earlier will require modification.  The main
 change is that the dummy variable t is used for the angle so that the x and
 y ranges can be controlled independently.  Other changes are:
 1) tics are no longer put along the zero axes automatically
 ---use `set xtics axis nomirror`; `set ytics axis nomirror`;
 2) the grid, if selected, is not automatically polar
 ---use `set grid polar`;
 3) the grid is not labelled with angles
 ---use `set label` as necessary.

 In polar coordinates, the dummy variable (t) is an angle.  The default range
 of t is [0:2*pi], or, if degree units have been selected, to [0:360] (see
 `set angles`).

 The command `unset polar` changes the meaning of the plot back to the default
 rectangular coordinate system.

 The `set polar` command is not supported for `splot`s.  See the `set mapping`
 command for similar functionality for `splot`s.

 While in polar coordinates the meaning of an expression in t is really
 r = f(t), where t is an angle of rotation.  The trange controls the domain
 (the angle) of the function, and the x and y ranges control the range of the
 graph in the x and y directions.  Each of these ranges, as well as the
 rrange, may be autoscaled or set explicitly.  See `set xrange` for details
 of all the `ranges` commands.

 Example:
       set polar
       plot t*sin(t)
       plot [-2*pi:2*pi] [-3:3] [-3:3] t*sin(t)

 The first `plot` uses the default polar angular domain of 0 to 2*pi.  The
 radius and the size of the graph are scaled automatically.  The second `plot`
 expands the domain, and restricts the size of the graph to [-3:3] in both
 directions.

 You may want to `set size square` to have `gnuplot` try to make the aspect
 ratio equal to unity, so that circles look circular.
 See also
^ <a href="http://www.gnuplot.info/demo/polar.html">
 polar demos (polar.dem)
^ </a>
 and
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 polar data plot (poldat.dem).
^ </a>
3 print
?commands set print
?commands show print
?set print
?show print
 The `set print` command redirects the output of the `print` command to a file.

 Syntax:
       set print
       set print "-"
       set print "<filename>"
       set print "<filename>" append
       set print "|<shell_command>"

 Without "<filename>", the output file is restored to <STDERR>.  The <filename>
 "-" means <STDOUT>. The `append` flag causes the file to be opened in append
 mode.  A <filename> starting with "|" is opened as a pipe to the
 <shell_command> on platforms that support piping.
3 object
?object
?rectangle
?commands set object
?commands show object
?commands set object rectangle
?commands show object rectangle
?set object
?show object
?set object rectangle
?show object rectangle
 This command defines a single object, which will appear in all subsequent
 2D plots. You may define as many objects as you like. Currently the only
 object type supported is `rectangle`.
 Each rectangle is specified by a pair of points that define diagonal vertices.
 A default set of style properties (fill, color, border) are inherited from
 those set by the command `set style rectangle`, but each rectangle can also be
 given individual style properties.

 Syntax:
     set object <index> rectangle
         {from <position> {to|rto} <position> |
          center <position> size <w>,<h> |
          at <position> size <w>,<h>}
         {front|back|behind} {fc|fillcolor <colorspec>} {fs <fillstyle>}
         {default} {lw|linewidth <width>}

 The position of the rectangle may be specified by giving the position of two
 diagonal corners (bottom left and top right) or by giving the position of the
 center followed by the width and the height.  In either case the positions
 may be given in axis, graph, or screen coordinates. See `coordinates`.
 The options `at` and `center` are synonyms.

 Setting `front` will draw the rectangle in front of all plot elements, but
 behind any labels that are also marked `front`. Setting `back` will place the
 rectangle behind all plot curves and labels. Setting `behind` will place the
 rectangle behind everything including the axes and `back` rectangles, and can
 be used to provide a colored background for the entire graph or page.

 The fill color of the rectangle is taken from the <colorspec>. `fillcolor`
 may be abbreviated `fc`.  The fill style is taken from <fillstyle>.
 See `colorspec` and `fillstyle`.  If the keyword `default` is given,
 these properties are inherited from the default settings of at the time a plot
 is drawn. See `set style rectangle`.

 Examples:
     # Force the entire area enclosed by the axes to have background color cyan
     set object 1 rect from graph 0, graph 0 to graph 1, graph 1 back
     set object 1 rect fc rgb "cyan" fillstyle solid 1.0

     # Position a red square with lower left at 0,0 and upper right at 2,3
     set object 2 rect from 0,0 to 2,3 fc lt 1

     # Position an empty rectangle (no fill) with a blue border
     set object 3 rect from 0,0 to 2,3 fs empty border 3

     # Return fill and color to the default style but leave vertices unchanged
     set object 2 rect default

3 rmargin
?commands set rmargin
?set rmargin
?rmargin
 The command `set rmargin` sets the size of the right margin.
 Please see `set margin` for details.
3 rrange
?commands set rrange
?commands show rrange
?set rrange
?show rrange
?rrange
 The `set rrange` command sets the range of the radial coordinate for a
 graph in polar mode.  Please see `set xrange` for details.
3 samples
?commands set samples
?commands show samples
?set samples
?show samples
?samples
 The sampling rate of functions, or for interpolating data, may be changed
 by the `set samples` command.

 Syntax:
       set samples <samples_1> {,<samples_2>}
       show samples

 By default, sampling is set to 100 points.  A higher sampling rate will
 produce more accurate plots, but will take longer.  This parameter has no
 effect on data file plotting unless one of the interpolation/approximation
 options is used.  See `plot smooth` re 2-d data and `set cntrparam` and
 `set dgrid3d` re 3-d data.

 When a 2-d graph is being done, only the value of <samples_1> is relevant.

 When a surface plot is being done without the removal of hidden lines, the
 value of samples specifies the number of samples that are to be evaluated for
 the isolines.  Each iso-v line will have <sample_1> samples and each iso-u
 line will have <sample_2> samples.  If you only specify <samples_1>,
 <samples_2> will be set to the same value as <samples_1>.  See also
 `set isosamples`.
3 size
?commands set size
?commands show size
?set size
?show size
?size
?aspect ratio
 Syntax:
       set size {{no}square | ratio <r> | noratio} {<xscale>,<yscale>}
       show size

 The <xscale> and <yscale> values are scale factors for the size of the plot,
 which includes the graph, labels, and margins.

 Important note:
       In earlier versions of gnuplot, some terminal types used the values from
       `set size` to control also the size of the output canvas; others did not.
       In version 4.2 almost all terminals now follow the following convention:

 `set term <terminal_type> size <XX>, <YY>` controls the size of the output
 file, or `canvas`. Please see individual terminal documentation for allowed
 values of the size parameters.  By default, the plot will fill this canvas.

 `set size <XX>, <YY>` scales the plot itself relative to the size of the
 canvas.  Scale values less than 1 will cause the plot to not fill the entire
 canvas.  Scale values larger than 1 will cause only a portion of the plot to
 fit on the canvas.  Please be aware that setting scale values larger than 1
 may cause problems on some terminal types.

 `ratio` causes `gnuplot` to try to create a graph with an aspect ratio of <r>
 (the ratio of the y-axis length to the x-axis length) within the portion of
 the plot specified by <xscale> and <yscale>.

 The meaning of a negative value for <r> is different.  If <r>=-1, gnuplot
 tries to set the scales so that the unit has the same length on both the x
 and y axes (suitable for geographical data, for instance).  If <r>=-2, the
 unit on y has twice the length of the unit on x, and so on.

 The success of `gnuplot` in producing the requested aspect ratio depends on
 the terminal selected.  The graph area will be the largest rectangle of
 aspect ratio <r> that will fit into the specified portion of the output
 (leaving adequate margins, of course).

 `square` is a synonym for `ratio 1`.

 Both `noratio` and `nosquare` return the graph to the default aspect ratio
 of the terminal, but do not return <xscale> or <yscale> to their default
 values (1.0).

 `ratio` and `square` have no effect on 3-d plots.

 Examples:

 To set the size so that the plot fills the available canvas:
       set size 1,1

 To make the graph half size and square use:
       set size square 0.5,0.5

 To make the graph twice as high as wide use:
       set size ratio 2

 See also
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
  airfoil demo.
^ </a>
3 style
?set style
?show style
?unset style
^ <a name="set style <style>"></a>
 Default plotting styles are chosen with the `set style data` and
 `set style function` commands.  See `plot with` for information about how to
 override the default plotting style for individual functions and data sets.
 See `plotting styles` for a complete list of styles.

 Syntax:
       set style function <style>
       set style data <style>
       show style function
       show style data

 Default styles for specific plotting elements may also be set.

 Syntax:
       set style arrow <n> <arrowstyle>
       set style fill <fillstyle>
       set style histogram <histogram style options>
       set style line <n> <linestyle>

4 set style arrow
?commands set style arrow
?commands unset style arrow
?commands show style arrow
?set style arrow
?unset style arrow
?show style arrow
?arrowstyle
^ <a name="arrowtype"></a>
^ <a name="arrowwidth"></a>
 Each terminal has a default set of arrow and point types, which can be seen
 by using the command `test`.  `set style arrow` defines a set of arrow types
 and widths and point types and sizes so that you can refer to them later by
 an index instead of repeating all the information at each invocation.

 Syntax:
       set style arrow <index> default
       set style arrow <index> {nohead | head | heads}
                               {size <length>,<angle>{,<backangle>}}
                               {filled | empty | nofilled}
                               {front | back}
                               { {linestyle | ls <line_style>}
                                 | {linetype | lt <line_type>}
                                   {linewidth | lw <line_width} }
       unset style arrow
       show style arrow

 <index> is an integer that identifies the arrowstyle.

 If `default` is given all arrow style parameters are set to their default
 values.

 If the linestyle <index> already exists, only the given parameters are
 changed while all others are preserved.  If not, all undefined values are
 set to the default values.

 Specifying `nohead` produces arrows drawn without a head---a line segment.
 This gives you yet another way to draw a line segment on the plot.  By
 default, arrows have one head. Specifying `heads` draws arrow heads on both
 ends of the line.

 Head size can be controlled by `size <length>,<angle>` or
 `size <length>,<angle>,<backangle>`, where `<length>` defines length of each
 branch of the arrow head and `<angle>` the angle (in degrees) they make with
 the arrow.  `<Length>` is in x-axis units; this can be changed by `first`,
 `second`, `graph`, `screen`, or `character` before the <length>;  see
 `coordinates` for details.  `<Backangle>` only takes effect when `filled`
 or `empty` is also used.  Then, `<backangle>` is the angle (in degrees) the
 back branches make with the arrow (in the same direction as `<angle>`).
 The `fig` terminal has a restricted backangle function. It supports three
 different angles. There are two thresholds: Below 70 degrees, the arrow head
 gets an indented back angle. Above 110 degrees, the arrow head has an acute
 back angle. Between these thresholds, the back line is straight.

 Specifying `filled` produces filled arrow heads (if heads are used).
 Filling is supported on filled-polygon capable terminals, see help of `pm3d`
 for their list, otherwise the arrow heads are closed but not filled.
 The same result (closed but not filled arrow head) is reached by specifying
 `empty`.  Further, filling and outline is obviously not supported on
 terminals drawing arrows by their own specific routines, like `metafont`,
 `metapost`, `latex` or `tgif`.

 The line style may be selected from a user-defined list of line styles
 (see `set style line`) or may be defined here by providing values for
 `<line_type>` (an index from the default list of styles) and/or
 `<line_width>` (which is a  multiplier for the default width).

 Note, however, that if a user-defined line style has been selected, its
 properties (type and width) cannot be altered merely by issuing another
 `set style arrow` command with the appropriate index and `lt` or `lw`.

 If `front` is given, the arrows are written on top of the graphed data. If
 `back` is given (the default), the arrow is written underneath the graphed
 data.  Using `front` will prevent a arrow from being obscured by dense data.

 Examples:

 To draw an arrow without an arrow head and double width, use:
       set style arrow 1 nohead lw 2
       set arrow arrowstyle 1

  See also `set arrow` for further examples.

4 set style data
?commands set style data
?commands show style data
?set style data
?show style data
?data style
 The `set style data` command changes the default plotting style for data
 plots.

 Syntax:
       set style data <plotting-style>
       show style data

 See `plotting styles` for the choices.  If no choice is given, the choices are
 listed.  `show style data` shows the current default data plotting style.
4 set style fill
?commands set style fill
?commands show style fill
?set style fill
?show style fill
?fillstyle
 The `set style fill` command is used to set the style of boxes,
 histograms, candlesticks and filledcurves.

 Syntax:
       set style fill {empty
                       | {transparent} solid {<density>}
                       | {transparent} pattern {<n>}}
                      {border {<linetype>} | noborder}

 The default fillstyle is `empty`.

 The `solid` option causes filling with a solid color, if the terminal
 supports that. The <density> parameter specifies the intensity of the
 fill color. At a <density> of 0.0, the box is empty, at <density> of 1.0,
 the inner area is of the same color as the current linetype.
 Some terminal types can vary the density continuously; others implement
 only a few levels of partial fill.  If no <density> parameter is given,
 it defaults to 1.

 The `pattern` option causes filling to be done with a fill pattern supplied
 by the terminal driver.  The kind and number of available fill patterns
 depend on the terminal driver.  If multiple datasets using filled boxes are
 plotted, the pattern cycles through all available pattern types, starting
 from pattern <n>, much as the line type cycles for multiple line plots.

 The `empty` option causes filled boxes not to be filled. This is the default.
 It is equivalent to the `solid` option with a <density> parameter of zero.

 By default, `border`, the box is bounded by a solid line of the current
 linetype. `border <lt>` specifies that a border is to be drawn using
 linetype <lt>. `noborder` specifies that no bounding lines are drawn.
5 set style fill transparent
?commands set style fill transparent
?set style fill transparent
?fillstyle transparent
?transparent
 Some terminals support the attribute `transparent` for filled areas.
 In the case of transparent solid fill areas, the `density` parameter is
 interpreted as an alpha value; that is, density 0 is fully transparent,
 density 1 is fully opaque.  In the case of transparent pattern fill, the
 background of the pattern is either fully transparent or fully opaque.

@start table - Driver support for transparency
       terminal   solid pattern    pm3d
       --------------------------------
       gif           no     yes      no
       jpeg         yes      no     yes
       pdf          yes     yes     yes
       png    TrueColor   index     yes
       post          no     yes      no
       svg          yes      no     yes
       wxt          yes     yes     yes
       x11           no     yes      no
#\begin{tabular}{|cccl|} \hline
#Terminal   &   solid & pattern &    pm3d \\ \hline
#gif        &      no &     yes &      no \\
#jpeg       &     yes &      no &     yes \\
#pdf        &     yes &     yes &     yes \\
#png        &TrueColor&   index &     yes \\
#post       &      no &     yes &      no \\
#svg        &     yes &      no &     yes \\
#wxt        &     yes &     yes &     yes \\
#x11        &      no &     yes &      no \\
%c l .
%Terminal@solid@pattern@pm3d
%_
%gif@no@yes@no
%jpeg@yes@no@yes
%pdf@yes@yes@yes
%png@TrueColor@index@yes
%post@no@yes@no
%svg@yes@yes@yes
%wxt@yes@yes@yes
%x11@no@yes@no
%_
@end table
 Note that there may be additional limitations on the creation or viewing of
 graphs containing transparent fill areas.  For example, the png terminal can
 only use transparent fill if the "truecolor" option is set.  Some pdf viewers
 may not correctly display the fill areas even if they are correctly described
 in the pdf file. Ghostscript/gv does not correctly display pattern-fill areas
 even though actual PostScript printers generally have no problem.
4 set style function
?commands set style function
?commands show style function
?set style function
?show style function
?function style
 The `set style function` command changes the default plotting style for
 function plots.

 Syntax:
       set style function <plotting-style>
       show style function

 See `plotting styles` for the choices.  If no choice is given, the choices are
 listed.  `show style function` shows the current default function plotting
 style.
4 set style increment
?commands set style increment
?commands show style increment
?set style increment
?show style increment
 Syntax:
       set style increment {default|userstyles}
       show style increment

 By default, successive plots within the same graph will use successive
 linetypes from the default set for the current terminal type.
 However, choosing `set style increment user` allows you to step through
 the user-defined line styles rather than through the default linetypes.

 Example:

       set style line 1 lw 2 lc rgb "gold"
       set style line 2 lw 2 lc rgb "purple"
       set style line 4 lw 1 lc rgb "sea-green"
       set style increment user

       plot f1(x), f2(x), f3(x), f4(x)

 should plot functions f1, f2, f4 in your 3 newly defined line styles.
 If a user-defined line style is not found then the corresponding default
 linetype is used instead.  E.g. in the example above, f3(x) will be plotted
 using the default linetype 3.

4 set style line
?commands set style line
?commands unset style line
?commands show style line
?set style line
?unset style line
?show style line
?linestyle
^ <a name="linewidth"></a>
 Each terminal has a default set of line and point types, which can be seen
 by using the command `test`.  `set style line` defines a set of line types
 and widths and point types and sizes so that you can refer to them later by
 an index instead of repeating all the information at each invocation.

 Syntax:
       set style line <index> default
       set style line <index> {{linetype  | lt} <line_type> | <colorspec>}
                              {{linecolor | lc} <colorspec>}
                              {{linewidth | lw} <line_width>}
                              {{pointtype | pt} <point_type>}
                              {{pointsize | ps} <point_size>}
                              {palette}
       unset style line
       show style line

 If `default` is given all line style parameters are set to their default
 values.

 If the linestyle <index> already exists, only the given parameters are
 changed while all others are preserved.  If not, all undefined values are
 set to the default values.

 The line and point types are taken from the default types for the terminal
 currently in use.  The line width and point size are multipliers for the
 default width and size (but note that <point_size> here is unaffected by
 the multiplier given on `set pointsize`).

 The defaults for the line and point types is the index.  The defaults for
 the width and size are both unity.

 Linestyles created by this mechanism do not replace the default linetype
 styles; both may be used.  If you want plots to use the defined styles in
 preference to the default linetypes, please see `set style increment`.

 Not all terminals support the `linewidth` and `pointsize` features; if
 not supported, the option will be ignored.

 Terminal-independent colors may be assigned using either
 `linecolor <colorspec>` or `linetype <colorspec>`, abbreviated `lc` or `lt`.
 This requires giving a RGB color triple, a known palette color name,
 a fractional index into the current palette, or a constant value from the
 current mapping of the palette onto cbrange.
 See `colors`, `colorspec`, `set palette`, `colornames`, `cbrange`.

 `set style line <n> linetype <lt>` will set both a terminal-dependent dot/dash
 pattern and color. The commands`set style line <n> linecolor <colorspec>` or
 `set style line <n> linetype <colorspec>` will set a new line color while
 leaving the existing dot-dash pattern unchanged.

 In 3d mode (`splot` command), the special keyword `palette` is allowed as a
 shorthand for "linetype palette z".  The color value corresponds to the
 z-value (elevation) of the splot, and varies smoothly along a line or surface.

 Examples:
 Suppose that the default lines for indices 1, 2, and 3 are red, green, and
 blue, respectively, and the default point shapes for the same indices are a
 square, a cross, and a triangle, respectively.  Then

       set style line 1 lt 2 lw 2 pt 3 ps 0.5

 defines a new linestyle that is green and twice the default width and a new
 pointstyle that is a half-sized triangle.  The commands

       set style function lines
       plot f(x) lt 3, g(x) ls 1

 will create a plot of f(x) using the default blue line and a plot of g(x)
 using the user-defined wide green line.  Similarly the commands

       set style function linespoints
       plot p(x) lt 1 pt 3, q(x) ls 1

 will create a plot of p(x) using the default triangles connected by a red
 line and q(x) using small triangles connected by a green line.

       splot sin(sqrt(x*x+y*y))/sqrt(x*x+y*y) w l pal

 creates a surface plot using smooth colors according to `palette`. Note,
 that this works only on some terminals. See also `set palette`, `set pm3d`.

       set style line 10 linetype 1 linecolor rgb "cyan"

 will assign linestyle 10 to be a solid cyan line on any terminal that
 supports rgb colors.

4 plotting styles
?plotting styles

 The commands `set style data` and `set style function` change the
 default plotting style for subsequent `plot` and `splot` commands.

 The types used for all line and point styles (i.e., solid, dash-dot, color,
 etc. for lines; circles, squares, crosses, etc. for points) will be either
 those specified on the `plot` or `splot` command or will be chosen
 sequentially from the types available to the terminal in use.  Use the
 command `test` to see what is available.

 None of the styles requiring more than two columns of information
 (e.g., `errorbars` or `errorlines`) can be used with `splot`s or
 function `plot`s. Neither `boxes`, `filledcurves` nor any
 of the `steps` styles can be used with `splot`s. If an inappropriate style
 is specified, it will be changed to `points`.

 The above caveat does not apply to `plot with labels`, for which the third
 column specifies a data source rather than coordinate information.
 See `set style labels`.

 For 2-d data with more than two columns, `gnuplot` is picky about the
 allowed `errorbars` and `errorlines` styles. The `using` option on the
 `plot` command can be used to set up the correct columns for the style
 you want. (In this discussion, "column" will be used to refer both to
 a column in the data file and an entry in the `using` list.)

 For three columns, only `xerrorbars`, `yerrorbars` (or `errorbars`),
 `xerrorlines`, `yerrorlines` (or `errorlines`), `boxes`,
 and `boxerrorbars` are allowed. If another plot style is used, the style
 will be changed to `yerrorbars`. The `boxerrorbars` style will
 calculate the boxwidth automatically.

 For four columns, only `xerrorbars`, `yerrorbars` (or `errorbars`),
 `xyerrorbars`, `xerrorlines`, `yerrorlines` (or `errorlines`), `xyerrorlines`,
 `boxxyerrorbars`, and `boxerrorbars` are allowed.  An illegal
 style will be changed to `yerrorbars`.

 Five-column data allow only the `boxerrorbars`, `financebars`, and
 `candlesticks` styles.  An illegal style will be changed to `boxerrorbars`
 before plotting.

 Six- and seven-column data only allow the `xyerrorbars`,
 `xyerrorlines`, and `boxxyerrorbars` styles. Illegal styles will be
 changed to `xyerrorbars` before plotting.

 For more information about error bars with and without lines,
 please see `plot errorlines` and `plot errorbars`.

4 set style rectangle
?commands set style rectangle
?commands unset style rectangle
?commands show style rectangle
?set style rectangle
?unset style rectangle
?show style rectangle

 Rectangles defined with the `set object rectangle` command can have individual
 styles. However, if a rectangle is not assigned a private style then it
 inherits a default that is taken from the `set style rectangle` command.

 Syntax:
     set style rectangle {front|back} {fillcolor <colorspec>} {fs <fillstyle>}
                         {lw|linewidth <lw>}

 See `colorspec` and `fillstyle`.  `fillcolor` may be abbreviated as `fc`.

 Examples:
     set style rectangle back fc rgb "white" fs solid 1.0 border -1
     set style rectangle fc linsestyle 3 fs pattern 2 noborder

 The default values correspond to solid fill with the background color and a
 black border.

5 boxerrorbars
?commands set style boxerrorbars
?set style boxerrorbars
?plotting styles boxerrorbars
?style boxerrorbars
?boxerrorbars
 The `boxerrorbars` style is only relevant to 2-d data plotting.  It is a
 combination of the `boxes` and `yerrorbars` styles.  The boxwidth will come
 from the fourth column if the y errors are in the form of "ydelta" and the
 boxwidth was not previously set equal to -2.0 (`set boxwidth -2.0`) or from
 the fifth column if the y errors are in the form of "ylow yhigh".  The
 special case  `boxwidth = -2.0` is for four-column data with y errors in the
 form "ylow yhigh".  In this case the boxwidth will be calculated so that each
 box touches the adjacent boxes.  The width will also be calculated in cases
 where three-column data are used.

 The box height is determined from the y error in the same way as it is for
 the `yerrorbars` style---either from y-ydelta to y+ydelta or from ylow to
 yhigh, depending on how many data columns are provided.
 See also
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar demo.
^ </a>
5 boxes
?commands set style boxes
?set style boxes
?plotting styles boxes
?style boxes
?boxes
 The `boxes` style is only relevant to 2-d plotting.  It draws a box centered
 about the given x coordinate from the x axis (not the graph border) to the
 given y coordinate.  The width of the box is obtained in one of three ways.
 If it is a data plot and the data file has a third column, this will be used
 to set the width of the box.  If not, if a width has been set using the `set
 boxwidth` command, this will be used.  If neither of these is available, the
 width of each box will be calculated automatically so that it touches the
 adjacent boxes.

 The interior of the boxes is drawn according to the current fillstyle.
 See `set style fill` for details.  Alternatively a new fillstyle
 may be specified in the plot command.

 For fillstyle `empty` the box is filled with the background color.

 For fillstyle `solid` the box is filled with a solid rectangle of the
 current drawing color. There is an optional parameter <density> that
 controls the fill density; it runs from 0 (background color) to 1
 (current drawing color).

 For fillstyle `pattern` the box is filled in the current drawing color with
 a pattern, if supported by the terminal driver.

 Examples:

 To plot a data file with solid filled boxes with a small vertical space
 separating them (bargraph):

       set boxwidth 0.9 relative
       set style fill solid 1.0
       plot 'file.dat' with boxes

 To plot a sine and a cosine curve in pattern-filled boxes style:

       set style fill pattern
       plot sin(x) with boxes, cos(x) with boxes

 The sin plot will use pattern 0; the cos plot will use pattern 1.
 Any additional plots would cycle through the patterns supported by the
 terminal driver.

 To specify explicit fillstyles for each dataset:

      plot 'file1' with boxes fs solid 0.25, \
           'file2' with boxes fs solid 0.50, \
           'file3' with boxes fs solid 0.75, \
           'file4' with boxes fill pattern 1, \
           'file5' with boxes fill empty

 Currently only the following terminal drivers support fillstyles other
 than `empty`:
 x11, windows, pm, wxt, postscript, fig, pbm, png, gif, hpdj, hppj, hpljii,
 hp500c, jpeg, nec_cp6, epson_180dpi, epson_60dpi, epson_lx800, okidata, starc
 and tandy_60dpi. The BeOS driver (`be`) is untested.
5 boxxyerrorbars
?commands set style boxxyerrorbars
?set style boxxyerrorbars
?plotting styles boxxyerrorbars
?style boxxyerrorbars
?boxxyerrorbars
 The `boxxyerrorbars` style is only relevant to 2-d data plotting.  It is a
 combination of the `boxes` and `xyerrorbars` styles.

 The box width and height are determined from the x and y errors in the same
 way as they are for the `xyerrorbars` style---either from xlow to xhigh and
 from ylow to yhigh, or from x-xdelta to x+xdelta and from y-ydelta to
 y+ydelta , depending on how many data columns are provided.

 If filled-box support is present, then the interior of the boxes is drawn
 according to the current fillstyle.  See `set style fill` and `boxes` for
 details.  Alternatively a new fillstyle may be specified in the plot command.
5 candlesticks
?commands set style candlesticks
?set style candlesticks
?plotting styles candlesticks
?style candlesticks
?candlesticks
 The `candlesticks` style can be used for 2-d data plotting of financial
 data or for generating box-and-whisker plots of statistical data.
 Five columns of data are required; in order, these should be the x
 coordinate (most likely a date) and the opening, low, high, and closing
 prices.  The symbol is a rectangular box, centered horizontally at the x
 coordinate and limited vertically by the opening and closing prices.  A
 vertical line segment at the x coordinate extends up from the top of the
 rectangle to the high price and another down to the low.  The vertical line
 will be unchanged if the low and high prices are interchanged.

 The width of the rectangle can be controlled by the `set boxwidth` command.
 For backwards compatibility with earlier gnuplot versions, when the
 boxwidth parameter has not been set then the width of the candlestick
 rectangle is controlled by `set bars <width>`.

 By default the vertical line segments have no crossbars at the top and
 bottom. If you want crossbars, which are typically used for box-and-whisker
 plots, then add the keyword `whiskerbars` to the plot command.  By default
 these whiskerbars extend the full horizontal width of the candlestick, but
 you can modify this by specifying a fraction of the full width.

 By default the rectangle is empty if (open > close), and filled with three
 vertical bars if (close > open). If filled-boxes support is present, then
 the rectangle is colored according to `set style fill <fillstyle>`.
 See `set bars` and `financebars`.  See also
^ <a href="http://gnuplot.sourceforge.net/demo/candlesticks.html">
 finance demos
^ </a>
 .

 Note: To place additional symbols, such as the median value, on a
 box-and-whisker plot requires additional plot commands as in this example:

   # Data columns: X Min 1stQuartile Median 3rdQuartile Max
   set bars 4.0
   set style fill empty
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
        ''         using 1:4:4:4:4 with candlesticks lt -1 notitle

   # Plot with crossbars on the whiskers, crossbars are 50% of full width
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5

  See `set boxwidth`, `set bars` and `set style fill`.
5 dots
?commands set style dots
?set style dots
?plotting styles dots
?style dots
?dots
 The `dots` style plots a tiny dot at each point; this is useful for scatter
 plots with many points. For some terminals (post, pdf) the size of the dot can
 be controlled by changing the linewidth.
5 filledcurves
?commands set style filledcurves
?set style filledcurves
?plotting styles filledcurves
?style filledcurves
?filledcurves
 The `filledcurves` style is only relevant to 2-d plotting. Three variants
 are possible. The first two variants require either a function or two columns
 of input data, and may be further modified by the options listed below.
 The first variant, `closed`, treats the curve itself as a closed polygon.
 This is the default if there are two columns of input data.

 The second variant is to fill the area between the curve and a given axis,
 a horizontal or vertical line, or a point.

 The third variant requires three columns of input data: the x coordinate and
 two y coordinates corresponding to two curves sampled at the same set of
 x coordinates; the area between the two curves is filled.
 This is the default if there are three or more columns of input data.

 Syntax:

     set style [data | function] filledcurves [option]
     plot ... with filledcurves [option]

 where the option can be

     [closed | {above | below} {x1 | x2 | y1 | y2}[=<a>] | xy=<x>,<y>]

 The first two plot variants can be further modified by the options

     filledcurves closed   ... just filled closed curve,
     filledcurves x1       ... x1 axis,
     filledcurves x2       ... x2 axis, etc for y1 and y2 axes,
     filledcurves y1=0     ... line y=0 (at y1 axis) ie parallel to x1 axis,
     filledcurves y2=42    ... line y=42 (at y2 axis) ie parallel to x2, etc,
     filledcurves xy=10,20 ... point 10,20 of x1,y1 axes (arc-like shape).

 Example of filling the area between two input curves.
^ <a href="http://www.gnuplot.info/demo/fillbetween.html">
 fill between curves demo.
^ </a>

     plot 'data' using 1:2:3 with filledcurves

 The `above` and `below` options apply both to commands of the form
     ... filledcurves above {x1|x2|y1|y2}=<val>
 and to commands of the form
     ... using 1:2:3 with filledcurves below
 In either case the option limits the filled area to one side of the bounding
 line or curve.

 Note: Not all terminal types support this plotting mode.

 Zoom of a filled curve drawn from a datafile may produce empty or incorrect
 area because gnuplot is clipping points and lines, and not areas.

 If the values of <a>, <x>, <y> are out of the drawing boundary, then they
 are moved to the graph boundary. Then the actually filled area in the case
 of option xy=<x>,<y> will depend on xrange and yrange.
5 financebars
?commands set style financebars
?set style financebars
?plotting styles financebars
?style financebars
?financebars
 The `financebars` style is only relevant for 2-d data plotting of financial
 data.  Five columns of data are required; in order, these should be the x
 coordinate (most likely a date) and the opening, low, high, and closing
 prices.  The symbol is a vertical line segment, located horizontally at the x
 coordinate and limited vertically by the high and low prices.  A horizontal
 tic on the left marks the opening price and one on the right marks the
 closing price.  The length of these tics may be changed by `set bars`.  The
 symbol will be unchanged if the high and low prices are interchanged.
 See `set bars` and `candlesticks`, and also the
^ <a href="http://www.gnuplot.info/demo/finance.html">
 finance demo.
^ </a>
5 fsteps
?commands set style fsteps
?set style fsteps
?plotting styles fsteps
?style fsteps
?fsteps
 The `fsteps` style is only relevant to 2-d plotting.  It connects consecutive
 points with two line segments: the first from (x1,y1) to (x1,y2) and the
 second from (x1,y2) to (x2,y2).
 See also
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps demo.
^ </a>
5 histeps
?commands set style histeps
?set style histeps
?plotting styles histeps
?style histeps
?histeps
 The `histeps` style is only relevant to 2-d plotting.  It is intended for
 plotting histograms.  Y-values are assumed to be centered at the x-values;
 the point at x1 is represented as a horizontal line from ((x0+x1)/2,y1) to
 ((x1+x2)/2,y1).  The lines representing the end points are extended so that
 the step is centered on at x.  Adjacent points are connected by a vertical
 line at their average x, that is, from ((x1+x2)/2,y1) to ((x1+x2)/2,y2).

 If `autoscale` is in effect, it selects the xrange from the data rather than
 the steps, so the end points will appear only half as wide as the others.
 See also
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps demo.
^ </a>

 `histeps` is only a plotting style; `gnuplot` does not have the ability to
 create bins and determine their population from some data set.
5 histograms
?commands set style histogram
?set style histogram
?style histograms
?plotting styles histograms
?histograms
 The `histograms` style is only relevant to 2-d plotting.  It produces a bar
 chart from a sequence of data columns in parallel. Each element of the
 `plot` command must specify a single input data source (e.g. one column of
 the input file), possibly with associated tic values or key titles.
 Four styles of histogram layout are currently supported.

       set style histogram clustered {gap <gapsize>}
       set style histogram errorbars {gap <gapsize>} {<linewidth>}
       set style histogram rowstacked
       set style histogram columnstacked

 The default style corresponds to `set style histogram clustered gap 2`.
 In this style, each set of parallel data values is collected into a group of
 boxes clustered at the x-axis coordinate corresponding to their sequential
 position (row #) in the selected datafile columns.  Thus if <n> datacolumns are
 selected, the first cluster is centered about x=1, and contains <n> boxes whose
 heights are taken from the first entry in the corresponding <n> data columns.
 This is followed by a gap and then a second cluster of boxes centered about x=2
 corresponding to the second entry in the respective data columns, and so on.
 The default gap width of 2 indicates that the empty space between clusters is
 equivalent to the width of 2 boxes.  All boxes derived from any one column
 are given the same fill color and/or pattern (see `set style fill`).

 Each cluster of boxes is derived from a single row of the input data file.
 It is common in such input files that the first element of each row is a
 label. Labels from this column may be placed along the x-axis underneath
 the appropriate cluster of boxes with the `xticlabels` option to `using`.

 The `errorbars` style is very similar to the `clustered` style, except that
 it requires two columns of input for each entry. The first column is treated
 as the height (y-value) of that box, exactly as for the `clustered` style.
 The second column is treated as an error magnitude, and used to generate a
 vertical error bar at the top of the box. The appearance of the error bar is
 controlled by the current value of `set bars` and by the optional <linewidth>
 specification.

 Two styles of stacked histogram are supported, chosen by the command
 `set style histogram {rowstacked|columnstacked}`.  In these styles the data
 values from the selected columns are collected into stacks of boxes.
 The default stacking mode is `rowstacked`.

 The `rowstacked` style places a box resting on the x-axis for each
 data value in the first selected column; the first data value results in
 a box a x=1, the second at x=2, and so on.  Boxes corresponding to the
 second and subsequent data columns are layered on top of these, resulting
 in a stack of boxes at x=1 representing the first data value from each
 column, a stack of boxes at x=2 representing the second data value from
 each column, and so on.  All boxes derived from any one column are given the
 same fill color and/or pattern (see `set style fill`).

 The `columnstacked` style is similar, except that each stack of boxes is
 built up from a single data column. Each data value from the first specified
 column yields a box in the stack at x=1, each data value from the second
 specified column yields a box in the stack at x=2, and so on.  In this style
 the color of each box is taken from the row number, rather than the column
 number, of the corresponding data field.

 Box widths may be modified using the `set boxwidth` command.
 Box fill styles may be set using the `set style fill` command.

 Histograms always use the x1 axis, but may use either y1 or y2.
 If a plot contains both histograms and other plot styles, the non-histogram
 plot elements may use either the x1 or the x2 axis.

 Examples:

 To plot a data file containing multiple columns of data as a histogram
 of clustered boxes (the default style):

       set boxwidth 0.9 relative
       set style data histograms
       set style fill solid 1.0 border -1
       plot 'file.dat' using 2, '' using 4, '' using 6

 This will produce a plot with clusters of three boxes (vertical bars) centered
 at each integral value on the x axis.  If the first column of the input file
 contains labels, they may be placed along the x-axis using the variant command

       plot 'file.dat' using 2, '' using 4, '' using 6:xticlabels(1)

 If the file contains both a magnitude and an error estimate for each value,
 then error bars can be added to the plot.  The following commands will add
 error bars extending from (y-<error>) to (y+<error>), capped by horizontal bar
 ends drawn the same width as the box itself. The error bars and bar ends are
 drawn in black with linewidth 2.

       set bars fullwidth
       set style histogram errorbars gap 2 lt -1 lw 2
       plot 'file.dat' using 2:3, '' using 4:5, '' using 6:7:xticlabels(1)

 To plot the same data as a rowstacked histogram:

       set style histogram rows
       plot 'file.dat' using 2, '' using 4, '' using 6:xtic(1)

 This will produce a plot in which each vertical bar contains a stack of three
 segments, corresponding in height to the values found in columns 2, 4 and 6
 of the datafile.

 Finally, the commands

       set style histogram columnstacked
       plot 'file.dat' using 2, '' using 4, '' using 6

 will produce three vertical stacks. The stack at x=1 will contain a box for
 each entry in column 2 of the datafile.  The stack at x=2 will contain a box
 for each parallel entry in column 4 of the datafile, and the stack at x=3 a
 box for each entry of column 6.  Because this interchanges gnuplot's usual
 interpretation of input rows and columns, the specification of key titles and
 x-axis tic labels must also be modified.

       set style histogram columnstacked
       plot '' u 5:key(1)            # uses first column to generate key titles
       plot '' u 5 title columnhead  # uses first row to generate xtic labels
6 newhistogram
?newhistogram
?histograms newhistogram
 More than one set of histograms can appear in a single plot. In this case you
 can force a gap between them, and a separate label for each set, by using the
 plot command `newhistogram {"<title>"} {<linestyle>}`.
 For example

       set style histogram  cluster
       plot newhistogram "Set A", 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B", 'b' using 1, '' using 2, '' using 3

 The labels "Set A" and "Set B" will appear beneath the respective sets of
 histograms, under the overall x axis label.

 The newhistogram command can also be used to force histogram coloring to
 begin with a specific color (linetype). By default colors will continue to
 increment successively even across histogram boundaries. Here is an example
 using the same coloring for multiple histograms
       plot newhistogram "Set A" lt 4, 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B" lt 4, 'b' using 1, '' using 2, '' using 3

5 image
?commands set style image
?set style image
?plotting styles image
?style image
?image
 The `image` style is intendend for plotting 2D images.  It may be used for
 both `plot` and `splot` in the form of 3D data (x,y,value) or projected 4D
 data (x,y,z,value), respectively.  It is assumed that in the viewing plane
 the image data forms an equidistant sampling grid in the viewing plane along
 two, not necessarily  orthogonal, directions.  In other words, groups of
 four adjacent points are assumed to form the same size parallelogram.  The
 variable `value` in the tuples represent a palette color (gray value) for
 indexing in the current palette.

 The `image` style will attempt to create a properly positioned and scaled
 data matrix to match the plot borders for those terminals supporting palettes
 and images.  Such output is efficient and draws quickly.  However, when a
 terminal driver does not support palettes and images, or when image support
 is not implemented, the `image` style reverts to drawing filled rectangular
 boxes for pixels, which is not as efficient.  General parallelogram-shaped
 images currently always have filled parallelograms for pixels.

 The coordinate of each data point of an image will lie at the center of a
 pixel.  That is, an M x N set of data will form an image with M x N pixels.
 This is slightly different than pm3d elements where an M x N set of data
 will form a surface of (M-1) x (N-1) elements.  The scan directions for the
 image data grid can be any of eight possible combinations.

 See also `rgbimage`.
6 image failsafe
?commands set style image failsafe
?set style image failsafe
?plotting styles image failsafe
?style image failsafe
?image failsafe
?failsafe
 Some terminal drivers provide code to optimize rendering of image data
 within a rectangular 2D area.  However this code is known to be imperfect
 (hence the label EXPERIMENTAL for image support in gnuplot version 4.2).
 This optimized code may be disabled by using the keyword `failsafe`. E.g.

       plot 'data' with image failsafe
 
 Here are some specific comments about particular terminal drivers:

 x11 and wxt - Pixels are either repeated or decimated to fit the display
       resolution; no other processing (filtering) is done.  Thus, aliasing may
       occur when decimating images having high spatial frequency content.

 postscript (pslatex, epslatex, pstex) - Image is copied in its original
       resolution, and sample interpolation is turned off.

 See also `rgbimage`.
5 impulses
?commands set style impulses
?set style impulses
?plotting styles impulses
?style impulses
?impulses
 The `impulses` style displays a vertical line from the x axis (not the graph
 border), or from the grid base for `splot`, to each point.
5 labels
?commands set style labels
?set style labels
?plotting styles labels
?style labels
?labels
 The `labels` style is available only if gnuplot is built with configuration
 option --enable-datastrings. For a 2-D plot with labels you must specify
 3 input data columns; the text string found in the third column is printed at
 the X and Y coordinates generated by the first two column specifiers. The
 font, color, rotation angle and other properties of the printed text may be
 specified as additional command options (see `set label`). The example below
 will generate a 2-D plot with text labels taken from column 4 of the input
 file (`tc lt 2` is shorthand for `textcolor linetype 2`, which is green).

   plot 'datafile' using 1:(0.5 * $2):4 with labels font "arial,11" tc lt 2

 The `labels` style can also be used in 3-D plots. In this case four input
 column specifiers are required, corresponding to X Y Z and text.

   splot 'datafile' using 1:2:3:4 with labels

 See also `datastrings`, `set style data`.
5 lines
?commands set style lines
?set style lines
?plotting styles lines
?style lines
?lines
 The `lines` style connects adjacent points with straight line segments.
 See also `linetype`, `linewidth`, and `linestyle`.
5 linespoints
?commands set style linespoints
?commands set style lp
?set style linespoints
?plotting styles linespoints
?set style lp
?style linespoints
?style lp
?linespoints
?lp
 The `linespoints` style does both `lines` and `points`, that is, it draws a
 small symbol at each point and then connects adjacent points with straight
 line segments.  The command `set pointsize` may be used to change the size of
 the points.  See `set pointsize` for its usage.

 `linespoints` may be abbreviated `lp`.
5 points
?commands set style points
?set style points
?plotting styles points
?style points
?points
 The `points` style displays a small symbol at each point.  The command `set
 pointsize` may be used to change the size of the points.  See `set pointsize`
 for its usage.
5 steps
?commands set style steps
?set style steps
?plotting styles steps
?style steps
?steps
 The `steps` style is only relevant to 2-d plotting.  It connects consecutive
 points with two line segments: the first from (x1,y1) to (x2,y1) and the
 second from (x2,y1) to (x2,y2).
 See also
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps demo.
^ </a>
5 rgbimage
?commands set style rgbimage
?set style rgbimage
?plotting styles rgbimage
?style rgbimage
?rgbimage
 The `rgbimage` style is intended for plotting 2D images and is similar
 in concept to `image`.  See `image` for details.  The difference is
 that 5D data (x,y,r,g,b) for `plot` and 6D data (x,y,z,r,g,b) for `splot`
 describe the coordinates and color components of an image.

 See also `image`.
5 vectors
?commands set style vectors
?set style vectors
?plotting styles vectors
?style vectors
?vectors
 The 2D `vectors` style draws a vector from (x,y) to (x+xdelta,y+ydelta).
 Thus it requires four columns of data.  It also draws a small arrowhead at the
 end of the vector.
 The 3D `vectors` style is similar, but requires six columns of data.
 splot with vectors is supported only for `set mapping cartesian`.
 The keywords "with vectors" may be followed by arrow style specifications.
 See `arrowstyle` for more details.

 Example:
       plot 'file.dat' using 1:2:3:4 with vectors head filled lt 2
       splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2

 `set clip one` and `set clip two` affect vectors drawn in 2D.
 Please see `set clip` and `arrowstyle`.
5 xerrorbars
?commands set style xerrorbars
?set style xerrorbars
?plotting styles xerrorbars
?style xerrorbars
?xerrorbars
 The `xerrorbars` style is only relevant to 2-d data plots.  `xerrorbars` is
 like `dots`, except that a horizontal error bar is also drawn.  At each point
 (x,y), a line is drawn from (xlow,y) to (xhigh,y) or from (x-xdelta,y) to
 (x+xdelta,y), depending on how many data columns are provided.  A tic mark
 is placed at the ends of the error bar (unless `set bars` is used---see
 `set bars` for details).
5 xyerrorbars
?commands set style xyerrorbars
?set style xyerrorbars
?plotting styles xyerrorbars
?style xyerrorbars
?xyerrorbars
 The `xyerrorbars` style is only relevant to 2-d data plots.  `xyerrorbars` is
 like `dots`, except that horizontal and vertical error bars are also drawn.
 At each point (x,y), lines are drawn from (x,y-ydelta) to (x,y+ydelta) and
 from (x-xdelta,y) to (x+xdelta,y) or from (x,ylow) to (x,yhigh) and from
 (xlow,y) to (xhigh,y), depending upon the number of data columns provided.  A
 tic mark is placed at the ends of the error bar (unless `set bars` is
 used---see `set bars` for details).

 If data are provided in an unsupported mixed form, the `using` filter on the
 `plot` command should be used to set up the appropriate form.  For example,
 if the data are of the form (x,y,xdelta,ylow,yhigh), then you can use

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars
5 yerrorbars
?commands set style yerrorbars
?commands set style errorbars
?plotting styles yerrorbars
?plotting styles errorbars
?set style yerrorbars
?set style errorbars
?style yerrorbars
?style errorbars
?yerrorbars
 The `yerrorbars` (or `errorbars`) style is only relevant to 2-d data plots.
 `yerrorbars` is like `points`, except that a vertical error bar is also drawn.
 At each point (x,y), a line is drawn from (x,y-ydelta) to (x,y+ydelta) or
 from (x,ylow) to (x,yhigh), depending on how many data columns are provided.
 A tic mark is placed at the ends of the error bar (unless `set bars` is
 used---see `set bars` for details).
 See also
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar demo.
^ </a>
5 xerrorlines
?commands set style xerrorlines
?set style xerrorlines
?plotting styles xerrorlines
?style xerrorlines
?xerrorlines
 The `xerrorlines` style is only relevant to 2-d data plots.
 `xerrorlines` is like `linespoints`, except that a horizontal error
 line is also drawn. At each point (x,y), a line is drawn from (xlow,y)
 to (xhigh,y) or from (x-xdelta,y) to (x+xdelta,y), depending on how
 many data columns are provided. A tic mark is placed at the ends of
 the error bar (unless `set bars` is used---see `set bars` for details).
5 xyerrorlines
?commands set style xyerrorlines
?set style xyerrorlines
?plotting styles xyerrorlines
?style xyerrorlines
?xyerrorlines
 The `xyerrorlines` style is only relevant to 2-d data plots.
 `xyerrorlines` is like `linespoints`, except that horizontal and
 vertical error bars are also drawn. At each point (x,y), lines are
 drawn from (x,y-ydelta) to (x,y+ydelta) and from (x-xdelta,y) to
 (x+xdelta,y) or from (x,ylow) to (x,yhigh) and from (xlow,y) to
 (xhigh,y), depending upon the number of data columns provided. A tic
 mark is placed at the ends of the error bar (unless `set bars` is
 used---see `set bars` for details).

 If data are provided in an unsupported mixed form, the `using` filter on the
 `plot` command should be used to set up the appropriate form.  For example,
 if the data are of the form (x,y,xdelta,ylow,yhigh), then you can use

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines
5 yerrorlines
?commands set style yerrorlines
?commands set style errorlines
?plotting styles yerrorlines
?plotting styles errorlines
?set style yerrorlines
?set style errorlines
?style yerrorlines
?style errorlines
?yerrorlines
 The `yerrorlines` (or `errorlines`) style is only relevant to 2-d data
 plots. `yerrorlines` is like `linespoints`, except that a vertical
 error line is also drawn. At each point (x,y), a line is drawn from
 (x,y-ydelta) to (x,y+ydelta) or from (x,ylow) to (x,yhigh), depending
 on how many data columns are provided. A tic mark is placed at the
 ends of the error bar (unless `set bars` is used---see `set bars` for
 details).
 See also
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar demo.
^ </a>
3 surface
?commands set surface
?commands unset surface
?commands show surface
?set surface
?unset surface
?show surface
?surface
?nosurface
 The command `set surface` controls the display of surfaces by `splot`.

 Syntax:
       set surface
       unset surface
       show surface

 The surface is drawn with the style specified by `with`, or else the
 appropriate style, data or function.

 Whenever `unset surface` is issued, `splot` will not draw points or lines
 corresponding to the function or data file points.  Contours may still be
 drawn on the surface, depending on the `set contour` option. `unset surface;
 set contour base` is useful for displaying contours on the grid base.  See
 also `set contour`.
3 table
?commands set table
?set table
?table
 When `table` mode is enabled, `plot` and `splot` commands print out a
 multicolumn ASCII table of X Y {Z} R values rather than creating an actual
 plot on the current terminal.  The character R takes on one of three values:
 "i" if the point is in the active range, "o" if it is out-of-range, or "u"
 if it is undefined.  The data format is determined by the format of the axis
 labels (see `set format`), and the columns are separated by single spaces.
 This can be useful if you want to generate contours and then save them for
 further use, perhaps for plotting with `plot`;  see `set contour` for example.
 The same method can be used to save interpolated data
 (see `set samples` and `set dgrid3d`).

 Syntax:
       set table {"outfile"}
       plot <whatever>
       unset table

 Tabular output is written to the named file, if any, otherwise it is written
 to the current value of `set output`.  You must explicitly `unset table`
 in order to go back to normal plotting on the current terminal.
3 terminal
?commands set terminal
?commands show terminal
?set terminal
?set term
?show terminal
?show term
?set terminal push
?set term push
?terminal push
?term push
?push
?set terminal pop
?set term pop
?terminal pop
?term pop
?pop
 `gnuplot` supports many different graphics devices.  Use `set terminal` to
 tell `gnuplot` what kind of output to generate. Use `set output` to redirect
 that output to a file or device.

 Syntax:
       set terminal {<terminal-type> | push | pop}
       show terminal

 If <terminal-type> is omitted, `gnuplot` will list the available terminal
 types.  <terminal-type> may be abbreviated.

 If both `set terminal` and `set output` are used together, it is safest to
 give `set terminal` first, because some terminals set a flag which is needed
 in some operating systems.

 Several terminals have many additional options.  For example, see `png`,
 or `postscript`.
 The options used by a previous invocation `set term <term> <options>` of a
 given `<term>` are remembered, thus subsequent `set term <term>` does
 not reset them.  This helps in printing, for instance, when switching
 among different terminals---previous options don't have to be repeated.

 The command `set term push` remembers the current terminal including its
 settings while `set term pop` restores it. This is equivalent to `save term`
 and `load term`, but without accessing the filesystem. Therefore they can be
 used to achieve platform independent restoring of the terminal after printing,
 for instance. After gnuplot's startup, the default terminal or that from
 `startup` file is pushed automatically. Therefore portable scripts can rely
 that `set term pop` restores the default terminal on a given platform unless
 another terminal has been pushed explicitly.

 For a complete list of available terminal types, see `terminal`.
3 termoption
?commands set termoption
?set termoption
?termoption
 The `set termoption` command allows you to change the behaviour of the
 current terminal without requiring a new `set terminal` command. Only one
 option can be changed per command, and only a small number of options can
 be changed this way. Currently the only options accepted are

      set termoption {no}enhanced
      set termoption font "<fontname>{,<fontsize>}"

3 tics
?commands set tics
?commands unset tics
?commands show tics
?set tics
?unset tics
?show tics
?tics
 Control of the major (labelled) tics on all axes at once is possible with the
 `set tics` command.

 Fine control of the major (labelled) tics on all axes at once is possible
 with the `set tics` command.  The tics may be turned off with the `unset tics`
 command, and may be turned on (the default state) with `set tics`.  Similar
 commands (by preceding 'tics' by the axis name) control the major tics on a
 single axis.

 Syntax:
       set tics {axis | border} {{no}mirror}
                {in | out} {scale {default | <major> {,<minor>}}}
                {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                { font "name{,<size>}" }
                { textcolor <colorspec> }
       set tics {front | back}
       unset tics
       show tics

 The options in the first set above can be applied individually to
 any or all axes, i.e., x, y, z, x2, y2, and cb.

 Set tics `front` or `back` applies to all axes at once, but only for 2D plots
 (not splot).  It controls whether the tics are placed behind or in front of
 the plot elements, in the case that there is overlap.

 `axis` or `border` tells `gnuplot` to put the tics (both the tics themselves
 and the accompanying labels) along the axis or the border, respectively.  If
 the axis is very close to the border, the `axis` option will move the
 tic labels to outside the border in case the border is printed (see
 `set border`).  The relevant margin settings will usually be sized badly by
 the automatic layout algorithm in this case.

 `mirror` tells `gnuplot` to put unlabelled tics at the same positions on the
 opposite border.  `nomirror` does what you think it does.

 `in` and `out` change the tic marks to be drawn inwards or outwards.

 With `scale`, the size of the tic marks can be adjusted. If <minor> is not
 specified, it is 0.5*<major>.  The default size 1.0 for major tics and 0.5
 for minor tics is requested by `scale default`.

 `rotate` asks `gnuplot` to rotate the text through 90 degrees, which will be
 done if the terminal driver in use supports text rotation.  `norotate`
 cancels this. `rotate by <ang>` asks for rotation by <ang> degrees, supported
 by some terminal types.

 The defaults are `border mirror norotate` for tics on the x and y axes, and
 `border nomirror norotate` for tics on the x2 and y2 axes.  For the z axis,
 the default is `nomirror`.

 The <offset> is specified by either x,y or x,y,z, and may be preceded by
 `first`, `second`, `graph`, `screen`, or `character` to select the
 coordinate system. <offset> is the offset of the tics texts from their
 default positions, while the default coordinate system is `character`.
 See `coordinates` for details. `nooffset` switches off the offset.

 `set tics` with no options restores to place tics inwards. Every other
 options are retained.

 See also `set xtics` for more control of major (labelled) tic marks and
 `set mxtics` for control of minor tic marks.  These commands provide control
 at a axis by axis basis.
3 ticslevel
 See `set xyplane`.
3 ticscale
?commands set ticscale
?commands show ticscale
?set ticscale
?show ticscale
?ticscale
 The `set ticscale` command is deprecated, use `set tics scale` instead.
3 timestamp
?commands set timestamp
?commands unset timestamp
?commands show timestamp
?set timestamp
?unset timestamp
?show timestamp
?timestamp
?notimestamp
 The command `set timestamp` places the time and date of the plot in the left
 margin.

 Syntax:
       set timestamp {"<format>"} {top|bottom} {{no}rotate}
                     {offset {<xoff>}{,<yoff>}} {font "<fontspec>"}
       unset timestamp
       show timestamp

 The format string allows you to choose the format used to write the date and
 time.  Its default value is what asctime() uses: "%a %b %d %H:%M:%S %Y"
 (weekday, month name, day of the month, hours, minutes, seconds, four-digit
 year).  With `top` or `bottom` you can place the timestamp at the top or
 bottom of the left margin (default: bottom).  `rotate` lets you write the
 timestamp vertically, if your terminal supports vertical text.  The constants
 <xoff> and <yoff> are offsets that let you adjust the position more finely.
 <font> is used to specify the font with which the time is to be written.

 The abbreviation `time` may be used in place of `timestamp`.

 Example:
       set timestamp "%d/%m/%y %H:%M" offset 80,-2 font "Helvetica"

 See `set timefmt` for more information about time format strings.
3 timefmt
?commands set timefmt
?commands show timefmt
?set timefmt
?show timefmt
?timefmt
 This command applies to timeseries where data are composed of dates/times.
 It has no meaning unless the command `set xdata time` is given also.

 Syntax:
       set timefmt "<format string>"
       show timefmt

 The string argument tells `gnuplot` how to read timedata from the datafile.
 The valid formats are:

@start table - first is interactive cleartext form
       Format       Explanation
       %d           day of the month, 1--31
       %m           month of the year, 1--12
       %y           year, 0--99
       %Y           year, 4-digit
       %j           day of the year, 1--365
       %H           hour, 0--24
       %M           minute, 0--60
       %s           seconds since the Unix epoch (1970-01-01, 00:00 UTC)
       %S           second, 0--60
       %b           three-character abbreviation of the name of the month
       %B           name of the month
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{Time Series timedata Format Specifiers}\\
#\hline \hline
#Format & Explanation \\ \hline
#\verb@%d@ & day of the month, 1--31 \\
#\verb@%m@ & month of the year, 1--12 \\
#\verb@%y@ & year, 0--99 \\
#\verb@%Y@ & year, 4-digit \\
#\verb@%j@ & day of the year, 1--365 \\
#\verb@%H@ & hour, 0--24 \\
#\verb@%M@ & minute, 0--60 \\
#\verb@%s@ & seconds since the Unix epoch (1970-01-01 00:00 UTC) \\
#\verb@%S@ & second, 0--60 \\
#\verb@%b@ & three-character abbreviation of the name of the month \\
#\verb@%B@ & name of the month \\
%c l .
%Format@Explanation
%_
%%d@day of the month, 1--31
%%m@month of the year, 1--12
%%y@year, 0--99
%%Y@year, 4-digit
%%j@day of the year, 1--365
%%H@hour, 0--24
%%M@minute, 0--60
%%s@seconds since the Unix epoch (1970-01-01 00:00 UTC)
%%S@second, 0--60
%%b@three-character abbreviation of the name of the month
%%B@name of the month
%_
@end table
 Any character is allowed in the string, but must match exactly.  \t (tab) is
 recognized.  Backslash-octals (\nnn) are converted to char.  If there is no
 separating character between the time/date elements, then %d, %m, %y, %H, %M
 and %S read two digits each, %Y reads four digits and %j reads three digits.
 %b requires three characters, and %B requires as many as it needs.

 Spaces are treated slightly differently.  A space in the string stands for
 zero or more whitespace characters in the file.  That is, "%H %M" can be used
 to read "1220" and "12     20" as well as "12 20".

 Each set of non-blank characters in the timedata counts as one column in the
 `using n:n` specification.  Thus `11:11  25/12/76  21.0` consists of three
 columns.  To avoid confusion, `gnuplot` requires that you provide a complete
 `using` specification if your file contains timedata.

 Since `gnuplot` cannot read non-numerical text, if the date format includes
 the day or month in words, the format string must exclude this text.  But
 it can still be printed with the "%a", "%A", "%b", or "%B" specifier:
 see `set format` for more details about these and other options for printing
 timedata.  (`gnuplot` will determine the proper month and weekday from the
 numerical values.)

 See also `set xdata` and `Time/date` for more information.

 Example:
       set timefmt "%d/%m/%Y\t%H:%M"
 tells `gnuplot` to read date and time separated by tab.  (But look closely at
 your data---what began as a tab may have been converted to spaces somewhere
 along the line; the format string must match what is actually in the file.)
 See also
^ <a href="http://www.gnuplot.info/demo/timedat.html">
 time data demo.
^ </a>
3 title
?commands set title
?commands show title
?set title
?show title
?title
 The `set title` command produces a plot title that is centered at the top of
 the plot.  `set title` is a special case of `set label`.

 Syntax:
       set title {"<title-text>"} {offset <offset>} {font "<font>{,<size>}"}
                 {{textcolor | tc} {<colorspec> | default}} {{no}enhanced}
       show title

 If <offset> is specified by either x,y or x,y,z the title is moved by the
 given offset.  It may be preceded by `first`, `second`, `graph`, `screen`,
 or `character` to select the coordinate system.  See `coordinates` for
 details.  By default, the `character` coordinate system is used.  For
 example, "`set title offset 0,-1`" will change only the y offset of the
 title, moving the title down by roughly the height of one character.  The
 size of a character depends on both the font and the terminal.

 <font> is used to specify the font with which the title is to be written;
 the units of the font <size> depend upon which terminal is used.

 `textcolor <colorspec>` changes the color of the text. <colorspec> can be a
 linetype, an rgb color, or a palette mapping. See help for `colorspec` and
 `palette`.

 `noenhanced` requests that the title not be processed by the enhanced text
 mode parser, even if enhanced text mode is currently active.

 `set title` with no parameters clears the title.

 See `syntax` for details about the processing of backslash sequences and
 the distinction between single- and double-quotes.
3 tmargin
?commands set tmargin
?set tmargin
?tmargin
 The command `set tmargin` sets the size of the top margin.
 Please see `set margin` for details.
3 trange
?commands set trange
?commands show trange
?set trange
?show trange
?trange
 The `set trange` command sets the parametric range used to compute x and y
 values when in parametric or polar modes.  Please see `set xrange` for
 details.
3 urange
?commands set urange
?commands show urange
?set urange
?show urange
?urange
 The `set urange` and `set vrange` commands set the parametric ranges used
 to compute x, y, and z values when in `splot` parametric mode.
 Please see `set xrange` for details.
3 variables
?commands show variables
?show variables
 The `show variables` command lists all user-defined variables and their
 values.

 Syntax:
       show variables {all}

 With the optional keyword "all", also the `gnuplot-defined variables` that
 begin with `GPVAL_` are listed.

3 version
?show version
 The `show version` command lists the version of gnuplot being run, its last
 modification date, the copyright holders, and email addresses for the FAQ,
 the gnuplot-info mailing list, and reporting bugs--in short, the information
 listed on the screen when the program is invoked interactively.

 Syntax:
       show version {long}

 When the `long` option is given, it also lists the operating system, the
 compilation options used when `gnuplot` was installed, the location of the
 help file, and (again) the useful email addresses.
3 view
?commands set view
?commands show view
?set view
?set view map
?show view
?view
 The `set view` command sets the viewing angle for `splot`s.  It controls how
 the 3-d coordinates of the plot are mapped into the 2-d screen space.  It
 provides controls for both rotation and scaling of the plotted data, but
 supports orthographic projections only.  It supports both 3D projection or
 orthogonal 2D projection into a 2D plot-like map.

 Syntax:
       set view { <rot_x>{,{<rot_z>}{,{<scale>}{,<scale_z>}}} | map }
       show view

 where <rot_x> and <rot_z> control the rotation angles (in degrees) in a
 virtual 3-d coordinate system aligned with the screen such that initially
 (that is, before the rotations are performed) the screen horizontal axis is
 x, screen vertical axis is y, and the axis perpendicular to the screen is z.
 The first rotation applied is <rot_x> around the x axis.  The second rotation
 applied is <rot_z> around the new z axis.

 Command `set view map` is used to represent the drawing as a map. It can be
 used for `contour` plots, or for color `pm3d` maps. In the latter, take care
 that you properly use `zrange` and `cbrange` for input data point filtering
 and color range scaling, respectively.

 <rot_x> is bounded to the [0:180] range with a default of 60 degrees, while
 <rot_z> is bounded to the [0:360] range with a default of 30 degrees.
 <scale> controls the scaling of the entire `splot`, while <scale_z> scales
 the z axis only.  Both scales default to 1.0.

 Examples:
       set view 60, 30, 1, 1
       set view ,,0.5

 The first sets all the four default values.  The second changes only scale,
 to 0.5.

 See also `set ticslevel`.
3 vrange
?commands set vrange
?commands show vrange
?set vrange
?show vrange
?vrange
 The `set urange` and `set vrange` commands set the parametric ranges used
 to compute x, y, and z values when in `splot` parametric mode.
 Please see `set xrange` for details.
3 x2data
?commands set x2data
?commands show x2data
?set x2data
?show x2data
?x2data
 The `set x2data` command sets data on the x2 (top) axis to timeseries
 (dates/times).  Please see `set xdata`.
3 x2dtics
?commands set x2dtics
?commands unset x2dtics
?commands show x2dtics
?set x2dtics
?unset x2dtics
?show x2dtics
?x2dtics
?nox2dtics
 The `set x2dtics` command changes tics on the x2 (top) axis to days of the
 week.  Please see `set xdtics` for details.
3 x2label
?commands set x2label
?commands show x2label
?set x2label
?show x2label
?x2label
 The `set x2label` command sets the label for the x2 (top) axis.
 Please see `set xlabel`.
3 x2mtics
?commands set x2mtics
?commands unset x2mtics
?commands show x2mtics
?set x2mtics
?unset x2mtics
?show x2mtics
?x2mtics
?nox2mtics
 The `set x2mtics` command changes tics on the x2 (top) axis to months of the
 year.  Please see `set xmtics` for details.
3 x2range
?commands set x2range
?commands show x2range
?set x2range
?show x2range
?x2range
 The `set x2range` command sets the horizontal range that will be displayed on
 the x2 (top) axis.  Please see `set xrange` for details.
3 x2tics
?commands set x2tics
?commands unset x2tics
?commands show x2tics
?set x2tics
?unset x2tics
?show x2tics
?x2tics
?nox2tics
 The `set x2tics` command controls major (labelled) tics on the x2 (top) axis.
 Please see `set xtics` for details.
3 x2zeroaxis
?commands set x2zeroaxis
?commands unset x2zeroaxis
?commands show x2zeroaxis
?set x2zeroaxis
?unset x2zeroaxis
?show x2zeroaxis
?x2zeroaxis
?nox2zeroaxis
 The `set x2zeroaxis` command draws a line at the origin of the x2 (top) axis
 (y2 = 0).  For details, please see `set zeroaxis`.
3 xdata
?commands set xdata
?commands show xdata
?set xdata
?show xdata
?xdata
 This command sets the datatype on the x axis to time/date.  A similar command
 does the same thing for each of the other axes.

 Syntax:
       set xdata {time}
       show xdata

 The same syntax applies to `ydata`, `zdata`, `x2data`, `y2data` and `cbdata`.

 The `time` option signals that the datatype is indeed time/date.  If the
 option is not specified, the datatype reverts to normal.

 See `set timefmt` to tell gnuplot how to read date or time data.  The
 time/date is converted to seconds from start of the century.  There is
 currently only one timefmt, which implies that all the time/date columns must
 conform to this format.  Specification of ranges should be supplied as quoted
 strings according to this format to avoid interpretation of the time/date as
 an expression.

 The function 'strftime' (type "man strftime" on unix to look it up) is used
 to print tic-mark labels.  `gnuplot` tries to figure out a reasonable format
 for this  unless the `set format x "string"` has supplied something that does
 not look like a decimal format (more than one '%' or neither %f nor %g).

 See also `Time/date` for more information.
3 xdtics
?commands set xdtics
?commands unset xdtics
?commands show xdtics
?set xdtics
?unset xdtics
?show xdtics
?xdtics
?noxdtics
 The `set xdtics` commands converts the x-axis tic marks to days of the week
 where 0=Sun and 6=Sat.  Overflows are converted modulo 7 to dates.  `set
 noxdtics` returns the labels to their default values.  Similar commands do
 the same things for the other axes.

 Syntax:
       set xdtics
       unset xdtics
       show xdtics

 The same syntax applies to `ydtics`, `zdtics`, `x2dtics`, `y2dtics` and
 `cbdtics`.

 See also the `set format` command.
3 xlabel
?commands set xlabel
?commands show xlabel
?set xlabel
?show xlabel
?xlabel
 The `set xlabel` command sets the x axis label.  Similar commands set labels
 on the other axes.

 Syntax:
       set xlabel {"<label>"} {offset <offset>} {font "<font>{,<size>}"}
                  {{textcolor | tc} {lt <line_type> | default}} {{no}enhanced}
                  {rotate by <degrees>}
       show xlabel

 The same syntax applies to `x2label`, `ylabel`, `y2label`, `zlabel` and
 `cblabel`.

 If <offset> is specified by either x,y or x,y,z the label is moved by the
 given offset.  It may be preceded by `first`, `second`, `graph`, `screen`,
 or `character` to select the coordinate system.  See `coordinates` for
 details.  By default, the `character` coordinate system is used.  For
 example, "`set xlabel offset -1,0`" will change only the x offset of the
 title, moving the label roughly one character width to the left.  The size
 of a character depends on both the font and the terminal.

 <font> is used to specify the font in which the label is written; the units
 of the font <size> depend upon which terminal is used.

 `textcolor lt <n>` sets the text color to that of line type <n>.

 `noenhanced` requests that the label text not be processed by the enhanced text
 mode parser, even if enhanced text mode is currently active.

 To clear a label, put no options on the command line, e.g., "`set y2label`".

 The default positions of the axis labels are as follows:

 xlabel:  The x-axis label is centered below the bottom axis.

 ylabel:  The position of the y-axis label depends on the terminal, and can be
 one of the following three positions:

 1. Horizontal text flushed left at the top left of the plot.  Terminals that
 cannot rotate text will probably use this method.  If `set x2tics` is also
 in use, the ylabel may overwrite the left-most x2tic label.  This may be
 remedied by adjusting the ylabel position or the left margin.

 2. Vertical text centered vertically at the left of the plot.  Terminals
 that can rotate text will probably use this method.

 3. Horizontal text centered vertically at the left of the plot.  The EEPIC,
 LaTeX and TPIC drivers use this method.  The EEPIC driver will produce a
 stack of characters so as not to overwrite the plot. With other drivers
 (such as LaTeX and TPIC), the user probably has to insert line breaks
 using \\ to prevent the ylabel from overwriting the plot.

 zlabel: The z-axis label is centered along the z axis and placed in the space
 above the grid level.

 cblabel: The color box axis label is centered along the box and placed below
 or right according to horizontal or vertical color box gradient.

 y2label: The y2-axis label is placed to the right of the y2 axis.  The
 position is terminal-dependent in the same manner as is the y-axis label.

 x2label: The x2-axis label is placed above the top axis but below the plot
 title.  It is also possible to create an x2-axis label by using new-line
 characters to make a multi-line plot title, e.g.,

       set title "This is the title\n\nThis is the x2label"

 Note that double quotes must be used.  The same font will be used for both
 lines, of course.

 The y and y2 axis labels can be explicitly rotated from their default
 orientation, but this applies only to 2D plots and only on terminals
 that support text rotation.

 If you are not satisfied with the default position of an axis label, use `set
 label` instead--that command gives you much more control over where text is
 placed.

 Please see `syntax` for further information about backslash processing
 and the difference between single- and double-quoted strings.
3 xmtics
?commands set xmtics
?commands unset xmtics
?commands show xmtics
?set xmtics
?unset xmtics
?show xmtics
?xmtics
?noxmtics
 The `set xmtics` command converts the x-axis tic marks to months of the
 year where 1=Jan and 12=Dec.  Overflows are converted modulo 12 to months.
 The tics are returned to their default labels by `unset xmtics`.  Similar
 commands perform the same duties for the other axes.

 Syntax:
       set xmtics
       unset xmtics
       show xmtics

 The same syntax applies to `x2mtics`, `ymtics`, `y2mtics`, `zmtics` and
 `cbmtics`.

 See also the `set format` command.
3 xrange
?commands set xrange
?commands show xrange
?set xrange
?show xrange
?writeback
?restore
?xrange
 The `set xrange` command sets the horizontal range that will be displayed.
 A similar command exists for each of the other axes, as well as for the
 polar radius r and the parametric variables t, u, and v.

 Syntax:
       set xrange { [{{<min>}:{<max>}}] {{no}reverse} {{no}writeback} }
                  | restore
       show xrange

 where <min> and <max> terms are constants, expressions or an asterisk to set
 autoscaling.  If the data are time/date, you must give the range as a quoted
 string according to the `set timefmt` format.  Any value omitted will not be
 changed.

 The same syntax applies to `yrange`, `zrange`, `x2range`, `y2range`, `cbrange`,
 `rrange`, `trange`, `urange` and `vrange`.

 The `reverse` option reverses the direction of the axis, e.g., `set xrange
 [0:1] reverse` will produce an axis with 1 on the left and 0 on the right.
 This is identical to the axis produced by `set xrange [1:0]`, of course.
 `reverse` is intended primarily for use with `autoscale`.

 The `writeback` option essentially saves the range found by `autoscale` in
 the buffers that would be filled by `set xrange`.  This is useful if you wish
 to plot several functions together but have the range determined by only
 some of them.  The `writeback` operation is performed during the `plot`
 execution, so it must be specified before that command.  To restore,
 the last saved horizontal range use `set xrange restore`.  For example,

       set xrange [-10:10]
       set yrange [] writeback
       plot sin(x)
       set yrange restore
       replot x/2

 results in a yrange of [-1:1] as found only from the range of sin(x); the
 [-5:5] range of x/2 is ignored.  Executing `show yrange` after each command
 in the above example should help you understand what is going on.

 In 2-d, `xrange` and `yrange` determine the extent of the axes, `trange`
 determines the range of the parametric variable in parametric mode or the
 range of the angle in polar mode.  Similarly in parametric 3-d, `xrange`,
 `yrange`, and `zrange` govern the axes and `urange` and `vrange` govern the
 parametric variables.

 In polar mode, `rrange` determines the radial range plotted.  <rmin> acts as
 an additive constant to the radius, whereas <rmax> acts as a clip to the
 radius---no point with radius greater than <rmax> will be plotted.  `xrange`
 and `yrange` are affected---the ranges can be set as if the graph was of
 r(t)-rmin, with rmin added to all the labels.

 Any range may be partially or totally autoscaled, although it may not make
 sense to autoscale a parametric variable unless it is plotted with data.

 Ranges may also be specified on the `plot` command line.  A range given on
 the plot line will be used for that single `plot` command; a range given by
 a `set` command will be used for all subsequent plots that do not specify
 their own ranges.  The same holds true for `splot`.

 Examples:

 To set the xrange to the default:
       set xrange [-10:10]

 To set the yrange to increase downwards:
       set yrange [10:-10]

 To change zmax to 10 without affecting zmin (which may still be autoscaled):
       set zrange [:10]

 To autoscale xmin while leaving xmax unchanged:
       set xrange [*:]
3 xtics
?commands set xtics
?commands unset xtics
?commands show xtics
?set xtics
?unset xtics
?show xtics
?xtics
?noxtics
 Fine control of the major (labelled) tics on the x axis is possible with the
 `set xtics` command.  The tics may be turned off with the `unset xtics`
 command, and may be turned on (the default state) with `set xtics`.  Similar
 commands control the major tics on the y, z, x2 and y2 axes.

 Syntax:
       set xtics {axis | border} {{no}mirror}
                 {in | out} {scale {default | <major> {,<minor>}}}
                 {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                 {add}
                 {  autofreq
                  | <incr>
                  | <start>, <incr> {,<end>}
                  | ({"<label>"} <pos> {<level>} {,{"<label>"}...) }
                 { font "name{,<size>}" }
                 { textcolor <colorspec> }
       unset xtics
       show xtics

 The same syntax applies to `ytics`, `ztics`, `x2tics`, `y2tics` and `cbtics`.

 `axis` or `border` tells `gnuplot` to put the tics (both the tics themselves
 and the accompanying labels) along the axis or the border, respectively.  If
 the axis is very close to the border, the `axis` option will move the
 tic labels to outside the border.  The relevant margin settings will usually
 be sized badly by the automatic layout algorithm in this case.

 `mirror` tells `gnuplot` to put unlabelled tics at the same positions on the
 opposite border.  `nomirror` does what you think it does.

 `in` and `out` change the tic marks to be drawn inwards or outwards.

 With `scale`, the size of the tic marks can be adjusted. If <minor> is not
 specified, it is 0.5*<major>.  The default size 1.0 for major tics and 0.5
 for minor tics is requested by `scale default`.

 `rotate` asks `gnuplot` to rotate the text through 90 degrees, which will be
 done if the terminal driver in use supports text rotation.  `norotate`
 cancels this. `rotate by <ang>` asks for rotation by <ang> degrees, supported
 by some terminal types.

 The defaults are `border mirror norotate` for tics on the x and y axes, and
 `border nomirror norotate` for tics on the x2 and y2 axes.  For the z axis,
 the `{axis | border}` option is not available and the default is
 `nomirror`.  If you do want to mirror the z-axis tics, you might want to
 create a bit more room for them with `set border`.

 The <offset> is specified by either x,y or x,y,z, and may be preceded by
 `first`, `second`, `graph`, `screen`, or `character` to select the
 coordinate system. <offset> is the offset of the tics texts from their
 default positions, while the default coordinate system is `character`.
 See `coordinates` for details. `nooffset` switches off the offset.

 Example:

 Move xtics more closely to the plot.
       set xtics offset 0,graph 0.05

 `set xtics` with no options restores the default border or axis if xtics are
 being displayed;  otherwise it has no effect.  Any previously specified tic
 frequency or position {and labels} are retained.

 Positions of the tics are calculated automatically by default or if the
 `autofreq` option is given; otherwise they may be specified in either of
 two forms:

 The implicit <start>, <incr>, <end> form specifies that a series of tics will
 be plotted on the axis between the values <start> and <end> with an increment
 of <incr>.  If <end> is not given, it is assumed to be infinity.  The
 increment may be negative.  If neither <start> nor <end> is given, <start> is
 assumed to be negative infinity, <end> is assumed to be positive infinity,
 and the tics will be drawn at integral multiples of <incr>.  If the axis is
 logarithmic, the increment will be used as a multiplicative factor.

 If you specify to a negative <start> or <incr> after a numerical value
 (e.g., `rotate by <angle>` or `offset <offset>`), the parser fails because
 it subtracts <start> or <incr> from that value.  As a workaround, specify
 `0-<start>` resp. `0-<incr>` in that case.

 Example:
       set xtics border offset 0,0.5 -5,1,5
 Fails with 'invalid expression' at the last comma.
       set xtics border offset 0,0.5 0-5,1,5
 or
       set xtics offset 0,0.5 border -5,1,5
 Sets tics at the border, tics text with an offset of 0,0.5 characters, and
 sets the start, increment, and end to -5, 1, and 5, as requested.

 The `set grid` options 'front', 'back' and 'layerdefault' affect the drawing
 order of the xtics, too.

 Examples:

 Make tics at 0, 0.5, 1, 1.5, ..., 9.5, 10.
       set xtics 0,.5,10

 Make tics at ..., -10, -5, 0, 5, 10, ...
       set xtics 5

 Make tics at 1, 100, 1e4, 1e6, 1e8.
       set logscale x; set xtics 1,100,1e8

 The explicit ("<label>" <pos> <level>, ...) form allows arbitrary tic
 positions or non-numeric tic labels.  In this form, the tics do not
 need to be listed in numerical order.  Each tic has a
 position, optionally with a label.  Note that the label is
 a string enclosed by quotes.  It may be a constant string, such as
 "hello", may contain formatting information for converting the
 position into its label, such as "%3f clients", or may be empty, "".
 See `set format` for more information.  If no string is given, the
 default label (numerical) is used.

 An explicit tic mark has a third parameter, the "level".  The default
 is level 0, a major tic.  A level of 1 generates a minor tic.  If the
 level is specified, then the label must also be supplied.

 Examples:
       set xtics ("low" 0, "medium" 50, "high" 100)
       set xtics (1,2,4,8,16,32,64,128,256,512,1024)
       set ytics ("bottom" 0, "" 10, "top" 20)
       set ytics ("bottom" 0, "" 10 1, "top" 20)

 In the second example, all tics are labelled.  In the third, only the end
 tics are labelled.  In the fourth, the unlabeled tic is a minor tic.

 Normally if explicit tics are given, they are used instead of auto-generated
 tics. Conversely if you specify `set xtics auto` or the like it will erase
 any previously specified explicit tics. You can mix explicit and auto-
 generated tics by using the keyword `add`, which must appear before
 the tic style being added.

 Example:
       set xtics 0,.5,10
       set xtics add ("Pi" 3.14159)

 This will automatically generate tic marks every 0.5 along x, but will
 also add an explicit labeled tic mark at pi.

 However they are specified, tics will only be plotted when in range.

 Format (or omission) of the tic labels is controlled by `set format`, unless
 the explicit text of a label is included in the `set xtics ("<label>")` form.

 Minor (unlabelled) tics can be added automatically by the `set mxtics`
 command, or at explicit positions by the `set xtics ("" <pos> 1, ...)` form.

 In case of timeseries data, position values must be given as quoted dates
 or times according to the format `timefmt`.  If the <start>, <incr>, <end>
 form is used, <start> and <end> must be given according to `timefmt`, but
 <incr> must be in seconds.  Times will be written out according to the format
 given on `set format`, however.

 Examples:
       set xdata time
       set timefmt "%d/%m"
       set format x "%b %d"
       set xrange ["01/12":"06/12"]
       set xtics "01/12", 172800, "05/12"

       set xdata time
       set timefmt "%d/%m"
       set format x "%b %d"
       set xrange ["01/12":"06/12"]
       set xtics ("01/12", "" "03/12", "05/12")
 Both of these will produce tics "Dec 1", "Dec 3", and "Dec 5", but in the
 second example the tic at "Dec 3" will be unlabelled.

3 xyplane
?commands set ticslevel
?commands show ticslevel
?set ticslevel
?show ticslevel
?ticslevel
?commands set xyplane
?commands show xyplane
?set xyplane
?show xyplane
?xyplane
 The `set xyplane` command adjusts the position at which the xy plane is drawn
 in a 3D plot.  The synonym "set ticslevel" is accepted for backwards
 compatibility.

 Syntax:
       set ticslevel <frac>
       set xyplane <frac>
       set xyplane at <zvalue>
       show xyplane

 The form `set ticslevel <frac>` places the xy plane below the range in Z, where
 the distance from the xy plane to Zmin is given as a fraction of the total
 range in z.  The default value is 0.5.  Negative values are permitted, but tic
 labels on the three axes may overlap.

 To place the xy-plane at a position 'pos' on the z-axis, `ticslevel` may
 be set equal to  (pos - zmin) / (zmin - zmax).  However, this position will
 change if the z range is changed.

 The alternative form `set xyplane at <zvalue>` fixes the placement of the
 xy plane at a specific Z value regardless of the current z range. Thus to
 force the x, y, and z axes to meet at a common origin one would specify
 `set xyplane at 0`.

 See also `set view`, and `set zeroaxis`.
3 xzeroaxis
?commands set xzeroaxis
?commands unset xzeroaxis
?commands show xzeroaxis
?set xzeroaxis
?unset xzeroaxis
?show xzeroaxis
?xzeroaxis
?noxzeroaxis
 The `set xzeroaxis` command draws a line at y = 0.  For details,
 please see `set zeroaxis`.
3 y2data
?commands set y2data
?commands show y2data
?set y2data
?show y2data
?y2data
 The `set y2data` command sets y2 (right-hand) axis data to timeseries
 (dates/times).  Please see `set xdata`.
3 y2dtics
?commands set y2dtics
?commands unset y2dtics
?set y2dtics
?unset y2dtics
?show y2dtics
?y2dtics
?noy2dtics
 The `set y2dtics` command changes tics on the y2 (right-hand) axis to days of
 the week.  Please see `set xdtics` for details.
3 y2label
?commands set y2label
?commands show y2label
?set y2label
?show y2label
?y2label
 The `set y2label` command sets the label for the y2 (right-hand) axis.
 Please see `set xlabel`.
3 y2mtics
?commands set y2mtics
?commands unset y2mtics
?commands show y2mtics
?set y2mtics
?unset y2mtics
?show y2mtics
?y2mtics
?noy2mtics
 The `set y2mtics` command changes tics on the y2 (right-hand) axis to months
 of the year.  Please see `set xmtics` for details.
3 y2range
?commands set y2range
?commands show y2range
?set y2range
?show y2range
?y2range
 The `set y2range` command sets the vertical range that will be displayed on
 the y2 (right-hand) axis.  Please see `set xrange` for details.
3 y2tics
?commands set y2tics
?commands unset y2tics
?commands show y2tics
?set y2tics
?unset y2tics
?show y2tics
?y2tics
?noy2tics
 The `set y2tics` command controls major (labelled) tics on the y2 (right-hand)
 axis.  Please see `set xtics` for details.
3 y2zeroaxis
?commands set y2zeroaxis
?commands unset y2zeroaxis
?commands show y2zeroaxis
?set y2zeroaxis
?unset y2zeroaxis
?show y2zeroaxis
?y2zeroaxis
?noy2zeroaxis
 The `set y2zeroaxis` command draws a line at the origin of the y2 (right-hand)
 axis (x2 = 0).  For details, please see `set zeroaxis`.
3 ydata
?commands set ydata
?commands show ydata
?set ydata
?show ydata
?ydata
 The `set ydata` commands sets y-axis data to timeseries (dates/times).
 Please see `set xdata`.
3 ydtics
?commands set ydtics
?commands unset ydtics
?commands show ydtics
?set ydtics
?unset ydtics
?show ydtics
?ydtics
?noydtics
 The `set ydtics` command changes tics on the y axis to days of the week.
 Please see `set xdtics` for details.
3 ylabel
?commands set ylabel
?commands show ylabel
?set ylabel
?show ylabel
?ylabel
 This command sets the label for the y axis.  Please see `set xlabel`.
3 ymtics
?commands set ymtics
?commands unset ymtics
?commands show ymtics
?set ymtics
?unset ymtics
?show ymtics
?ymtics
?noymtics
 The `set ymtics` command changes tics on the y axis to months of the year.
 Please see `set xmtics` for details.
3 yrange
?commands set yrange
?commands show yrange
?set yrange
?show yrange
?yrange
 The `set yrange` command sets the vertical range that will be displayed on
 the y axis.  Please see `set xrange` for details.
3 ytics
?commands set ytics
?commands unset ytics
?commands show ytics
?set ytics
?unset ytics
?show ytics
?ytics
?noytics
 The `set ytics` command controls major (labelled) tics on the y axis.
 Please see `set xtics` for details.
3 yzeroaxis
?commands set yzeroaxis
?commands unset yzeroaxis
?commands show yzeroaxis
?set yzeroaxis
?unset yzeroaxis
?show yzeroaxis
?yzeroaxis
?noyzeroaxis
 The `set yzeroaxis` command draws a line at x = 0.  For details,
 please see `set zeroaxis`.
3 zdata
?commands set zdata
?commands show zdata
?set zdata
?show zdata
?zdata
 The `set zdata` command sets zaxis data to timeseries (dates/times).
 Please see `set xdata`.
3 zdtics
?commands set zdtics
?commands unset zdtics
?commands show zdtics
?set zdtics
?unset zdtics
?show zdtics
?zdtics
?nozdtics
 The `set zdtics` command changes tics on the z axis to days of the week.
 Please see `set xdtics` for details.
3 zzeroaxis
?commands set zzeroaxis
?commands unset zzeroaxis
?commands show zzeroaxis
?set zzeroaxis
?unset zzeroaxis
?show zzeroaxis
?zzeroaxis
?nozzeroaxis
 The `set zzeroaxis` command draws a line through (x=0,y=0).  This has no effect
 on 2D plots, including splot with `set view map`. For details, please
 see `set zeroaxis` and `set xyplane`.
3 cbdata
?commands set cbdata
?commands show cbdata
?set cbdata
?show cbdata
?cbdata
 Set color box axis data to timeseries (dates/times).  Please see `set xdata`.
3 cbdtics
?commands set cbdtics
?commands unset cbdtics
?commands show cbdtics
?set cbdtics
?unset cbdtics
?show cbdtics
?cbdtics
?nocbdtics
 The `set cbdtics` command changes tics on the color box axis to days of the
 week. Please see `set xdtics` for details.
3 zero
?commands set zero
?commands show zero
?set zero
?show zero
?zero
 The `zero` value is the default threshold for values approaching 0.0.

 Syntax:
       set zero <expression>
       show zero

 `gnuplot` will not plot a point if its imaginary part is greater in magnitude
 than the `zero` threshold.  This threshold is also used in various other
 parts of `gnuplot` as a (crude) numerical-error threshold.  The default
 `zero` value is 1e-8.  `zero` values larger than 1e-3 (the reciprocal of the
 number of pixels in a typical bitmap display) should probably be avoided, but
 it is not unreasonable to set `zero` to 0.0.
3 zeroaxis
?commands set zeroaxis
?commands unset zeroaxis
?commands show zeroaxis
?set zeroaxis
?unset zeroaxis
?show zeroaxis
?zeroaxis
 The x axis may be drawn by `set xzeroaxis` and removed by `unset xzeroaxis`.
 Similar commands behave similarly for the y, x2, y2, and z axes.

 Syntax:
       set {x|x2|y|y2|z}zeroaxis { {linestyle | ls <line_style>}
                                  | { linetype | lt <line_type>}
                                    { linewidth | lw <line_width>}}
       unset {x|x2|y|y2|z}zeroaxis
       show {x|y|z}zeroaxis


 By default, these options are off.  The selected zero axis is drawn
 with a line of type <line_type> and width <line_width> (if supported
 by the terminal driver currently in use), or a user-defined style
 <line_style>.

 If no linetype is specified, any zero axes selected will be drawn
 using the axis linetype (linetype 0).

 `set zeroaxis` is equivalent to `set xzeroaxis; set yzeroaxis`.
 Note that the z-axis must be set separately using `set zzeroaxis`.

 Examples:

 To simply have the y=0 axis drawn visibly:

        set xzeroaxis

 If you want a thick line in a different color or pattern, instead:

        set xzeroaxis linetype 3 linewidth 2.5
3 zlabel
?commands set zlabel
?commands show zlabel
?set zlabel
?show zlabel
?zlabel
 This command sets the label for the z axis.  Please see `set xlabel`.
3 zmtics
?commands set zmtics
?commands unset zmtics
?commands show zmtics
?set zmtics
?unset zmtics
?show zmtics
?zmtics
?nozmtics
 The `set zmtics` command changes tics on the z axis to months of the year.
 Please see `set xmtics` for details.
3 zrange
?commands set zrange
?commands show zrange
?set zrange
?show zrange
?zrange
 The `set zrange` command sets the range that will be displayed on the z axis.
 The zrange is used only by `splot` and is ignored by `plot`.  Please see
 `set xrange` for details.
3 ztics
?commands set ztics
?commands unset ztics
?commands show ztics
?set ztics
?unset ztics
?show ztics
?ztics
?noztics
 The `set ztics` command controls major (labelled) tics on the z axis.
 Please see `set xtics` for details.
3 cblabel
?commands set cblabel
?commands show cblabel
?set cblabel
?show cblabel
?cblabel
 This command sets the label for the color box axis.  Please see `set xlabel`.
3 cbmtics
?commands set cbmtics
?commands unset cbmtics
?commands show cbmtics
?set cbmtics
?unset cbmtics
?show cbmtics
?cbmtics
?nocbmtics
 The `set cbmtics` command changes tics on the color box axis to months of the
 year. Please see `set xmtics` for details.
3 cbrange
?commands set cbrange
?commands show cbrange
?set cbrange
?show cbrange
?cbrange
 The `set cbrange` command sets the range of values which are colored using
 the current `palette` by styles `with pm3d`, `with image` and `with palette`.
 Values outside of the color range use color of the nearest extreme.

 If the cb-axis is autoscaled in `splot`, then the colorbox range is taken from
 `zrange`.  Points drawn in `splot ... pm3d|palette` can be filtered by using
 different `zrange` and `cbrange`.

 Please see `set xrange` for details on `set cbrange` syntax. See also
 `set palette` and `set colorbox`.
3 cbtics
?commands set cbtics
?commands unset cbtics
?commands show cbtics
?set cbtics
?unset cbtics
?show cbtics
?cbtics
?nocbtics
 The `set cbtics` command controls major (labelled) tics on the color box axis.
 Please see `set xtics` for details.
2 shell
?commands shell
?shell
 The `shell` command spawns an interactive shell.  To return to `gnuplot`,
 type `logout` if using VMS, `exit` or the END-OF-FILE character if using
 Unix, `endcli` if using AmigaOS, or `exit` if using MS-DOS or OS/2.

 There are two ways of spawning a shell command: using `system` command
 or via `!` ($ if using VMS). The former command takes a string as a
 parameter and thus it can be used anywhere among other gnuplot commands,
 while the latter syntax requires to be the only command on the line. Control
 will return immediately to `gnuplot` after this command is executed.  For
 example, in AmigaOS, MS-DOS or OS/2,

       ! dir
 or
       system "dir"


 prints a directory listing and then returns to `gnuplot`.


 Other examples of the former syntax:
        system "date"; set time; plot "a.dat"
        print=1; if (print) replot; set out; system "lpr x.ps"

 On an Atari, the `!` command first checks whether a shell is already loaded
 and uses it, if available.  This is practical if `gnuplot` is run from
 `gulam`, for example.
2 splot
?commands splot
?splot
 `splot` is the command for drawing 3-d plots (well, actually projections on
 a 2-d surface, but you knew that).  It can create a plot from functions or
 a data file in a manner very similar to the `plot` command.

 See `plot` for features common to the `plot` command; only differences are
 discussed in detail here.  Note specifically `plot`'s `axes` option is not
 available for `splot`.

 Syntax:
       splot {<ranges>}
             {<iteration>}
             <function> | "<datafile>" {datafile-modifiers}}
             {<title-spec>} {with <style>}
             {, {definitions,} <function> ...}

 where either a <function> or the name of a data file enclosed in quotes is
 supplied.  The function can be a mathematical expression, or a triple of
 mathematical expressions in parametric mode.

 By default `splot` draws the xy plane completely below the plotted data.
 The offset between the lowest ztic and the xy plane can be changed by `set
 ticslevel`.  The orientation of a `splot` projection is controlled by
 `set view`.  See `set view` and `set ticslevel` for more information.

 The syntax for setting ranges on the `splot` command is the same as for
 `plot`.  In non-parametric mode, the order in which ranges must be given is
 `xrange`, `yrange`, and `zrange`.  In parametric mode, the order is `urange`,
 `vrange`, `xrange`, `yrange`, and `zrange`.

 The `title` option is the same as in `plot`.  The operation of `with` is also
 the same as in `plot`, except that the plotting styles available to `splot`
 are limited to `lines`, `points`, `linespoints`, `dots`, and `impulses`;  the
 error-bar capabilities of `plot` are not available for `splot`.

 The `datafile` options have more differences.

 See also `show plot`.
3 data-file
?commands splot datafile
?splot datafile
?splot data-file
 As for `plot`, discrete data contained in a file can be displayed by
 specifying the name of the data file, enclosed in quotes,  on the `splot`
 command line.

 Syntax:
       splot '<file_name>' {binary <binary list>}
                           {matrix}
                           {index <index list>}
                           {every <every list>}
                           {using <using list>}

 The special filenames `""` and `"-"` are permitted, as in `plot`.

 In brief, `binary` and `matrix` indicate that the data are in a special
 form, `index` selects which data sets in a multi-data-set file are to be
 plotted, `every` specifies which datalines (subsets) within a single data
 set are to be plotted, and `using` determines how the columns within a single
 record are to be interpreted.

 The options `index` and `every` behave the same way as with `plot`;  `using`
 does so also, except that the `using` list must provide three entries
 instead of two.

 The `plot` options `thru` and `smooth` are not available for `splot`, but
 `cntrparam` and `dgrid3d` provide limited smoothing capabilities.

 Data file organization is essentially the same as for `plot`, except that
 each point is an (x,y,z) triple.  If only a single value is provided, it
 will be used for z, the datablock number will be used for y, and the index
 of the data point in the datablock will be used for x.  If two or four values
 are provided, `gnuplot` uses the last value for calculating the color in
 pm3d plots.  Three values are interpreted as an (x,y,z) triple.  Additional
 values are generally used as errors, which can be used by `fit`.

 Single blank records separate datablocks in a `splot` datafile; `splot`
 treats datablocks as the equivalent of function y-isolines.  No line will
 join points separated by a blank record.  If all datablocks contain the same
 number of points, `gnuplot` will draw cross-isolines between datablocks,
 connecting corresponding points.  This is termed "grid data", and is required
 for drawing a surface, for contouring (`set contour`) and hidden-line removal
 (`set hidden3d`). See also `splot grid_data`.

 It is no longer necessary to specify `parametric` mode for three-column
 `splot`s.
4 binary matrix
?commands plot datafile binary matrix
?commands splot datafile binary matrix
?plot datafile matrix binary
?splot datafile matrix binary
?plot binary matrix
?splot binary matrix
?plot matrix binary
?splot matrix binary
?matrix binary
?binary matrix
?gpbin
 Gnuplot can read matrix binary files by use of the option `binary` appearing
 without keyword qualifications unique to general binary, i.e., `array`,
 `record`, `format`, or `filetype`.  Other general binary keywords for
 translation should also apply to matrix binary.  (See `binary general` for
 more details.)

 In previous versions, `gnuplot` dynamically detected binary data files.  It
 is now necessary to specify the keyword `binary` directly after the filename.

 Single precision floats are stored in a binary file as follows:

       <N+1>  <y0>   <y1>   <y2>  ...  <yN>
        <x0> <z0,0> <z0,1> <z0,2> ... <z0,N>
        <x1> <z1,0> <z1,1> <z1,2> ... <z1,N>
         :      :      :      :   ...    :

 which are converted into triplets:
       <x0> <y0> <z0,0>
       <x0> <y1> <z0,1>
       <x0> <y2> <z0,2>
        :    :     :
       <x0> <yN> <z0,N>

       <x1> <y0> <z1,0>
       <x1> <y1> <z1,1>
        :    :     :

 These triplets are then converted into `gnuplot` iso-curves and then
 `gnuplot` proceeds in the usual manner to do the rest of the plotting.

 A collection of matrix and vector manipulation routines (in C) is provided
 in `binary.c`.  The routine to write binary data is

       int fwrite_matrix(file,m,nrl,nrl,ncl,nch,row_title,column_title)

 An example of using these routines is provided in the file `bf_test.c`, which
 generates binary files for the demo file `demo/binary.dem`.

 The `index` keyword is not supported, since the file format allows only one
 surface per file.  The `every` and `using` filters are supported.  `using`
 operates as if the data were read in the above triplet form.

 See also `binary general` and

^ <a href="http://www.gnuplot.info/demo/binary.html">
 Binary File Splot Demo.
^ </a>
4 example datafile
?commands splot datafile example
?splot datafile example
?splot example
 A simple example of plotting a 3-d data file is

       splot 'datafile.dat'

 where the file "datafile.dat" might contain:

       # The valley of the Gnu.
          0 0 10
          0 1 10
          0 2 10

          1 0 10
          1 1 5
          1 2 10

          2 0 10
          2 1 1
          2 2 10

          3 0 10
          3 1 0
          3 2 10

 Note that "datafile.dat" defines a 4 by 3 grid ( 4 rows of 3 points each ).
 Rows (datablocks) are separated by blank records.

^ <img align=bottom src="http://www.gnuplot.info/doc/splot.gif" alt="[splot.gif]" width=640 height=480>
 Note also that the x value is held constant within each dataline.  If you
 instead keep y constant, and plot with hidden-line removal enabled, you will
 find that the surface is drawn 'inside-out'.

 Actually for grid data it is not necessary to keep the x values constant
 within a datablock, nor is it necessary to keep the same sequence of y
 values.  `gnuplot` requires only that the number of points be the same for
 each datablock.  However since the surface mesh, from which contours are
 derived, connects sequentially corresponding points, the effect of an
 irregular grid on a surface plot is unpredictable and should be examined
 on a case-by-case basis.
4 matrix_ascii
?commands plot datafile matrix ascii
?commands splot datafile matrix ascii
?plot datafile matrix ascii
?splot datafile matrix ascii
?plot matrix ascii
?splot matrix ascii
?data-file matrix ascii
?datafile matrix ascii
?matrix ascii
 The `matrix` keyword (without a sequent `binary` keyword) in
     {s}plot 'a.dat' matrix
 indicates that data are stored in an ascii numbers matrix format.

 The z-values are read in a row at a time, i. e.,
     z11 z12 z13 z14 ...
     z21 z22 z23 z24 ...
     z31 z32 z33 z34 ...
 and so forth.

 In 3D, the x- and y-indices of the matrix surface plot correspond to column
 and row indices of the matrix, respectively, being enumerated from 0. You can
 rescale or transform the axes as usual for a data file with three columns
 by means of x=$1, y=$2, z=$3. For example
     splot 'a.dat' matrix using (1+$1/100):(1+$2*10):3

 A blank line or comment line ends the matrix, and starts a new surface mesh.
 You can select among the meshes inside a file by the `index` option to the
 `splot` command, as usual.

 See `matrix` for examples of plotting rows and columns of the matrix in
 a 2D plot.
4 matrix
?commands plot datafile matrix
?commands splot datafile matrix
?plot datafile matrix
?splot datafile matrix
?plot matrix
?splot matrix
?data-file matrix
?datafile matrix
?matrix
 Datafile can be in an ascii or binary matrix format. The `matrix` flag
 indicates that the file is ascii, the `binary` or `matrix binary` stands for
 a binary format. For details, see `matrix ascii` and `matrix binary`.

 Basic usage in `splot`:
     splot 'a.dat' matrix
     splot 'a.gpbin' {matrix} binary
 Advanced usage in `splot`:
     splot 'a.dat' matrix using 1:2:3
     splot 'a.gpbin' {matrix} binary using 1:2:3
 allows to transform the axes coordinates and the z-data independently.

 Usage in `plot`:
     plot `a.dat` matrix
     plot `a.dat` matrix using 1:3
     plot 'a.gpbin' {matrix} binary using 1:3
 will plot rows of the matrix, while using 2:3 will plot matrix columns, and
 using 1:2 the point coordinates (rather useless). Applying the `every` option
 you can specify explicit rows and columns.

 Example -- rescale axes of a matrix in an ascii file:
     splot `a.dat` matrix using (1+$1):(1+$2*10):3

 Example -- plot the 3rd row of a matrix in an ascii file:
     plot 'a.dat' matrix using 1:3 every 1:999:1:2
 (rows are enumerated from 0, thus 2 instead of 3).
3 grid data
?commands splot grid_data
?splot grid_data
?grid_data
 The 3D routines are designed for points in a grid format, with one sample,
 datapoint, at each mesh intersection; the datapoints may originate from
 either evaluating a function, see `set isosamples`, or reading a datafile,
 see `splot datafile`.  The term "isoline" is applied to the mesh lines for
 both functions and data.  Note that the mesh need not be rectangular in x
 and y, as it may be parameterized in u and v, see `set isosamples`.

 However, `gnuplot` does not require that format.  In the case of functions,
 'samples' need not be equal to 'isosamples', i.e., not every x-isoline
 sample need intersect a y-isoline. In the case of data files, if there
 are an equal number of scattered data points in each datablock, then
 "isolines" will connect the points in a datablock, and "cross-isolines"
 will connect the corresponding points in each datablock to generate a
 "surface".  In either case, contour and hidden3d modes may give different
 plots than if the points were in the intended format.  Scattered data can be
 converted to a {different} grid format with `set dgrid3d`.

 The contour code tests for z intensity along a line between a point on a
 y-isoline and the corresponding point in the next y-isoline.  Thus a `splot`
 contour of a surface with samples on the x-isolines that do not coincide with
 a y-isoline intersection will ignore such samples. Try:
        set xrange [-pi/2:pi/2]; set yrange [-pi/2:pi/2]
        set style function lp
        set contour
        set isosamples 10,10; set samples 10,10;
        splot cos(x)*cos(y)
        set samples 4,10; replot
        set samples 10,4; replot

3 splot overview
?commands splot overview
?splot overview
 `splot` can display a surface as a collection of points, or by connecting
 those points.  As with `plot`, the points may be read from a data file or
 result from evaluation of a function at specified intervals, see
 `set isosamples`.  The surface may be approximated by connecting the points
 with straight line segments, see `set surface`, in which case the surface
 can be made opaque with `set hidden3d.`  The orientation from which the 3d
 surface is viewed can be changed with `set view`.

 Additionally, for points in a grid format, `splot` can interpolate points
 having a common amplitude (see `set contour`) and can then connect those
 new points to display contour lines, either directly with straight-line
 segments or smoothed lines (see `set cntrparam`).  Functions are already
 evaluated in a grid format, determined by `set isosamples` and `set samples`,
 while file data must either be in a grid format, as described in `data-file`,
 or be used to generate a grid (see `set dgrid3d`).

 Contour lines may be displayed either on the surface or projected onto the
 base.  The base projections of the contour lines may be written to a
 file, and then read with `plot`, to take advantage of `plot`'s additional
 formatting capabilities.
2 system
?commands system
?system
 `system` spawns shell to execute a command. Please type `help shell` for
 more details.
2 test
?commands test
?test palette
?test
 This command graphically tests or presents terminal and palette capabilities.

 Syntax:
       test {terminal | palette [rgb|rbg|grb|gbr|brg|bgr]}

 `test` or `test terminal` creates a display of line and point styles and other
 useful things appropriate for and supported by the `terminal` you are just
 using.

 `test palette` draws graphically profiles R(z),G(z),B(z), where 0<=z<=1, as
 calculated by the current color `palette`. In other words, it is a beautiful
 plot you would have to do yourself with the result of `show palette palette 256 float`.
 The optional parameter, a permutation of letters rgb, determines the sequence of
 r,g,b profiles drawn one after the other --- try this yourself for `set palette
 gray`. The default sequence is rgb.
2 unset
?commands unset
?unset
 Options set using the `set` command may be returned to their default state by
 issuing the corresponding `unset` command.

 Example:
       set xtics mirror rotate by -45 0,10,100
       ...
       unset xtics

2 update
?commands update
?update
 This command writes the current values of the fit parameters into the given
 file, formatted as an initial-value file (as described in the `fit`section).
 This is useful for saving the current values for later use or for restarting
 a converged or stopped fit.

 Syntax:
       update <filename> {<filename>}

 If a second filename is supplied, the updated values are written to this
 file, and the original parameter file is left unmodified.

 Otherwise, if the file already exists, `gnuplot` first renames it by
 appending `.old` and then opens a new file.  That is, "`update 'fred'`"
 behaves the same as "`!rename fred fred.old; update 'fred.old' 'fred'`".
 [On DOS and other systems that use the twelve-character "filename.ext"
 naming convention, "ext" will be "`old`" and "filename" will be related
 (hopefully recognizably) to the initial name.  Renaming is not done at all
 on VMS systems, since they use file-versioning.]

 Please see `fit` for more information.
1 Terminal types
^ <h2> Terminal Types </h2>
2 terminal
?terminal
?term
 Gnuplot supports a large number of output formats. These are selected by
 choosing an appropriate terminal type, possibly with additional modifying
 options. See `set terminal`.

 This document may describe terminal types that are not available to you
 because they were not configured or installed on your system. To see a list of
 terminals available on a particular gnuplot installation, type 'set terminal'
 with no modifiers.
<3 -- all terminal stuff is pulled from the .trm files
1 Graphical User Interfaces
?graphical user interfaces
?gui's
 Several graphical user interfaces have been written for `gnuplot` and one for
 win32 is included in this distribution.  In addition, there is a Python
 interface at
^ <a href="http://py-gnuplot.darwinports.com/">
          http://py-gnuplot.darwinports.com/
^ </a>

 Also several X11 interfaces exist.
 One of them is called xgfe. It uses the Qt library and can be found on
^ <a href="http://www.flash.net/~dmishee/xgfe/xgfe.html">
          http://www.flash.net/~dmishee/xgfe/xgfe.html
^ </a>

 In addition three Tcl/Tk located at the usual Tcl/Tk repositories exist.

 Bruce Ravel (ravel@phys.washington.edu) has written a new version of
 gnuplot-mode for GNU emacs and XEmacs. This version is based on
 the gnuplot.el file by Gershon Elber.
 While the gnuplot CVS repository has its own copy the most recent
 version of this package is available from
^ <a href="http://feff.phys.washington.edu/~ravel/software/gnuplot-mode/">
           http://feff.phys.washington.edu/~ravel/software/gnuplot-mode/
^ </a>

1 Bugs
?bugs
 Bugs reported since the current release as well as older ones
 may be located via the official distribution site on SourceForge.

 Please e-mail bug reports to the gnuplot-bugs mailing list.
 Or upload the report to the gnuplot web site on SourceForge.
 Please give complete information on the version of gnuplot you are using
 and, if possible, a test script that demonstrates the bug.
 See `Seeking-assistance`.

 The sections below list problems known to be present in gnuplot version 4.2 at
 the time of release.  Some of these are actually bugs in external support
 libraries and may have been fixed indepently of any changes in gnuplot.

2 Gnuplot limitations
?bugs gnuplot
=gamma
=bessel
=timefmt
=load
=nohidden3d
 Floating point exceptions (floating point number too large/small, divide by
 zero, etc.) may occasionally be generated by user defined functions.  Some of
 the demos in particular may cause numbers to exceed the floating point range.
 Whether the system ignores such exceptions (in which case `gnuplot` labels
 the corresponding point as undefined) or aborts `gnuplot` depends on the
 compiler/runtime environment.

 The gamma and bessel functions do not work for complex arguments.

 If a command line contains a "load" command, then anything on the line after
 the "load <filename>" is ignored.

 Only one color palette at a time is active for any given x11 plot window.
 This means that multiplots whose constituent plots use different palettes
 will not display correctly in x11.

 Coordinates specified as "time" wrap at 24 hours, and have a precision limited
 to 1 second.  This is in particular a limitation in using time format to
 handle geographic coordinates.

 Error bars are not handled properly in polar/spherical coordinate plot modes.

 The 'nohidden3d' option that is supposed to exempt individual plots from the
 global property 'set hidden3d' does not work for parametric curves.

2 Specific terminals
?bugs terminals
 Some older models of HP plotters do not have a page eject command 'PG'.  The
 current HPGL driver uses this command in HPGL_reset.  This may need to be
 removed for these plotters.  The current PCL5 driver uses HPGL/2 for text as
 well as graphics.  This should be modified to use scalable PCL fonts.

2 External libraries
?bugs external_libraries
=libgd
=svgalib
=locale
=internationalization
=pdf
 External library GD (used by PNG/JPEG/GIF drivers):
 Versions of libgd through 2.0.33 contain various bugs in mapping the characters
 of Adobe's Symbol font.  Also it is possible to trigger a library segfault if
 an anti-aliased line crosses an upper corner of the canvas.

 External library PDFlib (used by PDF driver):
 Gnuplot can be linked against libpdf versions 4, 5, or 6. However, these
 versions differ in their handling of piped I/O.  Therefore gnuplot scripts
 using piped output to PDF may work only for some versions of PDFlib.

 External library svgalib (used by linux and vgagl driver):
 Requires gnuplot to be suid root (bad!) and has many bugs that are specific
 to the video card or graphics driver used in X11.

 Internationalization (locale settings):
 Gnuplot uses the C runtime library routine setlocale() to control
 locale-specific formatting of input and output number, times, and date strings.
 The locales available, and the level of support for locale features such as
 "thousands' grouping separator", depend on the internationalization support
 provided by your individual machine.
