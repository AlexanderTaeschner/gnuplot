C RCS $Id: gnuplot-ja.doc,v 1.789 2023-04-05 19:27:22+09 shige Exp $
C corresponding original gnuplot.doc at 2023-04-05
C
C Copyright (C) 1986 - 1993, 1998, 1999, 2000, 2001, 2004   Thomas Williams, Colin Kelley et al.
C
C Japanese translation: Hiroharu Tamaru (2.0, 3.2), MASUTANI Yasuhiro (3.5),
C Shigeharu Takeno et al (3.7, 4.X, 5.X)
1 Gnuplot
?gnuplot
C 下の contributors の表のアクセント文字は、現在のオリジナルでは UTF-8
C で書かれているが、それを HTML 名前参照形式に変更している。
^<h2 align="center"> An Interactive Plotting Program </h2>
^<p align="center">  Thomas Williams & Colin Kelley</p>
^<p align="center">  Version 6 organized by Ethan A Merritt</p>
^<p align="center">Major contributors (alphabetic order):<br>
^<br>
^  Hans-Bernhard Broeker, John Campbell,<br>
^  Robert Cunningham, David Denholm,<br>
^  Gershon Elber, Roger Fearick,<br>
^  Carsten Grammes, Lucas Hart, Lars Hecking,<br>
^  P&eacute;ter Juh&aacute;sz, Thomas Koenig, David Kotz,<br>
^  Ed Kubaitis, Russell Lang, Timoth&eacute;e Lecomte,<br>
^  Alexander Lehmann, Alexander Mai, Bastian M&auml;rkisch,<br>
^  Tatsuro Matsuoka, Ethan A Merritt, Petr Mikul&iacute;k,<br>
^  Hiroki Motoyoshi, Carsten Steger, Shigeharu Takeno,<br>
^  Tom Tkacik, Jos Van der Woude,<br>
^  James R. Van Zandt, Alex Woo, Johannes Zellner<br>
^</p>
^<p align="center">  Copyright (C) 1986 - 1993, 1998 - 2004   Thomas Williams, Colin Kelley<br>
^     Copyright (C) 2004 - 2023 various authors</p>
^<p align="center">   Mailing list for comments: <tt>gnuplot-info@lists.sourceforge.net</tt><br>
^   Gnuplot <a href="http://gnuplot.info"> home page </a><br>
^      Issue trackers: &nbsp;
^<a href="https://sourceforge.net/p/gnuplot/bugs"> bugs </a> &nbsp;&nbsp;
^<a href="https://sourceforge.net/p/gnuplot/feature-requests"> feature requests </a>
^<p align="center"> This manual was originally prepared by Dick Crawford</p>
^<!-- end of titlepage -->
C 行が長いのは、できればなんとかしたい
2 著作権 (Copyright)
?copyright
?license
     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley
     Copyright (C) 2004-2023  various authors

 Permission to use, copy, and distribute this software and its
 documentation for any purpose with or without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.

 Permission to modify the software is granted, but not the right to
 distribute the complete modified source code.  Modifications are to
 be distributed as patches to the released version.  Permission to
 distribute binaries produced by compiling modified sources is granted,
 provided you
   1. distribute the corresponding source modifications from the
    released version in the form of a patch file along with the binaries,
   2. add special version identification to distinguish your version
    in addition to the base release version number,
   3. provide your name and address as the primary contact for the
    support of your modified version, and
   4. retain our contact information in regard to use of the base software.
 Permission to distribute the released version of the source code along
 with corresponding source modifications in the form of a patch file is
 granted with same provisions 2 through 4 for binary distributions.

 This software is provided "as is" without express or implied warranty
 to the extent permitted by applicable law.

       AUTHORS
               Original Software:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 additions:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 additions:
                  Gershon Elber and many others.
               Gnuplot 4.0 and subsequent releases:
                  See list of contributors at head of this document.

 (以下おおまかな訳; 訳は正しくないかも知れませんので詳しくは上記の原文
 を当たってください。訳者は責任を持ちません。)

     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley
     Copyright (C) 2004-2023  多くの著者

 このソフトウェアとその付属文書の使用、複製、配布の許可は、上記の著作権
 (copyright) 表示が、全ての複製物に書かれていること、および著作権表示と
 この許諾文の両方がその支援文書に書かれていることを条件とした上で、この
 文書により保証されます。

 このソフトウェアの修正も認められています。しかし、修正を含む全ソースコ
 ードの配布の権利は認められません。修正はリリース版に対するパッチの形で
 配布しなければなりません。修正されたソースをコンパイルして作られたバイ
 ナリの配布は、以下の条件の元で認められます:
   1. リリース版からのソースの修正部分を、パッチの形でバイナリと共に配
      布すること
   2. ベースとなるリリース版と区別するために、そのバージョン番号に特別
      なバージョン指定子を付加すること
   3. その修正版のサポート用に、あなたの名前とアクセス可能なアドレスと
      を提供すること
   4. ベースとなるソフトウェアの使用に関しては、我々の連絡情報を保持し
      続けること
 リリース版のソースコードを、パッチの形でのソースの修正と一緒に配布する
 ことは、バイナリ配布に関する条項 2 から 4 までの条件の元で許されます。

 このソフトウェアは "あるがまま" 提供され、適用可能な法律で許められる範
 囲の保証を表明あるいは暗示していはいません。

       著者
               オリジナルソフトウェア:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 追加:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 追加:
                  Gershon Elber とその他の人々。
               Gnuplot 4.0 およびそれ以降のリリース:
                  この文書の先頭の寄与者 (contributors) の一覧参照。
2 はじめに (Introduction)
?introduction
?
 `gnuplot` は、ポータブルなコマンド入力方式のグラフユーティリティで、
 Linux, OS/2, MS Windows, macOS, VMS, その他多くのプラットホーム上で動
 作します。ソースコードには著作権がありますが、無料で配布されています
 (すなわち、それに対価を支払う必要はありません)。元は、科学者や学生が数
 学関数やデータなどを対話的に表示できるよう作られたのですが、現在までに
 例えば Web スクリプトなど、多くの非対話型の利用もサポートするように成
 長しています。これは、例えば Octave のようにサードパーティのアプリケー
 ションの描画エンジンとしても使われています。gnuplot は、1986 よりサポ
 ートと活発な開発が行われています。

 gnuplot は、2 次元、または 3 次元の多くの種類のグラフを生成できます。
 います: 折線グラフ、点グラフ、棒グラフ、等高線、ベクトル場描画、画像の
 取り込み、曲面、そしてそれらに関連するさまざまな文字列等。そしてさらに
 いくつかの特別なグラフ、例えば温度分布図 (heatmap)、蜘蛛の巣グラフ (レ
 ーダーチャート, spiderplot)、極射影 (polar projection)、ヒストグラム
 (histograms)、箱ひげ図 (boxplot)、ビースウォームグラフ (bee swarm)、
 非線形軸などもサポートしています。

 gnuplot は多くの異なる出力をサポートしています: 対話型スクリーン出力形
 式 (マウスやホットキー入力も可能)、ペンプロッタや現在のプリンタへの直
 接出力、または多くのファイル形式への出力 (eps, emf, fig, jpeg, LaTeX,
 pdf, png, postscript, ...)。gnuplot は、容易に新しい出力形式を追加する
 よう拡張することができます。最近では例えば webp アニメーションがサポー
 トされました。svg や HTML5 canvas 出力形式を利用すれば、グラフを Web
 ページ内にマウス利用可能な形で埋め込んだ出力を生成することもできます。

 `gnuplot` のコマンド言語は大文字小文字を区別します。すなわち、小文字で
 書かれたコマンドや関数名は、それらを大文字で書いたものとは同じではあり
 ません。いずれのコマンドも、あいまいさの無い限りにおいて省略することが
 できます。1 行中にはセミコロン (;) で区切って複数のコマンドを書くこと
 ができます。文字列は単一引用符、あるいは二重引用符のどちらかで書き始め
 ますが、両者には微妙な違いがあります (詳細は、以下参照: `syntax`)。例:

       set title "My First Plot";  plot 'data';  print "all done!"

 コマンドは、複数行にまたがることができます。その場合は、最終行以外の
 全ての行の行末にバックスラッシュ (\) を書く必要があります。バックスラ
 ッシュは必ず各行 *最後* の文字でなくてはなりません。その結果としてバッ
 クスラッシュと、それに続く改行文字が存在しなかったかのように扱われます。
 つまり、改行文字がスペースの役をすることもありませんし、改行によってコ
 メントが終了することもありません。ですから複数行にまたがる行の先頭をコ
 メントアウトすると、そのコマンド全体がコメントアウトされることになりま
 す (以下参照: `comments`)。なお注意しますが、もし、複数行のコマンドの
 どこかでエラーが起きたとき、パーサはその場所を正確には指示することがで
 きませんし、また、正しい行に指示する必要もないでしょう。

 このドキュメントにおいて、中括弧 ({}) は省略可能な引数を表すものとし、
 縦棒 (|) は、互いに排他的な引数を区切るものとします。`gnuplot` のキー
 ワードや `help` における項目名は、逆引用符 (｀)、または可能な場合には
 `boldface` (太字) で表します。角括弧 (<>) は、それに対応するものに置き
 換えられるべきものを表します。多くの場合、オプションの引数には、それが
 省略されるとデフォルトの値が使用されます。しかし、これらの場合、必ずし
 も角括弧が中括弧で囲まれて書かれているわけではありません。

 ある項目についてのヘルプが必要なときには、`help` に続けてその項目名を
 入力して下さい。または単に `help ?` でもヘルプの項目のメニューが現われ
 ます。

 大量のグラフサンプルが、以下の Web ページにあります。
^ <a href="http://www.gnuplot.info/demo/">
           http://www.gnuplot.info/demo/
^ </a>
 コマンドラインから起動するときは、以下の書式が使えます。
       gnuplot {OPTIONS} file1 file2 ...
 ここで file1, file2 等は、`local` コマンドで取り込むのと同等の入力ファ
 イル (スクリプトファイル) です。
 gnuplot に与えるオプションは、コマンド行のどこに置いても構いません。フ
 ァイルは指定した順に実行され、同様に -e オプションで任意のコマンドを与
 えることもできます。例:
       gnuplot   file1.in   -e "reset"   file2.in

 特別なファイル名 "-" は、標準入力から読ませるのに使います。`gnuplot`
 は最後のファイルを処理し終わると終了します。読み込ませるファイルを一つ
 も指定しない場合は、`gnuplot` は標準入力からの対話入力を取ります。詳細
 は、以下参照: `batch/interactive`。
 コマンドラインオプションの詳細は以下参照: `command-line-options`。また
 は以下を実行してください。
       gnuplot --help

 対話型描画ウィンドウでの作業中は、'h' を打つとホットキー (`hotkeys`)
 とマウス機能 (`mousing`) に関するヘルプを見ることができます。
2 探し出す手助け/バグ (Seeking-assistance / Bugs)
?help-desk
?faq
?FAQ
?bugs
?seeking-assistance
 公式の gnuplot ホームページは以下にあります。
^ <a href="http://www.gnuplot.info">
           http://www.gnuplot.info
^ </a>

 助けを求める前に、ファイル FAQ.pdf か、または上の Web サイトの
^ <a href="http://www.gnuplot.info/faq/">
           FAQ (度々聞かれる質問; Frequently Asked Questions) の一覧
^ </a>
 をチェックしてください。

 他に、(バグ以外の) 特定のグラフ描画の問題に関する助言は以下でも得られ
 ます。
           https://stackoverflow.com/questions/tagged/gnuplot

 バグの報告と、機能のリクエストは、以下のトラッキングシステムにあげてく
 ださい。
           https://sourceforge.net/p/gnuplot/_list/tickets
 ただし、あなたが報告しようとしているバグが、より新しい版で既に修正され
 ていないか、以前の報告をチェックしてください。

 バグの報告や質問を投稿するときは、あなたが使用している gnuplot のバー
 ジョン、出力形式 (terminal)、オペレーティングシステム、といった情報を
 すべて入れてください。問題を再現する自己完結型の短いスクリプトを提示す
 るとなお良いでしょう。

 gnuplot メーリングリストへの投稿の方法に関しては、gnuplot の開発 Web
 サイト
^ <a href="http://sourceforge.net/projects/gnuplot">
           http://sourceforge.net/projects/gnuplot
^ </a>
 を参照してください。

 gnuplot メーリングリストにメールを書く前に、最初にそのメーリングリスト
 に参加する必要があることに注意してください。これは、スパムの量を減らす
 ために必要です。

 メーリングリストメンバーへのメールアドレス:
           gnuplot-info@lists.sourceforge.net

 開発版に関するメーリングリスト:
           gnuplot-beta@lists.sourceforge.net

2 バージョン 6 での新しい機能 (New features in version 6)
?new version_6
?new
?version
 バージョン 6 は、遡ること 1986 年からの gnuplot 開発での最新メジャーリ
 リースです。それは、メジャーバージョン 5 (2015)、そしてその後のマイナ
 ーリリース 5.2 (2017), 5.4 (2020) に続くものです。開発は、SouceForge
 上の git リポジトリプロジェクト内の、正式版とは別なブランチで続けられ
 ています。

 このドキュメントに記述されている機能の中には、gnuplot をソースからコン
 パイルする際にそれを選択して設定している場合だけ使えるものがあります。
 あなたが実行している特定の gnuplot が、コンパイル時にどのようなオプシ
 ョンを設定して作られたかを知るには、`show version long` とタイプしてく
 ださい。

3 関数ブロックと局所変数 (Function blocks and scoped variables)
?new function blocks
 この版の gnuplot では、標準的な gnuplot コマンドのブロックを呼び出して
 関数として使える機能を導入しています。関数ブロックは、0 から 9 個の引
 数を使えて、一つの値を返します。関数ブロックは、計算した新しい値を変数
 に割り当てたり、異なる関数や演算子を結合したり、与えられたデータに対す
 る繰り返しの作業を行ったりするのに使うことができます。
 この仕組みには、3 つの要素があります。
 以下参照: `local`, `scope`, `function blocks`, `return`。
#start
#b 修飾子 `local` は、変数や配列のオプション宣言で、そのスコープは、そ
## れが書かれているプログラム単位の実行中のみに制限されます。単位とは、
## 現在は、`load` や `call` 文の実行単位、関数ブロック評価、そして `if`,
## `else`, `do for`, `while` に続く中かっこで囲まれたコードブロック単位
## です。局所 (local) 変数の名前が大域 (global) 変数の名前とぶつかる場
## 合は、その局所スコープから抜けるまでは大域変数は隠されます。
#b コマンド `function` は、gnuplot コマンドからなる名前付き関数ブロック
## (実際はある文字列の配列) を宣言します。関数ブロックを呼び出すと、そ
## のコマンドが、ブロックの最後になるか、または `return` コマンドに当た
## るまで、順次実行されます。
#b コマンド `return <expression>` は、関数ブロックの実行を終了します。
## 式 <expression> の評価の結果が、その関数の値として返されます。関数ブ
## ロックの外では、どこでも `return` は `exit` と同様に動作します。
#end

 この仕組みを使って、単純な一行の関数定義 `f(x) = ...` よりもっと複雑で
 自明ではない関数を定義し、描画する例として、`function_block.dem` を参
 照してください。

3 特殊関数と複素数値関数 (Special and complex-valued functions)
?new math
 gnuplot バージョン 6 は、膨大な複素数値関数群と、以前のバージョンにあ
 った関数の改良版をいくつか提供します。
#start
#b 新規: 複素変数、複素数値のリーマンゼータ (ζ) 関数。以下参照: `zeta`。
#b (正規化) 下方不完全ガンマ関数の定義域と精度の改良。複素引数が可能に。
## 以下参照: `igamma`。
#b 上方不完全ガンマ関数を新規追加 (実引数のみ)。
## 以下参照: `uigamma`。
#b (正規化) 不完全ベータ関数の定義域と精度の改良。
## 以下参照: `ibeta`。
#b 逆 (正規化) 不完全ガンマ関数を新しく追加。
## 以下参照: `invigamma`。
#b 逆 (正規化) 不完全ベータ関数を新しく追加。
## 以下参照: `invibeta`。
#b 多価関数 W_k(z) の第 k 分岐を返す複素関数 LambertW(z,k) を新しく追加。
^<br>
## 古い lambertw(x) は real(LambertW( real(z), 0 )) であることに注意。
## 以下参照: `LambertW`。
#b 複素関数 lnGamma(z) を新しく追加。
## 既にある lgamma(x) は real(lnGamma(real(z)) であることに注意。
## 以下参照: `lnGamma`。
#b z の複素共役を返す複素関数 conj(z)
#b (第 1) シンクロトロン関数 F(x)。以下参照: `SynchrotronF`。
#b acosh(z) の定義域を負の実数軸を覆うように拡張。
#b asin(z) asinh(z) の複素数引数に対する精度の改良。
#b 便利なように I = sqrt(-1) = {0,1} を定義済み変数に。
^<br>
## gnuplot は {a,b} を正しい複素数定数と見なしてくれませんが、しかし
## (a + b*I) なら正しい複素数数式として受けつけてくれるので有用です。
#end

 ビルド時に適切な外部ライブラリがあれば、さらにいくつかの特殊関数をサポ
 ートします。以下参照: `special_functions`。
#start
#b ν 次 (実数) の、引数 z に対する複素ベッセル関数 Iν(z), Jν(z),
## Kν(z), Yν(z)。以下参照: `BesselK`。
#b ν 次 (実数) の、引数 z に対する複素ハンケル関数 H1ν(z), H2ν(z)。
## 以下参照: `BesselH1`。
#b 複素エアリー関数 Ai(z), Bi(z)。
#b n 次の複素指数積分。以下参照: `expint`。
#b フレネル積分 C(x), S(x)。以下参照: `FresnelC`。
#b Voigt プロファイルの半値全幅を返す関数 `VP_fwhm(sigma,gamma)`。以下
## 参照: `VP`, `VP_fwhm`。
#end

3 新しい描画スタイル (New plot styles)
?new styles
#start
#b 描画スタイル `with surface` は、2 次元極座標で動作し、平面を色塗りし
## た格子表現のグラフを生成します 色は入力点の任意の集合のからの寄与に
## よる重み付きよって色付けされます。これは、3 次元格子曲面を作る
## `dgrid3d`とスタイル `with pm3d` の類似品です。
## 以下参照: `set polar grid`, `polar heatmap`。
#b 新しい 2 次元描画スタイル `with sectors` は、完全な極座標格子面を生
## 成する別の仕組みです。これは概念上の極座標格子内に、各入力データ点毎
## に丸い扇片をひとつ生成します。極座標モードでの `with surface` とは違
## い、これは極座標グラフでも直交座標グラフでも使用できます。
#b 描画スタイル `with lines` には、現在フィルタオプション `sharpen` が
## あります。このフィルタは関数グラフでスパイクを検出しますが、そのピー
## クは関数から標本として取った 2 つの x 座標の間にあるため、出力では不
## 完全に切り取られてしまいます。このフィルタは、そのようなピーク点の場
## 所に新しい標本点を追加します。以下参照: `filters`。
#b 3 次元描画スタイル `with pm3d` でオプション修飾子 `zclip [zmin:zmax]`
## が使えて、これは曲面全体のひとつの断面のみを選択します。クリッピング
## の境界値を増加させて連続描画を行うことで、3 次元では断面切り出しアニ
## メーションを見るのに使えますし、2 次元射影では間を塗り潰した等高線図
## を作成するのに使えます。
#end
D polargrid 4
DB
D windrose 1
D sectors 4
DB
D sharpen 1

3 凸包とマスクと平滑化 (Hulls, masks, and smoothing)
?new hulls
#start
#b 2 次元の点の集合を、その境界の多角形で置き換える新しいフィルタ
## `convexhull`。その境界の曲線を滑らかにするには、
## "convexhull smooth path with filledcurves" を使って塗り潰し領域とし
## て描画することでできます。以下参照: `convexhull`。
#b 試験的なフィルタ `concavehull` は、凸とは限らない、凹の度合を制御す
## る特性長パラメータで決定されるχ-形状の、多角形のデータ境界を生成し
## ます。これはデータ点の回りの本質的なしみを描画します。以下参照:
## `concavehull`。
#b pm3d 曲面や image 描画の選択した一部分のみを表示するようマスクするの
## に、凸包 (convex hull) や他の多角形 (polygon) を使用できます。新しい
## 描画スタイル `with mask` (マスクを定義) や、キーワード `mask` (その
## 後の描画要素にマスクを適用する) を参照してください。
#b 閉曲線や x に関して単調ではない 2 次元曲線向きの、パスに沿った 3 次
## 元スプライン平滑化。以下参照: `smooth path`。これは、凸包やマスクの
## 平滑化も可能にします。
#b 3 次元曲線の 3 次スプライン平滑化。以下参照: `splot smooth csplines`。
#b 平滑化オプションは `with filledcurves {above|below|between}` での描
## 画にも適用します。
#b 周期的データの平滑化用の新しいキーワード `period`。以下参照:
## `smooth kdensity`。
#end
D convex_hull 2
D mask_pm3d 3
D smooth_path 2

3 名前付きパレット (Named palettes)
?new colormaps
#start
#b 現在のパレットをその後の利用のため名前付きカラーマップに保存できます。
## 以下参照: `set colormap`。
#b pm3d と image plot で以前保存したパレットを名前で指定できます。
## これにより、一つの plot コマンドで複数のパレットを使用できます。
## 以下参照: `colorspec palette`。
#b 名前付きパレットカラーマップは、32-bit ARGB 色値の配列として操作でき
## ます。これにより、アルファチャネル値を追加したり、コマンド
## `set palette` では簡単に指定できない他の修正を可能にします。
#b 定義済みの新しい色機構 `set palette viridis`。
#b ファイルやデータブロックから読み込んだパレット (`set palette file`)
## は、実数の色成分か、24bit 形式の RGB 値のいずれかで指定できます。
#end
D named_palettes 4
D viridis 1

3 新しいデータ形式 (New data formats)
?new data_formats
#start
#b オプション `sparse matrix=(cols,rows)` は、`plot` と `splot` に、個
## 々のピクセル値を任意の順番で読みだすことができるような一様なピクセル
## 格子を生成させます。これは、不完全なデータから温度分布図 (heatmap)
## を描画するような場合に有用です。以下参照: `sparse`。
#b 非一様な matrix データの入力中、現在は column(0) はその matrix 要素
## の線形順序を返します。すなわち、MxN matrix の A の要素 A[i,j] に対し
## ては、column(0)/M が行番号 i に、column(0)%M が列番号 j になります。
#end

3 新しい組み込み関数と配列操作 (New built-in functions and array operations)
?new built-in functions
#start
#b cbrange 内の z に割当てる現在の RGB パレット色を返す関数 `palette(z)`
#b 色名からその色の 32bit ARGB 値を返す関数 `rgbcolor("name")`
#b 要素 Array[i] が element に等しい最初の添字 `i` を返す関数
## `index( Array, element )`。以下参照: `arrays`。
#b 配列を引数とするユーザ定義関数の許可。
^<br>
## 例: dot(A,B) = sum [i=1:|A|] A[i]*B[i]
#b 配列名に範囲を指定することで部分配列を実現。
## Array[n] は単一の要素、Array[n:n+5] は元の配列の 6 要素を持つ部分配
## 列。以下参照: `arrays`, `slice`。
#b `split("string", "separator")` は、文字列 string に含まれるフィール
## ド要素を、文字列の配列に詰めて返します。以下参照: `split`。
#b `join(array, "separator")` は、`split` の逆で、文字列配列の要素を、
## フィールド区切り文字 separator を間に挟んで結合して一つの文字列にし
## たものを返します。以下参照: `join`。
#b `stats <non-existent file>` はテスト可能な値を出力。以下参照:
## `stats test`。
#b `stats $vgrid` で格子内のボクセルの最小/最大/平均/標準偏差を調査
#end

3 プログラムの流れの制御 (Program control flow)
?control flow
#start
#b 新しい構文 `if ... else if ... else ...`
#b gnuplot の設定選択で、XDG ベースのディレクトリ配置をサポートしていま
## す。gnuplot は、$XDG_CONFIG_HOME/gnuplot/gnuplotrc から初期コマンド
## を読み込みます。対話コマンド履歴は、$XDG_STATE_HOME/gnuplot_history
## に保存します。これらのファイルがない場合は、gnuplot の以前のバージョ
## ンと同様、$HOME/.gnuplot と $HOME/.gnuplot_history をそれぞれ使用し
## ます。
#b `unset warnings` は、コンソールへの警告メッセージ出力を抑制します。
#b コマンド "fit" に対する例外処理。fit エラーが起きた場合でも、制御を
## 常に入力の次の行に返します。エラーが起きた場合は、返ったときに
## FIT_ERROR がゼロでない値になります。これは、良くないフィッティングか
## ら復帰するスクリプトを可能にします。以下参照: `fit error_recovery`。
#end

3 新しい出力形式とオプション (New terminals and terminal options)
?new terminals
#start
#b 新しい出力形式 `block` は、疑似グラフィックのテキストモード用のもの
## で、`dumb` や `caca` 出力形式に対して改良された解像度を提供するため
## に Unicode ブロック、あるいは点字 (Braille 文字) を使用します。
#b 新しい出力形式 `webp` は、webp エンコーディングを用いて、単一フレー
## ムか、アニメーション列を生成します。各フレームは pngcairo で生成し、
## その後 libwebp と libwebpmux による WebPAnimEncoder API を通してエン
## コードを行います。
#end

3 ウォッチポイント (Watchpoints)
?new watchpoints
 ウォッチポイントは、グラフ内の個々の曲線に関連する対象値です。曲線が描
 画されるとき、各線分要素が、その両端点の間にウォッチポイント座標 (x, y
 か z) か関数 f(x,y) の対象値を含んでいるかを確認します。それが見つかっ
 た場合、そのマッチする点の座標 [x,y] を後で使用するために保存します。
 以下参照: `watchpoints`。
#start
#b 2 つの曲線の交点を見つけること
#b 関数のゼロ点を見つけること
#b 従属変数 (y か z) か、関数 f(x,y) が指定値と一致する場所を見つけ表示
## すること
#b マウスを使って複数のグラフに沿った値を同時に追跡すること
#end

3 週曜日のサポート (Week-date time support)
?new week-date time
 2020-2021 年に起きた新型コロナウィルス (Covid-19) の騒動では、疫学的デ
 ータのグラフ化の関心が高まりましたが、そこでは報告の慣習として、よく
 「週曜日」を使った表が示されていました。この慣習に対する gnuplot のサ
 ポートの不足は改善し、週曜日もサポートするように拡張してあります。
#start
#b 日時書式 %W は、ISO 8601 の週曜日規則に従うようになりました。
#b 日時書式 %U は、CDC/MMWR の週曜日規則に従うようになりました。
#b 新しい関数 `tm_week(time, std)` は、ISO か CDC 規則でのその年の週番
## 号を返します。
#b 新しい関数 `weekdate_iso(year, week, day)` は、ISO 規則での週曜日を
## カレンダー時刻に変換します。
#b 新しい関数 `weekdate_cdc(year, week, day)` は、CDC 規則での週曜日を
## カレンダー時刻に変換します。
#end
D epi_data 1

3 その他の新しい機能
?new features
#start
#b `時間軸の主目盛りと副目盛り用の時間単位`
## 時間軸の主目盛りと副目盛りは、minutes/hours/days/weeks/months/years
## を単位とする目盛り間隔指定を受け付けます。
## 以下参照: `set xtics`, `set mxtics time`。
#b `using` 指定内での文字列 $# は、現在の入力データ行にある全列数と評価
## します。例えば、"plot FOO using 0:(column($# - 1))" は、各行の最後か
## ら一つ手前の列を描画します。
#b bin (箱) 用データの和でなく平均を描画するキーワード `binvalue=avg`
#b `set colorbox bottom` は、カラーボックスをグラフの下に配置します。
#b cbtics 以外の軸には影響しない `set colorbox cbtics <linestyle>`
#b 交差する pm3d 曲面のレンダリングの改良 - 重なる曲面のタイルを、交差
## 曲線に沿って 2 つの部分に分割し、一方の曲面のタイルが他方の曲面を通
## って不正に突き出てしまうことがないようにします。
#b pm3d 光源モデルに、ユーザ制御型のスポットライトを追加。以下参照:
## `set pm3d spotlight`。
#b key の全体の幅と列数を固定する新規オプション。以下参照: `key layout`。
#b `set pm3d border retrace` は、各 pm3d 四辺形の周りに、塗り潰し領域と
## 同じ色で境界を描きます。これは、原理的に視覚効果はありませんが、あま
## りよくない pdf や postscript ビューワのようなディスプレイモードで、
## アンチエイリアスによる副産物が導入されないようにします。
#b `set isotropic` は、2 次元グラフと 3 次元グラフの両方で、x, y, z 軸
## のすべてのスケールが同じになるようにスケールを合わせます。
#b 変更: 文字の回転角が整数という制限はなくなりました。
#b 特別な (非数値の) 線種 (linetype) `lt nodraw`, `lt black`, `lt bgnd`
## 以下参照: `special_linetypes`。
#b データ駆動型の histogram グラフの色割り当て。以下参照:
## `histograms colors`。
#b 凡例 (key) の箱の位置は、gnuplot が他に行う仕組みによるどんな位置決
## めに対しても、オフセットを与えることで手動で調整できます。以下参照:
## `set key offset`。
#end

3 バージョン 5 で導入された機能の要約 (3 Brief summary of features introduced in version 5)
?new version_5
?version_5

4 5.4 で導入された機能 (Features introduced in 5.4)
?new version_5 version_5.4
?version_5 version_5.4
#start
#b 数式と関数は 64 ビット整数演算を使用。以下参照: `integer`。
#b 2 次元描画スタイル `polygons`, `spiderplot`, `arrows`
#b 3 次元描画スタイル `boxes`, `circles`, `polygons`, `isosurface`, そ
## してその他ボクセル格子データの表現
#b データ前処理フィルタ `zsort`
#b カスタマイズした凡例 (key) を作成する `keyentry`
#b もはやデフォルトではビルドしない古い LaTeX 系出力形式 `latex`,
## `emtex`, `eepic`, `tpic` の代わりの出力形式 pict2e
#b `set pixmap` は、png/jpeg/gif 画像をピクスマップ画像として取り込み、
## グラフやページの任意の位置に配置しスケール変換も可能
#b 拡張文字列モードで \U+xxxx (xxxx は 16 進値の 4 または 5 文字) で
## Unicode コードポイントが指定できるように。それは出力時に対応する
## UTF-8 バイト文字列に変換します。
#b `with parallelaxes` の書式の改変により、描画スタイル `histogram` や
## `spiderplot` と同様な plot コマンド内部での便利な繰り返しが可能に
#end

4 5.2 で導入された機能 (Features introduced in 5.2)
?new version_5 version_5.2
?version_5 version_5.2
#start
#b 非線形座標系 (以下参照: `set nonlinear`)
#b データの階級幅割り当ての自動化 (以下参照: `bins`)
#b 2 次元ビースウォームグラフ。以下参照: `set jitter`。
#b 3 次元描画スタイル `zerrorfill`
#b 3 次元光源モデルで陰影と反射光ハイライトを提供 (以下参照: `lighting`)
#b 配列データ型と関連するコマンドや演算子。以下参照: `arrays`。
#b 新しい出力形式 `sizelgd`, `domterm`
#b 相対時間 (間隔長) を処理する新しい書式指定子 tH tM tS。
## 以下参照: `time_specifiers`。
#end

4 5.0 で導入された機能 (Features introduced in 5.0)
?new version_5 version_5.0
?version_5 version_5.0
#start
#b 出力形式に依存しない点線/破線型。
#b ひとつの plot での引き続く描画要素に使用するデフォルトの色の列は、色
## 弱者により容易に区別できるものに。
#b 新しい描画スタイル `with parallelaxes`, `with table`。
#b マウスがその上にあるときに有効になるハイパーテキストラベル。
#b 2 次元、3 次元関数描画や疑似ファイル '+', '++' での描画における明示
## 的なサンプリング範囲。
#b 新しいコマンド `import` によるプラグインのサポート。外部の共有オブジ
## ェクトが提供する関数にユーザ定義関数名を割り当てます。
#end

2 バージョン 5 と 6 との違い (2 Differences between versions 5 and 6)

 バージョン 5 で導入したいくつかの変更は、gnuplot の以前のバージョン用
 のスクリプトを失敗させる、または異なる振舞いをさせることがありました。
 バージョン 6 で導入した変更では、そういうことはとても少ないです。

3 非推奨な書式 (Deprecated syntax)
?deprecated syntax
 バージョン 5.4 では非推奨、6.0 では削除:
       # 繰り返しを行うために `reread` を含むファイルを使用
       N = 0;  load "file-containing-reread";
       file content:
           N = N+1
           plot func(N,x)
           pause -1
           if (N<5) reread
 現在の同等の機能:
       do for [N=1:5] {
           plot func(N, x)
           pause -1
       }

 バージョン 5.4 では非推奨、6.0 では削除
       set dgrid3d ,,foo     # foo が意味する指示のキーワードがない
 現在は以下と同等
       set dgrid3d qnorm foo # (例のみ、qnorm は単独のオプションでない)

 バージョン 5.0 では非推奨、6.0 では削除
       set style increment user
 現在は以下と同等
       必要な範囲の線種を "set linetype" を使用して再定義

 バージョン 5.0 では非推奨、6.0 では削除
       show palette fit2rgbformulae

2 デモ、ネット上のサンプル (Demos and Online Examples)
?demos
?online examples
?examples
 `gnuplot` の配布物の `demo` ディレクトリ内には、多くのサンプルが収めら
 れています。これらのサンプルの png, svg, canvas 出力形式による出力を、
 以下のネット上で見ることもできます:
^ <a href="http://gnuplot.info/demos/">
   http://gnuplot.info/demos
^ </a>
 そこでは、各デモを作成するコマンドがグラフの隣りに表示されますし、その
 gnuplot スクリプトをダウンロードすることもできますので、それを保存し同
 様のグラフを作成することができます。

2 バッチ/対話型操作 (Batch/Interactive)
?batch/interactive
 `gnuplot` は、バッチ処理形式、あるいは対話型のどちらの形式でも実行でき、
 それらを組み合わせることも可能です。

 コマンドライン引数は、プログラムへのオプションか、`gnuplot` コマンドを
 含むファイルの名前であると解釈します。
 各ファイルとコマンド文字列は、指定した順に実行します。
 特別なファイル名 "-" は、コマンドを標準入力から読込むことを意味します。
 最後のファイルを実行した後に `gnuplot` は終了します。読み込ませるファ
 イル、およびコマンド文字列を指定しなかった場合は、`gnuplot` は標準入力
 からの対話型の入力を受け付けます。
3 コマンドラインオプション (command line options)
?command-line-options
?batch/interactive command-line-options
 gnuplot は、コマンドラインで以下のオプションを受けつけます:
      -V, --version
      -h, --help
      -p, --persist
      -d, --default-settings
      -s, --slow
      -e  "command1; command2; ..."
      -c  scriptfile ARG1 ARG2 ...

 -p は、プログラムの終了時に、残っている対話型グラフウィンドウを一切閉
 じないよう gnuplot に指示します。

 -d は、各ユーザ用、およびシステム用の初期化 (以下参照: `initialization`)
 を一切行わないよう gnuplot に指示します。

 -s は、起動時のフォントの初期化をゆっくり待つように指示します。そうで
 ないと、エラーを表示し、不正なフォントサイズ情報で動作を継続します。

 -e "command" は、次に進む前に指定した単一のコマンドを実行するよう
 gnuplot に指示します。

 -c は、-e "call scriptfile ARG1 ARG2 ..." と同等です。以下参照: `call`。
3 例 (Examples)
?batch/interactive examples
 対話を開始する:
       gnuplot

 バッチモードで 2 つのコマンドファイル "input1", "input2" を実行:
       gnuplot input1 input2

 初期化ファイル "header" の後、対話型モードを起動し、その後別のコマンド
 ファイル "tailer" を実行する:
       gnuplot header - trailer

 コマンドラインから `gnuplot` コマンドを直接与え、終了後にスクリーン上
 にグラフが残るようにオプション "-persist" を使う:
       gnuplot -persist -e "set title 'Sine curve'; plot sin(x)"

 ファイルのコマンドを実行する前に、ユーザ定義変数 a と s をセットする:
       gnuplot -e "a=2; s='file.png'" input.gpl
2 キャンバスサイズ (Canvas size)
?canvas size
?canvas
?set term size

 ここの文書で使用する "canvas" という用語は、グラフやそれに関連するラベ
 ルやタイトル、凡例などを配置するのに利用可能な描画領域全体を意味します。
 注意: HTML5 canvas 出力形式に関する情報を知りたい場合は、以下参照:
 `set term canvas`。

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。デフォルトでは、グラフはその
 キャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、問題が起
 こるかもしれないことに注意してください。

 例:

       set size 0.5, 0.5
       set term png size 600, 400
       set output "figure.png"
       plot "data" with lines

 このコマンドは、幅 600 ピクセル、高さ 400 ピクセルの出力ファイル
 "figure.png" を生成します。グラフはキャンバスの中の左下に置かれます。

 注意: gnuplot の以前のバージョンでは、`set size` を出力キャンバスのサ
 イズ自体を制御するのに使用する出力形式がありましたが、それはバージョン
 4 で非推奨となっています。

2 コマンドライン編集 (Command-line-editing)
?line-editing
?editing
?command-line-editing
 コマンドラインでの編集機能とコマンドヒストリの機能は、外部の GNU
 readline ライブラリか外部の BSD libedit ライブラリ、または組み込まれて
 いる同等のもののいずれかを使ってサポートしています。この選択は、
 gnuplot のコンパイル時の configure のオプションで行います。

 組み込みの readline 版の場合の編集コマンドは以下の通りですが、DEL キー
 に関する動作はシステムに依存することに注意してください。GNU readline
 ライブラリと BSD libedit ライブラリに関しては、それ自身のドキュメント
 を参照してください。

@start table - まずは対話型テキスト形式
       `行編集`:

       ^B    1 文字前へ戻す
       ^F    1 文字先へ進める
       ^A    行の先頭に移動
       ^E    行の最後に移動
       ^H    直前の文字を削除
       DEL   現在の文字を削除
       ^D    現在位置の文字を削除、空行なら EOF を送信
       ^K    現在位置から行末まで削除
       ^L    壊れた表示の行を再表示
       ^U    行全体の削除
       ^W    直前の単語を削除
       ^V    この次のキーを編集コマンドと見なさない
       TAB   ファイル名補完動作

       `履歴`:

       ^P    前の履歴へ移動
       ^N    次の履歴へ移動
       ^R    後方検索を開始

#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{コマンド行編集コマンド} \\ \hline \hline
#文字 & 機能 \\ \hline
# & \multicolumn{1}{|c|}{行編集}\\ \cline{2-2}
#\verb~^B~ & 1 文字前へ戻す\\
#\verb~^F~ & 1 文字先へ進める\\
#\verb~^A~ & 行の先頭へ移動\\
#\verb~^E~ & 行の最後へ移動\\
#\verb~^H~ & 直前の文字を削除\\
#\verb~DEL~ & 現在の文字を削除\\
#\verb~^D~ & 現在位置の文字を削除、空行なら EOF\\
#\verb~^K~ & 現在位置から行末まで削除\\
#\verb~^L~ & 壊れた表示の行を再表示\\
#\verb~^U~ & 行全体の削除\\
#\verb~^W~ & 直前の単語を削除\\
#\verb~^V~ & この次のキーを編集コマンドと見なさない\\
#\verb~TAB~ & ファイル名補完動作\\ \hline
# & \multicolumn{1}{|c|}{履歴} \\ \cline{2-2}
#\verb~^P~ & 前の履歴へ移動\\
#\verb~^N~ & 次の履歴へ移動\\
#\verb~^R~ & 後方検索を開始\\
%c l .
%文字@機能
%_
%@行編集
%^B@1 文字前へ戻す
%^F@1 文字先へ進める
%^A@行の先頭に移動
%^E@行の最後に移動
%^H@直前の文字を削除
%DEL@現在の文字を削除
%^D@現在位置の文字を削除、空行なら EOF
%^K@現在位置から行末まで削除
%^L@壊れた表示の行を再表示
%^U@行全体の削除
%^W@直前の単語を削除
%_
%^V@この次のキーを編集コマンドと見なさない
%TAB@ファイル名補完動作
%_
%@履歴
%^P@前の履歴へ移動
%^N@次の履歴へ移動
%^R@後方検索を開始
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>文字</th>    <th>機能</th></tr>
^</thead>
^<tbody>
^<tr>    <td></td>    <th>行編集</th></tr>
^<tr>    <td><tt>^B</tt></td>    <td>1 文字前へ戻す</td></tr>
^<tr>    <td><tt>^F</tt></td>    <td>1 文字先へ進める</td></tr>
^<tr>    <td><tt>^A</tt></td>    <td>行の先頭へ移動</td></tr>
^<tr>    <td><tt>^E</tt></td>    <td>行の最後へ移動</td></tr>
^<tr>    <td><tt>^H</tt></td>    <td>直前の文字を削除</td></tr>
^<tr>    <td><tt>DEL</tt></td>    <td>現在の文字を削除</td></tr>
^<tr>    <td><tt>^D</tt></td>    <td>現在位置の文字を削除、空行なら EOF</td></tr>
^<tr>    <td><tt>^K</tt></td>    <td>現在位置から行末まで削除</td></tr>
^<tr>    <td><tt>^L</tt></td>    <td>壊れた表示の行を再表示</td></tr>
^<tr>    <td><tt>^U</tt></td>    <td>行全体の削除</td></tr>
^<tr>    <td><tt>^W</tt></td>    <td>直前の単語を削除</td></tr>
^<tr>    <td><tt>^V</tt></td>    <td>この次のキーを編集コマンドと見なさない</td></tr>
^<tr>    <td><tt>TAB</tt></td>    <td>ファイル名補完動作</td></tr>
^</tbody>
^<tbody>
^<tr>    <th></th>    <th>履歴</th></tr>
^<tr>    <td><tt>^P</tt></td>    <td>前の履歴へ移動</td></tr>
^<tr>    <td><tt>^N</tt></td>    <td>次の履歴へ移動</td></tr>
^<tr>    <td><tt>^R</tt></td>    <td>後方検索を開始</td></tr>
^</tbody>
^</table>
2 コメント (Comments)
?comments
 コメント記号 `#` は、コマンド行中のほとんどどこにでも書くことができま
 す。このとき `gnuplot` は、その行の残りの部分を無視します。ただし、記
 号 `#` は引用符内ではこの効果がありません。コメント行が '\' で終わって
 いる場合、次の行もコメントの一部として扱われることに注意してください。

 データファイルに対するコメント文字の指定については、以下参照:
 `set datafile commentschars`。
2 座標系 (Coordinates)
?coordinates
=axes
 コマンド `set arrow`, `set key`, `set label`, `set object` はグラフ上
 の任意の位置が指定できます。その位置は以下の書式で指定します:

       {<system>} <x>, {<system>} <y> {,{<system>} <z>}

 各座標系指定 <system> には、`first`, `second`, `polar`, `graph`,
 `screen`, `character` のいずれかが入ります。

 `first` は左と下の軸で定義される x,y (3D の場合は z も) の座標系を使用
 します。`second` は x2, y2 軸 (上と右の軸) を使用します。`graph` はグ
 ラフ描画領域内の相対的位置を指定し、左下が 0,0 で 右上が 1,1 (splot の
 場合はグラフ描画領域内の左下が 0,0,0 で、土台の位置は負の z の値を使用
 します。以下参照: `set xyplane`) となります。`screen` は表示範囲内 (範
 囲全体であり、`set size` で選択される一部分ではありません) を指定し、
 左下が 0,0 で 右上が 1,1 となります。`character` 座標は主にずれを指定
 するのに使用し、絶対的な位置を示すものではありません。`character` の水
 平、垂直サイズは、現在使用しているフォントに依存します。

 `polar` は、最初の 2 つの値を、x, y ではなく、角 theta と半径 r である
 と解釈します。これは、例えば 2 次元の極座標、あるいは 3 次元円柱座標で
 のグラフにラベルを配置するのに役に立つでしょう。

 x の座標系が指定されていない場合は `first` が使われます。y の座標系が
 指定されていない場合は x に対する座標系が使用されます。

 与える座標が絶対的な位置ではなくて相対的な値である場合もあります (例え
 ば `set arrow` ... `rto` の 2 番目の数値)。そのほとんどが、与えられた
 数値を最初の位置に対する差として使います。与えられた座標が対数軸内にあ
 る場合は、その相対的な値は倍率として解釈されます。例えば

       set logscale x
       set arrow 100,5 rto 10,2

 は、x 軸が対数軸で y 軸が線形の軸なので、100,5 の位置から 1000,7 の位
 置への矢印を書くことになります。

 一つ (あるいはそれ以上) の軸が時間軸である場合、`timefmt` の書式文字列
 に従って、引用符で囲まれた時間文字列で適切な座標を指定する必要がありま
 す。以下参照: `set xdata`, `set timefmt`。また、`gnuplot` は整数表記も
 認めていて、その場合その整数は 1970 年 1 月 1 日からの秒数と解釈されま
 す。
2 文字列データ (Datastrings)
?datastrings
 データファイルには、ホワイトスペース (空白やタブ) を含まない任意の印字
 可能な文字列、あるいは 2 重引用符で囲まれた任意の文字列 (ホワイトスペ
 ースが含まれても良い)、のいずれかの形からなる文字列データを持たせるこ
 とも可能です。データファイルに次のような行が含まれている場合、それは 4
 つの列を含み、3 列目がテキスト部分であると見なされます:

   1.000 2.000 "Third column is all of this text" 4.00

 テキスト部分は 2 次元や 3 次元描画内で例えば以下のように使用されます:

   plot 'datafile' using 1:2:4 with labels
   splot 'datafile' using 1:2:3:4 with labels

 テキスト部分の列データは 1 つ、または複数の描画軸の目盛りのラベルとし
 て使用できます。次の例は、入力データの 3 列目と 4 列目を (X,Y) 座標と
 して取り出し、それらの点の列を結ぶ線分を描画します。しかしこの場合
 gnuplot は、x 軸に沿って標準的に間の空いた数字ラベルのついた目盛り刻み
 をつけるのではなく、入力データファイルの 1 行目の X 座標の位置に、目盛
 り刻みと文字列を x 軸に沿ってつけて行きます。

   set xtics
   plot 'datafile' using 3:4:xticlabels(1) with linespoints

=columnheader
 入力データの列の最初のエントリ (すなわち列の見出し) をテキスト部分と解
 釈するもう一つのオプションがあり、それはテキスト部分を、その描画した列
 のデータの凡例 (key) のタイトル部分として使用します。次の例は、先頭の
 行の 2 列目の部分を凡例ボックス内のタイトルを生成するのに使用し、その
 後の列の 2,4 列目は要求された曲線を描画するのに処理されます:

   plot 'datafile' using 1:(f($2)/$4) with lines title columnhead(2)

 別の例:

   plot for [i=2:6] 'datafile' using i title "Results for ".columnhead(i)

 この列の先頭を使用する方法は、`set datafile columnheaders` か
 `set key autotitle columnhead` で自動化できます。以下参照: `labels`,
 `using xticlabels`, `plot title`, `using`, `key autotitle`。
2 拡張文字列処理モード (Enhanced text mode)
?enhanced text
?enhanced
?text_markup
?markup
?bold
?italic
 多くの出力形式が、拡張文字列処理モード (enhanced text mode) をサポート
 しています。これは、文字列に追加の書式情報を埋めこみます。例えば "x^2"
 は x の自乗を、通常我々が見る上付きの 2 がついた形で書き出します。この
 モードは、出力形式の設定時にデフォルトとして選択されますが、その後で
 `set termoption [no]enhanced` を使ってその機能を有効/無効にもできます
 し、`set label "x_2" noenhanced` のように個別の文字列に対して無効にす
 ることもできます。

 注意: TeX ベースの出力形式 (例えば cairolatex, pict2e, pslatex, tikz)
 の出力では、すべてのテキスト文字列には、これの代わりに TeX/LaTeX の書
 式を使用すべきです。以下参照: `latex`。


@start table - まずは対話型テキスト形式
  制御記号     例              説明
   ^           a^x             上付き文字
   _           a_x             下付き文字
   @           @x, a@^b_{cd}   空ボックス (幅がない)
   &           &{space}        指定した長さのスペースを挿入
   ~           ~a{.8-}         'a' の上に '-' を、現在のフォントサ
                               イズの .8 倍持ち上げた位置に重ね書き
   {/Times abc}                Times フォント、今のサイズで abc を出力
   {/Times*2 abc}              Times フォント、今の倍のサイズで abc
   {/Times:Italic abc}         TImes フォント、イタリック体で abc
   {/Arial:Bold=20 abc}        Arial フォント、太字、サイズ 20 で abc
   \U+         \U+221E         Unicode コードポイント U+221E (無限大)
#\begin{tabular}{|clll|} \hline
#\multicolumn{4}{|c|}{拡張文字列制御記号} \\ \hline
#制御記号 & 例 & 結果 & 説明 \\ \hline
#\verb~^~ & \verb~a^x~ & $a^x$ & 上付き文字\\
#\verb~_~ & \verb~a_x~ & $a_x$ & 下付き文字\\
#\verb~@~ & \verb~a@^b_{cd}~ & $a^b_{cd}$ & 空ボックス (幅がない)\\
#\verb~&~ & \verb~d&{space}b~ & d\verb*+     +b & 指定した長さのスペースを挿入\\
#\verb|~| & \verb|~a{.8-}| & $\tilde{a}$ & 'a' の上に '-' を、現在のフォントサ\\
#\verb~ ~ & \verb~ ~ & ~ ~ & イズの .8 倍持ち上げた位置に重ね書き\\
#\verb| | & \verb|{/Times abc}| & {\rm abc} & Times フォント、今のサイズで abc を出力\\
#\verb| | & \verb|{/Times*2 abc}| & \Large{\rm abc} & Times フォント、今の倍のサイズで abc\\
#\verb| | & \verb|{/Times:Italic abc}| & {\it abc} & Times フォント、イタリック体で abc\\
#\verb| | & \verb|{/Arial:Bold=20 abc}| & \Large\textsf{\textbf{abc}} & Arial フォント、太字、サイズ 20 で abc\\
#\verb|\U+| & \verb|\U+221E| & $\infty$ & Unicode コードポイント U+221E 無限大\\
%c c l .
C ugly - doc2ms uses @ for column separator, but here we
C  need @ in table, so end and restart the table !
%.TE
%.TS
%center box tab ($) ;
%c c l .
%制御記号$例$説明
%_
%^$a^x$上付き文字
%\&_$a\&_x$下付き文字
% @ $ @x, a\&@^b\&_{cd}$空ボックス (幅がない)
% & $ &{space}$指定した長さのスペースを挿入
% ~ $ ~a{.8-}$'a' の上に '-' を、現在のフォントサ
%   $   $イズの .8 倍持ち上げた位置に重ね書き
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>制御記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt> ^ </tt></td>    <td><tt>a^x</tt></td>    <td>上付き文字</td></tr>
^<tr>    <td><tt> _ </tt></td>    <td><tt>a_x</tt></td>    <td>下付き文字</td></tr>
^<tr>    <td><tt> @ </tt></td>    <td><tt> @x</tt>, <tt>a@^b_{cd}</tt></td>    <td>空ボックス (幅がない)</td></tr>
^<tr>    <td><tt> &amp;</tt></td>    <td><tt> &amp;{space}</tt></td>    <td>指定した長さのスペースを挿入</td></tr>
^<tr>    <td><tt> ~ </tt></td>    <td><tt> ~a{.8-}</tt></td>    <td>'a' の上に '-' を、現在のフォントサ<br>イズの .8 倍持ち上げた位置に重ね書き</td></tr>
^</tbody>
^</table>

 書式制御文字は、それに続く 1 文字、または中カッコで囲まれたものに適用
 されます。中カッコ内には、例えば 2^{10} のような追加の書式文字列のない
 文字列か、またはフォントの属性を変更する追加制御文字列を入れることがで
 きます。フォント指定は、開き中カッコ '{' の直後に続く '/' のすぐ次に書
 かなければ「いけません」。フォント名にスペースが含まれる場合、それを単
 一、または二重引用符で囲まなければいけません。

 例: 最初の例はその中カッコの入れ子を示していて、ボールド体の A にイタ
 リック体の下付きの添字 i がついたものが、いずれも現在のフォントで描か
 れます。この例の :Normal を取ると、下付きの添字はボールド体でかつイタ
 リック体になります。2 つ目の例は同じ書式制御を 20 ポイントサイズの
 "Times New Roman" フォントに適用したものです。
      {/:Bold A_{/:Normal{/:Italic i}}}
      {/"Times New Roman":Bold=20 A_{/:Normal{/:Italic i}}}

 空ボックス (phantom box) は a@^b_c の上付き文字と下付き文字を揃えると
 きに有用ですが、文字にダイアクリティカルマークを重ねる場合にはうまく働
 きません。その目的のためには、アクセントやその他のダイアクリティカルマ
 ークのある文字を持つエンコード (例えば utf8) を使用する方がいいでしょ
 う。以下参照: `set encoding`。そのボックスはスペーシングが行なわれない
 ので、ボックス内 (つまり @ の後ろ) の上付き文字や下付き文字を短く出力
 するのに適しています。

 ある文字列と同じ長さのスペースを文字 '&' を使うことで入れることができ
 ます。すなわち、
         'abc&{def}ghi'
 は以下を生成します (abc と ghi の間は 3 文字分の空白):
         'abc   ghi'

 文字 '~' は、次の文字、またはカッコで囲まれた文字列に、それに続く文字
 またはカッコで囲まれた文字列を重ね書きします。2 番目の文字は最初の文字
 にあわせて水平方向にセンタリングされます。よって '~a/' は 'a' を貫くよ
 うなスラッシュが得られます。2 番目の文字は、その前に数字を置くことで垂
 直方向に移動させることができます。その数字は現在のフォントサイズに対す
 る割合を意味し、それに従って文字が上がったり下がったりします。この場合
 数字と文字列は 1 文字より長くなるのでカッコで囲む必要があります。重ね
 書きされる文字列が数字から始まっている場合は、垂直にずらす値と文字列と
 の間にスペースを入れてください ('~{abc}{.5 000}')。それ以外はスペース
 は不要です ('~{abc}{.5---}')。一方、あるいは両方のフォントを変更するこ
 ともできます ('~a{.5 /*.2 o}'; 'a' その 1/5 の大きさの 'o'、この場合数
 字とスラッシュの間のスペースは必要です) が、その文字列が始まった後で変
 更することはできません。それぞれの文字列内で、他の特殊な書式を使うこと
 もできません。制御文字はエスケープしないといけません。例: サーカムフレ
 ックス付きの a (\U+00E2) を印字するには '~a{.8\^}' とします。

 二重引用符内の文字列は単一引用符内の文字列とは異なって解釈されることに
 注意してください。主な違いは、二重引用符内の文字列ではバックスラッシュ
 は 2 つ重ねる必要があることです。

 gnuplot ソース配布物内の /docs/psdoc サブディレクトリにあるファイル
 "ps_guide.ps" に、拡張された書式に関する例が載っています。同様のものが
 デモ
^ <a href="http://www.gnuplot.info/demo/enhanced_utf8.html">
 `enhanced_utf8.dem`
^ </a>
 にもあります。

3 エスケープシーケンス (escape sequences)
?escape sequences
?enhanced text escape sequences
?unicode
 バックスラッシュ文字 \ は、1 バイト文字コード、または Unicode コードポ
 イントをエスケープするのに使います。

 \ooo の形式 (ooo は 8 進値の 3 文字) は、特定のフォントエンコード内の
 文字コード番号を指し示すのに使えます。例えば、Adobe Symbol フォントは、
 無限大の記号を 8 進 245 番で示すようなカスタムエンコードを使用します。
 これは、拡張文字列としてフォント名と文字コードを "{/Symbol \245}" のよ
 うに指定することで埋め込むことができます。これは主に PostScript 出力形
 式で有用ですが、これは UTF-8 エンコーディングの処理は容易には行えませ
 ん。

 \U+hhhh の形式の Unicode のコードポイントで文字を指定することができま
 す。ここで hhhh は 16 進値の 4 または 5 文字です。例えば、無限大の記号
 ∞のコードポイントは \U+221E です。これは、必要ならば出力時に UTF-8 の
 バイト列に変換されます。UTF-8 環境では、印字可能な特殊文字は他の文字と
 同様に文字列内で処理できるので、この仕組みは必要ありません。しかしこれ
 は結合文字や発音区別符号 (例えばベクトルを意味するための文字の上の矢印
 など) には有用です。以下参照: `set encoding`, `utf8`。または
^ <a href="http://www.gnuplot.info/demo_5.4/unicode.html">
 オンラインユニコードデモ
^ </a>
 を参照。

2 環境変数 (Environment)
?environment
 `gnuplot` は多くのシェル環境変数を認識します。必須のものはありません。

 GNUTERM は、それが定義されていれば、起動時に "set term" に渡されます。
 これは、システム、または個人的な初期化ファイルによる指定 (以下参照:
 `startup`)。や、もちろんその後の明示的な `set term` コマンドによる指定
 で変更できます。
 terminal オプションを入れることもできます。例:
      bash$ export GNUTERM="postscript eps color size 5in, 3in"

 GNUHELP は、それが定義されていれば、ヘルプファイル (gnuplot.gih) のパ
 ス名に設定します。

 起動時の初期化には、設定ファイル $HOME/.gnuplot と
 $XDG_CONFIG_HOME/gnuplot/gnuplotrc を探します。MS-DOS, Windows, OS/2
 では GNUPLOT か USERPROFILE で指定されたファイルを探します。詳細につい
 ては以下参照: `startup`。

 Unix においては、PAGER がヘルプメッセージの出力用のフィルタとして使わ
 れます。

 Unix では、SHELL が `shell` コマンドの際に使われます。MS-DOS, OS/2 で
 は COMSPEC が使われます。

 FIT_SCRIPT は、当てはめ (fit) が中断されたときに実行する `gnuplot` コ
 マンドの指定に使われます。以下参照: `fit`。FIT_LOG は当てはめによるロ
 グファイルのデフォルトのファイル名の指定に使われます。

 GNUPLOT_LIB は、データやコマンドファイルの検索ディレクトリを追加定義す
 るのに使われます。その変数は、一つのディレクトリ名かまたは複数のディレ
 クトリ名を書くことができますが、ディレクトリの区切りはプラットホーム毎
 に違います。例えば Unix では ':' で、MS-DOS, Windows, OS/2 では ';' で
 す。GNUPLOT_LIB の値は変数 `loadpath` に追加されますが、それは `save`
 や `save set` コマンドでは保存されません。

 出力ドライバの中には gd ライブラリ経由で TrueType フォントを扱えるもの
 もいくつかあります (以下参照: `fonts`)。これらの出力形式では、
 GDFONTPATH や GNUPLOT_DEFAULT_GDFONT がフォントの選択に影響を与えます。

 postscript 出力ドライバは自分で持っているフォント検索パスを使いますが、
 それは、環境変数 GNUPLOT_FONTPATH で制御できます。

 PostScript ドライバは、外部 (組み込まれていない) 定義ファイルを探すた
 めに環境変数 GNUPLOT_PS_DIR を利用します。インストール時の作業により、
 gnuplot にはそれらのファイルのコピーが組み込まれているか、またはデフォ
 ルトのパスが埋め込まれています。この変数は、postscript 出力形式でデフ
 ォルトのファイルの代わりにカスタマイズした prologue ファイルを使用する
 のに利用できます。以下参照: `postscript prologue`。
2 式 (Expressions)
?expressions
?division
 基本的には C, FORTRAN, Pascal, BASIC において利用可能な数学表現を使用
 できます。 演算子の優先順位は C 言語の仕様に従います。数式中の空白文字
 とタブ文字は無視されます。

 gnuplot は "実数" と "整数" 演算を FORTRAN や C のように扱うということ
 に注意してください。"1", "-10" などは整数と見なされ、"1.0", "-10.0",
 "1e1", 3.5e-1 などは実数と見なされます。 これら 2 つのもっとも重要な違
 いは割算です。整数の割算は切り捨てられます: 5/2 = 2。実数はそうではあ
 りません: 5.0/2.0 = 2.5。それらが混在した式の場合、計算の前に整数は実
 数に "拡張" されます: 5/2e0 = 2.5。負の整数を正の整数で割る場合、その
 値はコンパイラによって変わります。"print -5/2" として、あなたのシステ
 ムが常に切り捨てる (-5/2 で -3 になる) のか、または 0 の近くに丸める
 (-5/2 で -2 になる) のかを確認してください。

 数式 "1/0" は "未定義値 (undefined)" フラグを生成し、それによりその点
 を無視します。あるいは、あらかじめ定義されている値 NaN を使っても同じ
 ことになります。例については、以下参照: `using`。
=NaN

 gnuplot は文字列に対する単純な演算、および文字列変数も利用できます。例
 えば式 ("A" . "B" eq "AB") は真と評価されますが、これは文字列の結合演
 算子と文字列の等号演算子を意味しています。

 数としての値を含む文字列は、それが数式で利用された場合は、対応する整数
 や実数に変換されます。よって、("3" + "4" == 7) や (6.78 == "6.78") は
 どちらも真になります。整数は、それが文字列結合演算子で使われた場合は文
 字列に変換されますが、実数や複素数はダメです。典型的な例は、ファイル名
 や他の文字列内に整数を使う場合でしょう: 例えば ("file" . 4 eq "file4")
 は真です。

 後置指定する範囲記述子 [beg:end] によって、部分文字列を指定することが
 できます。例えば、"ABCDEF"[3:4] == "CD" で、"ABCDEF"[4:*] == "DEF" で
 す。書式 "string"[beg:end] は、文字列値の組み込み関数
 substr("strings",beg,end) を呼ぶこととほぼ同じですが、関数呼び出しでは
 beg, end は省略することはできません。
3 複素数値 (Complex values)
?complex values
?complex
 計算の演算子とほとんどの組み込み関数は複素数引数の使用をサポートしてい
 ます。複素定数は、{<real>,<imag>} と表記し、<real> と <imag> は、数定
 数である必要があります。よって、{0,1} は 'i' を意味します。
 現在の gnuplot は、あらかじめ I = {0,1} を変数として定義していて、他の
 変数から複素数値を作るのに使えるようにしています。つまり、`x + y*I` は
 正しい数式なのですが、`{x,y}` はそうではありません。
 複素数値 z の実数部分と虚数部分は、real(z), imag(z) として取り出せます。
 長さは abs(z) で、偏角は arg(z) で得られます。

Ffigure_E0
 gnuplot の 2 次元と 3 次元の描画スタイルは、実数値を仮定しています。よ
 って 0 でない虚数部分を持つ複素数値関数 f(x) を描画する場合は、実数部
 分や虚数部分、あるいは長さや偏角を描画させなければいけません。
 例えば複素引数に対する関数 f(z) の複素数値の長さと偏角を表示させるには、
 長さを曲面の高さ、偏角を色で表示するという手があります。
 その場合、HSV 色空間のカラーパレットを用いて、0 から 1 の範囲の H 成分
 (色相) を arg(z) が返す偏角の範囲 [-π:π] に割り当て、偏角が 1 周した
 ら色も巻き戻るようにすると便利でしょう。デフォルトでは、これは H = 0
 (赤) から始まりますが、`set palette` の `start` キーワードを使ってその
 開始位置を変更し、H の他の値を 0 に割り当てることも可能です。
 以下の例は、H = 0.3 (緑) から開始し巻き戻るようにしています。以下参照:
 `set palette defined`, `arg`, `set angles`。

      set palette model HSV start 0.3 defined (0 0 1 1, 1 1 1 1)
      set cbrange [-pi:pi]
      set cbtics ("-π" -pi, "π" pi)
      set pm3d corners2color c1
      E0(z) = exp(-z)/z
      I = {0,1}
      splot '++' using 1:2:(abs(E0(x+I*y))):(arg(E0(x+I*y))) with pm3d

3 定数 (Constants)
?constants
?expressions constants
?octal
?hexadecimal
?complex constants
 整数定数は、C の strtoll() ライブラリルーチンを使って解釈しますが、こ
 れは、"0" で始まる定数は 8 進数と、また "0x" か "0X" で始まる定数は
 16 進数とみなすことを意味します。

 実数 (浮動小数) 定数は、C の atof() ライブラリルーチンを使って解釈しま
 す。

 複素数の定数は {<real>,<imag>} と表現します。ここで <real> と <imag>
 (実部、虚部) は数値定数である必要があります。例えば、{0,1} は 'i' 自身
 を表し、{3,2} は 3 + 2i を表します。これらには明示的に中カッコを使う必
 要があります。この gnuplot では、あらかじめ I = {0,1} を変数として定義
 して、明示的な形式の入力を避ける工夫をしています。例えば、`3 + 2*I` は
 `{3,2}` と同じですが、こちらは虚数成分に変数係数を使えるところが優位で
 す。すなわち、`x + y*I` は正しい数式ですが、`{x,y}` はそうではありませ
 ん。

 文字列定数は単一引用符か二重引用符のいずれかで囲まれた任意の文字の並び
 からなるものです。単一引用符と二重引用符の違いは重要です。以下参照:
 `quotes`。

 例:
      1 -10 0xffaabb        # 整数定数
      1.0 -10. 1e1 3.5e-1   # 実数定数
      {1.2, -3.4}           # 複素数定数
      "Line 1\nLine 2"      # 文字列定数 (\n は改行に展開される)
      '123\na456'           # 文字列定数 (\ と n はそのままの文字)

#TeX \newpage
3 関数 (Functions)
?expressions functions
 特に注意がなければ、`gnuplot` の数学関数の引数は整数、実数、複素数の値
 を取ることができます。角を引数や戻り値とする関数 (例えば sin(x)) は、
 その値をラジアンとして扱いますが、これはコマンド `set angles` によって
 度に変更できます。

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 数学ライブラリ、組み込み関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>abs(x)</td>    <td>整数または実数</td>    <td>|<i>x</i>|, <i>x</i> の絶対値; 同じ型</td></tr>
^<tr>    <td>abs(x)</td>    <td>複素数</td>    <td><i>x</i> の長さ, &radic;( Re(<i>x</i>)<sup>2</sup> + Im(<i>x</i>)<sup>2</sup> )</td></tr>
^<tr>    <td>acos(x)</td>    <td>任意</td>    <td>cos<sup>-1</sup> <i>x</i> (アークコサイン)</td></tr>
^<tr>    <td>acosh(x)</td>    <td>任意</td>    <td>cosh<sup>-1</sup> <i>x</i> (逆双曲余弦)</td></tr>
^<tr>    <td>airy(x)</td>    <td>実数</td>    <td>実数の x に対するエアリー (Airy) 関数 Ai(<i>x</i>)</td></tr>
^<tr>    <td>arg(x)</td>    <td>複素数</td>    <td><i>x</i> の偏角</td></tr>
^<tr>    <td>asin(x)</td>    <td>任意</td>    <td>sin<sup>-1</sup> <i>x</i> (アークサイン)</td></tr>
^<tr>    <td>asinh(x)</td>    <td>任意</td>    <td>sinh<sup>-1</sup> <i>x</i> (逆双曲正弦)</td></tr>
^<tr>    <td>atan(x)</td>    <td>任意</td>    <td>tan<sup>-1</sup> <i>x</i> (アークタンジェント)</td></tr>
^<tr>    <td>atan2(y,x)</td>    <td>整数または実数</td>    <td>tan<sup>-1</sup>(<i>y/x</i>) (アークタンジェント)</td></tr>
^<tr>    <td>atanh(x)</td>    <td>任意</td>    <td>tanh<sup>-1</sup> <i>x</i> (逆双曲正接)</td></tr>
^<tr>    <td>besj0(x)</td>    <td>実数</td>    <td>ラジアンでの <i>J</i><sub>0</sub> ベッセル関数 (0 次ベッセル関数)</td></tr>
^<tr>    <td>besj1(x)</td>    <td>実数</td>    <td>ラジアンでの <i>J</i><sub>1</sub> ベッセル関数 (1 次ベッセル関数)</td></tr>
^<tr>    <td>besjn(n,x)</td>    <td>整数, 実数</td>    <td>ラジアンでの <i>J</i><sub>n</sub> ベッセル関数 (n 次ベッセル関数)</td></tr>
^<tr>    <td>besy0(x)</td>    <td>実数</td>    <td>ラジアンでの <i>Y</i><sub>0</sub> ベッセル関数 (0 次ノイマン関数)</td></tr>
^<tr>    <td>besy1(x)</td>    <td>実数</td>    <td>ラジアンでの <i>Y</i><sub>1</sub> ベッセル関数 (1 次ノイマン関数)</td></tr>
^<tr>    <td>besyn(n,x)</td>   <td>整数, 実数</td>    <td>ラジアンでの <i>Y</i><sub>n</sub> ベッセル関数 (n 次ノイマン関数)</td></tr>
^<tr>    <td>besi0(x)</td>     <td>実数</td>       <td>ラジアンでの <i>I</i><sub>0</sub> 変形ベッセル関数 (0 次変形ベッセル関数</td></tr>
^<tr>    <td>besi1(x)</td>     <td>実数</td>       <td>ラジアンでの <i>I</i><sub>1</sub> 変形ベッセル関数 (1 次変形ベッセル関数</td></tr>
^<tr>    <td>besin(n,x)</td>   <td>整数, 実数</td> <td>ラジアンでの <i>I</i><sub>n</sub> 変形ベッセル関数 (n 次変形ベッセル関数</td></tr>
^<tr>    <td>cbrt(x)</td>    <td>実数</td>    <td>x の三乗根、定義域と値域は共に実数</td></tr>
^<tr>    <td>ceil(x)</td>    <td>任意</td>    <td>&lceil;<i>x</i>&rceil;, <i>x</i> (の実部) 以上の最小の整数</td></tr>
^<tr>    <td>conj(x)</td>    <td>複素数</td>    <td><i>x</i> の複素共役</td></tr>
^<tr>    <td>cos(x)</td>    <td>radians</td>    <td>cos <i>x</i>, <i>x</i> のコサイン</td></tr>
^<tr>    <td>cosh(x)</td>    <td>任意</td>    <td>cosh <i>x</i>, ラジアンでの <i>x</i> のハイパボリックコサイン</td></tr>
^<tr>    <td>EllipticK(k)</td>    <td>(-1:1) 内の実数 k</td>    <td><i>K(k)</i> 第 1 種完全楕円積分</td></tr>
^<tr>    <td>EllipticE(k)</td>    <td>[-1:1] 内の実数 k</td>    <td><i>E(k)</i> 第 2 種完全楕円積分</td></tr>
^<tr>    <td>EllipticPi(n,k)</td>    <td>実数 n&lt;1, (-1:1) 内の実数 k</td>    <td> &Pi;(<i>n,k</i>) 第 3 種完全楕円積分</td></tr>
^<tr>    <td>erf(x)</td>    <td>任意</td>    <td>erf(Re(<i>x</i>)), <i>x</i> の実部の誤差関数</td></tr>
^<tr>    <td>erfc(x)</td>    <td>任意</td>    <td>erfc(Re(<i>x</i>)), 1.0 - (<i>x</i> の実部の誤差関数)</td></tr>
^<tr>    <td>exp(x)</td>    <td>任意</td>    <td><i>e<sup>x</sup></i>, <i>x</i> の指数関数</td></tr>
^<tr>    <td>expint(n,x)</td>    <td>任意</td>    <td><i>E<sub>n</sub></i>(<i>x</i>), <i>x</i> の指数積分</td></tr>
^<tr>    <td>floor(x)</td>    <td>任意</td>    <td>&lfloor;<i>x</i>&rfloor;, <i>x</i> (の実部) 以下の最大の整数</td></tr>
^<tr>    <td>gamma(x)</td>    <td>任意</td>    <td>&Gamma;(Re(<i>x</i>)), <i>x</i> の実部のガンマ関数</td></tr>
^<tr>    <td>ibeta(p,q,x)</td>    <td>任意</td>    <td>ibeta(Re(<i>p,q,x</i>)), <i>p</i>,<i>q</i>,<i>x</i> の実部の不完全ベータ関数</td></tr>
^<tr>    <td>inverf(x)</td>    <td>任意</td>    <td><i>x</i> の実部の逆誤差関数</td></tr>
^<tr>    <td>igamma(a,z)</td>    <td>複素数</td>    <td>igamma(<i>a&gt;0,z</i>), 複素数 <a>a&gt;0</a>,<i>z</i> の不完全ガンマ関数</td></tr>
^<tr>    <td>imag(x)</td>    <td>複素数</td>    <td>Im(<i>x</i>), <i>x</i> の虚数部分 (実数)</td></tr>
^<tr>    <td>int(x)</td>    <td>実数</td>    <td><i>x</i> の整数部分 (0 に向かって丸め)</td></tr>
^<tr>    <td>invibeta(a,b,p)</td>    <td>0&lt;p&lt;1</td>    <td>逆不完全ベータ関数</td></tr>
^<tr>    <td>invigamma(a,p)</td>    <td>0&lt;p&lt;1</td>    <td>逆不完全ガンマ関数</td></tr>
^<tr>    <td>invnorm(x)</td>    <td>任意</td>    <td><i>x</i> の実部の逆正規分布関数</td></tr>
^<tr>    <td>LambertW(z,k)</td> <td>複素数, 整数</td> <td>複素 Lambert W 関数の第 k 分岐</td></tr>
^<tr>    <td>lambertw(x)</td>    <td>実数</td>    <td>Lambert <i>W</i> 関数の主値 (第 0 分岐)</td></tr>
^<tr>    <td>lgamma(x)</td>    <td>実数</td>    <td>lgamma(Re(<i>x</i>)), <i>x</i> の実部のガンマ対数関数</td></tr>
^<tr>    <td>lnGamma(x)</td>    <td>複素数</td>    <td>複素平面全体で正当な lnGamma(x)</td></tr>
^<tr>    <td>log(x)</td>    <td>任意</td>    <td>ln <i>x</i>, <i>x</i> の自然対数 (底 <i>e</i>)</td></tr>
^<tr>    <td>log10(x)</td>    <td>任意</td>    <td>log<sub>10</sub> <i>x</i>, <i>x</i> の対数 (底 10)</td></tr>
^<tr>    <td>norm(x)</td>    <td>任意</td>    <td>norm(<i>x</i>), <i>x</i> の実部の正規分布関数</td></tr>
^<tr>    <td>rand(x)</td>    <td>整数</td>    <td>区間 (0:1) 内の疑似乱数</td></tr>
^<tr>    <td>real(x)</td>    <td>任意</td>    <td>Re(<i>x</i>), <i>x</i> の実数部分</td></tr>
^<tr>    <td>sgn(x)</td>    <td>任意</td>    <td><i>x</i> &gt; 0 なら 1, <i>x</i> &lt; 0 なら -1, <i>x</i> = 0 なら 0. <i>x</i> の虚部は無視</td></tr>
^<tr>    <td>Sign(x)</td>    <td>複素数</td>    <td><i>x</i> = 0 なら 0、それ以外は <i>x</i>/|<i>x</i>|</td></tr>
^<tr>    <td>sin(x)</td>    <td>任意</td>    <td>sin <i>x</i>, <i>x</i> のサイン</td></tr>
^<tr>    <td>sinh(x)</td>    <td>任意</td>    <td>sinh <i>x</i>,ラジアンでの <i>x</i> のハイパボリックサイン</td></tr>
^<tr>    <td>sqrt(x)</td>    <td>任意</td>    <td>&radic;<i>x</i>, <i>x</i> の平方根</td></tr>
^<tr>    <td>SynchrotronF(x)</td> <td>実数</td> <td>(第 1) シンクロトロン関数 F</td></tr>
^<tr>    <td>tan(x)</td>    <td>任意</td>    <td>tan <i>x</i>, <i>x</i> のタンジェント</td></tr>
^<tr>    <td>tanh(x)</td>    <td>任意</td>    <td>tanh <i>x</i>, ラジアンでの <i>x</i> のハイパボリックタンジェント</td></tr>
^<tr>    <td>uigamma(a,x)</td>    <td>実数</td>    <td>uigamma(<i>a,x</i>), 上方不完全ガンマ関数 <a>a&gt;0</a>,<i>x</i></td></tr>
^<tr>    <td>voigt(x,y)</td>    <td>実数</td>    <td>ガウス関数とローレンツ関数の畳みこみ</td></tr>
^<tr>    <td>zeta(s)</td>    <td>任意</td>    <td>リーマンゼータ関数 </td></tr>
^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>   <th colspan="3">libcerf (利用可能な場合のみ) による特殊関数</th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>cerf(z)</td>    <td>複素数</td>    <td>複素誤差関数</td></tr>
^<tr>    <td>cdawson(z)</td>    <td>複素数</td>    <td>複素 Dawson 積分</td></tr>
^<tr>    <td>faddeeva(z)</td>    <td>複素数</td>    <td>再スケール化複素誤差関数 <i>w</i>(<i>z</i>) = exp(-<i>z</i><sup>2</sup>) × erfc(-i<i>z</i>)</td></tr>
^<tr>    <td>erfi(x)</td>    <td>実数</td>    <td>虚誤差関数 erfi(<i>x</i>) = -i × erf(i<i>x</i>)</td></tr>
^<tr>    <td>FresnelC(x)</td>    <td>実数</td>    <td>フレネル積分のコサイン (実数) 成分</td></tr>
^<tr>    <td>FresnelS(x)</td>    <td>実数</td>    <td>フレネル積分のサイン (虚数) 成分</td></tr>
^<tr>    <td>VP(x,sigma,gamma)</td>    <td>実数</td>    <td>Voigt プロファイル</td></tr>
^<tr>    <td>VP_fwhm(sigma,gamma)</td>    <td>実数</td>    <td>Voigt プロファイルの半値全幅 (FWHM)</td></tr>

^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 文字列関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>gprintf("format",x,...)</td>    <td>任意</td>    <td>gnuplot の書式解析器を適用した結果の文字列</td></tr>
^<tr>    <td>sprintf("format",x,...)</td>    <td>複数個</td>    <td>C 言語の sprintf の返す文字列</td></tr>
^<tr>    <td>strlen("string")</td>    <td>文字列</td>    <td>文字列の中の文字数</td></tr>
^<tr>    <td>strstrt("string","key")</td>    <td>文字列</td>    <td>部分文字列 "key" が現れる先頭位置</td></tr>
^<tr>    <td>substr("string",beg,end)</td>    <td>複数個</td>    <td>文字列 "string"[beg:end]</td></tr>
^<tr>    <td>split("string","separator")</td>    <td>文字列</td>    <td>元の文字列の個々のフィールドを持つ配列</td></tr>
^<tr>    <td>join(array,"separator")</td>    <td>配列, 文字列</td>    <td>配列要素を文字列に結合</td></tr>
^<tr>    <td>strftime("timeformat",t)</td>    <td>任意</td>    <td>gnuplot による時刻解析結果の文字列</td></tr>
^<tr>    <td>strptime("timeformat",s)</td>    <td>文字列</td>    <td>文字列 s を変換した 1970 年からの秒数</td></tr>
^<tr>    <td>system("command")</td>    <td>文字列</td>    <td>シェルコマンドの出力を持つ文字列</td></tr>
^<tr>    <td>trim(" string ")</td>    <td>文字列</td>    <td>前後につく空白を取り除いた文字列</td></tr>
^<tr>    <td>word("string",n)</td>    <td>文字列, 整数</td>    <td>文字列 "string" の n 番目の単語</td></tr>
^<tr>    <td>words("string")</td>    <td>文字列</td>    <td>文字列 "string" 中の単語数</td></tr>
^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>   <th colspan="3"> 時刻関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>time(x)</td>    <td>任意</td>    <td>現在のシステム時刻</td></tr>
^<tr>    <td>timecolumn(N,format)</td>    <td>整数, 文字列</td>    <td> 入力データの <i>N</i> 列目からの書式化日時データ</td></tr>
^<tr>    <td>tm_hour(t)</td>    <td>秒数による時刻</td>    <td>時</td></tr>
^<tr>    <td>tm_mday(t)</td>    <td>秒数による時刻</td>    <td>日 (その月の)</td></tr>
^<tr>    <td>tm_min(t)</td>    <td>秒数による時刻</td>    <td>分</td></tr>
^<tr>    <td>tm_mon(t)</td>    <td>秒数による時刻</td>    <td>月</td></tr>
^<tr>    <td>tm_sec(t)</td>    <td>秒数による時刻</td>    <td>秒</td></tr>
^<tr>    <td>tm_wday(t)</td>    <td>秒数による時刻</td>    <td>その週の何日目</td></tr>
^<tr>    <td>tm_week(t)</td>    <td>秒数による時刻</td>    <td>その年の週番号 (ISO 8601)</td></tr>
^<tr>    <td>tm_yday(t)</td>    <td>秒数による時刻</td>    <td>その年の何日目</td></tr>
^<tr>    <td>tm_year(t)</td>    <td>秒数による時刻</td>    <td>西暦</td></tr>
^<tr>    <td>weekdate_iso(year,week,day)</td> <td>整数</td> <td> ISO 8601 規則での週曜日に対応する時刻</td></tr>
^<tr>    <td>weekdate_cdc(year,week,day)</td> <td>整数</td> <td> CDC による疫学的週曜日に対応する時刻</td></tr>
^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 他の gnuplot の関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>column(x)</td>    <td>整数か文字列</td>    <td> 入力データ中の <i>x</i> 列目の内容</td></tr>
^<tr>    <td>columnhead(x)</td>    <td>整数</td>    <td> データファイルの最初の <i>x</i> 列目中の文字列</td></tr>
^<tr>    <td>exists("X")</td>    <td>文字列</td>    <td> 変数名 X が定義されていれば 1, そうでなければ 0</td></tr>
^<tr>    <td>hsv2rgb(h,s,v)</td>    <td>[0:1] 内の実数 h,s,v</td>    <td> HSV 色を 24ビットの RGB 色へ変換</td></tr>
^<tr>    <td>index(A,x)</td>    <td>配列, 任意</td>  <td> A[i] が x に等しい i</td></tr>
^<tr>    <td>palette(z)</td>    <td>実数</td>    <td> z に割り当てられた 24 ビット RGB パレット色</td></tr>
^<tr>    <td>rgbcolor("name")</td>    <td>文字列</td>    <td> 色名の 32 ビット ARGB 値</td></tr>
^<tr>    <td>stringcolumn(x)</td>    <td>整数</td>    <td> 文字列としての <i>x</i> 列目の内容</td></tr>
^<tr>    <td>valid(x)</td>    <td>整数</td>    <td> データ入力中の <i>x</i> 列の正当性</td></tr>
^<tr>    <td>value("name")</td>    <td>文字列</td>    <td> 名前 name の変数の現在の値</td></tr>
^</tbody>
^</table>

C TeX と troff 出力に関しては表は以下のヘルプセクションを置き換えます。
C HTML ヘルプに関しては表とセクションの両方が必要なので、以下のマジック
C マーカを doc2html へのこのシグナルとして使用します。
^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{longtable}{@{\extracolsep{\fill}}|lcrl|@{}} \hline
#\multicolumn{4}{|c|}{数学ライブラリ、組み込み関数} \\ \hline \hline
#関数 & 引数 & ~ & 戻り値 ({\gpCX } は複素数) \\ \hline
#\endhead \hline \endfoot
%c c l .
%関数@引数@戻り値
%_
4 abs
?expressions functions abs
?abs
#abs(x) & 整数または実数 & ~ &  $x$ の絶対値, $|x|$ \\
#abs(x) & 複素数 & ~ & $x$ の長さ, $\sqrt{{\mbox{real}(x)^{2} +
#\mbox{imag}(x)^{2}}}$ \\
%abs(x)@整数または実数@$x$ の絶対値, $|x|$
%abs(x)@複素数@$x$ の長さ, $sqrt{roman real (x) sup 2 + roman imag (x) sup 2}$
 関数 `abs(x)` 引数の絶対値を返します。返り値の型は引数と同じです。

=norm
=modulus
 複素数の引数に対しては, abs(x) は複素平面における x の長さと定義されて
 います [すなわち sqrt(real(x)**2 + imag(x)**2) ]。これは x のノルム
 (norm)、または x の複素絶対値 (modulus) とも呼ばれます。
4 acos
?expressions functions acos
?acos
#acos(x) &  ~~   & \gpCX & $\cos^{-1} x$ (アークコサイン) \\
%acos(x)@ ~~ @$cos sup -1 x$ (アークコサイン)
 関数 `acos(x)` は引数のアークコサイン (逆余弦) を返します。`acos` の返
 す値がラジアン単位かまたは度であるかは `set angles` で選択されます。
4 acosh
?expressions functions acosh
?acosh
#acosh(x) &  ~~   & \gpCX & $\cosh^{-1} x$ (逆双曲余弦) \\
%acosh(x)@ ~~ @$cosh sup -1 x$ (逆双曲余弦)
 関数 `acosh(x)` は逆ハイパボリックコサイン (逆双曲余弦) の値を、
 `set angles` に従ってラジアンか度で返します。
4 airy
?expressions functions airy
?airy
#airy(x) &  実数   & ~ & 実数 x に対するエアリー関数 Ai(x)\\
%airy(x)@ 実数 @実数 x に対するエアリー関数 Ai(x)
 関数 `airy(x)` は、エアリー (Airy) 関数 Ai(x) の値を返します。関数
 Ai(x) は、微分方程式 y'' - x y = 0 の、実数全体で有界な解です。引数が
 複素数の場合、その虚数部分は無視されます。
4 arg
?expressions functions arg
?arg
#arg(x) & 複素数 & ~ & $x$ の偏角, $-\pi\leq$arg($x$)$\leq\pi$ \\
%arg(x)@複素数@$x$ の偏角
 関数 `arg(x)` は複素数の偏角を、`set angles` の設定にしたがってラジア
 ン、または度で返します。
4 asin
?expressions functions asin
?asin
#asin(x) &  ~~   & \gpCX & $\sin^{-1} x$ (アークサイン) \\
%asin(x)@ ~~ @$sin sup -1 x$ (アークサイン)
 関数 `asin(x)` は引数のアークサイン (逆正弦) を返します。`asin` の返す
 値は `set angles` の設定によってラジアン単位かまたは度になります。
4 asinh
?expressions functions asinh
?asinh
#asinh(x) &  ~~   & \gpCX & $\sinh^{-1} x$ (逆双曲正弦)\\
%asinh(x)@ ~~ @$sinh sup -1 x$ (逆双曲正弦)
 関数 `asinh(x)` は逆ハイパボリックサイン (逆双曲正弦) の値を、
 `set angles` に従ってラジアンか度で返します。
4 atan
?expressions functions atan
?atan
#atan(x) &  ~~   & \gpCX & $\tan^{-1} x$ (アークタンジェント) \\
%atan(x)@ ~~ @$tan sup -1 x$ (アークタンジェント)
 関数 `atan(x)` は引数のアークタンジェント (逆正接) の値を返します。
 `atan` の返す値は `set angles` の設定によってラジアン単位かまたは度に
 なります。
4 atan2
?expressions functions atan2
?atan2
#atan2(y,x) & 整数または実数 & ~ & $\tan^{-1} (y/x)$ (アークタンジェント) \\
%atan2(y,x)@整数または実数@$tan sup -1 (y/x)$ (アークタンジェント)
 関数 `atan2(y,x)` は引数の実数部分の比のアークタンジェント (逆正接) の
 値を返します。`atan2` は `set angles` の設定によってラジアン単位か度に
 なる、適切な四分円における値を返します。
4 atanh
?expressions functions atanh
?atanh
#atanh(x) &  ~~   & \gpCX & $\tanh^{-1} x$ (逆双曲正接)\\
%atanh(x)@ ~~ @$tanh sup -1 x$ (逆双曲正接)
 関数 `atanh(x)` は逆ハイパボリックタンジェント (逆双曲正接) の値を、
 `set angles` に従ってラジアンか度で返します。
4 besj0
?expressions functions besj0
?besj0
# besj0(x) & 実数 & ~ & $x$ ラジアンの $J_{0}$ ベッセル関数 (0 次ベッセル関数)\\
%besj0(x)@実数@$x$ ラジアンの $J sub 0$ ベッセル関数 (0 次ベッセル関数)
 関数 `besj0(x)` は引数の J0 ベッセル関数 (0 次の第 1 種円柱関数 J0、0
 次ベッセル関数) の値を返します。`besj0` には引数はラジアンで与えます。
4 besj1
?expressions functions besj1
?besj1
# besj1(x) & 実数 & ~ & $x$ ラジアンの $J_{1}$ ベッセル関数 (1 次ベッセル関数)\\
%besj1(x)@実数@$x$ ラジアンの $J sub 1$ ベッセル関数 (1 次ベッセル関数)
 関数 `besj1(x)` は引数の J1 ベッセル関数 (1 次の第 1 種円柱関数 J1、1
 次ベッセル関数) の値を返します。`besj1` には引数はラジアンで与えます。
4 besjn
?expressions functions besjn
?besjn
# besjn(n,x) & 整数, 実数 & ~ & $x$ ラジアンの $J_{n}$ ベッセル関数 (n 次ベッセル関数)\\
%besjn(n,x)@整数, 実数@$x$ ラジアンの $J sub n$ ベッセル関数 (n 次ベッセル関数)
 関数 `besjn(n,x)` は引数の Jn ベッセル関数 (n 次の第 1 種円柱関数 Jn、
 n 次ベッセル関数) の値を返します。引数 x はラジアンで与えます。
4 besy0
?expressions functions besy0
?besy0
# besy0(x) & 実数 & ~ & $x$ ラジアンの $Y_{0}$ ベッセル関数 (0 次ノイマン関数)\\
%besy0(x)@実数@$x$ ラジアンの $Y sub 0$ ベッセル関数 (0 次ノイマン関数)
 関数 `besy0(x)` は引数の Y0 ベッセル関数 (0 次の第 2 種円柱関数 Y0、0
 次ノイマン関数) の値を返します。`besy0` には引数はラジアンで与えます。
4 besy1
?expressions functions besy1
?besy1
# besy1(x) & 実数 & ~ & $x$ ラジアンの $Y_{1}$ ベッセル関数 (1 次ノイマン関数)\\
%besy1(x)@実数@$x$ ラジアンの $Y sub 1$ ベッセル関数 (1 次ノイマン関数)
 関数 `besy1(x)` は引数の Y1 ベッセル関数 (1 次の第 2 種円柱関数 Y1、1
 次ノイマン関数) の値を返します。`besy1` には引数はラジアンで与えます。
4 besyn
?expressions functions besyn
?besyn
# besyn(n,x) & 整数, 実数 & ~ & $x$ ラジアンの $Y_{n}$ ベッセル関数 (n 次ノイマン関数)\\
%besyn(n,x)@整数, 実数@$x$ ラジアンの $Y sub n$ ベッセル関数 (n 次ノイマン関数)
 関数 `besyn(n,x)` は引数の Yn ベッセル関数 (n 次の第 2 種円柱関数 Yn、
 n 次ノイマン関数) の値を返します。引数 x はラジアンで与えます。
4 besi0
?expressions functions besi0
?besi0
# besi0(x) & 実数 & ~ & $x$ ラジアンの $I_{0}$ (0 次) 変形ベッセル関数\\
%besi0(x)@実数@$x$ ラジアンの $I sub 0$ (0 次) 変形ベッセル関数
 関数 `besi0(x)` は 0 次の変形ベッセル関数です。`besi0` の引数の単位は
 ラジアンです。
4 besi1
?expressions functions besi1
?besi1
# besi1(x) & 実数 & ~ & $x$ ラジアンの $I_{1}$ (1 次) 変形ベッセル関数\\
%besi1(x)@実数@$x$ ラジアンの $I sub 1$ (1 次) 変形ベッセル関数
 関数 `besi1(x)` は 1 次の変形ベッセル関数です。`besi1` の引数の単位は
 ラジアンです。
4 besin
?expressions functions besin
?besin
# besin(n,x) &整数, 実数& ~ & $x$ ラジアンの $I_{n}$ (n 次) 変形ベッセル関数\\
%besin(x)@整数, 実数l@$x$ ラジアンの $I sub n$ (n 次) 変形ベッセル関数
 関数 `besin(n,x)` は n 次の変形ベッセル関数です。引数 x の単位はラジア
 ンです。
4 cbrt
?expressions functions cbrt
?cbrt
#cbrt(x) & 実数 & ~ & $x$ の三乗根 (定義域、値域は共に実数に限定) \\
%cbrt(x)@ 実数 @ x の三乗根 (定義域、値域は共に実数に限定)
 関数 `cbrt(x)` は x の三乗根を返します。x が実数でない場合、NaN を返し
 ます。
??
C C 4 ceil
C ?expressions functions ceil
#ceil(x) & ~~ & ~ & $\lceil x \rceil$, $x$ の実部以上の最小の整数\\
%ceil(x)@ ~~ @$left ceiling x right ceiling$, $x$ (の実部) 以上の最小の整数
 `ceil(x)` は x の実部以上の最小の整数を返します。
 |x|<2^52 の範囲外の場合、ceil(x) は NaN を返します。
4 conj
?expressions functions conj
?conj
#conj(x) & 複素数 & \gpCX & $x$ の複素共役 \\
%conj(x)@複素数@$x$ の複素共役
 関数 `conj(x)` は、x の複素共役を返します。conj( {r, i} ) = {r, -i}
4 cos
?expressions functions cos
?cos
#cos(x) & ~~ & \gpCX & $x$ のコサイン $\cos x$\\
%cos(x)@ラジアン@$x$ のコサイン $cos~x$
 関数 `cos(x)` は引数のコサイン (余弦) の値を返します。`cos` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 cosh
?expressions functions cosh
?cosh
#cosh(x) & ~~ & \gpCX & $\cosh x$, $x$ ラジアンのハイパボリックコサイン \\
%cosh(x)@ ~~ @$cosh~x$, $x$ ラジアンのハイパボリックコサイン
 関数 `cosh(x)` は引数のハイパボリックコサインの値を返します。`cosh` の
 引数はラジアンで与えます。
?expressions functions EllipticK
?EllipticK
4 EllipticK
#EllipticK(k) & 実数 k $\in$ (-1:1) & ~ & $K(k)$ 第 1 種完全楕円積分\\
%EllipticK(k)@(-1:1) 内の実数 k@$K ( k )$ 第 1 種完全楕円積分
 関数 `EllipticK(k)` は、第 1 種完全楕円積分の値を返します。詳細は、以
 下参照: `elliptic integrals`。
?expressions functions EllipticE
?EllipticE
4 EllipticE
#EllipticE(k) & 実数 k $\in$ [-1:1] & ~ & $E(k)$ 第 2 種完全楕円積分\\
%EllipticE(k)@[-1:1] 内の実数 k@ $E ( k )$ 第 2 種完全楕円積分
 関数 `EllipticE(k)` は、第 2 種完全楕円積分の値を返します。詳細は、以
 下参照: `elliptic integrals`。
?expressions functions EllipticPi
?EllipticPi
4 EllipticPi
#EllipticPi(n,k) & 実数 n$<$1, 実数 k $\in$ (-1:1) & ~ & $\Pi(n,k)$ 第 3 種完全楕円積分\\
%EllipticPi(n,k)@ 実数 n<1, (-1:1) 内の実数 k@ $Pi ( n,k )$ 第 3 種完全楕円積分
 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分の値を返します。詳細は、
 以下参照: `elliptic integrals`。
4 erf
?expressions functions erf
?erf
#erf(x) & ~~ & ~ & $\mbox{erf}(\mbox{real}(x))$,  $x$ の 実部の誤差関数\\
%erf(x)@ ~~ @$erf ( roman real (x))$, $x$ の実部の誤差関数
 関数 `erf(x)` は引数の実部の誤差関数の値を返します。引数が複素数の場合
 は虚部は無視されます。以下参照: `cerf`, `erfc`, `inverf`, `norm`。
4 erfc
?expressions functions erfc
?erfc
#erfc(x) & ~~ & ~ & $\mbox{erfc}(\mbox{real}(x))$,  1.0 - ($x$ の実部の誤差関数) \\
%erfc(x)@ ~~ @$erfc ( roman real (x))$, 1.0 - ($x$ の実部の誤差関数)
 関数 `erfc(x)` は 1.0 から、引数の実部の誤差関数の値を引いたものを返し
 ます。引数が複素数の場合は虚部は無視されます。以下参照: `cerf`, `erf`,
 `inverf`, `norm`。
4 exp
?expressions functions exp
?exp
#exp(x) &  ~~  & \gpCX & $e^{x}$, $x$ の指数関数\\
%exp(x)@ ~~ @$e sup x$, $x$ の指数関数
 関数 `exp(x)` は、`e` の x 乗の値を返しますが、x は整数でも、実数でも
 複素数でも構いません。
??
C C 4 expint
#expint(n,x) & 整数 $n\ge0$, 実数 $x\ge0$ & ~ & $E_n(x)=\int_1^\infty t^{-n} e^{-xt}\,dt$, $x$ の指数積分 \\
%expint(n,x)@ ~~ @$E sub n (x)$, $x$ の指数積分
??
C C 4 floor
C ?expressions functions floor
#floor(x) &  ~~  & ~ & $\lfloor x \rfloor$, $x$ の実部以下の最大の整数\\
%floor(x)@ ~~ @$left floor x right floor$, $x$ の実部以下の最大の整数
 `floor(x)` は x の実部以下の最大の整数を返します。
 |x|<2^52 の範囲外の場合、floor(x) は NaN を返します。
4 gamma
?expressions functions gamma
#gamma(x) &  ~~  & ~ & $\Gamma(x)$, $x$ の実部のガンマ関数\\
%gamma(x)@ ~~ @$GAMMA ( roman real (x))$, $x$ の実部のガンマ関数
 関数 `gamma(x)` は引数の実部のガンマ関数の値を返します。整数 n に対し
 ては gamma(n+1) = n! です。引数が複素数の場合、虚数部分は無視されます。
 複素引数に関しては、以下参照: `lnGamma`。
??
C C 4 ibeta
#ibeta(a,b,x) & $a,b>0$, $x \in [0:1]$ & ~ & $B(a,b,x)=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\intop_{0}^{x}t^{a-1}(1-t)^{b-1}dt$, 不完全ベータ関数 \\
%ibeta(a,b,x)@ ~~ @$ibeta ( roman real (a,b,x))$, $a$,$b$,$x$ の実部の不完全ベータ関数
4 inverf
?expressions functions inverf
?inverf
#inverf(x) &  ~~  & ~ & $x$ の実部の逆誤差関数 \\
%inverf(x)@ ~~ @$x$ の実部の逆誤差関数
 関数 `inverf(x)` は引数の実部の逆誤差関数の値を返します。以下参照:
 `erf`, `invnorm`。
??
C C 4 igamma
#igamma(a,z) & 複素数, $\Re(a)>0$ & \gpCX & 不完全ガンマ関数 $P(a,z)=\frac{1}{\Gamma(z)}\intop_{0}^{z}t^{a-1}e^{-t}dt$ \\
%igamma(a,z)@ ~~ @$igamma (a,z)$, ($a$,$z$) の下方不完全ガンマ関数
4 imag
?expressions functions imag
?imag
#imag(x) & 複素数 & ~ & $x$ の虚数部分 (実数) \\
%imag(x)@複素数@$x$ の虚数部分 (実数)
 関数 `imag(x)` は引数の虚数部分を実数として返します。
??
C C 4 int
C ?expressions functions int
#int(x) & 実数 & ~ &  $x$ の 0 に向かって丸めた整数部分\\
%int(x)@実数@$x$ の 0 に向かって丸めた整数部分
 `int(x)` は、引数の 0 に向かって丸めた整数部分を返します。
4 invnorm
?expressions functions invnorm
?invnorm
#invnorm(x) &  ~~  & ~ & $x$ の実部の逆正規分布関数 \\
%invnorm(x)@ ~~ @$x$ の実部の逆正規分布関数
 関数 `invnorm(x)` は引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の逆関数の値を返します。以下参照: `norm`。

??
C C 4 invibeta
#invibeta(a,b,p) & 実数 & ~ &  逆 (正規化) 不完全ベータ関数  \\
%invibeta(a,b,p)@ 実数 @逆 (正規化) 不完全ベータ関数

??
C C 4 invigamma
#invigamma(a,p) & 実数 & ~ &  逆 (正規化) 不完全ガンマ関数  \\
%invigamma(a,p)@ 実数 @逆 (正規化) 不完全ガンマ関数

#LambertW(z,k) & 複素数, 整数 & \gpCX & 複素 Lambert W 関数の第 k 分岐 \\
%LambertW(z,k) & 複素数, 整数 & 複素 Lambert W 関数の第 $k$ 分岐

4 lambertw
?expressions functions lambertw
?lambertw
#lambertw(x) & 実数 & ~ & Lambert W 関数の主値 (第 0 分岐) \\
%lambertw(x)@実数@Lambert W 関数の主値 (第 0 分岐)
 関数 `lambertw(x)` は Lambert の W 関数の主値 (第 0 分岐) を返します。
 W 関数は、方程式 (W(x)*exp(W(x))=x によって定義されます。
 x は、x >= -exp(-1) を満たす実数でなければいけません。
4 lgamma
?expressions functions lgamma
?lgamma
#lgamma(x) & 実数 & ~ & 実数 $x$ に対する $\ln\Gamma(x)$ (ガンマ対数関数) \\
%lgamma(x)@実数@実数 $x$ に対する lgamma 関数 (ガンマ対数関数)
 関数 `lgamma(x)` は引数の実部のガンマ関数値の自然対数の値を返します。
 引数が複素数の場合、虚部は無視されます。複素数には lnGamma(z) を使用し
 てください。
4 lngamma
#lnGamma(x) & 複素数 & \gpCX & 複素平面全体で正当な $\ln\Gamma(x)$ \\
%lnGamma(x)@複素数@複素平面全体で正当な lgamma 関数
 関数 `lnGamma(x)` は、ガンマ関数の自然対数値を返します。この実装は、複
 素平面全体で正当な Lanczos 近似を使用しています。この値の虚数成分は、
 負の実軸部分を除く全体で連続な曲面を生成するよう位相をずらしています。
4 log
?expressions functions log
?log
#log(x) &  ~~  & \gpCX & $\log_{e} x$,  $x$ の自然対数 (底 $e$) \\
%log(x)@ ~~ @$ln~x$, $x$ の自然対数 (底 $e$)
 関数 `log(x)` は引数の自然対数 (底 `e`) の値を返します。以下参照:
 `log10`。
4 log10
?expressions functions log10
?log10
#log10(x) &  ~~  & \gpCX & $\log_{10} x$, $x$ の対数 (底 $10$) \\
%log10(x)@ ~~ @${log sub 10}~x$, $x$ の対数 (底 $10$)
 関数 `log10(x)` は引数の対数 (底 10) を返します。
4 norm
?expressions functions norm
?norm
#norm(x) &  ~~  & ~ & $x$ の実部の正規分布 (ガウス分布) 関数 \\
%norm(x)@ ~~ @$norm(x)$, $x$ の実部の正規分布 (ガウス分布) 関数
 関数 `norm(x)` は、引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の値を返します。以下参照: `invnorm`, `erf`, `erfc`。
4 rand
?expressions functions rand
?rand
#rand(x) & 整数 & ~ & 開区間 (0:1) 内の疑似乱数生成器 \\
%rand(x)@整数@開区間 (0:1) 内の疑似乱数生成器
 関数 `rand(x)` は、開区間 (0:1) 内の疑似乱数を返します。詳しくは以下
 参照: `random`。
4 real
?expressions functions real
?real
#real(x) &  ~~  & ~ & $x$ の実部 \\
%real(x)@ ~~ @$x$ の実部
 関数 `real(x)` は引数の実部を返します。
??
C C 4 round
C ?expressions functions round
#round(x) &  ~~  & ~ & $\lfloor x \rceil$,  $x$ の実部に一番近い整数\\
%round(x)@ ~~ @ $x$ の実部に一番近い整数
 `round(x)` は、x の実部に一番近い整数を返します。
 |x|<2^52 の範囲外の場合、round(x) は NaN を返します。
4 sgn
?expressions functions sgn
?sgn
#sgn(x) &  ~~  & ~ & $x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0 (虚部は無視) \\
%sgn(x)@ ~~ @$x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0 (虚部は無視)
 関数 `sgn(x)` は引数が正なら 1 を、負なら -1 を、0 ならば 0 を返します。
 引数が複素数の場合虚部は無視されます。
4 Sign
#Sign(x) & 複素数 & \gpCX & $x = 0$ なら 0、それ以外は $x/|x|$ \\
%Sign(x)@複素数@$x = 0$ なら 0、それ以外は $x/|x|$
 関数 `Sign(x)` は、引数が 0 なら 0 を返し、それ以外の場合は複素数値
 Sign(x) = x/|x| を返します。
4 sin
?expressions functions sin
?sin
#sin(x) &  ~~  & \gpCX & $\sin x$, $x$ のサイン \\
%sin(x)@ ~~ @$sin~x$, $x$ のサイン
 関数 `sin(x)` は引数のサイン (正弦) の値を返します。`sin` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 sinh
?expressions functions sinh
?sinh
#sinh(x) &  ~~  & \gpCX & $\sinh x$, $x$ ラジアンのハイパボリックサイン \\
%sinh(x)@ ~~ @$sinh~x$, $x$ ラジアンのハイパボリックサイン
 関数 `sinh(x)` は引数のハイパボリックサインの値を返します。`sinh` の
 引数はラジアンで与えます。
4 sqrt
?expressions functions sqrt
?sqrt
#sqrt(x) &  ~~  & \gpCX & $\sqrt{x}$,  $x$ の平方根\\
%sqrt(x)@ ~~ @$sqrt x $, $x$ の平方根
 関数 `sqrt(x)` は引数の平方根の値を返します。x が複素数の場合、これは
 常に正の実部を持つ根を返します。
??
C C 4 SynchrotronF
C ?expressions functions SynchrotronF
#SynchrotronF(x) & 実数 & ~ & $F(x) = x\intop_{x}^{\infty}K_{\frac{5}{3}}(\nu)~d\nu$ \\
%SynchrotronF(x)@ ~~ @ (第 1) シンクロトロン関数 F%
4 tan
?expressions functions tan
?tan
#tan(x) &  ~~  & \gpCX & $\tan x$,  $x$ のタンジェント \\
%tan(x)@ ~~ @$tan~x$, $x$ のタンジェント
 関数 `tan(x)` は引数のタンジェント (正接) の値を返します。`tan` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 tanh
?expressions functions tanh
?tanh
#tanh(x) &  ~~  & \gpCX & $\tanh x$, $x$ ラジアンのハイパボリックタンジェント\\
%tanh(x)@ ~~ @$tanh~x$, $x$ ラジアンのハイパボリックタンジェント
 関数 `tanh(x)` は引数のハイパボリックタンジェントの値を返します。
 `tanh` の引数はラジアンで与えます。
??
C C 4 uigamma
#uigamma(a,x) & 実数, 実数 & & 上方不完全ガンマ関数 $Q(a,x)=\frac{1}{\Gamma(x)}\intop_{x}^{\infty}t^{a-1}e^{-t}dt$ \\
%uigamma(a,x)@ ~~ @$uigamma (a,x)$, ($a$,$x$) の上方不完全ガンマ関数
4 voigt
?expressions functions voigt
?voigt
#voigt(x,y) & 実数 & ~ & Voigt/Faddeeva 関数 $\frac{y}{\pi} \int{\frac{exp(-t^2)}{(x-t)^2+y^2}}dt$ \\
#           &       & ~ & 注意: voigt$(x,y)$ = $real($faddeeva$(x+iy))$ \\
%voigt(x,y)@実数@ガウス関数とローレンツ関数の畳みこみ
 関数 `voigt(x,y)` は、スペクトル解析で使用される Voigt/Faddeeva 関数の
 近似を返します。その誤差は 1/10^4 以内です。libcerf ライブラリが利用可
 能ならば、より正確な値を求めるために re_w_of_z() ルーチンが使われます。
 voigt(x,y) = real(faddeeva( x + y*{0,1} )) に注意してください。
??
C C 4 zeta
#zeta(s) & 複素数 & \gpCX & リーマンゼータ関数 $\zeta(s) = \Sigma^{\infty}_{k=1} k^{-s}$\\
%zeta(s)@複素数@リーマンゼータ関数
#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|lcl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\setlength\LTleft{0pt}
#\setlength\LTright{0pt}
#\begin{longtable}{@{\extracolsep{\fill}}|lcrl|@{}} \hline
#\multicolumn{4}{|c|}{libcerf (利用可能な場合のみ) による特殊関数} \\ \hline \hline
#関数 ~~~~~~~~~~~~~~~~~ & 引数 & ~ & 戻り値 ({\gpCX } は複素数)\\ \hline
#\endhead \hline \endfoot
%c c l .
%関数@引数@戻り値
%_
# ~ & ~ & ~ & \hspace{9cm} \\
4 cerf
?expressions functions cerf
?cerf
#cerf(z) & 複素数 & \gpCX & 複素誤差関数 $cerf(z)={\frac{\sqrt{\pi}}{2}}{\int^{z}_{0}{e^{-t^2}dt}} $ \\
%cerf(z)@複素数@複素誤差関数
 `cerf(z)` は誤差関数 erf(x) の複素バージョンです。
 外部ライブラリ libcerf が必要です。
4 cdawson
?expressions functions cdawson
?cdawson
=Dawson's integral
?Dawson's integral
%cdawson(z)@複素数@複素 Dawson 積分
#cdawson(z)&複素数& \gpCX &Dawson 積分 $D(z)={\frac{\sqrt{\pi}}{2}e^{-z^2} erfi(z)}$ の複素拡張 \\
 `cdawson(z)` は複素引数に対する Dawson 積分の値を返します。
 cdawson(z) = sqrt(pi)/2 * exp(-z^2) * erfi(z)
 外部ライブラリ libcerf が必要です。
4 faddeeva
?expressions functions faddeeva
?faddeeva
%faddeeva(z)@複素数@スケール化複素相補誤差関数 w(z) = exp(-z^2) * erfc(-i*z)
#faddeeva(z)&複素数& \gpCX &スケール化複素相補誤差関数 $w(z) = e^{-z^2}~ erfc(-iz) $ \\
 `faddeeva(z)` はスケール化複素相補誤差関数です。
 faddeeva(z) = exp(-z^2) * erfc(-i*z)
 これは、Abramowitz-Stegun の式 7.1.3, 7.1.4 に対応します。
 外部ライブラリ libcerf が必要です。
4 erfi
?expressions functions erfi
?erfi
%erfi(x)@実数@虚誤差関数 erfi(x) = -i * erf(ix)
#erfi(x)&実数&~&虚誤差関数 $erf(x) = -i * erf(ix)$ \\
 虚誤差関数 erfi(x) = -i * erf(ix)
 外部ライブラリ libcerf が必要です。
??
C C 4 FresnelC
%FresnelC(x)@実数@ C(x) = integral[0;x] cos(pi/2 t^2)dt
#FresnelC(x)&実数&~&フレネル積分 $C(x)=\int^{x}_{0}\cos(\frac{\pi}{2}t^2)dt$ \\
??
C C 4 FresnelS
%FresnelS(x)@実数@ S(x) = integral[0;x] sin(pi/2 t^2)dt
#FresnelS(x)&実数&~&フレネル積分 $S(x)=\int^{x}_{0}\sin(\frac{\pi}{2}t^2)dt$ \\
4 Voigt Profile
?expressions functions VP
?expressions functions VP_fwhm
?VP
?VP_fwhm
%VP(x,sigma,gamma)@実数@Voigt プロファイル
%VP_fwhm(sigma,gamma)@実数@Voigt プロファイルの半値全幅 (FWHM)
#VP(x,$\sigma$,$\gamma$)&実数& ~ & Voigt プロファイル $ VP(x,\sigma,\gamma) = {\int^{\infty}_{-\infty}{G(x^\prime;\sigma) L(x-x^\prime;\gamma) dx^\prime }} $ \\
#VP\_fwhm($\sigma$,$\gamma$)&実数& ~ & Voigt プロファイルの半値全幅 (FWHM)\\
 `VP(x,sigma,gamma)` はガウス密度関数 G(x;sigma) とローレンツ密度関数
 L(x;gamma) の畳み込みで定義される Voigt プロファイル (密度関数) に対
 応します。
 `VP_fwhm(sigma,gamma)` は、この関数の半値全幅 (FWHM) を与えます。

#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|lcl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\setlength\LTleft{0pt}
#\setlength\LTright{0pt}
#\begin{longtable}{@{\extracolsep{\fill}}|lcrl|@{}} \hline
#\multicolumn{4}{|c|}{Amos ライブラリ (利用可能な場合のみ) による複素特殊関数} \\ \hline \hline
#関数 ~~~~~~~~~~~~~~~~~ & 引数 & ~ & 戻り値 ({\gpCX } は複素数)\\ \hline
#\endhead \hline \endfoot
%c c l .
%関数@引数@戻り値
%_
# ~ & ~ & ~ & \hspace{7cm} \\

#Ai(z) & 複素数 & \gpCX &  複素エアリー関数 $Ai(z)$\\
%Ai(z)@複素数@複素エアリー関数 Ai(z)
#Bi(z) & 複素数 & \gpCX &  複素エアリー関数 $Bi(z)$\\
%Bi(z)@複素数@複素エアリー関数 Bi(z)
#BesselH1(nu,z) & 実数, 複素数 & \gpCX & $H^{(1)}_{\nu}(z)$ 第 1 種ハンケル関数\\
%BesselH1(nu,z) @ 実数, 複素数 @ 第 1 種ハンケル関数 H1_nu
#BesselH2(nu,z) & 実数, 複素数 & \gpCX & $H^{(2)}_{\nu}(z)$ 第 2 種ハンケル関数\\
%BesselH2(nu,z) @ 実数, 複素数 @ 第 2 種ハンケル関数 H2_nu
#BesselJ(nu,z) & 実数, 複素数 & \gpCX & $J_{\nu}(z)$ 第 1 種ベッセル関数\\
%BesselJ(nu,z) @ 実数, 複素数 @ 第 1 種ベッセル関数 J_nu
#BesselY(nu,z) & 実数, 複素数 & \gpCX & $Y_{\nu}(z)$ 第 2 種ベッセル関数\\
%BesselY(nu,z) @ 実数, 複素数 @ 第 2 種ベッセル関数 Y_nu
#BesselI(nu,z) & 実数, 複素数 & \gpCX & $I_{\nu}(z)$ 第 1 種変形ベッセル関数\\
%BesselI(nu,z) @ 実数, 複素数 @ 第 1 種変形ベッセル関数 I_nu
#BesselK(nu,z) & 実数, 複素数 & \gpCX & $K_{\nu}(z)$ 第 2 種変形ベッセル関数\\
%BesselK(nu,z) @ 実数, 複素数 @ 第 2 種変形ベッセル関数 K_nu
#expint(n,z) & 整数 $n\geq0$, 複素数 $z$ & \gpCX & $E_n(z)=\int_1^\infty t^{-n} e^{-zt}\,dt$,  指数積分\\
%expint(n,z)@ 整数 n>=0, 複素数 @$E sub n (z)$, 複素指数積分関数
#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|lcl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{longtable}{@{\extracolsep{\fill}}|lcl|@{}} \hline
#\multicolumn{3}{|c|}{文字列関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
%c c l .
%関数@引数@戻り値
%_
4 gprintf
?expressions functions gprintf
#gprintf("format",x,...) & 任意 & gnuplot の書式解析器を適用した結果の文字列 \\
%gprintf("format",x,...)@任意@gnuplot の書式解析器を適用した結果の文字列 \\
 `gprintf("format",x)` は、gnuplot 独自の書式指定子に一つの変数 x を適
 用し、その結果の文字列を返します。標準的な C 言語書式指定子を使いたい
 場合は、代わりに `sprintf("format",x)` を使う必要があります。
 以下参照: `format specifiers`。
4 sprintf
?expressions functions sprintf
?sprintf
#sprintf("format",x,...) & 複数個 & C 言語の sprintf の返す文字列 \\
%sprintf("format",x,...)@複数個@C 言語の sprintf の返す文字列 \\
 `sprintf("format",var1,var2,...)` は標準的な C 言語の書式指定子を複数
 個の引数に適用し、その結果の文字列を返します。gnuplot 独自の書式指定子
 を使いたい場合は、代わりに `gprintf()` を使用する必要があります。
 sprintf の書式指定子に関するより詳しい情報については、標準的な C 言語
 の本か、unix の sprintf の man ページを参照してください。
4 strlen
?expressions functions strlen
?strlen
#strlen("string") & 文字列 & 文字列中の文字数\\
%strlen("string")@文字列@文字列中の文字数
 `strlen("string")` は、現在のエンコーディングを考慮した、文字列中の文
 字数を返します。現在のエンコーディングが多バイト文字 (SJIS UTF8) をサ
 ポートしていれば、この値は、文字列のバイト数よりも小さくなるでしょう。
 文字列に多バイト UTF8 文字が含まれていて、しかし現在のエンコーディング
 が UTF8 以外の別のものに設定されていると、strlen("utf8文字列") は、
 実際の文字数よりも大きな値を返すでしょう。
4 strstrt
?expressions functions strstrt
?strstrt
#strstrt("string","key") & 文字列 & 部分文字列 "key" が現れる先頭位置\\
%strstrt("string","key")@文字列@部分文字列 "key" が現れる先頭位置
 `strstrt("string","key")` は、文字列 "key" を "string" の中で探し、そ
 れが現れる先頭位置を返します。"key" が見つからなかった場合は 0 を返し
 ます。C ライブラリの strstr 関数に似ていますが、文字列へのポインタを返
 す strstr とは違い、これは整数での位置を返します。例えば、
 strstrt("hayneedlestack","needle") = 4 となります。
 この関数は、UTF-8 エンコーディング認識しますので、strstr("αβγ","β")
 は 2 を返します (訳注: UTF-8 エンコーディングで与えた場合)。
4 substr
?expressions functions substr
?substr
=substring
#substr("string",beg,end) & 複数個 & 文字列 "string"[beg:end] \\
%substr("string",beg,end)@複数個@文字列 "string"[beg:end]
 `substr("string",beg,end)` は、元の文字列の beg から end 番目までの文
 字からなる文字列を返します。これは、"string"[beg:end] という式とほぼ同
 じですが、こちらはオプション beg, end を省略できません。

4 split
?
#split("string","sep") & 文字列 & 部分文字列からなる配列 \\
%split("string","sep")@文字列@部分文字列からなる配列
 `split("string", "sep")` は、"sep" 内の文字をフィールドの区切りとして
 使用し、文字列 "string" の中身を個々のフィールドに切り分けます。これは、
 その要素が元の文字列のフィールドにそれぞれ対応する文字列の配列を返しま
 す。2 つ目のパラメータ "sep" はオプションで、"sep" を省略した場合、ま
 たは空白文字一つである場合は、フィールド文字列を任意個のホワイトスペー
 ス (スペース、タブ、改ページ、改行、復帰) で切り分けます。それ以外の場
 合は、区切りは "sep" 内の完全な文字列にマッチする必要があります。
 例えば、以下参照: `counting_words`。
4 join
?
 `join(array, "sep")` は、配列の文字列要素を、"sep" の文字列で区切られ
 たフィールドの列として一つの文字列に連結します。文字列でない配列要素は、
 空のフィールドを生成します。
 例えば、以下参照: `counting_words`。
#join(array,"sep") & 配列, 文字列 & 配列要素を一つの文字列に結合\\
%join(array,"sep") @配列,文字列@配列要素を一つの文字列に結合

4 strftime
?expressions functions strftime
?strftime
#strftime("timeformat",t) & 任意 & gnuplot による時刻解析結果の文字列 \\
%strftime("timeformat",t)@任意@gnuplot による時刻解析結果の文字列
 `strftime("timeformat",t)` は、1970 年からの秒数による時刻 t に、時刻
 書式指定 timeformat を適用します。
 以下参照: `time_specifiers`, `strptime`。
4 strptime
?expressions functions strptime
?strptime
#strptime("timeformat",s) & 文字列 & 文字列 s を変換した 1970 年からの秒数 \\
%strptime("timeformat",s)@文字列@文字列 s を変換した 1970 年からの秒数
 `strptime("timeformat",s)` 書式指定 timeformat を使って文字列 s から時
 刻を読み込んで、それを 1970 年からの秒数に変換します。
 以下参照: `time_specifiers`, `strftime`。
4 system
?expressions functions system
=system
#system("command") & 文字列 & シェルコマンドの出力を持つ文字列\\
%system("command")@文字列@シェルコマンドの出力を持つ文字列
 `system("command")` は、標準的なシェルを用いて "command" を実行し、そ
 の標準出力への文字列を文字列変数として返します。一番最後の改行一つは無
 視されます。

 これは、'f(x) = real(system(sprintf("somecommand %f", x)))' のようにし
 て、外部関数の出力を gnuplot スクリプト内に取り込むのに利用できます。
4 trim
=trim
?expressions functions trim
#trim(" string ") & 文字列 & 前後につく空白を取り除いた文字列 \\
%trim(" string ")@文字列@前後につく空白を取り除いた文字列
 `trim("  padded string ")` は、元々の文字列の前後につくホワイトスペー
 スを取り除いた文字列を返します。これは、入力データ列の、余計な空白を含
 みうる文字列を比較する際に有用です。例:
      plot FOO using 1:( trim(strcol(3)) eq "A" ? $2 : NaN )
4 word
?
=word
#word("string",n) & 文字列, 整数 & 文字列 "string" の n 番目の単語 \\
%word("string",n)@文字列, 整数@文字列 "string" の n 番目の単語
 `word("string",n)` は文字列 string の n 番目の単語文字列を返します。例
 えば `word("one two three",2)` は文字列 "two" を返します。
4 words
=words
#words("string") & 文字列 & 文字列 "string" 中の単語数 \\
%words("string")@文字列@文字列 "string" 中の単語数
 `words("string")` は文字列 string 中の単語数を返します。例えば
 `words(" a b c d")` は 4 を返します。
#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|lcl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{tabular}{|lcl|} \hline
#\multicolumn{3}{|c|}{時刻関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
%c c l .
%関数@引数@戻り値
%_
??
C C 4 time
C ?expressions functions time
#time(x) & 任意 & 現在のシステム時刻 (秒単位) \\
%time(x)@任意@現在のシステム時刻 (秒単位)
??
C C 4 timecolumn
C ?expressions functions timecolumn
#timecolumn(N,"timeformat") & 整数, 文字列 & 入力データの $N$ 列目からの書式化日時データ \\
%timecolumn(N,"timeformat")@整数, 文字列@入力データの $N$ 列目からの書式化日時データ
??
C C 4 tm_hour
?expressions functions tm_hour
?tm_hour
#tm\_hour(t) & 秒数による時刻 & 時 (0..23)\\
%tm_hour(t)@秒数による時刻@時 (0..23)
 関数 `tm_hour(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何時 (0--23 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_mday
?expressions functions tm_mday
?tm_mday
#tm\_mday(t) & 秒数による時刻 & 日 (1..31)\\
%tm_mday(t)@秒数による時刻@日 (1..31)
 関数 `tm_mday(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その月の何日 (1--31 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_min
?expressions functions tm_min
?tm_min
#tm\_min(t) & 秒数による時刻 & 分 (0..59)\\
%tm_min(t)@秒数による時刻@分 (0..59)
 関数 `tm_min(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何分 (0--59 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_mon
?expressions functions tm_mon
?tm_mon
#tm\_mon(t) & 秒数による時刻 & 月 (0..11)\\
%tm_mon(t)@秒数による時刻@月 (0..11)
 関数 `tm_mon(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 何月 (0--11 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_sec
?expressions functions tm_sec
?tm_sec
#tm\_sec(t) & 秒数による時刻 & 秒 (0..59)\\
%tm_sec(t)@秒数による時刻@秒 (0..59)
 関数 `tm_sec(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何秒 (0--59 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_wday
?expressions functions tm_wday
?tm_wday
#tm\_wday(t) & 秒数による時刻 & 曜日 (日から土を 0..6 で)\\
%tm_wday(t)@秒数による時刻@曜日 (日から土を 0..6 で)
 関数 `tm_wday(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 何曜日であるかを、日曜から土曜を 0 から 6 の整数として返します。
??
C C 4 tm_week
#tm\_week(t) & 秒数による時刻 & ISO 8601 規則での週番号 (1..53)\\
%tm_week(t)@秒数による時刻@ISO 8601 規則での週番号 (1..53)
??
C C 4 tm_yday
?expressions functions tm_yday
?tm_yday
#tm\_yday(t) & 秒数による時刻 & その年の何日目 (0..365)\\
%tm_yday(t)@秒数による時刻@その年の何日目 (0..365)
 関数 `tm_yday(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その年の何日目 (0--365 の範囲の整数) であるかを、実数として返します。
??
C C 4 tm_year
?expressions functions tm_year
?tm_year
#tm\_year(t) & 秒数による時刻 & 西暦 \\
%tm_year(t)@秒数による時刻@西暦
 関数 `tm_year(t)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 西暦何年 (整数) であるかを、実数として返します。
??
C C 4 weekdata_iso
#weekdate\_iso(year,week,day) & 整数 & ISO 8601 規則での週曜日に対応する時刻\\
%weekdate_iso(year,week,day)@整数@ ISO 8601 規則での週曜日に対応する時刻
??
C C 4 weekdata_cdc
#weekdate\_cdc(year,week,day) & 整数 & CDC による疫学的週曜日に対応する時刻\\
%weekdate_cdc(year,week,day)@整数@ CDC による疫学的週曜日に対応する時刻\\
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{tabular}{|lcl|} \hline
#\multicolumn{3}{|c|}{他の {\bf gnuplot} の関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
%c c l .
%関数@引数@戻り値
%_
??
#column(x) & 整数か文字列 & データ入力中の $x$ 列目の数値 \\
%column(x)@整数か文字列@データ入力中の $x$ 列目の数値
??
#columnhead(x) & 整数 & データファイルの最初の $x$ 列目中の文字列 \\
%columnhead(x)@整数@データファイルの最初の $x$ 列目中の文字列
??
4 exists
?expressions functions exists
?exists
#exists("X") & 文字列 & 変数名 X が定義されていれば 1, そうでなければ 0\\
%exists("X")@文字列@変数名 X が定義されていれば 1, そうでなければ 0
 `exists()` の引数は文字列定数、または文字列変数です。その文字列が、定
 義されている変数名を持っていれば 1 を、そうでなければ 0 を返します。
4 hsv2rgb
?expressions functions hsv2rgb
?hsv2rgb
?hsv
#hsv2rgb(h,s,v) & h,s,v $\in$ [0:1] & 24 ビット RGB 色値 \\
%hsv2rgb(h,s,v)@[0:1] 内の h,s,v@24 ビット RGB 色値
 関数 `hsv2rgb(h,s,v)` は、HSV (色相(Hue)/彩度(Saturation)/明度(Value))
 の 3 つ組をそれと同等な RGB 値に変換します。
??
#index(A,x) & 配列, 任意 & A[i] = x となる整数 i。なければ 0。\\
%index(A,x)@配列, 任意@A[i] = x となる整数 i。なければ 0。
4 palette
?expressions functions palette
?palette
#palette(z) & 実数 & z に割り当てられた 24 ビット RGB パレット色 \\
%palette(z)@実数@z に割り当てられた 24 ビット RGB パレット色
 `palette(z)` は cbrange の現在の範囲で z に割り当てられるパレット色の
 24 ビット RGB 表現を返します。
4 rgbcolor
?expressions functions rgbcolor
?rgbcolor
=alpha channel
#rgbcolor("name") & 文字列 & 色名か文字列表現の色の 32 ビット ARGB 値\\
%rgbcolor("name")@文字列@色名か文字列表現の色の 32 ビット ARGB 値
 `rgbcolor("name")` は、色名か、"0xAARRGGBB" や "#AARRGGBB" の形式の文
 字列に対する、アルファ値 + RGB 色表現の 32 ビット整数値を返します。文
 字列が色の表現であると認識されなければ、この関数は 0 を返します。これ
 を使えば、データファイルから色名を読んだり、色名の色にアルファ値を上位
 バイトに追加した値を返り値として得たりできます。以下参照: `colorspec`。
??
#stringcolumn(x) & 整数か文字列 & 文字列としての $x$ 列目の内容 \\
%stringcolumn(x)@整数か文字列@文字列としての $x$ 列目の内容
??
#valid(x) & 整数 & データ入力中の $x$ 列目の正当性\\
%valid(x)@整数@データ入力中の $x$ 列目の正当性
??
#value("name") & 文字列 & 名前 name の変数の現在の値\\
%value("name")@文字列@名前 name の変数の現在の値
4 voxel
?expressions functions voxel
?voxel
#voxel(x,y,z) & 実数 & 点 (x,y,z) を含む有効ボクセルの値\\
%voxel(x,y,z)@実数@点 (x,y,z) を含む有効ボクセルの値
 関数 voxel(x,y,z) は、現在有効な格子の、点 (x,y,z) を含むボクセルの値
 を返します。これは、代入式の左辺に置いて、ボクセルの値を設定するのにも
 使えます。例: voxel(x,y,z) = 0.0
 以下参照: `splot voxel-grids`, `vgrid`。
@end table

4 整数変換関数 (integer conversion functions): int floor ceil round
?integer conversion
?integer
?precision
 gnuplot の整数変数値は、使用環境が許せば、64 ビットの精度で保存します。

 gnuplot の複素数変数値、実数変数値は、ほとんどの使用環境で IEEE754 の
 binary64 (double) 浮動小数形式で保存します。その精度は、53 ビットに制
 限され、有効数字はおよそ 16 桁です。

 よって、絶対値が 2^53 よりも大きい整数は、浮動小数変数で一意に表現する
 ことはできません。つまり、大きな N に対する int(real(N)) という操作は
 N に近いけれども N とは異なる整数を返す可能性があります。

 さらに、浮動小数値を切り捨てにより整数値に変換する関数は、その値自身が
 小さくても、16 桁以上の精度に依存する操作では期待する値を得られない可
 能性があります。例えば、int(log10(0.1)) は、-1 でなく 0 を返しますが、
 それはその浮動小数表現が -0.999999999999999... に等しいからです。
 以下も参照: `overflow`。

?expressions functions int
?int
 `int(x)` は、引数の 0 の方向に切り捨てた整数部分を返します。
 |x| > 2^63、すなわち整数値として大きすぎる場合は NaN を返します。
 |x| > 2^52 の場合は、返り値はある整数の近傍におさまりますが、浮動小数
 精度の制限のためにそれらを区別できません。
 以下参照: `integer conversion`。

?expressions functions floor
?floor
 `floor(x)` は、x の実数部分以下の最大の整数を返します。
 |x| > 2^52 の場合、その値は一意に決定できませんので、その場合は NaN を
 返します。以下参照: `integer conversion`。

?expressions functions ceil
?ceil
 `ceil(x)` は、x の実数部分以上の最小の整数を返します。
 |x| > 2^52 の場合、その値は一意に決定できませんので、その場合は NaN を
 返します。以下参照: `integer conversion`。

?expressions functions round
?round
 `round(x)` は、x の実数部分に一番近い整数を返します。
 |x| > 2^52 の場合、その値は一意に決定できませんので、その場合は NaN を
 返します。以下参照: `integer conversion`。

4 種々の楕円積分 (elliptic integrals)
?elliptic integrals
?elliptic
=elliptic integrals
 関数 `EllipticK(k)` は、第 1 種完全楕円積分、すなわち、関数
 `(1 - k^2*sin^2(θ))^(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を
 返します。`k` の定義域は -1 から 1 です (両端は含まない)。

#TeX \quad\quad EllipticK$(k)=\int_0^{\pi/2} {\sqrt{1-k^2\sin^2\theta}~}^{-1}~d\theta$

 関数 `EllipticE(k)` は、第 2 種完全楕円積分、すなわち、関数
 `(1 - k^2*sin^2(θ))^(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を
 返します。`k` の定義域は -1 から 1 です (両端も含む)。

#TeX \quad\quad EllipticE$(k)=\int_0^{\pi/2} {\sqrt{1-k^2\sin^2\theta}}~d\theta$

 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分、すなわち関数
 `(1 - k^2*sin^2(θ))^(-0.5) / (1 - n*sin^2(θ))` の 0 からπ/2 までの
 範囲の広義積分の値を返します。パラメータ `n` は 1 より小さく、`k` は
 -1 と 1 の間 (両端は含まない) でなければいけません。定義より、すべての
 正の `k` に対し EllipticPi(0,k) == EllipticK(k) であることに注意してく
 ださい。

#TeX \quad\quad EllipticPi$(n,k)=\int_0^{\pi/2} {\big[(1-n\sin^2\theta)\sqrt{1-k^2\sin^2\theta}~\big]}^{-1}d\theta$

 楕円積分のアルゴリズム: B.C.Carlson 1995, Numerical Algorithms 10:13-26.

4 複素エアリー関数  (Complex Airy functions)
?expressions functions Ai
?Ai
?expressions functions Bi
?Bi
 `Ai(z)` と `Bi(z)` は、複素引数 z のエアリー関数で、変形ベッセル関数 K
 と I を用いて計算されます。
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

#TeX \quad\quad Ai$(z) = \frac{1}{\pi}\sqrt{\frac{z}{3}} K_{\nicefrac{1}{3}}(\zeta)$
#TeX \quad\quad\quad $\zeta = \frac{2}{3}z^{\nicefrac{3}{2}}$

#TeX \quad\quad Bi$(z) = \sqrt{\frac{z}{3}} {\big[I_{\nicefrac{-1}{3}}(\zeta) + I_{\nicefrac{1}{3}}(\zeta)]}$

4 複素ベッセル関数 (Complex Bessel functions)
?expressions functions BesselJ
?BesselJ
 `BesselJ(nu,z)` は、実引数の nu と複素引数の z に対する第 1 種ベッセル
 関数 J_nu です。
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

?expressions functions BesselY
?BesselY
 `BesselY(nu,z)` は、実引数の nu と複素引数の z に対する第 2 種ベッセル
 関数 Y_nu です。
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

?expressions functions BesselI
?BesselI
 `BesselI(nu,z)` は、実引数の nu と複素引数の z に対する第 1 種変形ベッ
 セル関数 I_nu です。
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

?expressions functions BesselK
?BesselK
 `BesselK(nu,z)` は、実引数の nu と複素引数の z に対する第 2 種変形ベッ
 セル関数 K_nu です。
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

?expressions functions BesselH1
?expressions functions BesselH2
?expressions functions Hankel
?BesselH1
?BesselH2
?Hankel
 `BesselH1(nu,z)` と `BesselH2(nu,z)` は、それぞれ実引数の nu と複素引
 数の z に対する第 1 種、第 2 種のハンケル関数です。
     H1(nu,z) = J(nu,z) + iY(nu,z)
     H2(nu,z) = J(nu,z) - iY(nu,z)
 Donald E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によ
 るルーチンを含む外部ライブラリによってサポートしています。

4 Expint
?expressions functions expint
?expint
 `expint(n,z)` は、0 以上の整数 n に対して、次数 n の指数積分を返します。
 これは、t^(-n) e^(-tz) dt の 1 から∞までの積分値です。

#TeX \quad\quad $E_n(x)=\int_1^\infty t^{-n} e^{-xt}\,dt$

 あなたが使っている gnuplot が、Amos ライブラリによる複素関数のサポート
 付きでビルドされたものであれば、n>0 に対して、その評価には Amos ルーチ
 ンの cexint を使用します [Amos 1990 Algorithm 683, ACM Trans Math
 Software 16:178]。その場合、z は -pi < arg(z) <= pi の任意の複素数とで
 きます。expint(0,z) は、exp(-z)/z と計算します。

 Amos ライブラリのサポートがなければ、z は 0 以上の実数値に制限されます。

4 フレネル積分 (Fresnel integrals FresnelC(x) and FresnelS(x))
?expressions functions FresnelC
?expressions functions FresnelS
?FresnelC
?FresnelS
 コサインとサインのフレネル積分は、複素誤差関数 erf(z) との関係を用いて
 計算します。erf(z) に依存するため、これらの積分は libcerf ライブラリの
 サポートがある場合にのみ利用できます。

#TeX \quad\quad $C(x) = \int^{x}_{0}\cos(\frac{\pi}{2} t^2)dt$ \quad $S(x) = \int^{x}_{0}\sin(\frac{\pi}{2} t^2)dt$

#TeX \quad\quad $C(x)+iS(x)=\frac{1+i}{2} erf(z)$、$z = \frac{\sqrt{\pi}}{2}(1-i)x$

4 Gamma
?gamma
 `gamma(x)` は、その引数の実数部分のガンマ関数値を返します。整数 n に対
 しては gamma(n+1) = n! です。引数が複素数の場合、その虚数部分は無視し
 ます。複素数引数に対しては、以下参照: `lnGamma`。

4 Igamma
?expressions functions igamma
?igamma
 `igamma(a, z)` は、下方 (正規化) 不完全ガンマ関数 P(a, z) を返します
  [Abramowitz and Stegun (6.5.1); NIST DLMF 8.2.4]。複素関数サポートが
 あれば、a と z は real(a) > 0 の複素数値も許されます。
 逆に、上方不完全ガンマ関数に関しては、以下参照: `uigamma`。

#TeX \quad\quad igamma$(a,z)=P(a,z) = z^a\gamma^*(a,z)$
#TeX $=\frac{1}{\Gamma(z)}\intop_{0}^{z}t^{a-1}e^{-t}dt$

 a, z の値に依存して、以下の 4 つのアルゴリズムを使用します。
#TeX \\
 ケース (1) a が大きく (>100) (z-a)/a が小さい (<0.2) 場合、
 Numerical Recipes 第 3 版 6.2 節 (2007) にある係数での Gauss-Legendre
 数値積分公式を利用します。
#TeX \\
 ケース (2) z > 1 で z > (a+2) の場合、Shea (1988) J. Royal Stat. Soc.
 Series C (Applied Statistics) 37:466-473 の連分数を利用します。
#TeX \\
 ケース (3) z < 0 で a < 75 で imag(a) == 0 の場合は、Abramowitz &
 Stegun (6.5.29) の数列を利用します。
#TeX \\
 ケース (4) その他の場合は、Peason の級数展開を利用します。

 全平面では、ある領域でその収束は良くないことに注意してください。選択し
 たアルゴリズムで 1.E-14 の範囲で収束しなければ、関数は NaN を返し、警
 告を表示します。

 複素関数サポートがない場合は、定義域は実数の引数の a > 0, z >= 0 に制
 限されます。

4 Invigamma
?expressions functions invigamma
?invigamma
 逆不完全ガンマ関数 `invigamma(a,p)` は、p = igamma(a,z) となる z の値
 を返します。p は (0;1] に制限され、a は正の実数でなければいけません。
 gnuplot での実装は、a<1 に対する 1.e-16 から、a = 1.e10 に対する 5.e-6
 までの相対精度を持ちます。

4 Ibeta
?expressions functions ibeta
?ibeta
 `ibeta(a,b,x)` は、実数引数 a,b > 0, [0;1] 内の x に対する、正規化下方
 不完全ベータ積分値を返します。

#TeX \quad\quad ibeta$(a,b,x)=\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\intop_{0}^{x}t^{a-1}(1-t)^{b-1}dt$

 引数が複素数の場合、虚数部分は無視します。gnuplot での実装は、Cephes
 ライブラリ [Moshier 1989, "Methods and Programs for Mathematical
 Functions", Prentice-Hall] からのコードを利用しています。

4 Invibeta
?expressions functions invibeta
?invibeta
 逆不完全ベータ関数 `invibeta(a,b,p)` は、p = ibeta(a,b,z) となる z の
 値を返します。a, b は正の実数に、p は [0,1] 内の値に制限されています。
 a, b が 0 に近づくとき
#TeX ($\lessapprox 0.05$)
 invibeta() は 1.0 に近づくので、その相対精度は浮動小数精度に制限される
 ことに注意してください。

4 LambertW
?expressions functions LambertW
?LambertW
 複素定義域と複素値域を持つ Lambert W 関数です。
 LambertW( z, k ) は、方程式 W(z) * exp(z) = z で定義される 関数 W の第
 k 分岐を返します。
 その複素数値は、Corless et al [1996], Adv. Comp. Math 5:329 に記載され
 ている Halley の方法を使って求めます。
 名目上の精度は 1.E-13 ですが、不連続、すなわち分岐点の近くでは収束は良
 くありません。
4 lnGamma
?expressions functions lnGamma
?lnGamma
 lnGamma(z) は、複素定義域と複素値域を持つ、ガンマ関数の自然対数値を返
 します。 Lanczos [1964], SIAM JNA 1:86-96 による 14 項近似による実装で
 す。結果の虚数成分は、負の実軸部分を除く全体で連続な曲面を生成するよう
 位相をずらしています。
4 乱数の生成 (random)
?expressions random
?random
=rand
 関数 `rand()` は 0 と 1 の間の疑似乱数列を生成します。これは以下からの
 アルゴリズムを使用しています: P. L'Ecuyer and S. Cote, "Implementing a
 random number package with splitting facilities", ACM Transactions on
 Mathematical Software, 17:98-111 (1991).

       rand(0)     内部に持つ 2 つの 32bit の種 (seed) の現在の値から生
                   成される開区間 (0:1) 内の疑似乱数値を返す
       rand(-1)    2 つの種の値を標準値に戻す
       rand(x)     0 < x < 2^31-1 の整数なら種の両方を x に設定する
       rand({x,y}) 0 < x,y < 2^31-1 の整数なら seed1 を x に seed2 を y
                   に設定する
4 複素引数の特殊関数 (Special functions with complex arguments)
?expressions functions special
?expressions functions complex
?special_functions
?libcerf
?Amos
?libopenspecfun

 複素定義域を持ついくつかの特殊関数を、外部ライブラリを通して提供します。
 あなたが使っている gnuplot がこれらのライブラリへのリンクなしでビルド
 されている場合は、定義域が実数の場合のみサポートするか、または関数自体
 を全く提供しないかとなるでしょう。

 libcerf (http://apps.jcns.fz-juelich.de/libcerf) を必要とする関数は、
 ビルド時の設定オプション `--with-libcerf` に依存し、これがデフォルトで
 す。以下参照: `cerf`, `cdawson`, `faddeeva`, `erfi`, `VP`, `VP_fwhm`。

 実数次 nu と複素引数の複素エアリー、ベッセル、ハンケル関数は、Douglas
 E. Amos, Sandia National Laboratories, SAND85-1018 (1985) によって実装
 されたルーチンを含むライブラリを必要とします。これらのルーチンは、
 netlib (http://netlib.sandia.gov) や、libopenspecfun
 (https://github.com/JuliaLang/openspecfun) にあります。これらに対応す
 るビルド時の設定オプションは `--with-amos=<library directory>` です。
 以下参照: `Ai`, `Bi`, `BesselJ`, `BesselY`, `BesselI`, `BesselK`,
 `Hankel`。
 複素指数積分は、netlib, libamos では提供していますが、libopenspecfun
 にはありません。以下参照: `expint`。

4 Synchrotron function
?expressions functions SynchrotronF
?SynchrotronF
 (第 1) シンクロトロン関数 SynchrotronF(x) は、シンクロトロン放射のパワ
 ー分布スペクトルを、臨界フォトンエネルギー (臨界周波数 vc) の単位で与
 える x の関数として記述するものです。

#TeX \quad\quad $F(x) = x\intop_{x}^{\infty}K_{\nicefrac{5}{3}}(\nu)~d\nu$
#TeX ここで、$K_{\nicefrac{5}{3}}$ は第 2 種変形ベッセル関数。

 1.E-15 まで正確な近似の Chebyshev 係数は、MacLead (2000)
 NuclInstMethPhysRes A443:540-545 から採用しています。

4 時刻関数 (Time functions)
5 time
?expressions functions time
?time
 関数 `time(x)` は現在のシステム時刻を返します。この値は `strftime` 関
 数で日時文字列に変換できますし、`timecolumn` と組み合わせて相対的な日
 時グラフを作成するのにも使えます。引数の型はそれが返すものを決定します。
 引数が整数の場合は time() は現在の時刻を 1970 年 1 月 1 日からの整数と
 して返し、引数が実数 (または複素数) ならば同様の値を実数として返します。
 引数が文字列ならば、それを書式文字列であるとみなし、書式化された日時文
 字列を提供するようそれを `strftime` に渡します。
 以下参照: `time_specifiers`, `timefmt`。
5 timecolumn
?expressions functions timecolumn
?timecolumn
 `timecolumn(N,"timeformat")` は、N 列目から始まる文字列データを日時デ
 ータ値として読み、"timeformat" を使用して、それを "Unix エポック (1970
 年 1 月 1 日) からの秒数" としてミリ秒精度で解釈します。書式パラメータ
 の指定がない場合、デフォルトの `set timefmt` による文字列を使います。
 この関数は、plot か stats コマンドでの `using` 指定でのみ有効です。以
 下参照: `plot datafile using`。
5 tm_structure
?epoch
 gnuplot は、内部では時刻を、Unix エポック 1970 年 1 月 1 日からの秒数
 を表す 64 bit の浮動小数値として保持しています。これを時刻や日付として
 解釈するために、それを POSIX 標準の構造体 `struct_tm` に変換します。
 1 秒未満の秒数は、どんな場合でも tm_sec() からは取得できないことに注意
 してください。各要素には、以下の関数を利用して個別にアクセスできます。
#start
#b `tm_hour(t)` 整数 0--23 の範囲の時間
#b `tm_mday(t)` 整数 1--31 の範囲のその月の日
#b `tm_min(t)`  整数 0--59 の範囲の分
#b `tm_mon(t)`  整数 0--11 の範囲のその年の月
#b `tm_sec(t)`  整数 0--59 の範囲の秒
#b `tm_wday(t)` 整数 0(日)-- 6(土) の範囲の曜日
#b `tm_yday(t)` 整数 0--365 の範囲のその年の日
#b `tm_year(t)` 整数 西暦
#end
5 tm_week
?expressions functions tm_week
?time_specifiers tm_week
?tm_week
?epidemiological week
=epidemiological week
 関数 `tm_week(t, standard)` は、その引数を 1970 年 1 月 1 日からの秒数
 での時刻とみなします。なお、関数名から POSIX の tm 構造体のメンバと思
 うかもしれませんが、そうではありません。

 standard = 0 の場合、これは ISO 8601 週曜日規則での週番号を返します。
 これは、gnuplot の時刻書式 %W に対応します。
 standard = 1 の場合、これは CDC (アメリカ疾病予防管理センター) 疫学的
 週曜日規則 (「疫学的週」) での週番号を返します。
 これは、gnuplot の時刻書式 %U に対応します。
 これらに対応する、週曜日からカレンダー時刻に変換する逆関数については、
 以下参照: `weekdate_iso`, `weekdate_cdc`。

 解説: ISO の YYYY 年の 1 番の週は、YYYY 年 1 月 1 に一番近い月曜日から
 始まります。これは、前の年になる可能性もあります。例えば、2008 年 12
 月 30 日火曜日は、ISO の週曜日では 2009-W01-2 (2009 年の週番号 1 の第
 2 日) となります。逆に、1 月の 1 日から 3 日までは、ISO の週番号 1 の
 月曜より前になることがありえます。この場合、これらの日は、前の年の最後
 の週番号の週に含まれることになります。例えば、2021 年 1 月 1 日金曜日
 は、ISO の週曜日では 2020-W53-5 です。

 アメリカ疾病予防管理センター (CDC) の定める疫学的週は、同様の週曜日規
 則ですが、ISO 規則とは、月曜開始ではなく、日曜開始であるところが違いま
 す。

5 weekdate_iso
?expressions functions weekdate_iso
?time_specifiers weekdate_iso
?weekdate_iso
 書式:
      time = weekdate_iso( year, week [, day] )

 この関数は、ISO 8601 週曜日での year(西暦), week(週番号), day(日番号)
 の要素を、Unix エポックの 1970 年 1 月 1 日からの秒数でのカレンダー時
 刻に変換します。週曜日系での名目上の年 (year) は、カレンダーでの年と必
 ずしも一致しないことに注意してください。週番号 week は 1 から 53 の間
 の整数です。日番号 day はオプションで、それが 0 かまたは省略した場合は
 その週の開始時刻を返し、そうでなければ day は 1 (月曜) から 7 (日曜)
 までの整数です。
 カレンダー日を、ISO 規則での週番号に変換する逆関数に関する情報について
 は、以下参照: `tm_week`。

 例:
      # 1 列目に ISO 週番号を持つファイルからのデータの描画
      #     週      感染者  死亡者
      #     2020-05    432       1
      calendar_date(w) = weekdate_iso( int(w[1:4]), int(w[6:7]) )
      set xtics time format "%b\n%Y"
      plot FILE using (calendar_date(strcol(1))) : 2   title columnhead

5 weekdate_cdc
?expressions functions weekdate_cdc
?time_specifiers weekdate_cdc
?weekdate_cdc
=epidemiological week
 書式:
      time = weekdate_cdc( year, week [, day] )

 この関数は、CDC/MMWR (アメリカ疾病予防管理センター/疫学週報) の疫学的
 週曜日での year(西暦), week(週番号), day(日番号) の要素を、Unix エポッ
 クの 1970 年 1 月 1 日からの秒数でのカレンダー時刻に変換します。CDC 週
 曜日規則は、ISO 規則とは、週が 1 = 日曜から 7 = 土曜まで、と定義されて
 いる点に違いがあります。3 番目のパラメータが 0 または省略した場合は、
 その週の開始時刻が返ります。
 以下参照: `tm_week`, `weekdate_iso`。

4 uigamma
?expressions functions uigamma
?uigamma
 `uigamma(a, x)` は、上方 (正規化) 不完全ガンマ関数 Q(a, x) を返します
 [NIST DLMF eq 8.2.4]。
 逆に、下方不完全ガンマ関数 P(a,x) に対しては、以下参照: `igamma`。
#TeX \\
 Q(a, x) + P(a, x) = 1 です。

#TeX \quad\quad uigamma$(a,z)=Q(a,x) = 1-P(a,x)$
#TeX $=\frac{1}{\Gamma(z)}\intop_{x}^{\infty}t^{a-1}e^{-t}dt$

 現在の実装は、Cephes library (Moshier 2000) によるものです。定義域は、
 実数の a>0, 実数の x>=0 に制限されています。
 試験段階:
 そのうちに複素引数を処理する実装に置き換えられるでしょう。

4 using 指定用関数 (using specifier functions)
 以下の関数は、データ入力時のみ有効です。通常それは、`plot`, `splot`,
 `fit`, `stats` のいずれかのコマンド上の `using` 指定の入力列を使用する
 数式内で使用します。しかしその関数の適用範囲は、実際の plot コマンド文
 全体であり、例えばグラフタイトルの作成時の `columnhead` の使用も含まれ
 ます。

5 column
?expressions functions column
?column
 関数 `column(x)` は、plot, splot, stats コマンドの一部としてのみ使いま
 す。これは、$x$ 列目の内容を数値として評価します。
 文字列を持つと思われる列の場合は、代わりに stringcolumn(x) か、
 timecolumn(x, "timeformat") を使用してください。
 以下参照: `plot datafile using`, `stringcolumn`, `timecolumn`。
5 columnhead
?expressions functions columnhead
?columnhead
 関数 `columnhead(x)` は、plot, splot, stats コマンドの一部としてのみ使
 います。これは、データファイルの最初の行の $x$ 列目の内容を文字列とし
 て評価します。典型的には、これは先頭行をグラフタイトルとして展開するの
 に使用します。
 以下参照: `plot datafile using`。
 例:
      set datafile columnheader
      plot for [i=2:4] DATA using 1:i title columnhead(i)
5 stringcolumn
?expressions functions stringcolumn
?stringcolumn
?expressions functions strcol
?strcol
 関数 `stringcolumn(x)` は、データ描画か fit における `using` 指定での
 み使います。これは $x$ 列目の内容を文字列として返します。`strcol(x)`
 は、`stringcolumn(x)` の省略形です。
 その文字列を、時間や日付と認識させたい場合は、代わりに
 timecolumn(x, "timeformat") を使用してください。以下参照:
 `plot datafile using`。
5 valid
?expressions functions valid
?valid
 関数 `valid(x)` は、データ描画か fit における `using` 指定の式の中でし
 か使いません。これは、明らかな NaN 値や、入力列内の予期せぬゴミを検出
 したり、多分デフォルト値に置き換えたり、NaN を使ってさらに計算をするこ
 とを避けたりするのに使えます。欠損値 ("missing") と NaN (非数値) デー
 タ値はどちらも不正と認識されますが、以下は重要ですが、gnuplot がその列
 を本当に欠損値であると認識するか、または欠損値フラグを含んでいると認識
 した場合、valid() を使用する数式が呼び出される前に、その入力行は捨てら
 れてしまう、ということに注意してください。
 以下参照: `plot datafile using`, `missing`。

 例:
      # 箱のある認識できない値を、無視する代わりに、期待値である定数
      # prior として、箱全体に寄与するように扱う。
      plot DATA using 1 : (valid(2) ? $2 : prior) smooth unique

4 value
?expressions functions value
?value
 A がユーザー定義変数の名前であれば、B = value("A") は事実上 B = A と全
 く同じです。これは、変数の名前自身が文字列変数に収められている場合に有
 用です。以下参照: `user-defined variables`。これは、変数名をデータファ
 イルから読み取ることも可能にします。引数が数式である場合、value() はそ
 の数式の値を返します。引数が文字列で、定義されている変数に対応するもの
 がない場合、value() は NaN を返します。

4 単語の取り出しと単語数 (word, words)
?counting_words
?expressions functions word
?expressions functions words
?words
?word
 `word("string",n)` は、文字列 (string) の n 番目の単語を返します。例え
 ば `word("one two three",2)` は文字列 "two" を返します。

 `words("string")` は、文字列 (string) の単語数を返します。例えば、
 `words(" a b c d")` は 4 を返します。

 関数 `word` と `words` は、単一引用符、二重引用符で囲まれた文字列も、
 限定的ですがサポートしています:
       print words("\"double quotes\" or 'single quotes'")   # 3
 開始引用符の前は、スペースか、または文字列の先頭でなければいけません。
 これは、単語内、あるいは単語終わりにつくアポストロフィー (') は、それ
 ぞれの単語の要素であると見なされることを意味します:
       print words("Alexis' phone doesn't work") # 4
 引用符文字のエスケープはサポートしていませんので、ある引用符を維持した
 い場合は、それぞれを別の種類の引用符で囲まなければいけません:
       s = "Keep \"'single quotes'\" or '\"double quotes\"'"
       print word(s, 2) # 'single quotes'
       print word(s, 4) # "double quotes"
 最後の例では、引用符のエスケープが文字列の定義時のみに必要であることに
 注意してください。

=split
?split
?expressions functions split
 `split("string", "sep")` は、
 `split("string", "sep")` は、"sep" 内の文字をフィールドの区切りとして
 使用し、文字列 "string" の中身を個々のフィールドに切り分けます。これは、
 その要素が元の文字列のフィールドにそれぞれ対応する文字列の配列を返しま
 す。2 つ目のパラメータ "sep" はオプションで、"sep" を省略した場合、ま
 たは空白文字一つである場合は、フィールド文字列を任意個のホワイトスペー
 ス (スペース、タブ、改ページ、改行、復帰) で切り分けます。それ以外の場
 合は、区切りは "sep" 内の完全な文字列にマッチする必要があります。

 以下の 3 つの例は、いずれも配列 [ "A", "B", "C", "D" ] を生成します。
     t1 = split( "A B C D" )
     t2 = split( "A B C D", " ")
     t3 = split( "A;B;C;D", ";")

 しかし、以下のコマンド
     t4 = split( "A;B; C;D", "; " )
 は、2 つの文字列のみを持つ配列 [ "A;B", "C;D" ] を生成しますが、それは、
 2 文字のフィールド区切り文字列 "; " が 1 つしか見つからないからです。

 注意: 文字列を、1 文字ずつの配列に保存するために、区切りとして空文字を
 設定することは、現在は実装されていません。それは、代わりに 1 文字の部
 分文字列を使うことで実現できます:   Array[i] = "string"[i:i]

=join
?join
?expressions functions join
 `join(array, "sep")` は、配列の文字列要素を、"sep" の文字列で区切られ
 たフィールドの列として一つの文字列に連結します。文字列でない配列要素は、
 空のフィールドを生成します。この逆に `split` 関数は一つの文字列を複数
 のフィールドに切り分けて一つの配列を生成します。
 例:
     array A = ["A", "B", , 7, "E"]
     print join(A,";")
           A;B;;;E

=trim
?trim
 `trim("  padded string ")` は、元の文字列の前後にある空白部分を取り除
 いた文字列を返します。これは、余計な空白を持ちうる入力データ列の文字列
 同士を比較する際に有用です。例:
      plot FOO using 1:( trim(strcol(3)) eq "A" ? $2 : NaN )

4 zeta
?expressions functions zeta
?zeta
?Riemann
 zeta(s) は、複素変数、複素数値のリーマンゼータ関数です。
#TeX \quad\quad $\zeta(s) = \Sigma^{\infty}_{k=1}k^{-s}$

 この実装は、P. Borwein [2000] Canadian Mathematical Society Conference
 Proceedings でアルゴリズム 3 として記述されている多項式級数を使用して
 います。名目上の精度は、複素平面上で 1.e-16 です。しかし、これは、ゼー
 タ関数の自明でない零点が完全に 0 と評価されることを保証はしません。

3 演算子 (operators)
?expressions operators
?operators
 `gnuplot` の演算子は、C 言語の演算子とほぼ同じですが、特に注意がなけれ
 ば全ての演算子が整数、実数、複素数の引数を取ることができます。また、
 FORTRAN で使える ** (累乗) 演算子もサポートされています。

 演算子の優先順位は Fortran や C と同じです。それらの言語同様、演算の評
 価される順序を変えるためにかっこが使われます。よって -2**2 = -4 で、
 (-2)**2 = 4 です。

4 単項演算子 (Unary)
?expressions operators unary
?operators unary
?unary
 以下は、単項演算子の一覧です:

@start table - まずは対話型テキスト形式
     記号          例        説明
       -           -a          マイナス符号
       +           +a          プラス符号 (何もしない)
       ~           ~a        * 1 の補数 (ビット反転)
       !           !a        * 論理的否定
       !           a!        * 階乗
       $           $3        * `using` 指定上のデータ列
       ||          |A|         配列 A の要素数
=factorial
=negation
=one's complement
=operator precedence
=cardinality
#\begin{tabular}{|lcl|} \hline
#\multicolumn{3}{|c|}{単項演算子}\\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb@-@ & \verb@-a@ & マイナス符号 \\
#\verb@+@ & \verb@+a@ & プラス符号 (何もしない) \\
#\verb@~@ & \verb@~a@ & * 1 の補数 (ビット反転) \\
#\verb@!@ & \verb@!a@ & * 論理的否定 \\
#\verb@!@ & \verb@a!@ & * 階乗 \\
#\verb@$@ & \verb@$3@ & * `using` 指定上のデータ列 \\
#\verb@|@ & \verb@|A|@ & 配列 A の要素数 \\
C ugly hack: doc2ms uses $ as delimiter for eqn's so it doesn't seem to
C be able to print them. So we have to typeset this table without using
C eqn (at least that's the only solution I found, without any real docs
C on *roff and eqn
C First, terminate the table doc2ms.c already started:
%c c l .
%.TE
C ... then turn off eqn delimiters:
%.EQ
%delim off
%.EN
C ... and restart the table:
%.TS
%center box tab (@) ;
%c c l .
%記号@例@説明
%_
%-@-a@マイナス符号
%+@+a@プラス符号 (何もしない)
%~@~a@* 1 の補数 (ビット反転)
%!@!a@* 論理的否定
%!@a!@* 階乗
%$@$3@* `using` 指定上のデータ列
%|@|A|@配列 A の要素数
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>-</tt></td>    <td><tt>-a</tt></td>    <td>マイナス符号</td></tr>
^<tr>    <td><tt>+</tt></td>    <td><tt>+a</tt></td>    <td>プラス符号 (何もしない)</td></tr>
^<tr>    <td><tt>~</tt></td>    <td><tt>~a</tt></td>    <td>* 1 の補数 (ビット反転)</td></tr>
^<tr>    <td><tt>!</tt></td>    <td><tt>!a</tt></td>    <td>* 論理的否定</td></tr>
^<tr>    <td><tt>!</tt></td>    <td><tt>a!</tt></td>    <td>* 階乗</td></tr>
^<tr>    <td><tt>$</tt></td>    <td><tt>$3</tt></td>    <td>* `using` 指定上のデータ列</td></tr>
^<tr>    <td><tt>|</tt></td>    <td><tt>|A|</tt></td>   <td>配列 A の要素数</td></tr>
^</tbody>
^</table>

 説明に星印 (*) のついた演算子の引数は整数でなければなりません。

 階乗演算子は、N! が十分小さければ (64 ビット整数では N <= 20) 整数を返
 し、大きな N の値に対しては実数での近似値を返します。

?cardinality
 基数オペレータ |...| は、配列 A の要素数 |A| を返します。データブロッ
 ク $DATA に適用した場合は、|$DATA| はデータ行数を返します。
4 二項演算子 (Binary)
?expressions operators binary
?operators binary
 以下は、二項演算子の一覧です:

@start table - まずは対話型テキスト形式
     記号          例          説明
       **          a**b          累乗
       *           a*b           積
       /           a/b           商
       %           a%b         * 余り
       +           a+b           和
       -           a-b           差
       ==          a==b          等しい
       !=          a!=b          等しくない
       <           a<b           より小さい
       <=          a<=b          以下
       >           a>b           より大きい
       >=          a>=b          以上
       <<          0xff<<1       符号なし左シフト
       >>          0xff>>2       符号なし右シフト
       &           a&b         * ビット積 (AND)
       ^           a^b         * ビット排他論理和 (XOR)
       |           a|b         * ビット和 (OR)
       &&          a&&b        * 論理的 AND
       ||          a||b        * 論理的 OR
       =           a = b         代入
       ,           (a,b)         累次評価
       .           A.B           文字列の連結
       eq          A eq B        文字列が等しい
       ne          A ne B        文字列が等しくない
=bitwise operators
=string operators
=modulo
=exponentiation
#\begin{tabular}{|lcl|} \hline
#\multicolumn{3}{|c|}{二項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~**~ & \verb~a**b~ & 累乗\\
#\verb~*~ & \verb~a*b~ & 積\\
#\verb~/~ & \verb~a/b~ & 商\\
#\verb~%~ & \verb~a%b~ & * 余り\\
#\verb~+~ & \verb~a+b~ & 和\\
#\verb~-~ & \verb~a-b~ & 差\\
#\verb~==~ & \verb~a==b~ & 等しい\\
#\verb~!=~ & \verb~a!=b~ & 等しくない\\
#\verb~<~ & \verb~a<b~ & より小さい\\
#\verb~<=~ & \verb~a<=b~ & 以下\\
#\verb~>~ & \verb~a>b~ & より大きい\\
#\verb~>=~ & \verb~a>=b~ & 以上\\
#\verb~<<~ & \verb~0xff<<1~ & 符号なし左シフト\\
#\verb~>>~ & \verb~0xff>>1~ & 符号なし右シフト\\
#\verb~&~ & \verb~a&b~ & * ビット積 (AND)\\
#\verb~^~ & \verb~a^b~ & * ビット排他的論理和 (XOR)\\
#\verb~|~ & \verb~a|b~ & * ビット和 (OR)\\
#\verb~&&~ & \verb~a&&b~ & * 論理的 AND\\
#\verb~||~ & \verb~a||b~ & * 論理的 OR\\
#\verb~=~ & \verb~a = b~ & 代入\\
#\verb~,~ & \verb~(a,b)~ & 累次評価\\
#\verb~.~ & \verb~A.B~ & 文字列の連結\\
#\verb~eq~ & \verb~A eq B~ & 文字列が等しい\\
#\verb~ne~ & \verb~A ne B~ & 文字列が等しくない\\
%c c l .
%記号@例@説明
%_
%**@a**b@累乗
%*@a*b@積
%/@a/b@商
%%@a%b@* 余り
%+@a+b@和
%-@a-b@差
%==@a==b@等しい
%!=@a!=b@等しくない
%<@a<b@より小さい
%<=@a<=b@以下
%>@a>b@より大きい
%>=@a>=b@以上
%<<@0xff<<1@符号なし左シフト
%>>@0xff>>1@符号なし右シフト
%&@a&b@* ビット積 (AND)
%^@a^b@* ビット排他的論理和 (XOR)
%|@a|b@* ビット和 (OR)
%&&@a&&b@* 論理的 AND
%||@a||b@* 論理的 OR
%\&=@a = b@代入
%,@(a,b)@累次評価
%.@a.b@文字列の連結
%eq@A eq B@文字列が等しい
%ne@A ne B@文字列が等しくない

@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>**</tt></td>    <td><tt>a**b</tt></td>    <td>累乗</td></tr>
^<tr>    <td><tt>*</tt></td>    <td><tt>a*b</tt></td>    <td>積</td></tr>
^<tr>    <td><tt>/</tt></td>    <td><tt>a/b</tt></td>    <td>商</td></tr>
^<tr>    <td><tt>%</tt></td>    <td><tt>a%b</tt></td>    <td>* 余り</td></tr>
^<tr>    <td><tt>+</tt></td>    <td><tt>a+b</tt></td>    <td>和</td></tr>
^<tr>    <td><tt>-</tt></td>    <td><tt>a-b</tt></td>    <td>差</td></tr>
^<tr>    <td><tt>==</tt></td>    <td><tt>a==b</tt></td>    <td>等しい</td></tr>
^<tr>    <td><tt>!=</tt></td>    <td><tt>a!=b</tt></td>    <td>等しくない</td></tr>
^<tr>    <td><tt>&lt;</tt></td>    <td><tt>a&lt;b</tt></td>    <td>より小さい</td></tr>
^<tr>    <td><tt>&lt;=</tt></td>    <td><tt>a&lt;=b</tt></td>    <td>以下</td></tr>
^<tr>    <td><tt>&gt;</tt></td>    <td><tt>a&gt;b</tt></td>    <td>より大きい</td></tr>
^<tr>    <td><tt>&gt;=</tt></td>    <td><tt>a&gt;=b</tt></td>    <td>以上</td></tr>
^<tr>    <td><tt>&lt;&lt;</tt></td>    <td><tt>0xff&lt;&lt;1</tt></td>    <td>符号なし左シフト</td></tr>
^<tr>    <td><tt>&gt;&gt;</tt></td>    <td><tt>0xff&gt;&gt;1</tt></td>    <td>符号なし右シフト</td></tr>
^<tr>    <td><tt>&amp;</tt></td>    <td><tt>a&amp;b</tt></td>    <td>* ビット積 (AND)</td></tr>
^<tr>    <td><tt>^</tt></td>    <td><tt>a^b</tt></td>    <td>* ビット排他的論理和 (XOR)</td></tr>
^<tr>    <td><tt>|</tt></td>    <td><tt>a|b</tt></td>    <td>* ビット和 (OR)</td></tr>
^<tr>    <td><tt>&amp;&amp;</tt></td>    <td><tt>a&amp;&amp;b</tt></td>    <td>* 論理的 AND</td></tr>
^<tr>    <td><tt>||</tt></td>    <td><tt>a||b</tt></td>    <td>* 論理的 OR</td></tr>
^<tr>    <td><tt>=</tt></td>    <td><tt>a = b</tt></td>    <td>代入</td></tr>
^<tr>    <td><tt>,</tt></td>    <td><tt>(a,b)</tt></td>    <td>累次評価</td></tr>
^<tr>    <td><tt>.</tt></td>    <td><tt>a.b</tt></td>    <td>文字列の連結</td></tr>
^<tr>    <td><tt>eq</tt></td>    <td><tt>A eq B</tt></td>    <td>文字列が等しい</td></tr>
^<tr>    <td><tt>ne</tt></td>    <td><tt>A ne B</tt></td>    <td>文字列が等しくない</td></tr>
^</tbody>
^</table>

 説明に星印 (*) のついた演算子の引数は整数でなければなりません。
 大文字の A,B は演算子が文字列引数を要求することを意味します。

 論理演算子の AND (&&) と OR (||) は C 言語同様に必要最小限の評価しかし
 ません。すなわち、`&&` の第 2 引数は、第 1 引数が偽ならば評価されませ
 んし、`||` の第 2 引数は、第 1 引数が真ならば評価されません。

 累次評価 (,) は、カッコの中でのみ評価され、左から右へ順に実行すること
 が保証され、最も右の式の値が返されます。
4 三項演算子 (Ternary)
?expressions operators ternary
?operators ternary
?ternary
 一つだけ三項演算子があります:

@start table - まずは対話型テキスト形式
      記号          例       説明
       ?:          a?b:c     三項演算子
#\begin{tabular}{|lcl|} \hline
#\multicolumn{3}{|c|}{三項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~?:~ & \verb~a?b:c~ & 三項演算子\\
%c c l .
%記号@例@説明
%_
%?:@a?b:c@三項演算子

@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>?:</tt></td>    <td><tt>a?b:c</tt></td>    <td>* 三項演算子</td></tr>
^</tbody>
^</table>

 三項演算子は C のものと同じ働きをします。最初の引数 (a) は整数でなけれ
 ばいけません。この値が評価され、それが真 (ゼロでない) ならば 2 番目の
 引数 (b) が評価されその値が返され、そうでなければ 3 番目の引数 (c) が
 評価され、その値が返されます。

 三項演算子は、区分的に定義された関数や、ある条件が満たされた場合にのみ
 点を描画する、といったことを行なう場合に有用です。

 例:

 0 <= x < 1 では sin(x) に、1 <= x < 2 では 1/x に等しくて、それ以外の
 x では定義されない関数を描画:
       f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
       plot f(x)
 `gnuplot` は描画時は未定義値に対しては何も表示せずにただ無視するので、
 最後の場合の関数 (1/0) は点を全く出力しないことに注意してください。ま
 た、この関数描画の描画スタイルが lines (線描画) の場合、不連続点 (x=1)
 の所も連続関数として線が結ばれることにも注意してください。その点を不連
 続になるようにするには、関数を 2 つの部分それぞれに分けてください。

 ファイル 'file' のデータで、4 列目のデータが負でないときだけ、1 列目の
 データに関する 2 列目と 3 列目のデータの平均値を描画:

       plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )

 `using` の書式の説明に関しては、以下参照: `plot datafile using`。
3 和 (summation)
?expressions operators summation
?operators summation
?summation
 和の式は、以下の形式で表します:
       sum [<var> = <start> : <end>] <expression>
 ここで <var> は、<start> から <end> までの整数値を順に取る整数変数とし
 て扱われます。その各値に対して、式 <expression> の値が合計値に追加され、
 最終的な合計値がこの和の式の値となります。
 例:
       print sum [i=1:10] i
           55.
       # 以下は plot 'data' using 1:($2+$3+$4+$5+$6+...) と同等
       plot 'data' using 1 : (sum [col=2:MAXCOL] column(col))
 <expression> は、必ずしも変数 <var> を含む必要はありません。<start> と
 <end> は変数値や数式で指定もできますが、それらの値は動的に変更すること
 はできません。そうでないと副作用が起こり得ます。<end> が <start> より
 小さい場合は、和の値は 0 となります。
3 定義済み変数 (Gnuplot-defined variables)
?expressions gnuplot-defined
?gnuplot-defined
?gnuplot-defined variables
?GPVAL
?gpval
 gnuplot は、プログラムの現在の内部状態と直前の描画を反映するような読み
 出し専用の変数をいくつか持っています。これらの変数の名前は、例えば
 GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN のように "GPVAL_" で
 始まります。これらすべての一覧とその値を見るには、`show variables all`
 と入力してください。ただし、軸のパラメータに関連する値 (範囲、対数軸で
 あるか等) は、現在 `set` したものではなく、最後に描画されたものが使用
 されます。

 例: 点 [X,Y] のスクリーン比での座標を計算する方法
      GRAPH_X = (X - GPVAL_X_MIN) / (GPVAL_X_MAX - GPVAL_X_MIN)
      GRAPH_Y = (Y - GPVAL_Y_MIN) / (GPVAL_Y_MAX - GPVAL_Y_MIN)
      SCREEN_X = GPVAL_TERM_XMIN + GRAPH_X * (GPVAL_TERM_XMAX - GPVAL_TERM_XMIN)
      SCREEN_Y = GPVAL_TERM_YMIN + GRAPH_Y * (GPVAL_TERM_YMAX - GPVAL_TERM_YMIN)
      FRAC_X = SCREEN_X * GPVAL_TERM_SCALE / GPVAL_TERM_XSIZE
      FRAC_Y = SCREEN_Y * GPVAL_TERM_SCALE / GPVAL_TERM_YSIZE

=errors
=error state
 読み出し専用変数 GPVAL_ERRNO は、任意の gnuplot コマンドがあるエラーの
 ために早く終わってしまった場合に 0 でない値にセットされ、直前のエラー
 メッセージは文字列変数 GPVAL_ERRMSG に保存されます。GPVAL_ERRNO と
 GPVAL_ERRMSG は、コマンド `reset errors` を使ってクリアできます。

 `mouse` 機能が使える対話型入出力形式は、"MOUSE_" で始まる読み出し専用
 変数をいくつか持っています。詳細は、以下参照: `mouse variables`。

 `fit` 機能は、"FIT_" で始まるいくつかの変数を使用しますので、そのよう
 な名前を使うのは避けるべきでしょう。`set fit errorvariables` を使用す
 ると、各当てはめ変数のエラーは、そのパラメータ名に "_err" を追加した変
 数に保存されます。詳細は、以下参照: `fit`。

 以下も参照: `user-defined variables`, `reset errors`,
 `mouse variables`, `fit`。

3 ユーザ定義の変数と関数 (User-defined)
?expressions user-defined
?functions user-defined
?user-defined variables
?user-defined
?variables
 新たなユーザ定義変数と 1 個から 12 個までの引数を持つユーザ定義関数を、
 任意の場所で定義したり使ったりすることができます。それは `plot` コマン
 ド上でも可能です。

 ユーザ定義関数書式:
       <func-name>( <dummy1> {,<dummy2>} ... {,<dummy12>} ) = <expression>

 ここで <expression> は、仮変数 <dummy1> から <dummy12> で表される数式
 です。この形式の関数定義は、1 行での使用に制限されています。より複雑で
 複数行からなる関数は、関数ブロックの仕組みを使えば定義できます (現バー
 ジョンでの新機能)。以下参照: `function blocks`。

 ユーザ定義変数書式:
       <variable-name> = <constant-expression>

 例:
       w = 2
       q = floor(tan(pi/2 - 0.1))
       f(x) = sin(w*x)
       sinc(x) = sin(pi*x)/(pi*x)
       delta(t) = (t == 0)
       ramp(t) = (t > 0) ? t : 0
       min(a,b) = (a < b) ? a : b
       comb(n,k) = n!/(k!*(n-k)!)
       len3d(x,y,z) = sqrt(x*x+y*y+z*z)
       plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)

       file = "mydata.inp"
       file(n) = sprintf("run_%d.dat",n)

 最後の 2 行の例は、ユーザ定義文字列変数と、ユーザ定義文字列関数を意味
 しています。

=NaN
=pi
 変数 `pi` (3.14159...) と `NaN` (IEEE 非数 ("Not a Number")) はあらか
 じめ定義されています。これらが必要なければ、他のものに再定義することも
 可能ですし、以下のようにして元の値に復帰することもできます:

       NaN = GPVAL_NaN
       pi  = GPVAL_pi

 他にもいくつかの変数が、例えば対話型入出力形式でのマウス操作や当てはめ
 (fit) などの gnuplot の動作状態に応じて定義されます。詳細は
 以下参照: `gnuplot-defined variables`。

 ある変数 V が既に定義されているかどうかは、式 exists("V") でチェックで
 きます。例:
       a = 10
       if (exists("a")) print "a is defined"
       if (!exists("b")) print "b is not defined"

 変数名や関数名の命名規則は、大抵のプログラミング言語と同じで、先頭はア
 ルファベットで、その後の文字はアルファベット、数字、"_" が使えます。

 各関数の定義式は、'GPFUN_' という接頭辞を持つ特別な文字列値変数として
 利用できます。

 例:
       set label GPFUN_sinc at graph .05,.95

 以下参照: `show functions`, `functions`, `gnuplot-defined variables`,
 `macros`, `value`。
3 配列 (arrays)
?arrays
=cardinality
 配列は、ユーザ変数の添字付きリストとして実装されています。一つの配列の
 要素は、一つの変数型には限定されていません。配列は、参照する前に明示的
 に作られていなければいけません。配列を作成した後で、そのサイズを変更す
 ることはできません。配列の要素は、宣言時に提供されてない限り、最初は未
 定義 (undefined) です。ほとんどの場面で、名前付きユーザ変数の代わりに
 配列要素を利用できます。

 配列 A の要素数は、数式 |A| で取得できます。

 例:
      array A[6]
      A[1] = 1
      A[2] = 2.0
      A[3] = {3.0, 3.0}
      A[4] = "four"
      A[6] = A[2]**3
      array B[6] = [ 1, 2.0, A[3], "four", , B[2]**3 ]
      array C = split("A B C D E F")

      do for [i=1:6] { print A[i], B[i] }
          1 1
          2.0 2.0
          {3.0, 3.0} {3.0, 3.0}
          four four
          <undefined> <undefined>
          8.0 8.0

 注意: 配列と変数は、同じ名前空間を共有します。例えば、あらかじめ FOO
 という名前の配列がある場合、FOO という名前の変数に文字列を割り当てると
 配列を破壊します。

 配列の名前を `plot`, `splot`, `fit`, `stats` コマンドに与えることもで
 きます。その場合、配列の添字がファイルの 1 列目の値で (1 から size ま
 で)、その値 A[i] の実数部分 real(A[i]) がファイルの 2 列目、虚数部分
 imag(A[i]) がファイルの 3 列目であるようなデータファイルを与えたことと
 同等になります。

 例:
      array A[200]
      do for [i=1:200] { A[i] = sin(i * pi/100.) }
      plot A title "sin(x) in centiradians"

 ただし、plot 時に複素数値配列の虚数部分を描画したい場合、その値は
 imag(A[$1]) かまたは $3 として参照できます。よって以下の 2 つのコマン
 ドは同等です。

      plot A using (real(A[$1])) : (imag(A[$1]))
      plot A using 2:3

4 配列関数 (array functions)
?arrays functions
?arrays slice
?slice
=split
 gnuplot バージョン 6 より、配列を関数に渡すことも、返り値にすること
 もできるようになりました。例えば、2 つのサイズの同じ数値配列のドット積
 (内積) は以下のように定義できます。

      dot(A,B) = (|A| != |B|) ? NaN : sum [i=1:|A|] A[i] * B[i]

 配列をやりとりする組み込み関数には、配列の分割操作 array[min:max] や添
 字取得関数 index(Array,value) があります。

      T = split("A B C D E F")
      U = T[3:4]
      print T
         [ "A", "B", "C", "D", "E", "F" ]
      print U
         [ "C", "D" ]
      print index( T, "D" )
         4

 この例の T と U は、それが以前にどのように宣言されていたかどうかに関わ
 らず、この例の時点では配列になることに注意してください。

4 配列の添字付け (Array indexing)
?arrays indexing
=index
 要素が N 個の配列 (array) の添字は、1 から N までとなります。
 配列 A の i 番目の要素は、A[i] と参照します。
 組み込み関数 `index(Array, <value>)` は、A[i] が <value> に等しいよう
 な整数 i を返します。ここで、<value> は数値 (整数、実数、または複素数)
 と評価される任意の数式、あるいは文字列です。配列の要素とは型と値の両方
 が一致する必要があります。見つからない場合は、0 を返します。

     array A = [ 4.0, 4, "4" ]
     print index( A, 4 )
           2
     print index( A, 2.+2. )
           1
     print index( A, "D4"[2:2] )
           3

2 フォント
?fonts
 gnuplot それ自身にはどんなフォントも含まれてはおらず、外部フォント処理
 に頼っているだけで、その細部は悲しいことに出力形式毎に異なります。ここ
 では、複数の出力形式に適用されるフォント機構について説明します。ここに
 上げたもの以外の出力形式でのフォントの使用に関しては、その出力形式のド
 キュメントを参照してください。

 一時的に、例えば Adobe Symbol フォントのような特別なフォントに切り替え
 ることでアルファベットではない記号を入れることも可能ですが、現在は、
 UTF-8 エンコーディングを使用して、他の文字と同様にその記号を扱うのがよ
 り良い方法でしょう。その他に、必要な記号の Unicode コードポイントを、
 拡張文字列モード内でエスケープシーケンスとして指定する手もあります。
 以下参照: `encoding`, `unicode`, `locale`, `escape sequences`。

3 cairo (pdfcairo, pngcairo, epscairo, wxt 出力形式)
?fonts cairo
?fontconfig
?fonts fontconfig
=fonts
=pdf
=png
=wxt
 出力形式により (例えば cairo 系の出力形式すべて)、fontconfig システム
 ライブラリを使ってフォントにアクセスします。
^ <a href="http://fontconfig.org/fontconfig-user.html">
 fontconfig ユーザマニュアル
^ </a>
 を参照してください。これは、gnuplot で一般的な名前やサイズでフォントを
 要求することを可能にし、必要ならば fontconfig に同等のフォントを代用さ
 せることもできるので、通常はこれで十分でしょう。以下は、多分いずれも機
 能します:
      set term pdfcairo font "sans,12"
      set term pdfcairo font "Times,12"
      set term pdfcairo font "Times-New-Roman,12"

3 gd (png, gif, jpeg, sixel terminals)
?gd
?fonts gd
=fonts
=png
=jpeg
=gif
=sixel
 png, gif, jpeg, sixelgd 出力形式のフォント処理は、外部ライブラリ libgd
 が行います。これは、最低でも `tiny`, `small`, `medium`, `large`,
 `giant` の 5 種類の基本フォントを提供しますが、これは伸縮させたり回転
 したりはできません。これらの一つを使用する際は、`font` キーワードの代
 わりに上のキーワードを指定します。例:
      set term png tiny

 多くのシステムで、libgd は、fontconfig ツールが提供する一般的なフォン
 ト処理も使用できます。以下参照: `fontconfig`。
 fontconfig のないシステム上では、大抵 Adobe フォント (*.pfa) と
 TrueType フォント (*.ttf) へのアクセスを提供しています。その場合フォン
 ト自身の名前ではなく、フォントファイルの名前を、"<face> {,<size>}" の
 形式で与えなければいけません。
 ここで、<face> はフォントファイルのフルパス名か、または環境変数
 GDFONTPATH で指示されるディレクトリの一つの中のファイル名の先頭部分、
 のいずれかです。よって、'set term png font "Face"' は、
 <あるディレクトリ>/Face.ttf か <あるディレクトリ>/Face.pfa というファ
 イル名のフォントを探そうとします。例えば、GDFONTPATH に
 `/usr/local/fonts/ttf:/usr/local/fonts/pfa` が含まれている場合は、以下
 のコマンドの 2 つずつはいずれも同じことになります:
      set term png font "arial"
      set term png font "/usr/local/fonts/ttf/arial.ttf"
      set term png font "Helvetica"
      set term png font "/usr/local/fonts/pfa/Helvetica.pfa"
 デフォルトのフォントサイズも同時に指定するには:
      set term png font "arial,11"

 "set term" コマンドでフォントを指定しなかった場合、gnuplot は環境変数
 GNUPLOT_DEFAULT_GDFONT を参照します。
3 postscript (カプセル化 postscript *.eps も)
?fonts postscript
=fonts
=postscript
=eps
 PostScript フォント処理は、プリンタか表示ソフトが行います。もし、あな
 たのコンピュータにフォントが一切なくても、gnuplot は正しい PostScript
 ファイル、またはカプセル化 PostScript (*.eps) ファイルを生成できます。
 gnuplot は単に出力ファイル中にフォントを名前として入れるだけで、プリン
 タや表示ソフトがその名前からフォントを見つけるか近似することを仮定して
 います。

 PostScript プリンタや表示ソフトはすべて、標準的な Adobe フォントセット
 `Times-Roman`, `Helvetica`, `Courier`, `Symbol` は知っているはずです。
 多分その他にも多くのフォントが使えるようになっていると思いますが、それ
 ら特定のフォントセットはあなたのシステムやプリンタの設定に依存します。
 gnuplot は、それは知りませんし気にもしません。gnuplot が作成した *.ps
 や *.eps 出力は、あなたの要求したフォント名を単に持っているだけです。

 よって、
      set term postscript eps font "Times-Roman,12"
 は、すべてのプリンタや表示ソフトに適切な出力を作成します。

 一方、
      set term postscript eps font "Garamond-Premier-Pro-Italic"
 は、正しい PostScript 出力ファイルを作成しますが、それは特別な専用フォ
 ントを参照しているので、要求されたその特定のフォントは一部のプリンタや
 表示ソフトでしか表示できないでしょう。大抵の場合は別なフォントで代用さ
 れます。

 しかし、指定したフォントを出力ファイル中に埋め込んで、どんなプリンタで
 もそれを使うようにすることも可能です。これには、あなたのシステムに適切
 なフォント記述ファイルがあることが必要となります。この方法でフォントを
 埋め込む場合、特定のライセンスが必要となるフォントファイルもあることに
 注意してください。より詳細な説明や例については、以下参照:
 `postscript fontfile`。
2 ヘルプの用語解説 (Glossary)
?glossary
=terminal
=screen
=record
=block
 `gnuplot` は 30 年以上かけて開発されているので、コマンドやこの文書で使
 われている用語の意味は、現在の普通の用法とは違っているかもしれません。
 この節では、`gnuplot` 内ではそれらの用語のいくつかをどのように使ってい
 るかを説明します。

 用語 "出力形式 (terminal)" は、出力モードのことを意味し、あなたがキー
 ボード入力するもの (ターミナル) を指しているのではありません。例えば、
 コマンド `set terminal pdf` は、その後の描画コマンドが PDF 出力を生成
 することを意味します。通常は、その PDF 出力を書き出す場所を指定するコ
 マンド `set output "filename"` を一緒に使う必要があるでしょう。

 "ページ (page)"、"表示画面 (screen)"、"キャンバス (canvas)" は、
 `gnuplot` がアクセス可能な領域全体を指します。デスクトップではそれはウ
 ィンドウ全体を指し、プロッタでは、一枚の紙全体を指します。

 データファイルに関する議論では、用語 "行 (record)" は、ファイルの一行
 の文字列、すなわち、改行文字や行末文字同士に挟まれた文字列を指します。
 "点 (point)" は、一行から取り出した一つのデータです。データの
 "ブロック (block)" は、空行で区切られた連続した複数の行からなる集合で
 す。データファイルの議論の中で "line" が参照される場合は、これはブロッ
 クの部分集合を指します。"データのブロック (data block)" という言葉は、
 インラインデータの名前付きブロックを指すのにも使われています。以下参照:
 `datablocks`。

2 インラインデータとデータブロック (inline data and datablocks)
?inline data
?inline
?data inline
?datablocks
?data datablocks
 gnuplot のコマンド入力の中にデータを埋め込む仕組みは 2 種類用意されて
 います。まず、特殊ファイル名 '-' が plot コマンド中に与えると、その
 plot コマンド以下に続く行がインラインデータと解釈されます。以下参照:
 `special-filenames`。この方法で提供されるデータは、その plot コマンド
 で一度しか使用できません。

 もう一つは、ヒアドキュメントとして名前付きのデータブロックを定義する方
 法です。その名前付きのデータは残るので、複数の plot コマンドで参照でき
 ます。例:
      $Mydata << EOD
      11 22 33 first line of data
      44 55 66 second line of data
      # データファイル同様コメントも機能する
      77 88 99
      EOD
      stats $Mydata using 1:3
      plot $Mydata using 1:3 with points, $Mydata using 1:2 with impulses

 データブロック名は、他の変数と区別するために、最初の文字を $ にする必
 要があります。データの終わりの区切り (上の例では EOD) は、任意のアルフ
 ァベット、数字からなる文字列で構いません。

 データを名前付きブロックに保存するかわりに、実行可能コマンドを保存する
 同様の仕組みについては、以下参照: `function blocks`。

 コマンド `undefine` を使えば、保存した名前付きデータブロックを削除でき
 ます。`undefine $*` は、すべての名前付きデータブロック、関数ブロックを
 一度に削除します。
2 繰り返し (iteration)
?iteration
?iterate
Ffigure_newsyntax
 gnuplot は、繰り返し (iteration) コマンドやブロック構造を扱うための
 if/else/while/do をサポートしています。以下参照: `if`, `while`, `do`。
 コマンド `plot`, `set` で単純な繰り返しも可能です。以下参照:
 `plot for`。複数のコマンドを包含する一般的な繰り返しは、下で紹介するブ
 ロック構造を利用することで行えます。
 関連する新しい機能である数式型の以下も参照: `summation`。
 以下は、これらの新しい構文機能をいくつか利用した例です:
       set multiplot layout 2,2
       fourier(k, x) = sin(3./2*k)/k * 2./3*cos(k*x)
       do for [power = 0:3] {
           TERMS = 10**power
           set title sprintf("%g term Fourier series",TERMS)
           plot 0.5 + sum [k=1:TERMS] fourier(k,x) notitle
       }
       unset multiplot

=iteration-specifier
 繰り返しは、以下のような書式による繰り返し指定で制御します。

      for [<var> in "string of N elements"]

 または

      for [<var> = <start> : <end> { : <increment> }]

 最初の書式では <var> は文字列変数で、その後ろに指定した文字列に含まれ
 る 1 番目から N 番目までの単語文字列を順に値として取ります。
 2 番目の書式では、<start>, <end>, <increment> は整数、または整数値を取
 る数式です。

=scope
 繰り返し変数の有効範囲 (scope) は、その繰り返しの中だけです。以下参照:
 `scope`。繰り返し変数の値を、その実行ブロック内で永続的に変更すること
 はできません。繰り返し変数が繰り返しの前に値を持っていたとしたら、その
 値は繰り返しの終了時に保持、または復帰されます。
 例えば、以下のコマンドは、1 2 3 4 5 6 7 8 9 10 A を出力します。

      i = "A"
      do for [i=1:10] { print i; i=10; }
      print i

2 線種、色、スタイル (linetypes)
?linetypes
?colors
 古い版の gnuplot では、各出力形式は "線種 (linetype)" をある程度用意し
 ていて、それらは色、太さ、点線/破線のパターン、または色と点線/破線の組
 合せで違いを表現していました。それらの色、点線/破線のパターンは、出力
 形式を越えて同じものになるという保証は何もありませんでしたが、多くは同
 じ色の列、赤/緑/青/紫/水色/黄色を使用していました。この古い挙動は、今
 は `set colorsequence classic` で選択できますが、現在の gnuplot のデフ
 ォルトは、出力形式に無関係に共通の 8 色列を使用します。

 線種 (linetype) の属性の並びは、対話的か初期化ファイルのいずれかによっ
 てさらにカスタマイズ可能です。以下参照: `set linetype`。配布パッケージ
 に初期化ファイルのサンプルがいくつか用意されています。

 特定の出力形式に対する線種の属性の現在の状態は、その出力形式を設定した
 あとで `test` コマンドを実行することで確認できます。

 一つの描画コマンド内での関数やデータファイルの連続する並びには、現在の
 デフォルトの線種列から線種が順番に割り当てられます。個々の関数、データ
 ファイル、またはその他の描画要素に対する線種は、その描画コマンド上で明
 示的に線の属性を指定することで上書きできます。

 例:

      plot "foo", "bar"                 # 線種 1, 2 で 2 ファイルを描画
      plot sin(x) linetype 4            # 線種色 4 を使用

 一般に、色の指定は、色の名前か、RGB (赤、緑、青) 成分か、HSV (色相、彩
 度、明度) 成分か、現在の pm3d パレットに沿った座標で行います。キーワー
 ド `linecolor` は、`lc` と省略できます。

 例:

      plot sin(x) lc rgb "violet"       # gnuplot 内の色名の一つを使用
      plot sin(x) lc rgb "#FF00FF"      # 明示的な 16 進 RGB 3 つ組
      plot sin(x) lc palette cb -45     # 現在のパレットの cbrange の
                                        # -45 に対応する色
      plot sin(x) lc palette frac 0.3   # パレットに対応する小数値

 以下参照: `colorspec`, `show colornames`, `hsv`, `set palette`,
 `cbrange`。以下も参照: `monochrome`。

 線種 (linetype) には、点線/破線のパターンも結びつけられていますが、す
 べての出力形式でそれが使えるわけではありません。線色とは独立に点線/破
 線パターンを指定できます。以下参照: `dashtype`。

3 色指定 (colorspec)
?colorspec
=colors
?lc
?linecolor
?tc
?textcolor
=fillcolor
 多くのコマンドで、明示的な色の指定をともなった線種を指定することができ
 ます。

 書式:

       ... {linecolor | lc} {"colorname" | <colorspec> | <n>}
       ... {textcolor | tc} {<colorspec> | {linetype | lt} <n>}
       ... {fillcolor | fc} {<colorspec> | linetype <n> | linestyle <n>}

 <colorspec> は以下の形式のいずれかです:

       rgbcolor "colorname"    # 例: "blue"
       rgbcolor "0xRRGGBB"     # 16 進数値の定数文字列
       rgbcolor "0xAARRGGBB"   # 16 進数値の定数文字列
       rgbcolor "#RRGGBB"      # x11 形式の 16 進数文字列
       rgbcolor "#AARRGGBB"    # x11 形式の 16 進数文字列
       rgbcolor <integer val>  # AARRGGBB を表す整数値
       rgbcolor variable       # 入力ファイルから整数値を読み込む
       palette frac <val>      # <val> は 0 から 1 の値
       palette cb <value>      # <val> は cbrange の範囲の値
       palette z
       palette <colormap>      # 名前付きカラーマップを使用
       variable                # 入力ファイルから色番号を読み込む
       bgnd                    # 背景色
       black

 <n> は、その線種 (linetype) 番号が使う色を意味します。以下参照:
 `test`。

 "colorname" は gnuplot が内部に持っている色の名前のうちの一つを指定し
 ます。有効な名前の一覧に関しては、以下参照: `show colornames`。

 16 進定数は、引用符付きで "#RRGGBB" や "0xRRGGBB" の形で与えることがで
 きます。RRGGBB は、色の赤、緑、青の成分を意味し、それぞれ 00 から FF
 までの範囲内でなければいけません。例えば、マゼンタ (紫) は、最も明るい
 赤 + 最も明るい青、なので "0xFF00FF" と表され、これは 16 進数で
 (255 << 16) + (0 << 8) + (255) を意味しています。

 "#AARRGGBB" は、RGB 色の上位ビットにアルファ値 (透過性) がついているこ
 とを意味します。アルファ値 0 は完全に不透明色であることを意味し、よっ
 て "#00RRGGBB" は "#RRGGBB" と同じになります。アルファ値の 255 (FF) は
 完全に透明であることを意味します。

 これらの任意の形式から、色の 32 ビット整数表現への変換を行うのに利用で
 きる関数については、以下参照: `expressions functions rgbcolor`。

 カラーパレットとは、色の線型なグラデーションで、単一の数値を特定の色に
 滑らかに対応づけます。常にそのような 2 つの対応付けが効力を持ちます。
 `palette frac` は 0 から 1 までの小数値を、カラーパレットの全範囲に対
 応付けるもので、`palette cb` は、色軸の範囲を同じカラーパレットへ割り
 当てるものです。以下参照: `set cbrange`, `set colorbox`。これらの対応
 付けのどちらかを使って、現在のパレットから定数色を選び出すことができま
 す。

 "palette z" は、各描画線分や描画要素の z の値を、パレットへ対応づけら
 れている cbrange の範囲に対応づけます。これにより、3 次元の曲線や曲面
 に沿って色を滑らかに変化させることができます。これは、2 次元描画で、パ
 レット値を追加の列データから読み込ませて色付けするのにも使えます (すべ
 ての 2 次元描画スタイルがこの追加列を認識するわけではありません)。
=bgnd
=black
 特殊な色指定が 2 つあります。背景色の `bgnd` と、`black` です。
4 background color
?background
?bgnd
 多くの出力形式でグラフの背景色を明示的に設定できます。特別な線種
 (linetype) `bgnd` はその色で描画しますが、その `bgnd` は色としても認識
 されます。
 例:
      # 以下はキャンバスの一部分を背景色で上書きすることで消去します。
      set term wxt background rgb "gray75"
      set object 1 rectangle from x0,y0 to x1,y1 fillstyle solid fillcolor bgnd
      # y=0 に「見えない」線を描き、その下のものをすべて消します。
      plot 0 lt bgnd
4 linecolor variable
?linecolor variable
?lc variable
?textcolor variable
?tc variable
?variable linecolor
 `lc variable` は、入力データの一つの列から読んだ値を線種 (linetype) の
 番号として使い、その線種に属する色を使うようプログラムに指示します。よ
 ってこれは、`using` 指定子へ対応する列の指定の追加を必要とします。文字
 の色も同様に、`tc variable` で指定できます。

 例:
       # データの 3 列目を、個々の点に色を割り当てるのに使用
       plot 'data' using 1:2:3 with points lc variable

       # 一つのデータファイルには複数のデータ集合を入れることが可能で、
       # それらは 2 行の空行で分離されています。個々のデータ集合には
       # index 値が割り当てられていて (以下参照: `index`)、using 指定の
       # column(-2) で取得できます。以下参照: `pseudocolumns`。以下の例
       # は -2 の column 値を使って、個々のデータ集合を異なる線色で描画
       # します。
       plot 'data' using 1:2:(column(-2)) with lines lc variable

4 palette
?colorspec palette
 書式
       ... {lc|fc|tc} palette {z}
       ... {lc|fc|tc} palette frac <fraction>
       ... {lc|fc|tc} palette cb <fixed z-value>
       ... fc palette <colormap>

 パレットは、0 から 1 までの灰色値で、色の範囲を定義したものですが、
 `palette frac <fraction>` は、灰色値 <fraction> でその色を選択します。

 `palette cb <z>` は、灰色値が (z - cbmin) / (cbmax - cbmin) である色を
 選択します。

 `palette` と `palette z` はどちらも描画要素の z 座標を現在のパレットの
 色に写像します。z が cbrange の範囲外ならば、それはデフォルトでは
 palette fraction 0 か palette fraction 1 になります。オプション
 `set pm3d noclipcb` がセットされている場合、z 座標が範囲外にある pm3d
 グラフの 四辺形は何も描かれなくなります。

 `fillcolor palette <colormap>` は、描画要素の z 座標を、現在のパレット
 を使用するのではなく、事前に保存した名前付きカラーマップに写像します。
 以下参照: `set colormap`。

 カラーマップがそれ用の個別の範囲を持っている場合、cbrange を標準パレッ
 トに写像するのに使うのと同様に、z の値を写像するのにその範囲を使用しま
 す。

4 rgbcolor variable
?rgbcolor variable
?lc rgbcolor variable
?tc rgbcolor variable
?variable rgbcolor
?variable textcolor
 グラフの各データ点、各線分、または各ラベルにそれぞれ異なる色を割り当て
 ることができます。`lc rgbcolor variable` は、データファイルの各行から
 RGB 色の情報を読み込むようプログラムに指示します。よってこれは、
 `using` 指定子による対応する列の指定の追加を必要とし、その列は 24-bit
 形式の RGB の 3 つ組であるとみなされます。その値をデータファイルから直
 接与える場合は、これは最も簡単な形式の 16 進値で与えます (以下参照:
 `rgbcolor`)。一方で、以下の例のように 24-bit RGB 色として評価されるよ
 うな数式を `using` 指定子に入れることもできます。文字の色も同様に、
 `tc rgbcolor variable` で指定できます。

 例:
       # 3 次元描画で、各 x,y,z 座標に対応した赤、緑、青の成分を持つ色
       # のついた点を配置
       rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
       splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable

3 点線/破線種 (dashtype)
?dashtype
=dashtype
 `linecolor` や `linewidth` と同様に、点線/破線パターン (`dashtype`) が
 各曲線毎の属性として独立しました。従来のような、使用中の出力形式の点線
 を書くための特別なモードとして指定する必要はありません。すなわち、
 `set term <termname> {solid|dashed}` のようなコマンドは現在は無視され
 ます。バージョン 4 用に書いた古いスクリプトへの後方互換性が必要な場合
 は、以下のような書き方で代用できます:

      if (GPVAL_VERSION >= 5.0) set for [i=1:9] linetype i dashtype i
      if (GPVAL_VERSION < 5.0) set termoption dashed

 すべての線は、ほかに指定しなければ、`dashtype solid` という属性を持ち
 ますが、このデフォルト値をコマンド `set linetype` で特定の線種に変更し
 その後のコマンドで使えるようにできます。または、`plot` や他のコマンド
 の一部分として使用したい点線/破線の型を指定できます。

 書式:
       dashtype N          # 定義済み点線/破線型を番号で呼び出し
       dashtype "pattern"  # 点 (.) 横線 (-) 下線 (_) と空白の組み合わ
                           # せ文字列による指定
       dashtype (s1,e1,s2,e2,s3,e3,s4,e4)  # 1~4 個の <実線長>,<空白長>
                           # の組による点線/破線パターン指定

 例:
       # 2 つの関数が線種 1 を使うが dashtype で区別
       plot f1(x) with lines lt 1 dt solid, f2(x) with lines lt 1 dt 3

 いくつかの出力形式は、それが提供する定義済み点線/破線パターンに、ユー
 ザ定義パターンを追加することをサポートしています。

 例:
      plot f(x) dt 3            # 出力形式の持つパターン 3 を使用
      plot f(x) dt ".. "        # 一時的なパターンを作成
      plot f(x) dt (2,5,2,15)   # 同じパターンを数値で表現
      set dashtype 11 (2,4,4,7) # 新パターンを番号で呼び出せるよう定義
      plot f(x) dt 11           # 新パターンを使って描画

 点線/破線パターンを文字列で指定した場合、gnuplot はそれを <実線長>,
 <空白長> の組の列に変換します。ドット "." は (2,5) に、ダッシュ "-" は
 (10,10) に、下線 "_" は (20,10) に、また空白 " " は直前の <空白長> の
 値に 10 を追加します。その場合、コマンド `show dashtype` は、元の文字
 列と変換後の数値の列の両方を表示します。

3 linestyles と linetypes
?linestyles vs linetypes
 `linestyle` は、属性 linecolor, linewidth, dashtype, pointtype の一時
 的な組み合わせで、これはコマンド `set style line` で定義します。一度
 linestyle を定義すると、1 回の plot コマンド上でそれを使って、1 つ、ま
 たはより多くの描画要素の見た目を制御できます。言い換えれば、これは丁度
 linetype から永続性を取り除いたもの、と言うことができるでしょう。
 `linetypes` は永続的 (明示的にそれらを再定義するまでは保持される) です
 が、`linestyles` は、次のグラフィックの状態がリセットされるまでの間し
 か保持されません。

 例:

      # 新しいラインスタイルを、出力形式に依存しない色 cyan、線幅が 3、
      # 点種 6 (丸の中に点) と定義
      set style line 5 lt rgb "cyan" lw 3 pt 6
      plot sin(x) with linespoints ls 5          # 定義スタイル 5 で

3 特別な線種 (special linetypes)
?linetypes special linetypes
?special_linetypes
?nodraw
=bgnd
=background
=black
 特別な (数値ではない) 線種 (linetype) がいくつか用意されています。

 `lt black` は、黒い実線を意味します。

 `lt bgnd` は、現在の出力形式の背景色の実線を意味します。以下参照:
 `background`。

 `lt nodraw` は、その曲線全体の描画をスキップします。これは、描画スタイ
 ル `linespoints` と組み合わせて使うと便利です。すなわち、この描画スタ
 イルのみに有効な点部分の属性を残しつつ、線部分を抑制することが可能にな
 ります。例えば、
      plot f(x) with linespoints lt nodraw pointinterval -3
 は、3 点置きに描画し、その下に背景色の小さな円を置くことで孤立させます。
 以下参照: `linespoints`。`lt nodraw` は、自動的に描かれる線分の特別な
 集合を抑制するのにも使えます。例えば、等高線描画の中のあるレベルの等高
 線を、その線種に `nodraw` を設定することで、その描画を抑制できます。

2 レイヤー (layers)
?layers
?behind
?front
?back
 gnuplot のグラフは、色々な要素を固定された順番で描き上げていくことで構
 成されています。この順番は、キーワード `behind`, `back`, `front` を使
 って要素に特定の階層を割り当てることで変更できます。例えば、グラフ領域
 の背景色を変更するには、色のついた長方形を属性 `behind` で定義すればい
 いわけです。
      set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb "gray" behind
 描画の順番は以下の通りです:
      behind
      back
      グラフ自体
      グラフの表題 (`key`)
      front
 各階層内では、要素の描画は以下の順番です:
      格子線、軸、境界要素 (grid, axis, border elements)
      番号順のピクスマップ画像 (pixmaps)
      番号順のオブジェクト (rectangle, circle, ellipse, polygon)
      番号順のラベル (label)
      番号順の矢印 (arrow)
 1 ページに複数のグラフがある場合 (multiplot モード)、この順序は、複数
 グラフを全体として適用するのではなく、各描画要素に別々に適用します。

 これに対する例外は、TeX 系の出力形式 (例えば pslatex や cairolatex 等)
 で、これらは一つの出力にすべての文字列要素を積み重ね、グラフ要素は別な
 出力に積み重ねます。一般にこの場合、各文字列要素は全部がグラフの前に出
 てしまうか、逆に全部がグラフの裏に置かれてしまうかのどちらかになります。

2 マウス入力 (mouse input)
?mouse input
 多くの出力形式で、現在の描画にマウスを使って作用をすることが可能になっ
 ています。そのうちいくつかはホットキーの定義もサポートしていて、マウス
 カーソルが有効な描画ウィンドウにあるときに、あるキーを押すことであらか
 じめ定義した関数を実行させることができます。マウス入力を `batch` コマ
 ンドスクリプトと組み合わせることも可能で、例えば `pause mouse` として、
 その後にマウスクリックによってパラメータとして返って来るマウス変数をそ
 の後のスクリプト動作に反映させることができます。以下参照: `bind`,
 `mouse variables`。また以下も参照: `set mouse`。
3 bind
?commands bind
?hotkey
?hotkeys
?bind
 書式:
       bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
       bind <key-sequence> ""
       reset bind

 `bind` は、ホットキーの定義、再定義に使用します。ホットキーとは、入力
 カーソルがドライバのウィンドウ内にあるときに、あるキー、または複数のキ
 ーを押すことで、gnuplot のコマンド列を実行させる機能のことを言います。
 `bind` は、gnuplot が `mouse` をサポートするようにコンパイルされていて
 かつマウスが有効な出力形式上で使われてる場合にのみ有効であることに注意
 してください。ユーザ指定のキー割当 (binding) は、組み込み (builtin) キ
 ー割当を置き換えますが、<space> と 'q' は通常は再定義はできません。そ
 の唯一の例外については、以下参照: `bind space`。

 マウスボタン割り当ては、2 次元描画でのみ有効です。

 ホットキーの一覧を得るには `show bind`, または `bind` とタイプするか、
 グラフウィンドウ上でホットキー 'h' を入力してください。

 キー定義は、`reset bind` でデフォルトの状態に復帰できます。

 修飾キーを含む複数のキーの定義は引用符で囲む必要があることに注意してく
 ださい。

 標準ではホットキーは現在の描画ウィンドウ上に入力カーソルがある場合のみ
 認識されます。`bind allwindows <key> ...` (`bind all <key> ...` と省略
 可) は、<key> の割当を、それが現在の有効なものか否かに関わらず、すべて
 の gnuplot の描画ウィンドウ上で可能にします。この場合、gnuplot 変数
 MOUSE_KEY_WINDOW にそれが行なわれたウィンドウの ID が保存されるのでそ
 れをキーに割り当てたコマンドで使用することができます。

 例:

 - キー割当の設定:

     bind a "replot"
     bind "ctrl-a" "plot x*x"
     bind "ctrl-alt-a" 'print "great"'
     bind Home "set view 60,30; replot"
     bind all Home 'print "This is window ",MOUSE_KEY_WINDOW'

 - キー割当を表示:
     bind "ctrl-a"          # ctrl-a に対するキー割当を表示
     bind                   # 全てのキー定義を表示
     show bind              # 全てのキー定義を表示

 - キー割当を削除:
     bind "ctrl-alt-a" ""   # ctrl-alt-a のキー割当を削除
                              (組み込みキー定義は削除されません)
     reset bind             # デフォルト (組み込み) のキー定義を導入

 - トグルスイッチ形式にキー割当:
   v=0
   bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term x11 raise"

 修飾キー (ctrl / alt) は大文字小文字の区別はありませんが、キーはそうで
 はありません:
     ctrl-alt-a == CtRl-alT-a
     ctrl-alt-a != ctrl-alt-A

 修飾キー (alt == meta) の一覧:
     ctrl, alt, shift (ボタン 1, ボタン 2, ボタン 3 でのみ有効)

 サポートされている特殊キーの一覧:

    "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
    "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
    "PageUp", "PageDown", "End", "Begin",

    "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
    "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
    "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
    "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
    "KP_Divide",

    "KP_1" - "KP_9", "F1" - "F12"

 以下は、実際のキーではなく、ウィンドウに関するイベントです:

    "Button1" "Button2" "Button3" "Close"

 以下も参照: `mouse`。
4 bind space
?commands bind space
?bind space
 gnuplot が、configure 時にオプション --enable-rase-console をつけてイ
 ンストールされた場合は、描画ウィンドウ内で <space> をタイプすると
 gnuplot のコマンドウィンドウが前面に出ます。多分。実際には、これは強く
 システムに依存します。このホットキーは、'gnuplot -ctrlq' のようにして
 gnuplot を起動するか、または X リソースの 'gnuplot*ctrlq' を設定するこ
 とで ctrl-space に変更できます。
3 マウス用の変数 (Mouse variables)
?mouse variables
 `mousing` (マウス機能) が有効な場合、現在のウィンドウ上でのマウスクリ
 ックによって gnuplot のコマンドライン上で使うことができる色々なユーザ
 変数が設定されます。クリック時のマウスの座標は変数 MOUSE_X, MOUSE_Y,
 MOUSE_X2, MOUSE_Y2 に代入されます。クリックされたボタンや、そのときの
 メタキーの状態は MOUSE_BUTTON, MOUSE_SHIFT, MOUSE_ALT, MOUSE_CTRL に代
 入されます。これらの変数は任意の描画の開始時には未定義で、有効な描画ウ
 ィンドウ中でのマウスクリックイベントによって初めて定義されます。有効な
 描画ウィンドウ中でマウスが既にクリックされたかどうかをスクリプトから調
 べるには、これらの変数のうちのどれか一つが定義されているかどうかをチェ
 ックすれば十分です。

       plot 'something'
       pause mouse
       if (exists("MOUSE_BUTTON")) call 'something_else'; \
       else print "No mouse click."

 描画ウィンドウ上での一連のキー入力を追跡することも、マウスコードを使う
 ことで可能となります。

       plot 'something'
       pause mouse keypress
       print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y

 `pause mouse keypress` が、キー入力で終了した場合は MOUSE_KEY には押さ
 れたキーの ASCII コードが保存されます。MOUSE_CHAR にはその文字自身が文
 字列値として保存されます。pause コマンドが (例えば ctrl-C や描画ウィン
 ドウが外部から閉じられるなどして) 異常終了した場合は MOUSE_KEY は -1
 になります。

 マウスによる拡大の後の新しい描画範囲は、GPVAL_X_MIN, GPVAL_X_MAX,
 GPVAL_Y_MIN, GPVAL_Y_MAX で参照できることに注意してください。
 以下参照: `gnuplot-defined variables`。
2 残留 (Persist)
?persist
 gnuplot の多くの出力形式 (aqua, pm, qt, x11, windows, wxt, ...) が、ス
 クリーン上にグラフをその中に描いた表示用のウィンドウを別に開きます。オ
 プション `persist` は、主たるプログラムが終了したときにも、それらのウ
 ィンドウを残すよう gnuplot に指示します。
 これは、非対話型出力形式出力では何もしません。
 例えば、以下のコマンドを実行すると

      gnuplot -persist -e 'plot sinh(x)'

 gnuplot は、表示ウィンドウを開き、その中にグラフを描き、そして終了し、
 表示ウィンドウはグラフをその中に持ったままスクリーンに残ります。
 新しい出力形式を設定するときに `persist` や `nopersist` を指定すること
 もできます。

      set term qt persist size 700,500

 出力形式によっては、その残ったウィンドウ上でも多少のマウス操作が可能な
 場合もあります。しかし、グラフの再描画を要求するズーム (とその逆) のよ
 うな操作は、既にプログラムが終了しているので無理です。描画ウィンドウを
 開いたまま残し、その後のマウス機能も完全に可能にするには、例えば
 gnuplot を対話型ではなく、スクリプトファイルから実行させる方法がありま
 す。以下参照: `pause mouse close`。

2 描画 (Plotting)
?plotting
 `gnuplot` にはグラフを描画する 4 つのコマンド `plot`, `splot`, `replot`,
 `refresh` があります。他のコマンドは、最終的にグラフ上に生成される描画
 要素や、レイアウト、スタイルの制御を行います。
 `plot` は 2 次元グラフを生成します。`splot` は 3 次元グラフ (もちろん
 実際にはその 2 次元面への射影) を生成します。`replot` は、直前の `plot`
 や `splot` コマンドを再実行します。`refresh` は、`replot` と似ています
 が、入力データをファイルや入力ストリームから再読み込みする代わりに、前
 に保存したデータを再使用します。

=multiplot
=inset
=subfigures
 これら 4 つのコマンドのうちの一つを実行した場合は、現在定義されている
 軸、ラベル、タイトル、および元の plot コマンドで指定されたさまざまな関
 数やデータのすべてを含む出力のスクリーンを再描画するか、新しい出力ペー
 ジを生成します。もし、一つのページに複数のグラフを隣り合うように並べて
 出力したい場合、例えば複数の図のパネルを作成したり、大きなグラフの中に
 小さなグラフを挿入したりしたい場合は、コマンド `set multiplot` を使用
 し、各描画コマンドで新しいページが作られるのを抑制してください。

 描画に関する一般的な情報の大半は、`plot` に関する項で見つかります。3
 次元描画に固有の情報は `splot` の項にあります。

 `plot` は xy 直交座標系と極座標系が使えます。以下参照: `set polar`。
 `splot` は xyz 直交座標が使えますが、3 次元極座標、円柱座標データも入
 力できます。以下参照: `set mapping`。
=axes
 `plot` では、4 つの境界 x (下), x2 (上), y (左), y2 (右) をそれぞれ独
 立な軸として扱うこともできます。オプション `axes` で、与えられた関数や
 データ集合をどの軸のペアで表示させるかを選べます。また、各軸の縮尺や見
 出しづけを完全に制御するために十分な補佐となる `set` コマンド群が存在
 します。いくつかのコマンドは、`set xlabel` のように軸の名前をその中に
 持っていますし、それ以外のものは `set logscale xy` のように、1 つ、ま
 たは複数の軸の名前をオプションとしてとります。z 軸を制御するオプション
 やコマンドは 2 次元グラフには効力を持ちません。

 `splot` は、点や線に加えて曲面や等高線を書くことができます。3 次元の関
 数の格子定義に関する情報については、以下参照: `set isosamples`。3 次元
 データのファイルに必要な形態については、以下参照: `splot datafile`。等
 高線に関する情報については、以下参照: `set contour`, `set cntrlabel`,
 `set cntrparam`。

 `splot` での縮尺や見出し付けの制御は、z 軸にも有効であること、および
 x2 軸、y2 軸のラベル付けが `set view map` を使って作られる疑似的な 2
 次元描画にのみ可能であることを除けば `plot` と全く同じです。
2 プラグイン (Plugins)
?plugins
 グラフや数式に利用できる関数群は、共有ライブラリから実行可能な関数を取
 り込むプラグインの仕組みにより拡張できます。例えば、gnuplot のバージョ
 ン 5.4 では、上方不完全ガンマ関数 Q(a,x) は組み込み関数としては実装し
 ていません。
#TeX \\ $Q(a,x)=\frac{1}{\Gamma(x)}\intop_{x}^{\infty}t^{a-1}e^{-t}dt$ .\quad\quad
 これは、gnuplot 内で直接以下のようにして近似的に定義できます。
       Q(a,x) = 1. - igamma(a,x)
 しかし、これは、1 の近くの igamma(a,x) の値の精度に実質的な限界があり
 ます。より正確な値を返す実装が欲しい場合、プラグインを通して用意するの
 がいいでしょう (下を参照)。一度取り込めば、関数は、gnuplot 内の他の組
 み込み関数、ユーザ定義関数と全く同様に利用できます。
 以下参照: `import`。

 gnuplot の配布物のディレクトリ demo/plugin には、プラグインライブラリ
 を生成するための説明とソースコードがあります。簡単なサンプルファイル
 `demo_plugin.c` の関数を、あなたの興味ある関数の実装に置き換えて修正し
 てください。
 これには、外部の数学ライブラリの関数の呼び出しも含まれています。

 ディレクトリ demo/plugin には、Q(a,x) を実装するプラグインのソースも
 あります。上で注意したように、このプラグインは、gnuplot バージョン 6
 に含まれる `uigamma` と同じ関数を、以前のバージョンに実装することを可
 能にします。
      import Q(a,x) from "uigamma_plugin"
      uigamma(a,x) = ((x<1 || x<a) ? 1.0-igamma(a,x) : Q(a,x))

C 変数の有効範囲 (スコープ) (Scope of variables)
2 Scope of variables
?scope
?variables local
=local
=global
 gnuplot の変数は、以下に示す特別な場合を除いては大域的 (global) です。
 有効な変数に対しては、その名前で区別された、永続的な一覧表があります。
 変数の割り当てとは、その一覧表に項目を一つ作るか、置き換えることを意味
 します。その一覧表から変数を削除する唯一の方法は、コマンド `undefine`
 を使用することです。

 例外 1: 繰り返し指定の中で使用される変数の有効範囲 (スコープ) は、その
 繰り返しの中だけです。繰り返し変数の値を、その実行ブロック内で永続的に
 変更することはできません。繰り返し変数が繰り返しの前に値を持っていたと
 したら、その値は繰り返しの終了時に保持、または復帰されます。
 例えば、以下のコマンドは、1 2 3 4 5 6 7 8 9 10 A を出力します。

      i = "A"
      do for [i=1:10] { print i; i=10; }
      print i

 例外 2: 関数定義で使用されるパラメータの名前は、その関数を呼び出すとき
 に与える実際の値の置き場所に過ぎません。例えば、以下の例では、x と y
 の現在、あるいは未来の値はここで示される定義には関係しないが、A はこの
 関数が後で評価されるときには大域変数として存在しなければいけません:

      func(x,y) = A + (x+y)/2.

 例外 3: コマンド `local` で宣言された変数。
 `local` 指定 (バージョン 6 での新機能) は、変数、または配列のオプショ
 ン的な宣言を可能にし、それによりそれが見つかるコードブロック内部にその
 有効範囲を制限するものです。このコードブロックとは、`load` や `call`
 の対象、関数ブロックの評価、そして条件 `if`, `else`, `do for`, `while`
 の後に続く中括弧内のコードです。
 局所 (local) 変数の名前が大域 (global) 変数と重なった場合、その局所変
 数の有効範囲から抜けるまでは、大域変数は隠されます。

2 初期化 (Startup (initialization))
?startup
?start
?start-up
?initialization
?.gnuplot
?gnuplotrc
 起動時に、gnuplot はまずシステム用の初期設定ファイル `gnuplotrc` を探
 します。そのファイルの置き場所は gnuplot のインストール時に決定され、
 `show loadpath` で知ることができます。次にユーザのホームディレクトリ内
 に個人用の設定ファイルを探します。そのファイルは Unix 系のシステムでは
 `.gnuplot` であり、その他の処理系では `GNUPLOT.INI` となっています。
 (OS/2 では、環境変数 `GNUPLOT` に設定されている名前のディレクトリ内に
 それを探します; Windows では、`APPDATA` を使用します)。Unix 系のシステ
 ムでは、追加で gnuplot は $XDG_CONFIG_HOME/gnuplot/gnuplotrc もチェッ
 クします。
2 文字列定数、文字列変数、文字列関数 (Strings)
?string
?strings
 文字列定数に加えて、ほとんどの gnuplot コマンドは文字列変数、文字列式
 または文字列を返す関数も受け付けます。例えば、以下の 4 つの plot のや
 り方は結果として全て同じ描画タイトルを生成します:

       four = "4"
       graph4 = "Title for plot #4"
       graph(n) = sprintf("Title for plot #%d",n)

       plot 'data.4' title "Title for plot #4"
       plot 'data.4' title graph4
       plot 'data.4' title "Title for plot #".four
       plot 'data.4' title graph(4)

 整数は、それが文字列結合演算子 (文字 '.') によって作用された場合は、文
 字列に変換されますので、以下の例も上と同様に動作します:

       N = 4
       plot 'data.'.N title "Title for plot #".N

 一般に、コマンドラインの各要素は、それらが標準的な gnuplot への命令文
 法の一部分と認識されるもの以外は、有効な文字列変数としての評価のみが行
 なわれます。よって、以下のコマンド列は、恐らくは混乱を引き起こさないよ
 うに避けられるべきですが、文法的には間違ってはいません:

       plot = "my_datafile.dat"
       title = "My Title"
       plot plot title title
3 部分文字列 (substrings)
?string substring
?substrings
 任意の文字列、文字列変数、文字列値関数に、範囲指定子をつけることにより
 部分文字列を指定できます。範囲指定子は [begin:end] の形で、begin は部
 分文字列の先頭位置、end は最後の位置です。位置指定は、最初の文字を 1
 番目と見ます。先頭の位置、最後の位置は空、あるいは '*' でも構いません。
 その場合、それは元の文字列自体の先頭、あるいは最後を意味します。よって
 str[:] や str[*:*] はどちらも str の文字列全体を意味します。
 例:
      eos = strlen(file)
      if (file[eos-3:*] eq ".dat") {
          set output file[1:eos-4] . ".png"
          plot file
      }

 同等の関数 `substr( string, begin, end )` もあります。
3 文字列演算子 (string operators)
?string operators
 次の 3 つの二項演算子は文字列に作用します: 文字列の結合演算子 ".", 文
 字列の等号演算子 "eq", および文字列の不等号演算子 "ne" です。以下の例
 では TRUE が表示されます。

      if ("A"."B" eq "AB") print "TRUE"
3 文字列関数 (string functions)
?string functions
 gnuplot は、文字列に作用する組み込み関数をいくつか持っています。
 汎用的な書式関数: 以下参照: `gprintf`, `sprintf`。
 時刻書式関数: 以下参照: `strftime`, `strptime`。
 文字列操作: 以下参照: `split`, `substr`, `strstrt`, `trim`, `word`,
 `words`。
3 文字列エンコード (string encoding)
?string encoding
=utf8
 gnuplot の組み込み文字列操作関数は、UTF-8 エンコードを認識します (以下
 参照: `set encoding`)。例:

  set encoding utf8
  utf8string = "αβγ"
  strlen(utf8string) は 3 を返す (文字数であって、バイト数ではない)
  utf8string[2:2] は "β" となる
  strstrt(utf8string,"β") は 2 となる
 (訳注: いずれも UTF-8 エンドードで与えた場合)

2 置換とコマンドラインマクロ (Substitution)
?substitution
 gnuplot への命令文字列が最初に読み込まれた時点、すなわちまだそれが解釈
 され、もしくは実行される前の段階で、2 つの形式の単語の置換が実行されま
 す。それらは逆引用符 (｀) (ASCII 番号 96) で囲まれているか、または @
 (ASCII 番号 64) が頭についた文字列に対して行なわれます。
3 逆引用符によるシステムコマンドの置換 (Substitution backquotes)
?substitution backquotes
?backquotes
?shell commands
 シェルコマンドを逆引用符 (｀) で囲むことによってコマンド置換を行うこと
 ができます。このコマンドは子プロセスで実行され、その出力結果でコマンド
 ラインの逆引用符で囲まれた部分を置き換えます。システムコマンドの終了ス
 テータスは、変数 GPVAL_SYSTEM_ERRNO と GPVAL_SYSTEM_ERRMSG に返されま
 す。

 注意:  内部の復帰 ('\r') と改行 ('\n') 文字は、置換後の文字入力から取
 り除きません。

 コマンド置換は、単一引用符内の文字列以外は、`gnuplot` のコマンドライ
 ン中、どこででも使用可能です。

 例えば、以下は現在の日付とユーザー名のラベルを生成します:
       set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
       set timestamp "generated on %Y-%m-%d by `whoami`"

 以下は、カレントディレクトリ内のファイル名からなる配列を生成します:
       FILES = split( "`ls -1`" )
3 文字列変数のマクロ置換 (Substitution macros)
?substitution macros
?macros
=exists
 文字 @ は、コマンドライン上でその文字列変数の値への置換を行なうのに使
 われます。文字列変数の値としての文は、複数の単語からなることも可能です。
 これにより文字列変数をコマンドラインマクロとして使うことが可能になりま
 す。この機能により展開できるのは文字列定数のみで、文字列を値に取る数式
 を使うことはできません。
 例:

       style1 = "lines lt 4 lw 2"
       style2 = "points lt 3 pt 5 ps 2"
       range1 = "using 1:3"
       range2 = "using 1:5"
       plot "foo" @range1 with @style1, "bar" @range2 with @style2

 この @ 記号を含む行は、その入力時に展開され、それが実際に実行されると
 きには次のように全部打ち込んだ場合と同じことになります。

       plot "foo" using 1:3 with lines lt 4 lw 2, \
            "bar" using 1:5 with points lt 3 pt 5 ps 2

 関数 exists() はマクロの評価に関して有用でしょう。以下の例は、C が安全
 にユーザ定義変数の名前に展開できるかどうかをチェックします。

       C = "pi"
       if (exists(C)) print C," = ", @C

 マクロの展開は、単一引用符内、または二重引用符内では行なわれませんが、
 逆引用符 (｀) 内ではマクロ展開されます。

 マクロの展開は、gnuplot が新しいコマンド行を見たときに非常に早い段階で
 gnuplot が処理し、そしてただ一度だけそれを行います。よって、

      A = "c=1"
      @A

 のようなコードは正しく実行しますが、以下のような行はだめです。それは、
 マクロの定義が同じ行にあるため展開に間に合わないからです。

      A = "c=1"; @A   # will not expand to c=1

 繰り返し用の中括弧内でのマクロの展開は、そのループが実行される前に行い
 ます。すなわち、ループ内では A 自体を再定義しても、@A は常に A の元の
 値に展開されます。

 コマンドを完成させて実行するには、コマンド `evaluate` も有用でしょう。
3 文字列変数、マクロ、コマンドライン置換 (mixing_macros_backquotes)
?mixing_macros_backquotes
?substitution mixing_macros_backquotes
 文字列変数や逆引用符 (｀) による置換、マクロによる置換の相互関係は少し
 ややこしいです。逆引用符はマクロ置換を妨げないので、

       filename = "mydata.inp"
       lines = ` wc --lines @filename | sed "s/ .*//" `

 は、mydata.ipn の行数を整数変数 lines に保存することになります。また、
 二重引用符は逆引用符の置換を妨げないので、

       mycomputer = "`uname -n`"

 は、システムコマンド `uname -n` の返す文字列を文字列変数 mycomputer に
 保存することになります。

 しかし、マクロ置換は二重引用符内では機能しないので、システムコマンドを
 マクロとして定義してそれをマクロとして利用しかつ逆引用符置換を行なうこ
 とはでできません。

        machine_id = "uname -n"
        mycomputer = "`@machine_id`"  # うまくいかない !

 この失敗は、二重引用符が @machine_id をマクロとして解釈することを妨げ
 ているからです。システムコマンドをマクロとして保存し、その後それを実行
 するには、逆引用符自体もマクロ内に含める必要があります。これは以下のよ
 うにマクロを定義することで実現できます。sprintf の書式には 3 種類の引
 用符全てが入れ子になっていることに注意してください。

       machine_id = sprintf('"`uname -n`"')
       mycomputer = @machine_id
2 区切りやカッコの使い方 (Syntax)
?syntax
?specify
?punctuation
 リストや座標がコンマ (,) 区切りであるのに対し、オプションやそれに伴う
 パラメータはスペース ( ) 区切りです。範囲はコロン (:) で区切ってかぎか
 っこ ([]) でくくりますし、文字列やファイル名は引用符でくくり、他にいく
 つかカッコ (()) でくくるものがあります。

 コンマは以下の区切りで使用されます。`set` コマンドの `arrow`, `key`,
 `label` の座標; 当てはめ (fit) られる変数のリスト (コマンド `fit` のキ
 ーワード `via` に続くリスト); コマンド `set cntrparam` で指定されると
 びとびの等高線の値やそのループパラメータのリスト; `set` コマンドの
 `dgrid3d` `dummy`, `isosamples`, `offsets`, `origin`, `samples`,
 `size`, `time`, `view` の引数; 目盛りの位置やそのループパラメータのリ
 スト; タイトルや軸の見出しの位置; `plot`, `replot`, `splot` コマンドの
 x,y,z 座標の計算に使われる媒介変数関数のリスト; `plot`, `replot`,
 `splot` コマンドの複数の描画 (データ、または関数) のそれぞれの一連のキ
 ーワードのリスト。

 (丸) カッコは、目盛りの見出しを (ループパラメータではなく) 明示的に集
 合与える場合の区切りとして、または `fit`, `plot`, `replot`, `splot` コ
 マンドの `using` 指定での計算を指示するために使われます。

 (カッコやコンマは通常の関数の表記でも使われます。)

 かぎかっこは、`set`, `plot`, `splot` コマンドでは範囲を区切るのに使わ
 れます。

 コロンは `range` (範囲) 指定 (`set`, `plot`, `splot` コマンドで使われ
 る) の両端の値を区切るのに、または `plot`, `replot`, `splot`, `fit` コ
 マンドの `using` 指定の各エントリを区切るのに使われます。

 セミコロン (;) は、一行のコマンド行内で与えられる複数のコマンドを区切
 るのに使われます。

 中カッコ ({}) は、拡張文字列処理モード (enhanced text mode) の記述や、
 if/then/else 文のブロックの区切りとして使われますし、または複素数を記
 述するのにも使われます: {3,2} = 3 + 2i となります。
3 引用符 (quote marks)
?quotes
?syntax quotes
 gnuplot は、文字列を区切るのに、二重引用符 (ASCII コード 34 番)、単一
 引用符 (ASCII コード 39 番)、および逆引用符 (｀) (ASCII コード 96 番)
 の 3 種類の引用符を使います。

 ファイル名は単一引用符、あるいは二重引用符内で囲みます。このマニュアル
 では一般にコマンドの例示では、わかりやすくするためにファイル名は単一引
 用符でくくり、他の文字列は二重引用符でくくります。

 見出し (label)、タイトル (title)、またはその他の描画要素で使用される文
 字列定数や複数行文字列は単一引用符、あるいは二重引用符内で囲みます。引
 用符で囲まれた文字列のさらなる処理の結果は、どの引用符記号を選ぶかによ
 って変わります。

 \n (改行) や \345 (8 進表記の文字コード) のようなバックスラッシュ (\)
 による特殊文字表現は、2 重引用符内の文字列でのみ効力を持ちます。単一引
 用符内では、バックスラッシュ自体が通常の文字と見なされます。単一引用符
 内の文字列で単一引用符自体 (ASCII コード 39 番) を使うには、それを重ね
 て書く必要があります。つまり、文字列 "d\" s' b\\" と、'd" s'' b\' は完
 全に同じものとなります。

 1 つの複数行文字列に関する行揃えは各行に同等に働きます。よって、中央に
 行揃えされた文字列
       "This is the first line of text.\nThis is the second line."
 は次のように表示されます:
                        This is the first line of text.
                           This is the second line.
 しかし
       'This is the first line of text.\nThis is the second line.'
 だと次のようになります。
           This is the first line of text.\nThis is the second line.

 拡張文字列処理 (enhanced text processing) は二重引用符に対しても単一引
 用符に対しても機能します。しかし、そのモードをサポートしている出力形式
 でのみ働きます。以下参照: `enhanced text`。

 逆引用符は,コマンドライン中の置換のためにシステムコマンドを囲むのに使
 います。以下参照: `substitution`。
2 時間/日付データ (Time/Date)
?time/date
 `gnuplot` は入力データとして時間/日付情報の使用をサポートしています。
 この機能は `set xdata time`, `set ydata time` などのコマンドによって有
 効になります。

 内部では全ての時間/日付は 1970 年からの秒数に変換されます。コマンド
 `set timefmt` は全ての入力に対するデフォルトの書式を定義します。データ
 ファイル、範囲、軸の目盛りの見出し、ラベルの位置と、日時データ値を受け
 入れるすべてのものへの入力の書式が、デフォルトでこれになります。一時に
 は一つのデフォルト入力書式のみが有効です。よって、ファイル内の x と y
 の両方が時間/日付データである場合は、デフォルトではそれは同じ書式と解
 釈されます。しかし、このデフォルトは、`using` 指定で関数 `timecolumn`
 を用いて、それに対応する特定のファイルや列からデータを読みこむことによ
 り、変えることが可能です。

 秒数へ (秒数から) の変換は国際標準時 (UT; グリニッジ標準時 (GMT) と同
 じ) が使われます。各国標準時や夏時間への変換の機能は何も持ち合わせてい
 ません。もしデータがすべて同じ標準時間帯に従っているなら (そして全てが
 夏時間か、そうでないかのどちらか一方にのみ従うなら) これに関して何も心
 配することはありません。しかし、あなたが使用するアプリケーションで絶対
 的な時刻を厳密に考察しなければいけない場合は、あなた自身が UT に変換す
 べきでしょう。

 `show xrange` のようなコマンドは、その整数値を `timefmt` に従って解釈
 し直します。`timefmt` を変更してもう一度 `show` でその値を表示させると、
 それは新しい `timefmt` に従って表示されます。このため、(`set xdata` な
 どにより) その軸に対するデータ型をリセットすると、その値は整数値として
 表示されることになります。

 コマンド `set format` または `set tics format` は、指定された軸に対す
 る入力が時間/日付であるなしに関わらず目盛りの見出しに使われる書式を定
 義します。

 時間/日付情報がファイルから描画される場合、`plot`, `splot` コマンドで
 は `using` オプションを「必ず」使う必要があります。`plot`, `splot` で
 は各行のデータ列の分離にスペースを使いますが、時間/日付データはその中
 にスペースを含み得るからです。もしタブ区切りを使用しているのなら、あな
 たのシステムがそれをどう扱うか確かめるために何度もテストする必要がある
 でしょう。

 関数 `time` は、現在のシステム時刻を得るのに使えます。この値は、
 `strftime` 関数で日時文字列に変換できますし、`timecolumn` と組み合わせ
 て相対的な日時グラフを作成するのにも使えます。引数の型はそれが返すもの
 を決定します。引数が整数の場合は time() は現在の時刻を 1970 年 1 月 1
 日からの整数として返し、引数が実数 (または複素数) ならば同様の値を実数
 として返しますが、小数 (秒以下) 部分の精度は、オペレーティングシステム
 に依存します。引数が文字列ならば、それを書式文字列であるとみなし、書式
 化された日時文字列を提供するようそれを `strftime` に渡します。

 次の例は時間/日付データの描画の例です。

 ファイル "data" は以下のような行からなるとします:

       03/21/95 10:00  6.02e23

 このファイルは以下のようにして表示されます:

       set xdata time
       set timefmt "%m/%d/%y"
       set xrange ["03/21/95":"03/22/95"]
       set format x "%m/%d"
       set timefmt "%m/%d/%y %H:%M"
       plot "data" using 1:3

 ここで、x 軸の目盛りの見出しは "03/21" のように表示されます。

 現在の gnuplot は、時刻をミリ秒精度で追跡し、時刻のフォーマットもそれ
 に伴って変更されています。
 例: 現在の時刻をミリ秒精度で表示
      print strftime("%H:%M:%.3S %d-%b-%Y",time(0.0))
      18:15:04.253 16-Apr-2011

 以下参照: `time_specifiers`, `set xtics time`, `set mxtics time`。
2 ウォッチポイント (Watchpoints)
?watchpoints
?watch
 ウォッチポイントは、あなたが使用する gnuplot が configure 時にオプショ
 ン --enable-watchpoints をつけて作られた場合にのみサポートされます。こ
 の昨日は試験段階です (詳細は、今後のリリース版で変更される可能性があり
 ます)。

 書式:
       plot FOO watch {x|y|z|F(x,y)} = <value>
       plot FOO watch mouse

       set style watchpoints nolabels
       set style watchpoints label <label-properties>

       unset style watchpoints      # デフォルトスタイルに戻す

       show watchpoints    # 直前の plot コマンドからのすべてのウォッチ
                           # ポイントを要約表示

 一つのウォッチポイントは、x, y, z 座標、または関数 f(x,y) に対する一つ
 の対象値です。各ウォッチポイントは、コマンド `plot` 内の一つのグラフに
 付随します。ウォッチポイントは、`with lines` と `with linespoints` の
 描画スタイルでのみ機能します。その場合、そのグラフのすべての構成線分に
 対し、そのグラフに付随するすべてのウォッチポイントがチェックされ、一つ
 以上のウォッチポイントの対象がその線分上の点で満たされるかどうかを調べ
 ます。対象条件を満たす (「ヒット」("hits") と呼びます) 点の一覧は、グ
 ラフの描画毎に累積されます。

 例えば、対象値 y=100 のウォッチポイントがある場合、各線分に対して、そ
 の両端点の y 座標がその対象値を挟んでいるかをチェックします。もしそう
 なら、その線分上のある点 [x,y] が、対象条件 y=100 を完全に満たすことに
 なります。そして線形補間、または 2 分反復法によりその対象点が見つかり
 ます。

 一つの plot コマンド上の複数のウォッチポイントは、順番に番号づけします。
 各描画要素毎に、1 つ以上のウォッチポイントを指定できます。
 例:
      plot DATA using 1:2 smooth cnormal watch y=0.25 watch y=0.5 \
          watch y=0.75

Ffigure_watchpoints
 直前の plot コマンドで対象にヒットしたウォッチポイントは、WATCH_n とい
 う名前の配列に保存されます。直前の plot コマンドからヒットしたすべての
 ウォッチポイントの要約を表示させることもできます。以下参照:
 `show watchpoints`。

      gnuplot> show watchpoints
      Plot title:     "DATA using 1:2 smooth cnormal"
        Watch 1 target y = 0.25         (1 hits)
                hit 1   x 49.7  y 0.25
        Watch 2 target y = 0.5          (1 hits)
                hit 1   x 63.1  y 0.5
        Watch 3 target y = 0.75         (1 hits)
                hit 1   x 67.8  y 0.75

 平滑化: 線分は、それらを描画する際にチェックします。平滑化しないデータ
 描画に対しては、これは、補間によって見つかる対象点は、2 つのデータ点を
 結ぶ線分の上に完全に乗ることを意味します。データグラフを平滑化する場合
 は、ヒットする点は平滑化された曲線に対する線分の上にあります。それが平
 滑化しないデータに対する対象点よりも精度が良いか悪いかは、平滑化の当て
 はめの質に依存します。

 精度: 線分が関数描画で生成されたものであれば、f(x) = y となる x の値は
 2 分反復法で見つけます。それ以外の場合は、その線分に沿う線形補間で座標
 [x,y] を近似します。

3 ウォッチマウス (watch mouse)
?watchpoints mouse
?watch mouse

 現在のマウス x 座標をウォッチ対象として使用すると、マウスの水平位置を
 追跡しながら、グラフの線に沿って移動するラベルを生成します。これにより
 同じグラフ上の複数の曲線の y の値を同時に表示することも可能です。現在
 の位置を示す点とラベルの見た目は、`set style watchpoint` で変更できま
 す。

 例:

      set style watchpoint labels point pt 6 ps 2 boxstyle 1
      set style textbox 1 lw 0.5 opaque
      plot for [i=1:N] "file.dat" using 1:(column(i)) watch mouse

3 ウォッチラベル (watch labels)
?watchpoint labels
?watch labels
 デフォルトではラベルは、対象 "watch mouse" に対して常に生成します。他
 の対象に対しても、コマンド `set style watchpoint labels` を使えばラベ
 ルをオンにできます。ラベル文字列は "x : y" で、x, y は対象点の座標、そ
 の書式化は対応する軸に対する現在の設定を使用します。

 例:
      set y2tics format "%.2f<C2><B0>"
      set style watchpoint labels point pt 6
      plot FOO axes x1y2 watch mouse

1 描画スタイル (Plotting styles)
?plotting styles
=plot styles

 gnuplot では、たくさんの描画スタイルが利用できます。
 それらは、アルファベット順に以下に紹介されています。
 コマンド `set style data` と `set style function` は、それ以降の
 `plot` や `splot` コマンドに対してデフォルトの描画スタイルを変更
 します。

 描画スタイルは、コマンド `plot` や `splot` の一部分として、明示的にオ
 プション指定することもできます。一つの描画の中で、複数の描画スタイルを
 組み合わせたい場合は、各要素に対して描画スタイルを指定する必要がありま
 す。

 例:

      plot 'data' with boxes, sin(x) with lines

 各描画スタイルは、それ自体がデータファイルからのいくつかのデータの組
 を期待します。例えば、デフォルトでは `lines` スタイルは、y の値だけの
 1 列のデータ (x の値は暗黙に順番に取られる)、または最初が x, 次が y の
 2 つの列を期待しています。ファイルの何列のデータを描画データと解釈させ
 るうまい方法に関する情報については、以下参照: `using`。

2 arrows
?plotting styles arrows
?style arrows
?with arrows
?arrows
^figure_vectors
 2 次元のスタイル `arrows` は、各点 (x,y) に長さと方向の角を指定して矢
 印を描きます。追加の入力列は、各データ点毎の variable color 情報、ある
 いは arrow style として使用します。
 これは、矢先の場所の指定方法以外は 2 次元描画スタイルの `with vectors`
 と同じで、矢先は delta_x + delta_y でなく length (長さ) + angle (角)
 で与えます。以下参照: `with vectors`。

      4 列:  x  y  length  angle

 キーワード `with arrows` の後ろには、インラインの arrow style 属性や、
 定義済みの arrow style の参照、また `arrowstyle variable` による各矢印
 毎に適用したい arrow style 番号を他の列から読み込ませること、などを
 追加指定できます。

 正の `length` 値は、x 軸の座標で解釈します。
 -1 < `length` < 0 の値は、水平グラフ座標、すなわち |length| を全体のグ
 ラフ幅に対する割合として解釈します。
 gnuplot は x と y の拡大率の差、または描画アスペクト比に関して調整して、
 見た目の長さが方向角とは独立であるようにしようとします。

 `angle` は常に度単位で指定します。
3 arrowstyle variable
?arrowstyle variable
?variable arrowstyle
 描画スタイル `with arrows` と `with vectors` で、入力データの追加列を
 与えて、事前に `set style arrow` で定義した arrow スタイルに対応するス
 タイル番号を指定することができます。

 例:
      set style arrow 1 head nofilled linecolor "blue" linewidth 0.5
      set style arrow 2 head filled linecolor "red" linewidth 1.0
      # 第 5 列の値は 1 か 2 のいずれかで、それが事前に定義したスタイル
      # のうち使用する方を決定する
      plot DATA using 1:2:3:4:5 with arrows arrowstyle variable

#TeX \newpage
2 ビースウォーム描画 (Bee swarm plots)
?beeswarm
?bee swarm
=jitter
#TeX ~
Ffigure_jitter
 ビースウォーム (bee swarm) グラフは、揺らぎ (jitter) を適用して重複点
 を分離することにより得られる結果です。その典型的な例は、各点に x 座標
 を決定する 2 つ以上のカテゴリによって表わされる y の値の分布の比較です。
 重なりの判定基準や、jitter で使用する移動パターンを制御する方法に関し
 ては、以下参照: `set jitter`。この図のグラフは、異なる jitter の設定に
 対する同じ plot コマンドによって作られたものです。

      set jitter
      plot $data using 1:2:1 with points lc variable
2 boxerrorbars
?plotting styles boxerrorbars
?style boxerrorbars
?with boxerrorbars
?boxerrorbars
 描画スタイル `boxerrorbars` は 2 次元のデータ描画でのみ利用可能です。
 これは、3 列、または 4 列、または 5 列のデータが必要です。入力列を追加
 (4,5,6 列目) すると、それらは各データ点毎の variable color 情報 (以下
 参照: `linecolor`, `rgbcolor variable`) として使われます。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh          (xdelta <= 0 は boxwidth を使用)
      5 列:  x  y  ylow  yhigh  xdelta  (xdelta <= 0 は boxwidth を使用)

Ffigure_boxerrorbars
 y の誤差を "ydelta" の形式で与える場合は、箱の横幅は 4 列目の値を使用
 し、"ylow yhigh" の形式で与える場合は、横幅は 5 列目の値を使用します。
 xdelta の値が 0 かまたは負の場合は、箱の横幅は、事前に与える boxwidth
 の値で制御します。以下参照: `set boxwidth`。

 誤差線の垂直方向は、`yerrorbars` スタイル同様に y の誤差の値を表現する
 ように描きます。y-ydelta から y+ydelta まで、あるいは ylow から yhigh
 まで、これらは何列のデータが与えられているかによって決まります。誤差線
 の描画で使用する線スタイルは、`set bars` を使って制御できますが、使わ
 なければ、箱の境界と同じもので誤差線を描きます。

 非推奨: 古いバージョンの gnuplot では、"ylow yhigh" の誤差形式の 4 列
 のデータに対して `boxwidth = -2.0` を特別に扱っていました。その場合、
 隣接する箱の間に隙間ができないように箱の幅を調節していました。この処理
 は、後方互換性のために残されていますが、将来のバージョンでは削除するで
 しょう。

2 boxes
?plotting styles boxes
?style boxes
?with boxes
?boxes
 2 次元グラフでは、スタイル `boxes` は与えられた x 座標を中心とし、x 軸
 から (すなわち y=0 からであって、グラフの境界からではない) 与えられた
 y 座標まで伸ばした長方形の箱を書きます。箱の横幅は入力の追加列で指定す
 ることもできますし、`set boxwidth` で制御することもできます。そうでな
 ければ、各箱は、隣接する箱同士がくっつくように引き伸ばされます。

 3 次元グラフでは、スタイル `boxes` は与えられた x, y 座標を中心とし、
 xy 平面 (z=0) から与えられた z 座標まで伸ばした直方体の箱を書きます。
 x 方向の箱の幅は、別の入力列か `set boxwidth` で指定でき、y 方向の箱の
 奥行きは、`set boxdepth` で制御できます。箱は、自動的にはくっつくよう
 には引き伸ばされません。
3 2 次元の boxes (2D boxes)
?style boxes 2D
?boxes 2D

 `plot with boxes` は、基本的に 2 列、または 3 列のデータを使用します。
 さらに入力列を追加すると、それは variable 行や塗り潰し色の情報として使
 用します。以下参照: `rgbcolor variable`。

      2 列:  x  y
      3 列:  x  y  x_width

Ffigure_boxes
 箱の幅は 3 つのうち一つの方法で決定されます。入力データに 3 列目のデー
 タがある場合は、それを箱の幅として使用します。そうでない場合でコマンド
 `set boxwidth` で箱の幅をセットした場合は、それを使います。そのどちら
 でもない場合は、隣接する箱がくっつくように箱の幅を自動的に計算します。

 箱の内部は現在の塗りつぶしスタイル (fillstyle) で塗りつぶします。それ
 以外に、塗りつぶしスタイルを plot コマンド上で指定することもできます。
 以下参照: `set style fill`。
 塗り潰し色を plot コマンドで指定しなければ、現在の線色を使用します。

 例:

 データファイルを単色塗りした箱で描画し、箱同士を少し垂直方向にスペース
 を空ける (棒グラフ):

       set boxwidth 0.9 relative
       set style fill solid 1.0
       plot 'file.dat' with boxes

 塗り色を明示してパターン塗りスタイルの箱で sin と cos のグラフを描画:

       set style fill pattern
       plot sin(x) with boxes fc 'blue', cos(x) with boxes fc 'gold'

 sin はパターン 0 で、cos はパターン 1 で描画されます。追加される描画は
 出力ドライバがサポートするパターンを循環的に使用します。

3 3 次元の boxes (3D boxes)
?style boxes 3D
?boxes 3D

 `splot with boxes` には、少なくとも 3 列の入力列が必要です。さらに入力
 列を追加すると、それは箱の幅や塗り潰し色の情報として使用します。

      3 列:  x  y  z
      4 列:  x  y  z  [x_width または color]
      5 列:  x  y  z  x_width  color

 最後の列は、splot コマンドで明示的に variable カラーモードを指定してい
 る場合のみ色として使用します。例:

      splot 'blue_boxes.dat' using 1:2:3 fc "blue"
      splot 'rgb_boxes.dat' using 1:2:3:4 fc rgb variable
      splot 'category_boxes.dat' using 1:2:3:4:5 lc variable

 最初の例は、すべての箱を青に塗り、幅はあらかじめ `set boxwidth` で設定
 した幅を使用します。2 つ目の例は、4 列目を 24-bit RGB 色として認識する
 ため、箱の幅は相変わらず `set boxwidth` の幅を使います。3 つ目の例は、
 4 列目の値を箱の幅として読み、5 列目の整数値を色を提供する線種と解釈し
 ます。

Ffigure_3Dboxes
 デフォルトでは、箱には太さはなく、それらは単に xz 平面に平行な 1 つの
 長方形で構成されますが、y 方向の幅として 0 でない値を設定すれば 4 面と
 天井をを持つ本当の箱に変更できます。以下参照: `set boxdepth`。

 3 次元の箱は、曲面ではなく pm3d 長方形として処理しています。よって、表
 裏の描画順は、`set hidden3d` の影響を受けません。以下参照: `set pm3d`。
 gnuplot バージョン 6 は、箱の端はグラフの fill style の境界色で色付け
 します。これはバージョン 5 とは異なる変更です。
 最良の結果を得るには、`set pm3d depthorder base` と `set pm3d lighting`
 を組み合わせてください。

2 boxplot
?plotting styles boxplot
?style boxplot
?with boxplot
?boxplot
Ffigure_boxplot
 boxplot は、値の統計的な分布を表現する一般的な方法です。四分位境界は、
 1/4 の点が第一四分位境界以下の値を持つように、1/2 の点が第二四分位境界
 (メジアン) 以下の値を持つように、等と決定されます。第一四分位と第三四
 分位の間の領域を囲むように箱を描画し、メジアン値のところには水平線を描
 きます。箱ひげは、箱からユーザ指定限界まで延長されます。それらの限界の
 外にある点は、ひとつひとつ描画されます。

 例:

     # x 座標は 1.0、y は 5 列目の値のところに boxplot を配置
     plot 'data' using (1.0):5

     # 上と同じだが、範囲外の点は隠し、boxplot の幅を 0.3 にする
     set style boxplot nooutliers
     plot 'data' using (1.0):5:(0.3)

 デフォルトでは、using 指定による 2 列目の y のすべての値に対する
 boxplot を 1 つだけ生成します。しかし、追加の (4 つ目の) 列を指定する
 と、その列の値をある因子変数の離散的なレベル値であると見なし、その離散
 値のレベルの値の数だけの boxplot を描画します。それらの boxplot の間隔
 はデフォルトでは 1.0 ですが、これは `set style boxplot separation` で
 変更できます。デフォルトでは、因子変数の値は、各 boxplot の下 (または
 上) の目盛りのラベルに表示します。

 例

     # 'data' の 2 列目は "control" か "treatment" のいずれかの文字列で
     # 以下の例は、その因子毎の 2 つの boxplot を生成する
     plot 'data' using (1.0):5:(0):2

 その箱のデフォルトの幅は `set boxwidth <width>` で設定できますが、plot
 コマンドの `using` による 3 番目のオプション列でも指定できます。1 番目
 と 3 番目の列 (x 座標と幅) は通常データ列ではなく定数として与えます。

 デフォルトでは、箱ひげは箱の端から、y の値が四分位範囲の 1.5 倍の中に
 収まっていて最も離れているような点まで延長されます。デフォルトでは、範
 囲外の点 (outlier) は円 (pointtype 7) で描かれます。箱ひげの端の棒の幅
 は `set bars` または `set errorbars` を使って制御できます。

 これらのデフォルトの性質は `set style boxplot` コマンドで変更できます。
 以下参照: `set style boxplot`, `bars`, `boxwidth`, `fillstyle`,
 `candlesticks`。

2 boxxyerror
?plotting styles boxxyerror
?style boxxyerror
?with boxxyerror
?boxxyerror
Ffigure_boxxyerror
 `boxxyerror` 描画スタイルは 2 次元のデータ描画でのみ利用可能です。これ
 は、`xyerrorbars` スタイルが線分の交差で表現するところを長方形で表現す
 ることを除けばほぼ同じです。これは入力データの 4 列、または 6 列を使用
 します。余分な入力列 (5 列目、または 7 列目) は、データ点毎の可変色
 (variable color) 情報の提供として扱います (以下参照: `linecolor`,
 `rgbcolor variable`)。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 箱の幅と高さは `xyerrorbars` スタイル同様 x, y の誤差から決定されます
 つまり、xlow から xhigh までと ylow から yhigh まで、または x-xdelta
 から x+xdelta までと y-ydelta から y+ydelta まで。これらは何列のデータ
 が与えられているかによって決まります。

 6 列の形式のコマンドは、任意の x, y の幅の長方形を書く簡単な方法を提供
 します。

 箱の内部は現在の塗りつぶしスタイル (fillstyle) に従って塗られます。詳
 細は、以下参照: `set style fill`, `boxes`。plot コマンド上で新しい塗り
 つぶしスタイルを指定することもできます。
2 candlesticks
?plotting styles candlesticks
?style candlesticks
?with candlesticks
?candlesticks
Ffigure_candlesticks
 `candlesticks` スタイルは、金融データの 2 次元のデータ描画、および統計
 データのひげ付きの棒グラフを生成するのに使えます。
 記号は、水平方向には x を中心とし、垂直方向には開始値 (open) と終値
 (close) を境界とする長方形が使われます。そして、その x 座標のところに
 長方形のてっぺんから最高値 (high) までと、長方形の底から最安値 (low)
 までの垂直線が引かれますが、この垂直線は最高値と最安値が入れ替わっても
 変更されません。

 基本的に 5 列のデータが必要です:

       金融データ:   date  open  low  high  close
       箱ひげ描画:   x  box_min  whisker_min  whisker_high  box_high

 長方形の幅はコマンド `set boxwidth` で制御できますが、以前の gnuplot
 への後方互換性として、boxwidth パラメータが設定されていない場合は
 `set errorbars <width>` を長方形の幅として取ります。

 これの代わりに、箱ひげ (box-and-whisker) のグループ化に関する明示的な
 幅の指定を、追加の 6 番目のデータで指定できます。その幅は、x 座標と同
 じ単位で与えなければいけません。

 入力列を追加 (6 列目、または 6 列目がデータの幅として使れる場合は 7 列
 目) すると、それらは各データ点毎の variable color 情報 (以下参照:
 `linecolor`, `rgbcolor variable`) として使われます。

 デフォルトでは、鉛直線分のてっぺんと底には垂直に交わる水平線は引かれま
 せん。それを引きたい場合、例えば典型的な例は箱ひげ図 (box-and-whisker
 plot) での使用ですが、描画コマンドにキーワード `whiskerbars` を追加し
 てください。デフォルトでは、水平線は箱 (candlestick) の水平幅一杯に引
 かれますが、それは全体の幅に対する割合を指定することで変更できます。

 金融データの通常の慣習では、(開始値) < (終値) の場合は長方形は空で、
 (終値) < (開始値) の場合は単色塗りします。現在の fillstyle に "empty"
 をセットしている場合は、実際にこうなります。以下参照: `fillstyle`。
 fillstyle に solid (単色塗り)、または pattern (パターン) をセットして
 いる場合は、開始値、終値に関係なく、すべての箱にそれが使われます。以下
 参照: `set errorbars`, `financebars`。また、以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/candlesticks.html">
 candlestick
^ </a>
 と
^ <a href="http://www.gnuplot.info/demo/finance.html">
 finance
^ </a>
 のデモ。

 注意: 箱ひげグラフ上に記号や線を追加して置くには、追加の描画要素が必要
 になります。以下の最初の例は、2 番目の要素で、箱を潰して中央値の場所に
 置く線分にしています。

   # データ列:  X '最小値' '1/4 位の値' '中央値' '3/4 位の値' '最大値'
   set errorbars 4.0
   set style fill empty
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
        ''         using 1:4:4:4:4 with candlesticks lt -1 notitle

   # ひげの上に水平線を伴う描画で、水平線の幅を全体幅の 50% にする
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5

 以下参照: `set boxwidth`, `set errorbars`, `set style fill`, `boxplot`。
2 circles
?plotting styles circles
?style circles
?with circles
?circles
Ffigure_circles
 スタイル `circles` は、各データ点に明示された半径の円を描画します。半
 径は、常に描画の水平軸 (x または x2) の単位で解釈されます。y 方向の縮
 尺と描画のアスペクト比は、いずれも無視されます。半径を各点毎の列として
 指定しない場合、それは `set style circle` から取ります。この場合、半径
 は graph か screen の座標系を使用できます。

 各点毎に、そして事前に、設定する属性の多くの組み合わせ指定が可能です。
 2 次元描画では、以下が指定できます。

     using x:y
     using x:y:radius
     using x:y:color
     using x:y:radius:color
     using x:y:radius:arc_begin:arc_end
     using x:y:radius:arc_begin:arc_end:color

 デフォルトでは完全な円を描画します。
 この結果は `points` と pointtype 7 を用いて、可変点サイズのグラフを書
 くことと同様ですが、その円を x 軸の範囲で伸縮すことが違います。
 4 列目、5 列目に開始角と終了角 (単位は度)を指定することで円弧の一部を
 描画することもできます。

 using 指定の最後の列で、円毎の色も指定できます。この場合、plot コマン
 ドには `lc variable` か `fillcolor rgb variable` のような変動色指定を
 入れる必要があります。

 以下参照: `set style circle`, `set object circle`, `set style fill`。

 3 次元描画では、using 指定には以下のものが必要です。

     splot DATA using x:y:z:radius:color

 変動色の列はオプション (省略可) です。

 例:

     # 面積が 3 列目の値に比例するような円を描画
     set style fill transparent solid 0.2 noborder
     plot 'data' using 1:2:(sqrt($3)) with circles, \
          'data' using 1:2 with linespoints

     # 円の代わりにパックマンを描画
     plot 'data' using 1:2:(10):(40):(320) with circles

Ffigure_piechart
=piechart

     # インランデータで円グラフを描画
     set xrange [-15:15]
     set style fill transparent solid 0.9 noborder
     plot '-' using 1:2:3:4:5:6 with circles lc var
     0    0    5    0    30    1
     0    0    5   30    70    2
     0    0    5   70   120    3
     0    0    5  120   230    4
     0    0    5  230   360    5
     e

2 ellipses
?plotting styles ellipses
?style ellipses
?with ellipses
?ellipses
Ffigure_ellipses
 スタイル `ellipses` は、各データ点に楕円 (ellipse) を描画します。この
 スタイルは、2 次元描画にのみ適用されます。各楕円は、中心、主軸直径、副
 軸直径、x 軸と主軸のなす角、で表現されます。

      2 列: x y
      3 列: x y diam  (主軸、副軸の両方に使用)
      4 列: x y major_diam minor_diam
      5 列: x y major_diam minor_diam angle

 2 列のデータのみが与えられた場合は、それらは中心の座標とみなされ、楕円
 はデフォルトの大きさで描画されます (以下参照: `set style ellipse`)。楕
 円の向きは、主軸と x 軸のなす角で定義されますが、それもデフォルトの
 ellipse のスタイルから取られます (以下参照: `set style ellipse`)。

 3 列のデータが与えられた場合は、3 列目は主、副両軸の直径 (幅) として使
 われます。向きはデフォルトで 0 になります。

 4 列のデータが与えられた場合は、それらは中心の座標、主軸直径 (幅)、副
 軸直径として使わわれます。これらは直径であり、半径でないことに注意して
 ください。
 一方の直径が負ならば、直径は両方とも `set style ellipse` で設定したデ
 フォルト値を使います。

 5 列のデータとして、向きの角度 (単位は度) を指定することもできます。
 楕円は、3,4,5 列の値は負の値として指定することで、それらのデフォルトの
 値を利用して楕円を書かせることもできます。

 上のすべての場合で、variable color データを最後の列 (3,4,5,6 列目) と
 して追加できます。以下参照: `colorspec`。

 キーワード `units`: `units xy` が描画指定に含まれている場合、主軸直径
 は水平軸 (x または x2) の単位、副軸直径は垂直軸 (y または y2) の単位で
 あるとみなされます。x 軸と y 軸の縮尺が異なる場合、主軸と副軸の比は回
 転後には正しくはなりません。
 `units xx` は、直径は両軸とも x 軸の単位で計算します。
 `units yy` は、直径は両軸とも y 軸の単位で計算します。
 後の 2 つは、描画のサイズを変更しても、楕円は正しいアスペクト比を持ち
 ます。plot コマンドで `units` を省略した場合は、`set style ellipse` の
 設定を使います。

 例 (楕円を有効な線種を周期的に使用して描画):

     plot 'data' using 1:2:3:4:(0):0 with ellipses

 以下も参照: `set object ellipse`, `set style ellipse`, `fillstyle`。

2 dots
?plotting styles dots
?style dots
?with dots
?dots
Ffigure_dots
 `dots` スタイルは各点に小さなドットを描画します。これはたくさんの点か
 らなる散布図の描画に便利でしょう。2 次元描画では 1 列、または 2 列の入
 力データが、3 次元描画では 3 列のデータが必要です。

 出力形式によっては (post, pdf など)、ドットの大きさは linewidth を変更
 することで制御できることもあります。

      1 列:  y         # x は行番号
      2 列:  x  y
      3 列:  x  y  z   # 3D のみ (splot)

2 filledcurves
?plotting styles filledcurves
?style filledcurves
?with filledcurves
?filledcurves
Ffigure_filledcurves
 スタイル `filledcurves` は 2 次元描画でのみ利用します。これは 3 種類の
 異なる指定が可能です。最初の 2 種類は 1 つの関数描画、あるいは (x,y) 2
 列の入力データ用のもので、後で紹介するようにオプションで更なる指定がで
 きます。

 書式:

     plot ... with filledcurves [option]

 ここで、オプションは以下のうちのいずれかです:

     closed
     {above|below} x1 x2  y r=<a> xy=<x>,<y>
     between

 最初のものは `closed` で、これは曲線それ自身を閉多角形と見なします。入
 力データが 2 列の場合にはこれがデフォルトです。

     filledcurves closed   ... 丁度閉曲線で囲まれる領域

 2 種類目は指定された軸、あるいは水平線、垂直線、与えられた点などと、曲
 線との間に作られる領域を塗りつぶします。この場合、さらに塗り潰し領域を
 指定した直線の上または下に制限できます。

     filledcurves x1       ... x1 軸
     filledcurves x2       ... x2 軸 (y1, y2 軸も同様)
     filledcurves y=42     ... 直線 y=42, すなわち x 軸と平行
     filledcurves xy=10,20 ... x1,y1 軸での点 10,20 (扇型のような形状)
     filledcurves above r=1.5  極座標での動径軸の 1.5 の外側の領域

Ffigure_yerrorfill
 3 種類目は、x 座標の集合が同じである 2 つの曲線の間の領域を塗り潰しま
 す。これは、(x, y1, y2) の 3 列の入力データが必要です。入力データが 3
 列以上の場合にはこれがデフォルトです。2 列目が y の値で、3 列目がその
 誤差データである場合は、不確定領域を陰影で表現することができます。
 これに似た 3 次元描画スタイル `zerrorfill` も参照してください。

     3 列:  x  y  yerror

     plot $DAT using 1:($2-$3):($2+$3) with filledcurves, \
          $DAT using 1:2 smooth mcs with lines

 `above` と `below` オプションは
     ... filledcurves above {x1|x2|y|r}=<val>
 および
     ... using 1:2:3 with filledcurves below
 の形のコマンドに適用可能です。どちらの場合でも、これらのオプションは
 塗りつぶし領域を、境界線、または境界曲線の片側に制限します。

 データファイルから描かれた曲線の塗りつぶしを拡大すると、何もなくなった
 り正しくない領域になることがありますが、それは gnuplot が、領域ではな
 く点や線をクリッピングしているからです。

 <x>, <y>, <a> が描画領域の外にある場合、それらはグラフの境界へ移動され
 ます。よって、オプション xy=<x>,<y> を指定した場合の実際の塗りつぶし領
 域は、xrange や yrange に依存します。
3 塗り潰しの属性 (fill properties)
?filledcurves border
=border
 `with filledcurves` での描画は、fillstyle (solid/transparent/pattern)
 や fillcolor を指定することでさらにカスタマイズできます。plot コマンド
 で fillstyle (`fs`) を指定しなければ、現在のデフォルトの fill スタイル
 を使用します。以下参照: `set style fill`。plot コマンドで fillcolor
 (`fc`) を指定しなければ、現在の線色を使います。

 fillstyle の属性の {{no}border} は、filledcurves のモードがデフォルト
 の `closed` である場合に受け付けます。
 例:
      plot 'data' with filledcurves fc "cyan" fs solid 0.5 border lc "blue"
2 financebars
?plotting styles financebars
?style financebars
?with financebars
?financebars
 `financebars` スタイルは金融データの 2 次元のデータ描画でのみ利用可能
 です。これは、x 座標 1 つ (通常日付) と、4 つの y 座標 (金額) を必要と
 します。

      5 列:   date  open  low  high  close

 入力列を追加 (6 列目) すると、それらは各行毎の variable color 情報 (以
 下参照: `linecolor`, `rgbcolor variable`) として使われます。

Ffigure_financebars
 記号は、水平方向にはその x 座標に置かれ、垂直方向には最高値 (high) と
 最安値 (low) を端とする線分が使われます。そして、その線分に水平左側の
 刻みが開始値 (open) の所に、水平右側の刻みが終り値 (close) の所につき
 ます。その刻みの長さは `set errorbars` で変更できます。記号は最高値と
 最安値が入れ替わっても変わりません。以下参照: `set errorbars`,
 `candlesticks`。以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/finance.html">
 金融データデモ。
^ </a>
#TeX \newpage
2 fillsteps
?style fillsteps
?with fillsteps
?fillsteps
      plot <data> with fillsteps {above|below} {y=<baseline>}

Ffigure_steps
 `fillsteps` スタイルは 2 次元描画でのみ利用可能です。
 これは、`steps` とほぼ同じですが、曲線とベースライン (デフォルトは y=0)
 との間の領域を現在の fillstyle で塗り潰します。オプション `above` と
 `below` は、ベースラインの片方の部分のみ塗り潰します。一つのデータ点か
 ら次の点への移動の際に、`steps` と `fillsteps` はいずれもまず x 座標の
 変化の線を引き、その後 y 座標の変化の線を引くことに注意してください。
 以下参照: `steps`。
2 fsteps
?plotting styles fsteps
?style fsteps
?with fsteps
?fsteps
Ffigure_fsteps
 `fsteps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で
 隣り合う点をつなぎます: 1 本目は (x1,y1) から (x1,y2) まで、2 本目は
 (x1,y2) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>
2 histeps
?plotting styles histeps
?style histeps
?with histeps
?histeps
Ffigure_histeps
 `histeps` スタイルは 2 次元描画でのみ利用可能です。これはヒストグラム
 の描画での利用を意図しています。y の値は、x の値を中心に置くと考え、
 x1 での点は ((x0+x1)/2,y1) から ((x1+x2)/2,y1) までの水平線として表現
 されます。端の点では、その線はその x 座標が中心になるように延長されま
 す。隣り合う点同士の水平線の端は、その両者の平均値のところでの鉛直線、
 すなわち ((x1+x2)/2,y1) から ((x1+x2)/2,y2) の線分で結ばれます。
 入力列の条件は、`lines` や `points` に対するものと同じです。

 `autoscale` が有効である場合、x の範囲は、その延長された水平線の範囲で
 はなく、データ点の範囲が選択されます。よって、端の点に関してはその水平
 線は半分しか描かれないことになります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

#TeX \newpage
2 温度分布図 (heatmaps)
?heatmaps
 gnuplot のいくつかの描画スタイルで温度分布図 (heatmaps) を作ることがで
 きます。どのスタイルを使うかは、データの型で決まります。

Ffigure_heatmap
 ピクセルベースの温度分布図は、すべて分布図内の各ピクセルが完全に一つの
 元のデータ値に対応するという特性を持っています。
 ピクセルベースの画像スタイルは、データ値が規則的な長方形格子であること
 を要求します。以下参照: `with image`。しかし、格子値の欠けを処理するこ
 とは可能ですし (以下参照: `sparse`)、格子の一部を表示からマスクして消
 してしまうことも可能です (以下参照: `masking`)。格子要素がそれほど多く
 ない場合は、各長方形要素を別々に塗って (`with image pixels`)、平滑化や
 非可逆圧縮が 結果の画像 ("image")に適用されないようにすることは通常は
 いいでしょう。

Ffigure_sector_heatmap
 ピクセルベース温度分布図の画像と同等の極形のものは、2 次元描画スタイル
 `sectors` で生成できます。各入力点は、ピクセルと同等の極座標格子上の一
 つの環状の扇片に完全に対応します。以下に説明する極座標格子面のオプショ
 ンとは違い、格子の個々の扇片は任意個提供できます。この描画スタイルを、
 極座標グラフ、あるいは直交座標グラフの任意の場所に、極扇片を置くように
 使うことができます。ここの図は、直交座標グラフ上で、温度分布図の極形の
 2 つの半分を、原点を挟んで±Δx離れた場所に置き直したものを示します。

Ffigure_mask
 データ点が規則的な長方形格子を構成しない場合は、補間やスプラインを使っ
 て格子曲面に当てはめることがよく行われます。他には、点の密度関数を格子
 平面や滑らかな曲面に写像することもできます。以下参照: `set dgrid3d`。
 その格子曲面は、その後 pm3d 曲面として描画できます (例は以下参照:
 `masking`)。この場合、温度分布図上の点と入力点との 1 対 1 対応は保持さ
 れません。すなわち、温度分布表現の妥当性は、格子近似と同程度に過ぎませ
 ん。デモコレクションに、点集合から 2 次元温度分布図を生成する例があり
 ます。
^ <a href="http://www.gnuplot.info/demo/heatmap_points.html">
 heatmap_points.dem
^ </a>

Ffigure_polar_grid
 あなたが使用する gnuplot が --enable-polar-grid オプション付きでビルド
 された場合、極座標データ点を、2 次元極座標温度分布図を生成するのに使え、
 各 "ピクセル" は事前に決定したθと r の範囲に対応します。以下参照:
 `set polar grid`, `with surface`。この作業は、2 次元極座標空間で操作す
 ることを除いて、丁度 `set dgird3d` と `with pm3d` を使用することの類似
 です。

2 histograms
?style histograms
?with histograms
?set style histogram
?plotting styles histograms
?histograms
 スタイル `histograms` は 2 次元描画でのみ有効です。これは、データの各
 列の並びから平行な棒グラフを作ります。`plot` コマンドの各要素は、それ
 に関する目盛りの値や凡例 (key) のタイトルが付属するかも知れませんが、
 単一の入力データを指定する必要があります (例えば入力ファイルの 1 つの
 列)。現在は、4 種類のヒストグラム形式のスタイルをサポートしています。

       set style histogram clustered {gap <gapsize>}
       set style histogram errorbars {gap <gapsize>} {<linewidth>}
       set style histogram rowstacked
       set style histogram columnstacked
       set style histogram {title font "name,size" tc <colorspec>}

 デフォルトのスタイルは `set style histogram clustered gap 2` に対応し
 ています。このスタイルでは、並列に指定されたデータの値の集合は、選択さ
 れたデータ列のそのそれぞれの序列 (行番号) に対応する x 座標の場所に、
 各々箱のグループとして固められて置かれます。よって、<n> 個のデータ列を
 並列に指定した場合、最初の固まりは x=1 を中心とする <n> 個の箱の固まり
 からなり、その各々の高さは、その <n> データ列各々の最初 (1 行目) の値
 が取られます。その後に少し空白 (gap) が空けられ、次に各データ列の次 (2
 行目) の値に対応する箱の固まりが x=2 を中心として置かれます。以下同様
 です。デフォルトの空白 (gap) 幅の 2 は、箱の固まり同士の間の空白が、箱
 2 つの幅に等しいことを意味します。同じ列に対する箱は全て同じ色または同
 じパターンで与えられます; しかし、以下も参照: `histograms colors`。

 箱の固まりそれぞれは、データファイルの 1 つの行から得られます。そのよ
 うな入力ファイルの各行の最初の項目が見出し (ラベル) でることは良くある
 ことです。その列にある見出し (ラベル) は、`using` に `xticlabels` オプ
 ションをつけることで、それに対応する箱の固まりの真下の x 軸に沿ったと
 ころに置くことができます。

 `errorbars` スタイル は、各エントリに対して追加の入力列を必要とする以
 外は `clustered` スタイルにとても良く似ています。最初の列は、
 `clustered` スタイルの場合と全く同様に箱の高さ (y の値) として保持され
 ます。
      2 列:       y yerr          # 線は y-yerr から y+err へ伸びる
      3 列:       y ymin ymax     # 線は ymin から ymax へ伸びる
 誤差線の見た目は、現在の `set errorbars` の値と <linewidth> オプション
 指定で制御できます。

 積み上げ型のヒストグラムも 2 つの形式がサポートされています。それらは
 コマンド `set style histogram {rowstacked|columnstacked}` で選択できま
 す。これらのスタイルにおいて、選択された列のデータの値は積み上げられた
 箱として集められます。正の値は、y=0 から上の方へ積み上げられ、負の値は
 下へ向かって積み上げられます。正の値と負の値が混じってい場合は、上向き
 と下向きの両方の積み上げが生成されます。デフォルトの積み上げモードは
 `rowstacked` です。

 スタイル `rowstacked` は、まず最初に選択された列の各行の値を x 軸のそ
 れぞれの位置に配置します: 1 行目の値は x=1 の箱、2 行目のは x=2、以下
 同様となります。2 番目以降に選択された列に対応する箱は、それらの上に積
 み重ねられて行きます。そして結果として、x=1 にできる箱の積み重ねは、各
 列の最初の値 (1 行目の値) からなり、x=2 の箱の積み重ねは各列の 2 行目
 の値、などのようになります。同じ列に対する箱は全て同じ色または同じパタ
 ーンで与えられます (以下参照: `set style fill`)。

 スタイル `columnstacked` も同様ですが、こちらは各箱の積み上げは (各行
 のデータからではなく) 各列のデータからなります。最初に指定したデータ列
 の各行のデータが x=1 の箱の積み上げを生成し、2 番目に指定したデータ列
 の各行のデータが x=2 の箱の積み上げ、などのようになります。このスタイ
 ルでは、各箱の色は、各データ項目の (列番号ではなく) 行番号から決定され
 ます。

 箱の幅はコマンド `set boxwidth` で変更できます。
 箱の塗りつぶしスタイルはコマンド `set style fill` で設定できます。

 histograms は x 軸は常に x1 軸を使いますが、y 軸に関しては y1 軸か y2
 軸かを選択できます。plot 命令が、histograms と他のスタイルの描画の両方
 を含む場合、histogram でない方は、x1 軸を使うか x2 軸を使うかを選択で
 きます。

 一つ追加のスタイルオプション `set style histogram nokeyseparators` は、
 複数のヒストグラムを含むグラフにのみ適切なものです。その場合の追加説明
 については、以下参照: `newhistogram`。

 例:
Ffigure_histclust
 入力ファイルは、2, 4, 6, ... の列にデータ値を持ち、3, 5, 7, ...  の列
 に誤差評価を持つとします。以下の例は、2 列目、4 列目の値を箱の固まり型
 (clustered; デフォルトスタイル) のヒストグラムとして描画します。ここで
 は、plot コマンドで繰り返し (iteration) を使用していますので、任意の個
 数のデータ列を一つのコマンドで処理できます。以下参照: `plot for`。

       set boxwidth 0.9 relative
       set style data histograms
       set style histogram cluster
       set style fill solid 1.0 border lt -1
       plot for [COL=2:4:2] 'file.dat' using COL

 これは、x 軸上の各整数値を中心とするそれぞれ 2 つの箱 (鉛直な棒) 毎の
 固まりによる描画を生成します。入力ファイルの最初の列にラベルが含まれて
 いるならそれを、以下の少し変更したコマンドで x 軸に沿って配置できます。

       plot for [COL=2:4:2] 'file.dat' using COL:xticlabels(1)

Ffigure_histerrorbar
 ファイルが、各データの測定値と範囲の情報の両方を含んでいる場合、描画に
 誤差線を追加することができます。以下のコマンドは誤差線を (y-<error>)
 から (y+<error>) に引き、その頭に箱と同じ幅の水平線をつけます。誤差線
 と誤差線の端の線は、黒で線幅 2 で描画されます。

       set errorbars fullwidth
       set style fill solid 1 border lt -1
       set style histogram errorbars gap 2 lw 2
       plot for [COL=2:4:2] 'file.dat' using COL:COL+1

 以下は、同じデータを行毎の積み上げ型 (rowstacked) のヒストグラムで描画
 する方法を示しています。これまでとは違い、以下の例の描画コマンドでは、
 繰り返しの使用ではなく、個別に別々の列を指定しています。

       set style histogram rowstacked
       plot 'file.dat' using 2, '' using 4:xtic(1)

Ffigure_histrows
 これは、一つ一つの鉛直な棒が、データの一つの列に対応する描画を生成しま
 す。各棒は、2 つの部分の積み上げの形であり、それぞれの部分の高さが、デ
 ータファイルの 2 列目と 4 列目の値に対応します。
#TeX \vspace{1em}
 最後に以下のコマンド

       set style histogram columnstacked
       plot 'file.dat' using 2, '' using 4

Ffigure_histcols
 は、一つ一つがそれぞれデータ列に対応する、2 つの鉛直な積み重ねの棒を生
 成します。x=1 にある棒は、データファイルの 2 列目の各行の値に対応する
 箱からなります。x=2 にある棒は、データファイルの 4 列目の各行の値に対
 応する箱からなります。

 これは、gnuplot の通常の入力の縦、横の解釈を入れ換えることになりますの
 で、凡例のタイトルや x 軸の目盛りの見出しの指定も変更する必要がありま
 す。以下のコメント部分を参照してください。

       set style histogram columnstacked
       plot '' u 5:key(1)            # 1 列目を凡例タイトルに使用
       plot '' u 5 title columnhead  #

 この 2 つの例は、全く同じデータ値を与えているのですが、異なる書式であ
 ることに注意してください。
3 newhistogram
?newhistogram
?with histograms newhistogram
?histograms newhistogram
?styles histograms newhistogram
?plotting styles histograms newhistogram
 書式:

      newhistogram {"<title>" {font "name,size"} {tc <colorspec>}}
                   {lt <linetype>} {fs <fillstyle>} {at <x-coord>}

 一回の描画に 2 つ以上のヒストグラムの組を作ることもできます。この場合
 コマンド `newhistogram` を使うことで、それらを強制的に分離し、またそれ
 ぞれのラベルを分離することができます。
 例:

       set style histogram  cluster
       plot newhistogram "Set A", 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B", 'b' using 1, '' using 2, '' using 3

 ラベル "Set A" と "Set B" は、それぞれのヒストグラムの組の下、x 軸の全
 てのラベルの下の位置に現われます。

 コマンド newhistogram は、ヒストグラムの色付けを強制的に指定した色
 (linetype) で始めるのにも使えます。デフォルトでは、色の番号はヒストグ
 ラムの境界をまたいでさえも連続的に増加し続けます。次の例は、複数のヒス
 トグラムに同じ色付けを施します。
       plot newhistogram "Set A" lt 4, 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B" lt 4, 'b' using 1, '' using 2, '' using 3

 同様に、次のヒストグラムを指定した fillstyle で始めさせることが可能で
 す。その fillstyle を `pattern` にセットした場合、塗り潰しに使用される
 パターン番号は自動的に増加されていきます。

 新しいヒストラムの開始は、通常は凡例 (key) に空のエントリを追加し、そ
 れによりそのヒストグラム要素の集合のタイトルは、それ以前のヒストグラム
 のものと分離されることになります。しかしこの空行は、その要素が個々のタ
 イトルを持たない場合は望ましいものではありません。これは、そのスタイル
 を `set style histogram nokeyseparators` と変更することで、その空行の
 出力を抑制できます。

Ffigure_newhist
 オプション `at <x-coord>` は、その後のヒストグラムの x 座標の位置を
 <x-coord> に設定します。例:

        set style histogram cluster
        set style data histogram
        set style fill solid 1.0 border -1
        set xtic 1 offset character 0,0.3
        plot newhistogram "Set A", \
             'file.dat' u 1 t 1, '' u 2 t 2, \
             newhistogram "Set B" at 8, \
             'file.dat' u 2 t 2, '' u 2 t 2

 この場合、2 つ目のヒストグラムの位置は x=8 から始まります。
3 複数の列に渡る自動的な繰り返し (automated)
?automated
?with histograms automated
?histograms automated
?styles histograms automated
?plotting styles histograms automated
 一つのデータファイルのたくさんの列から、一つのヒストグラムを生成したい
 場合、plot の繰り返し (iteration) 機能を使うと便利でしょう。以下参照:
 `plot for`。例えば、3 列目から 8 列目までのデータを積み上げた形のヒス
 トグラムを生成する例:

       set style histogram columnstacked
       plot for [i=3:8] "datafile" using i title columnhead
3 ヒストグラムの色の割り当て (histogram color assignments)
?with histograms colors
?histograms colors
?styles histograms colors
?plotting styles histograms colors
 gnuplot は、ヒストグラム内の各要素の箱に自動的に色を割り当てますが、同
 値なデータには、それらがヒストグラムの行、または列にどこに現れたとして
 も首尾一貫した色を保持するようにします。色は、連続する線種 (linetype)
 の、まだ使用されていない次の線種、または `newhistogram` 命令の提示によ
 って初期化される最初の線種のいずれかから始まるものが使われます。

 この仕組みは、データソースが真に並列ではない (すなわち、いくつかのファ
 イルのデータが不完全) ために失敗することがあります。または、基本色の光
 度や彩度を変えることにより視覚化するためのデータの追加属性を与えたいか
 もしれません。自動的な色の割り当ての代わりに、各データ用の明示的な色の
 値を、2 番目の `using` 列で、`linecolor variable` か `rgb variable` の
 仕組みによって与えることができます。以下参照: `colorspec`。あなたのデ
 ータのレイアウトによって、色のカテゴリは、行のヘッダか、列のヘッダか一
 つのデータ列でありえます。多分、凡例 (key) のサンプルの色は、それに合
 うようにカスタマイズする必要があることに注意してください (以下参照:
 `keyentry`)。

 例: file_001.dat から file_008.dat は、1 列目はカテゴリ識別子の A, B,
 C, ... で、2 列目がデータ値になっています。すべてのファイルがすべての
 カテゴリに対する行を持っているとは限らず、よって完全な並列データ群では
 ありません。この場合、gnuplot は、間違って各ファイルの N 行目の値に同
 じ色を割り当てようとしてしまいます。その代わりに、1 列目のカテゴリに基
 づいた色を割り当てる例です。

      file(i) = sprintf("file_%03d.dat",i)
      array Category = ["A", "B", "C", "D", "E", "F"]
      color(c) = index(Category, strcol(c))
      set style data histogram
      plot for [i=1:8] file(i) using 2:(color(1)) linecolor variable

 さらに key のカスタマイズの生成も含む完全な例が、デモの中の
^ <a href="http://www.gnuplot.info/demo/histogram_colors.html">
 histogram_colors.dem
^ </a>
 にあります。
D histogram_colors 1

2 image
?plotting styles image
?style image
?with image
?image
?rgbimage
?rgbalpha
 描画スタイル `image`, `rgbimage`, `rgbalpha` は、いずれも一様に標本点
 を取った格子状データ値を、2 次元、または 3 次元中のある平面上に射影し
 ます。入力データは、既にあるビッマップ画像ファイル (PNG のような標準的
 なフォーマットから変換したものでよい) か、単純な数値配列です。
 これらの描画スタイルは、温度分布図 (heatmap) を作るのによく使われます。
 極座標での 2 次元温度分布図については、以下参照: `set polar grid`。

Ffigure_heatmap
 この図は、スカラー値の配列から温度分布を生成した例です (訳注: 図が表示
 されている場合)。現在のパレットを、各スカラー値から対応するピクセルの
 色への割り当てに使用します。以下も参照: `sparse`。
       plot '-' matrix with image
       5 4 3 1 0
       2 2 0 0 1
       0 0 0 1 0
       0 1 2 4 3
       e
       e

Ffigure_rgb3D
 入力 2 次元画像の各ピクセル (データ点) は、描画グラフ中では長方形、ま
 たは平行六面体となります。画像の各データ点の座標は、平行六面体の中心を
 決定します。すなわち、M x N 個のデータ集合は M x N ピクセルの画像を生
 成します。これは、M x N 個のデータ集合が (M-1) x (N-1) 要素を作成する
 pm3d の構造とは異なります。バイナリ画像データの格子の走査方向は、追加
 キーワードでさらに制御可能です。以下参照: `binary keywords flipx`,
 `keywords center`, `keywords rotate`。

Ffigure_scaled_image
 各ピクセルの x と y の大きさを示すことで、画像データを 2 次元描画座標
 系内の特定の長方形に収まるように伸縮することができます。以下参照:
 `binary keywords dx`, `dy`。右の画像を生成するのには、同じ入力画像を、
 それぞれ dx, dy, origin を指定して複数回配置しました。入力 PNG 画像で
 あるビルの絵は 50x128 ピクセルです。高いビルは、`dx=0.5 dy=1.5` で割り
 当てて描画し、低いビルは、`dx=0.5 dy=0.35` としています (訳注: 図が表
 示されている場合)。

 スタイル `image` は、グレイスケール (灰色階調)、またはカラーパレット値
 を含んでいるピクセルの入力を処理します。よって 2 次元描画 (`plot` コマ
 ンド) では 3 列のデータ (x,y,value) を、3 次元描画 (`splot` コマンド)
 では 4 列のデータ (x,y,z,value) が必要になります。

 スタイル `rgbimage` は、赤、緑、青の 3 つの色成分 (RGB) で記述されたピ
 クセルの入力を処理します。よって `plot` では 5 次元データ (x,y,r,g,b)
 が、`splot` では 6 次元データ (x,y,z,r,g,b) が必要になります。赤、緑、
 青の各成分は [0:255] の範囲内にあると仮定されます。
 これは、PNG や JPEG ファイルで使用されている仕組みに合っています (以下
 参照: `binary filetype`)。しかし、RGB 成分として [0:1] の範囲の実数値
 を取る仕組みを使用するようなデータファイルも中にはあります。そのような
 データで `rgbimage` スタイルを使用するには、まず `set rgbmax 1.0` とし
 てください。

=alpha channel
 スタイル `rgbalpha` は、赤、緑、青の RGB 成分に加えて、アルファ値 (透
 過パラメータ) の情報も含んだピクセルの入力を処理します。よって、`plot`
 では 6 次元データ (x,y,r,g,b,a) が、`splot` では 7 次元データ
 (x,y,z,r,g,b,a) が必要になります。赤、緑、青、およびアルファの各成分は
 [0:255] の範囲内にあると仮定されます。RGBA 成分が [0:1] の範囲の実数値
 であるデータを描画するには、まず `set rgbmax 1.0` としてください。

 rgbimage か rgbalpha のいずれかでの描画で色要素用にデータ 1 列しか指定
 しなかった場合は、それは、alpha=0 は不透明、alpha=255 が完全な透明を意
 味する、32 bit パックの ARGB データであるとみなします。このアルファ値
 の見方は、アルファ値が別の列で与えられる場合は古臭い慣習ですが、しかし、
 色を設定する必要のある個々のコマンド用の ARGB パックの仕組みには合って
 います。
3 透明化 (transparency)
?image transparency
?transparency
?alpha channel
 描画スタイル `rgbalpha` は、入力データの各ピクセルが [0:255] の範囲内
 のアルファ値を持っている必要があります。alpha = 0 のピクセルは完全な透
 明で、その下 (奥) の描画要素を全く変えません。alpha = 255 のピクセルは
 完全な不透明です。すべての出力形式は、これら 2 つの両極端な値をサポー
 トします。0 < alpha < 255 のピクセルは半透明で、半透明をサポートしてい
 ない出力形式では、その値を 0 か 255 のいずれかに丸めます。
3 image pixels
?plotting styles image pixels
?style image pixels
?with image pixels
?image pixels
?pixels
=heatmaps
 出力形式によっては、2 次元の長方形領域内での画像データ描画の、デバイス
 やライブラリに依存した最適化ルーチンを使用しますが、これは、中間ピクセ
 ル平滑化を行ったり、クリッピングがうまくなかったり、縁が欠けるなど、望
 ましくない出力を生成することがあります。例として、SVG 画像レンダリング
 時のウェブブラウザによる平滑化があります。
 キーワード `pixels` は、画像を 1 ピクセルずつ描画するような一般的なコ
 ードを使用するよう gnuplot に指示します。この描画モードでは、描画は遅
 く、大きな出力ファイルを生成しますが、どの出力形式でも共通的な見た目を
 作成してくれるます。これは、特にピクセル数の少ない温度分布図 (heatmap)
 で好まれるでしょう。
 例:
       plot 'data' with image pixels

2 impulses
?plotting styles impulses
?style impulses
?with impulses
?impulses
Ffigure_impulses
 `impulses` スタイルは、2 次元描画では y=0 から各点の y の値への、3 次
 元描画では z=0 から各点の z の値への、垂直な線分を表示します。y や z
 の値は負の値でもよいことに注意してください。データの追加列を各垂直線分
 の色の制御に利用できます。このスタイルを 3 次元描画で使用する場合、太
 い線 (linewidth > 1) を利用するとより効果的でしょう。それは 3 次元の棒
 グラフに似たものになります。

      1 列:  y
      2 列:  x  y     # [x,0] から [x,y] への線 (2D)
      3 列:  x  y  z  # [x,y,0] から [x,y,z] への線 (3D)

2 labels
?plotting styles labels
?style labels
?with labels
?labels
Ffigure_labels1
 スタイル `labels` は、データファイルから座標と文字列を読み込み、その文
 字列をその 2 次元、または 3 次元座標に置きます。これは基本的に 3 列、
 または 4 列の入力を必要とします。さらに余分な入力列は、文字列の回転角
 (キーワード `rotate variable`) や文字色 (以下参照: `textcolor variable`)
 のような、点毎に変動する属性値が指定されたとみなされます。

      3 列:  x  y  string    # 2 次元版
      4 列:  x  y  z  string # 3 次元版

 フォント、色、回転角やその他の描画テキストの属性は追加オプションとして
 指定可能です (以下参照: `set label`)。次の例は、入力ファイルの 1 列目
 から取った市の名前から作られる文字列を、4, 5 列目から取った地図座標に
 描画します。フォントサイズは、3 列目の値から計算していて、この場合はそ
 れは人口を意味しています。

   CityName(String,Size) = sprintf("{/=%d %s}", Scale(Size), String)
   plot 'cities.dat' using 5:4:(CityName(stringcolumn(1),$3)) with labels

 フォントサイズを、個々の市の名前に対して異なるサイズに合わせなくていい
 ならば、コマンドはもっと簡単です:

   plot 'cities.dat' using 5:4:1 with labels font "Times,8"

 labels に `hypertext` がついている場合、その文字列はマウスがそれに対応
 する点の上に来たときにだけ現われます。以下参照: `hypertext`。この場合
 ハイパーテキストの置き場所として機能する点を作るためにそのラベルの
 `point` 属性を有効にする必要があります:

   plot 'cities.dat' using 5:4:1 with labels hypertext point pt 7

Ffigure_labels2
 スタイル `points` であらかじめ定義されている点の記号が適切でない、ある
 いは十分でない場合、その代わりとしてスタイル `labels` を使うこともでき
 ます。例えば、以下は単一文字として選択される組を定義し、3 列目のデータ
 値に対応するその一つをグラフの各点に割り当てる例です (訳注: 以下のサン
 プルの <UTF-8 文字列> の部分には、元々、丸に中点記号や□、＋、トランプ
 記号などの UTF-8 文字列が並んでいますが、この日本語訳とは両立しないた
 め取り除いています):

   set encoding utf8
   symbol(z) = "<UTF-8 文字列>"[int(z):int(z)]
   splot 'file' using 1:2:(symbol($3)) with labels

 以下は、4 列目の値を可変値の回転角とし、5 列目の値を文字色 ("tc") とす
 るラベルの使用例です。可変値の色指定は、常に `using` 指定の最後の列か
 ら取ることに注意してください。

   plot $Data using 1:2:3:4:5 with labels tc variable rotate variable

2 lines
?plotting styles lines
?style lines
?with lines
?lines
Ffigure_lines
 `lines` スタイルは隣接する点を真直な線分で結びます。
 これは、2 次元描画でも、3 次元描画でも使用でき、基本的には、1 列か 2
 列か 3 列かの入力データを必要とします。
 余分な入力列は、線の色の変更などの情報が提供されたものとして使用されま
 す (以下参照: `rgbcolor variable`)。

 2 次元 ("using" 指定なし) の場合
      1 列:  y       # 行番号による暗黙の x
      2 列:  x  y
 3 次元 ("using" 指定なし) の場合
      1 列:  z       # x は暗黙の行番号、y は index から
      3 列:  x  y  z

 以下も参照: `linetypes`, `linewidth`, `linestyle`。
2 linespoints
?plotting styles linespoints
?style linespoints
?with linespoints
?style lp
?with lp
?linespoints
?lp
?pointinterval
?pointnumber
Ffigure_linespoints
 `linespoints` スタイル (省略形 `lp`) は、隣接する点を真っ直ぐな線分で
 結び、その後で最初に戻って各点に小さな記号を描きます。点記号は、
 `set pointsize` で決まるデフォルトの大きさで描きますが、plot コマンド
 上で点のサイズを指定したり、あるいは入力データの追加列で個別の点サイズ
 を指定することもできます。追加の入力列は、個別の線の色などの情報を提供
 するのにも使われます。以下参照: `lines`, `points`。

 グラフのすべての点に記号の印をつけるか否かを制御する 2 つのキーワード
 `pointinterval` (省略形 `pi`), `pointnumber` (省略形 `pn`) があります。

 `pi N` あるいは `pi -N` は、N 個毎に 1 つだけ記号を置くよう gnuplot に
 指示します。負の値を指定すると、記号の下の線分の部分を消します。その消
 す部分のサイズは `set pointintervalbox` で制御できます。

 `pn N` あるいは `pn -N` は、データ点のうち N 個だけラベル付けするよう
 gnuplot に指示します。点はそのデータ全体に渡って均等な間隔に取ります。
 `pi` 同様、負の値を指定すると、記号の下の線分の部分を消します。

2 マスキング (masking)
?plotting styles mask
?plot with mask
?with mask
?masking
 描画スタイル `with mask` は、マスキング領域を定義するのに使います。こ
 れは、同じ `plot`, `splot` コマンド上で後で指定した pm3d 曲面や画像に
 適用できます。入力データは、1 つ、または複数の多角形の頂点を定義する
 [x,y] 座標列、または [x,y,z] 座標列として解釈します。描画スタイル
 `with polygons` と同様に、多角形は空行で分離します。マスクが 3 次元描
 画コマンド (splot) の一部である場合、入力には z の値が必要ですが、しか
 しそれは現在のところ全く使いません。

 plot コマンド上にマスク定義がある場合、その後の同じコマンド上の image
 描画、pm3d 曲面が、キーワード `mask` を追加することでマスクされます。
 マスクを定義していなければ、そのキーワードは無視します。

 以下の例は、点の集合を囲む凸包を使い、ある pm3d 曲面に対応する領域をマ
 スクする方法を示します。
Ffigure_mask
^<p align="center"><picture>
^   <source srcset="figure_mask.webp" type="image/webp">
^   <img src="figure_mask.png" alt="figure_mask">
^   </picture><p>
    set table $HULL
    plot $POINTS using 1:2 convexhull
    unset table

    set view map
    set multiplot layout 1,2
    splot $POINTS using 1:2:3 with pm3d, \
          $POINTS using 1:2:(0) nogrid with points
    splot $HULL using 1:2:(0) with mask, \
          $POINTS using 1:2:3 mask with pm3d
    unset multiplot
 最初のパネルに対するコマンド `splot` は、元の点から dgrid3d で生成した
 マスクされていない曲面を描画し、その後で点自身を順に描画します。2 つ目
 のパネルに対するコマンド `splot` はマスクした曲面を描画します。マスク
 の定義 (`with mask` での plot) は最初に行わなければならず、それを適用
 する pm3d 曲面はその後であることに注意してください (描画スタイル
 `with pm3d` にキーワード `mask` をつけて変更)。
 この例のより完全な版は、デモ集合
^ <a href="http://www.gnuplot.info/demo/mask_pm3d.html">
 mask_pm3d.dem
^ </a>
 内にあります。

 ここには示しませんが、一つのマスクが複数の多角形領域を含み得ます。

 マスキングコマンドは試験段階です。詳細は、将来のリリースで変更されるか
 もしれません。

2 parallelaxes
Ffigure_parallel
?plotting styles parallelaxes
?plot with parallelaxes
?with parallelaxes
?parallelaxes
?parallel
 平行座標描画 (parallel axis plot, parallel coordinates plot とも呼ばれ
 る) は、多次元データの相関を視覚化します。入力データの個々の列は、それ
 ぞれ別々のスケールの縦軸に割り当てられます。一つのファイルのすべての列
 を描画する場合は、グラフの折れ線 1 本が、そのファイルのデータの 1 行分
 の値を表しています。
 それらを数種類に分類して色を割り当てることはよく行われますが、
 それは、その分類と軸との間の関係を視覚的に調査することを可能にします。

 書式:

     set style data parallelaxes
     plot $DATA using col1{:varcol1} {at <xpos>} {<line properties}, \
          $DATA using col2, ...

 変更: gnuplot バージョン 5.4 では、描画スタイル parallelaxes の書式を
 変更しています。改良された書式では、平行座標軸数の制限をなくすことが可
 能です。

      gnuplot 5.2:   plot $DATA using 1:2:3:4:5 with parallelaxes
      gnuplot 5.4:   plot for [col=1:5] $DATA using col with parallelaxes

 新しい書式では、以下の例に見られるように、平行座標軸の x 軸位置での明
 示的な配置も可能になっています。明示的な x 座標指定がなければ、N 番目
 の軸は x=N の場所に置かれます。

      array xpos[5] = [1, 5, 6, 7, 11, 12]
      plot for [col=1:5] $DATA using col with parallelaxes at xpos[col]

 デフォルトでは、gnuplot は自動的に個々の軸の範囲、スケールを入力データ
 から決定しますが、通常の `set axis range` コマンドによってそれをカスタ
 マイズすることも可能です。以下参照: `set paxis`。
2 極座標描画 (Polar plots)
=polar
Ffigure_polar
 極座標描画 (polar) は、plot コマンドを入力する前に現在の座標系を極座標
 に変更することによって生成します。オプション `set polar` は、入力する
 2 次元座標を <x>,<y> の代わりに <角>,<半径> と解釈することを gnuplot
 に指示します。すべてではないですが、多くの 2 次元描画スタイルが極座標
 モードでも機能します。図は、描画スタイル `lines` と `filledcurves` の
 組み合わせを示しています。(訳注: 図が表示されている場合) 以下参照:
 `set polar`, `set rrange`, `set size square`, `set theta`, `set ttics`。

?polar heatmap
 極座標での温度分布_図は、スタイル `with surface` と `set polar grid`
 を合わせて使用することで生成できます。
Ffigure_polar_grid
      set size square
      set angle degrees
      set rtics
      set grid polar
      set palette cubehelix negative gamma 0.8
      set polar grid gauss kdensity scale 35
      set polar grid theta [0:190]
      plot DATA with surface, DATA with points pt 7

2 points
?plotting styles points
?style points
?with points
?points
?point type
?pointtype
Ffigure_points
 `points` スタイルは各点に小さな記号を表示します。すべての記号のデフォ
 ルトの大きさを変更するにはコマンド `set pointsize` を使います。デフォ
 ルトの点種は、線種と同じものになります。以下参照: `linetypes`。plot コ
 マンドに `using` 指定がない場合は、入力データ列は暗黙のうちに
      x y pointsize pointtype color
 の順で解釈されます。最初の 2 つ (x, y) の後ろのすべての列は省略可能で、
 それらは追加の描画属性 `pointsize variable`, `pointtype variable` 等に
 対応します。

 最初の 8 つの点種は、すべての出力形式で共通ですが、より多くの点種を個
 別にサポートする出力形式もあります。現在の出力形式の設定でどのような点
 種が用意されているかを見るには、コマンド `test` を使用してください。

 また、下の例のようにして、任意の印字可能文字を点種番号の代わりに使用す
 ることもできます。点種として、任意の UTF-8 文字を使用できます (utf8 を
 サポートしている必要あり)。以下参照: `escape sequences`。より長い文字
 列は、描画スタイル `points` ではなく `labels` を使えば出力できます。

      plot f(x) with points pt "#"
      plot d(x) with points pt "\U+2299"

?points variable
?with points variable
=variable
?variable
?pointtype variable
?pointsize variable
 plot コマンド上でキーワード `pointtype`, `pointsize`, `linecolor` を使
 う際、番号の代わりにキーワード `variable` を追加することができます。こ
 の場合、各点の対応する属性値を入力データの追加列から取得します。可変
 (variable) pointsize 値は、常に `using` 指定で与えられる最初の追加列か
 ら取り、可変 color 値は、常に最後の追加列から取ります。以下参照:
 `colorspec`。各点に対して 3 つの属性をすべて指定する場合は、入力データ
 列指定の順番は以下のようになります。

      plot DATA using x:y:pointsize:pointtype:color \
           with points lc variable pt variable ps variable

 注意: 「ユーザ定義変数」の方の variable に関する情報については、以下
 参照: `variables`。
2 polygons
?plotting styles polygons
?style polygons
?with polygons
?polygons
 2 次元グラフ:

      plot DATA {using 1:2} with polygons

 `plot with polygons` は、現在は `plot with filledcurves closed` として
 処理されます。各多角形には、3 列目の値を与え、キーワード `lc variable`
 を指定する (その値を linetype と解釈) か、`lc rgb variable` を指定する
 (その値を 24 ビット RGB 色と解釈) ことで、個別の色を割り当てることがで
 きます。多角形の最初の頂点の色の値のみが使用されます。境界の線種は、も
 しあれば塗り潰しスタイル (fill style) から取ります。

 3 次元グラフ:

      splot DATA {using x:y:z} with polygons
            {fillstyle <fillstyle spec>}
            {fillcolor <colorspec>}

 `splot with polygons` は、3 次元空間の個々の三角形、四角形、およびそれ
 以上の多角形を描画するのに pm3d を使用します。これらは 3 次元曲面の一
 面や単独の形状となり得ます。このルーチンは、頂点が一つの平面に乗ってい
 なければいけません。
 個々の多角形を定義する頂点は、入力ファイルの連続する行から読み込みます。
 空行は多角形同士を分離します。

 塗り潰しスタイルと色は、splot コマンド上で指定できますが、そうでなけれ
 ば大域的な塗り潰しスタイルの `set style fill` の設定を使用します。pm3d
 ルーチンの制限のため、`set pm3d border` による一つの境界線スタイルが、
 すべての 3 次元多角形に適用されますが、この制限は将来の版の gnuplot で
 は取り除かれるでしょう。

 各多角形には、4 列目の値を与え、キーワード `lc variable` を指定する
 (その値を linetype と解釈) か、`lc rgb variable` を指定する (その値を
 24 ビット RGB 色と解釈) ことで、個別の色を割り当てることができます。多
 角形の最初の頂点の色の値のみが使用されます。

 面には、pm3d のソート順と光源モデルを適用しますので、常に、
 `set pm3d depthorder` を使う方がいいかもしれせん。

Ffigure_polygons
      set xyplane at 0
      set view equal xyz
      unset border
      unset tics
      set pm3d depth
      set pm3d border lc "black" lw 1.5
      splot 'icosahedron.dat' with polygons \
            fs transparent solid 0.8 fc bgnd

2 rgbalpha
?plotting styles rgbalpha
?style rgbalpha
?with rgbalpha
 以下参照: `image`。
2 rgbimage
?plotting styles rgbimage
?style rgbimage
?with rgbimage
 以下参照: `image`。
2 扇片 (sectors)
?plotting styles sectors
?with sectors
?sectors
?windrose
Ffigure_sector_definition
 2 次元描画スタイル `with sectors` は、入力データの 1 行毎に一つの環状
 の扇片 ("sector") を描画します。各扇片の形は、データ値として要求する 4
 つの値で決定します。この扇片の環の部分の原点を、データ値に追加指定する
 こともできます。扇片毎の色を追加列として指定することもできます。

 この描画スタイルは、直交座標で、または極座標モード (`set polar`) の元
 で使用できます。方位角と扇の中心角の単位、解釈は、`set angles` と
 `set theta` で制御します。

 データの 1,2 列目は、その扇片の一つの角の方位 (theta) と半径 (r) です。
#TeX \newline
 データの 3,4 列目は、その扇片の方位の変位 (中心角; sector_angle) と半
 径の変位 (動径方向の幅; annular_width) です。
#TeX \newline
 データの 5,6 列目を指定した場合は、それは扇形の中心の座標を意味し (デ
 フォルトは [0,0])、直交座標では [x,y]、極座標モードでは [theta,r] と解
 釈します。

 書式:
     plot DATA {using specifier} {units xy | units xx | units yy}

 using 指定
     4 列: azimuth radius sector_angle annular_width
     5 列: azimuth radius sector_angle annular_width color
     6 列: azimuth radius sector_angle annular_width center_x center_y
     7 列: azimuth radius sector_angle annular_width center_x center_y
             color

 x 軸と y 軸スケールが等しくない場合、x,y 座標の環状の全体の概形は円で
 はなく楕円となって現れることに注意してください。等しくない軸のスケール
 に関して楕円 (ellipse) と同じ仕組みを使用して、環状の概形、および扇片
 の幅の外見を正しく合わせることができます。コマンドラインに `units xx`
 を追加すると、現在の x 軸のスケールを x, y 両方に等しく適用したかのよ
 うに扇片を描きます。同様に、`units yy` は、現在の y 軸のスケールを x,y
 両方に等しく適用したかのように扇片を描きます。
 以下参照: `set isotropic`, `set style ellipse`。

Ffigure_windrose
 with sectors での描画は、直交座標での描画スタイルである `boxes` (風配
 図 (wind rose) の図を参照)、`boxxyerror` と `image pixels` (`heatmaps`
 の例を参照) に対する極座標での同等品を提供します。sector での描画は直
 交座標モードでのグラフレイアウトと両立するため、一つのグラフ上の異なる
 場所に複数のグラフを配置することが可能ですが、それは他の極座標モードグ
 ラフスタイルでは不可能です。

 ここに示しているのは、sectors を使って風配図 (wind rose) を生成する例
 です。極座標温度分布図を含む他の応用例としては、ダイヤルチャート、円グ
 ラフ/円環グラフ、そして 極座標でのデータ点に対する環状のエラーボックス
 です。これらすべての加工された例は、
^ <a href="http://www.gnuplot.info/demo/sectors.html">
 sector のデモ
^ </a>
 に置かれています。

2 spiderplot
?plotting styles spiderplot
?with spiderplot
?spiderplot
?radar chart
 クモの巣グラフ (spiderplot) は、本質的に、平行座標描画 (parallel axis)
 で、その軸を垂直方向ではなく放射状に配置したものです。これはよく「レー
 ダーチャート」(`radar chart`) とも呼ばれます。gnuplot 内部では、これは
 コマンド `set spiderplot` で確立される座標系での作業が必要となりますが、
 これは偏角座標が平行軸番号によって暗黙に決まることを除けば `set polar`
 に似ています。見た目や、ラベル付け、軸の目盛りの配置は、`set paxis` で
 制御できます。このスタイルのさらなる設定は、`set style spiderplot`、
 `set grid`、および plot コマンドの個々の指定で行えます。

 各クモの巣グラフは、列データではなく行データに対応するため、通常の方法
 での凡例 (key) タイトルの生成は意味がありません。代わりに、描画要素が
 タイトル文字列を持っていれば、その文字列を対応する軸のラベルに使用しま
 す。これは、事前の `set paxis n label "Foo"` をすべて上書きします。凡
 例にタイトルを配置するには、個別の `keyentry` コマンドを使用するか、ま
 たは using 指定で `key(column)` を使って入力ファイル列から文字列を展開
 する方法が使えます。

 以下の図は、軸が 5 つのクモの巣グラフで、それぞれ 5 つの点数で特徴付け
 られる複数のものを比較するのに使います。$DATA の各行は、グラフ上に新し
 い多角形を生成します。
Ffigure_spiderplot

      $DATA << EOD
               A      B      C      D      E      F
      George  15     75     20     43     90     50
      Harriet 40     40     40     60     30     50
      EOD
      set spiderplot
      set style spiderplot fs transparent solid 0.2 border
      set for [p=1:5] paxis p range [0:100]
      set for [p=2:5] paxis p tics format ""
      set             paxis 1 tics font ",9"
      set for [p=1:5] paxis p label sprintf("Score %d",p)
      set grid spiderplot
      plot for [i=1:5] $DATA using i:key(1)

3 newspiderplot
?newspiderplot
?spiderplot newspiderplot
 通常、`with spiderplot` による plot コマンドに与えられるデータ列の個々
 の値は、1 個の多角形に対するそれぞれの頂点に対応します。1 つのグラフ上
 に、複数の多角形を描くには、それらを `newspiderplot` で分離して指定し
 ます。
 例:
      # 以下は 10 個の頂点を持つ 1 つの多角形
      plot for [i=1:5] 'A' using i, for [j=1:5] 'B' using j
      # 以下は 5 個の頂点を持つ 2 つの多角形
      plot for [i=1:5] 'A' using i, newspiderplot, for [j=1:5] 'B' using j

2 steps
?plotting styles steps
?style steps
?with steps
?steps
Ffigure_steps
 `steps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で隣
 り合う点をつなぎます: 1 本目は (x1,y1) から (x2,y1) まで、2 本目は
 (x2,y1) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。曲線とベースラインである y=0 との
 間の領域を塗り潰すには、`fillsteps` を使用してください。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

2 surface
?plotting styles surface
?style surface
?with surface
 描画スタイル `with surface` には、2 種類の利用法があります。

 3 次元グラフでは、`with surface` は常に曲面を生成します。
 3 次元データ集合が格子集合 (grid) と認識できれば、gnuplot はデフォルト
 では、`with lines` を `with surface` に対する同義語として、格子曲面を
 要求したかのように暗黙に描画スタイル `with lines` で処理します。しかし
 コマンド `set surface explicit` はこの処理を抑制し、その場合
 `with surface` と `with lines` は異なるスタイルとなり、同じグラフ内で
 利用することもできます。

 格子点とは認識されない 3 次元の点がある場合、最初に適切な格子に合わせ
 ることが可能です。以下参照: `set dgrid3d`。

 2 次元極座標グラフでは、`with surface` は、データの色塗り格子表現を生
 成するのに使います。その曲面の生成は、コマンド `set polar grid` で制御
 します。

2 vectors
?plotting styles vectors
?style vectors
?with vectors
?vectors
Ffigure_vectors
 2 次元の `vectors` スタイルは (x,y) から (x+xdelta,y+ydelta) までのベ
 クトルを書きます。3 次元の `vectors` スタイルも同様ですが、データは基
 本的に 6 列必要です。いずれの場合も、入力列を追加 (2D では 5 列目、3D
 では 7 列目) すると、それらは各データ点毎の variable color 情報 (以下
 参照: `linecolor`, `rgbcolor variable`) として使われます。
 各ベクトルの先端には小さな矢先も書かれます。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  z  xdelta  ydelta  zdelta

 キーワード "with vectors" は、その後ろに、arrow スタイル属性を直接書い
 たり、事前に定義した arrow スタイルを参照したり、あるいは別の入力列か
 ら各ベクトルに対する適用したい arrow スタイルのインデックスを読むよう
 指定したりすることができます。下の最初の 3 つの例を見てください。

 例:

      plot ... using 1:2:3:4 with vectors filled heads
      plot ... using 1:2:3:4 with vectors arrowstyle 3
      plot ... using 1:2:3:4:5 with vectors arrowstyle variable
      splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2

 注意: plot コマンド内にキーワード `arrowstyle` と他の線属性を混在させ
 ることはできません。arrow スタイルに `lc variable` か `lc rgb variable`
 がある場合、色の値用の追加列が必要です。

 vectors スタイルを使っての splot は `set mapping cartesian` のみでサポ
 ートされています。
 `set clip one` と `set clip two` は 2 次元のベクトルの描画に影響を与え
 ます。以下参照: `set clip`, `arrowstyle`。

 2 次元描画スタイルの以下も参照: `with arrows`。これは、各矢印を
 x:y:length:angle の形式で指定する以外は `with vectors` と同じです。

2 xerrorbars
?plotting styles xerrorbars
?style xerrorbars
?with xerrorbars
?xerrorbars
Ffigure_xerrorbars
 `xerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorbars` は、水平の誤差指示線 (error bar) が表示される以外は
 `points` と同じです。各点 (x,y) において (xlow,y) から (xhigh,y) まで、
 または (x-xdelta,y) から (x+xdelta,y) までの線分が引かれますが、これら
 はいくつのデータ列が与えられるかによって変わります。誤差指示線の端の刻
 みの印の見た目は、`set errorbars` で制御できます。
 点と誤差指示線の間の隙間は、`set pointintervalbox` で制御します。
 このスタイルは基本的に、3 列か 4 列のデータが必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) するとそれらを variable color として使います。
 このスタイルでは、variable point 属性は使えません。

2 xyerrorbars
?plotting styles xyerrorbars
?style xyerrorbars
?with xyerrorbars
?xyerrorbars
Ffigure_xyerrorbars
 `xyerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorbars` は、水平、垂直の誤差指示線 (error bar) も表示される以外
 は `points` と同じです。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y) まで、または
 (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y) までの線分が引
 かれますが、これらはいくつのデータ列が与えられるかによって変わります。
 誤差指示線の端の刻みの印の見た目は、`set errorbars` で制御できます。
 点と誤差指示線の間の隙間は、`set pointintervalbox` で制御します。
 これは 4 列か、6 列のデータが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` 指定を使って適切な形に直さないといけません。例えばデ
 ータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のようにしま
 す:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 入力列を追加 (5,7 列目) するとそれらを variable color として使います。
 このスタイルでは、variable point 属性は使えません。

#TeX \newpage
2 xerrorlines
?plotting styles xerrorlines
?style xerrorlines
?with xerrorlines
?xerrorlines
Ffigure_xerrorlines
 `xerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorlines` は `linespoints` に似ていますが、水平の誤差線が描かれる
 ことが違います。各点 (x,y) で、データ列の個数に応じて (xlow,y) から
 (xhigh,y) まで、または (x-xdelta,y) から (x+xdelta,y) までの線分が描か
 れます。誤差線の端の刻みの印の見た目は、`set errorbars` で制御できます。
 基本的には、3 列か 4 列のデータが必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) するとそれらを variable color として使います。
 このスタイルでは、variable point 属性は使えません。

2 xyerrorlines
?plotting styles xyerrorlines
?style xyerrorlines
?with xyerrorlines
?xyerrorlines
Ffigure_xyerrorlines
 `xyerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorlines` は `linespoints` に似ていますが、水平と垂直の誤差線も描
 かれることが違います。各点 (x,y) で、データ列の個数に応じて、
 (x,y-ydelta) から (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y)
 まで、あるいは (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y)
 までの線分が描かれます。誤差線の端の刻みの印の見た目は、`set errorbars`
 で制御できます。これは、4 列か 6 列の入力データが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` 指定を使って適切な形に直さないといけません。例えばデ
 ータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のようにしま
 す:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 入力列を追加 (5,7 列目) するとそれらを variable color として使います。
 このスタイルでは、variable point 属性は使えません。

2 yerrorbars
?plotting styles yerrorbars
?plotting styles errorbars
?style yerrorbars
?with yerrorbars
?style errorbars
?with errorbars
?yerrorbars
=errorbars
Ffigure_yerrorbars
 `yerrorbars` (または `errorbars`) スタイルは 2 次元のデータ描画のみで
 利用可能です。`yerrorbars` は、垂直の誤差指示線 (error bar) が表示され
 る以外は `points` に似ています。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) まで、または (x,ylow) から (x,yhigh) までの線分が引かれま
 すが、これらはいくつのデータ列が与えられるかによって変わります。誤差指
 示線の端の刻みの印の見た目は、`set errorbars` で制御できます。点と誤差
 線との隙間は `set pointintervalbox` で制御します。

      2 列:  [暗黙の x]  y  ydelta
      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加すると、それらは可変 (variable) pointsize, 可変 pointtype,
 可変色 (variable color) の情報として使われます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar デモ。
^ </a>

2 yerrorlines
?plotting styles yerrorlines
?plotting styles errorlines
?style yerrorlines
?with yerrorlines
?style errorlines
?with errorlines
?yerrorlines
?errorlines
Ffigure_yerrorlines
 `yerrorlines` (または `errorlines`) スタイルは 2 次元のデータ描画のみ
 で利用可能です。`yerrorlines` は `linespoints` に似ていますが、垂直の
 誤差線が描かれることが違います。各点 (x,y) で、データ列の個数に応じて
 (x,y-ydelta) から (x,y+ydelta) まで、または (x,ylow) から (x,yhigh)
 までの線分が描かれます。誤差線の端の刻みの印の見た目は、
 `set errorbars` で制御できます。これは、3 列か 4 列の入力が必要です。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。
 さらなる入力列は、variable point size, variable point type, variable
 color の情報として使われます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 エラーバーのデモ
^ </a>
#TeX \newpage
2 3 次元描画 (3D plots)
?3D plots
?plotting styles 3D plots
=3D
 3 次元グラフは、コマンド `plot` ではなくコマンド `splot` を使って生成
 します。多くの 2 次元描画スタイル (points, images, impulse, labels,
 vectors) は、z 座標データ列を追加指定すれば 3 次元でも使えます。2 次元
 射影グラフのみが欲しい場合でも、`splot` コマンドを使って生成しなければ
 いけない描画型 (pm3d coloring, surfaces, contours) も中にはあります。
3 曲面描画 (surface plots)
?surface plots
=surface
Ffigure_surface+contours
 描画スタイル `splot with lines` や `splot with surface` はいずれも曲面
 を格子線で生成します。曲面の塗り潰しは、スタイル `splot with pm3d` で
 行うことができます。曲面は通常、それが 3 次元の曲面であるとはっきりわ
 かるような適切な視方向から表示されます。以下参照: `set view`。
 その場合、X, Y, Z 軸はすべて描画内に表示されます。3 次元的な錯覚は、隠
 線処理により、より増幅されます。以下参照: `hidden3d`。
 コマンド `splot` は、定数の Z 値に対する等高線を計算し描画することもで
 きます。これらの等高線は、曲面それ自体の上に書くこともできますし、XY
 平面へ射影することもできます。以下参照: `set contour`。
3 2 次元射影 (set view map)
?2D projection (set view map)
Ffigure_mapcontours
 コマンド `splot` の特別な場合として、グラフの Z 軸に沿った xy 平面への
 射影による、Z 座標の 2 次元曲面への地図作成 (map) があります。以下参照:
 `set view map`。この描画モードは、等高線の描画や温度分布 (heatmap) の
 生成に便利でしょう。以下の図は描画スタイル `lines` を一度、`labels` を
 一度描画した等高線を示しています (訳注: 図が表示されている場合)。
3 PM3D 描画 (PM3D plots)
?PM3D PLOTS
Ffigure_pm3dsolid
 3 次元曲面は、線分でなく、単色の pm3d 四辺形を使って描画することもでき
 ます。その場合、隠面処理はありませんが、各面要素を背景から前面に向かっ
 て描くことで同様の効果が得られます。以下参照: `set pm3d depthorder`。
 pm3d 曲面は、デフォルトでは滑らかな連続的なカラーパレットを使って色付
 けします (以下参照: `set palette`) が、単色の曲面を指定することもでき
 ますし、この図にあるように (訳注: 図が表示されている場合)、上の面と下
 の面に異なる単色を指定することもできます。以下参照: `pm3d fillcolor`。
 hidden3d モードでの線分の切り取りとは違い、pm3d 曲面は現在の zrange の
 範囲に滑らかにクリッピングできます。以下参照: `set pm3d clipping`。

#TeX \newpage
2 柵グラフ (Fence plots)
?fenceplots
=zerrorfill
Ffigure_fenceplot
 柵グラフ (fence plot) は、複数の 2 次元グラフを、その Y 座標は揃え、そ
 れぞれを区別するために X に沿ってはずらした形で結合したものです。土台
 の値から個々のグラフの Z 座標までの間の領域を塗り潰すことで、Y 方向の
 整列と Z 座標の高さの違いの見た目を強調します。gnuplot でこの形式のグ
 ラフを書くにはいくつかの方法があります。最も単純なのは、5 列の形式の
 `zerrorfill` スタイルを利用する方法です。i で添字化された複数の曲線 z
 = Fi(y) があるとき、`splot with zerrorfill` で以下のような入力列を使え
 ば柵グラフを書くことができます:
      i y z_base z_base Fi(y)

2 ボクセルデータのモザイク型曲面 (isosurface)
?plotting styles isosurface
?style isosurface
?with isosurface
?isosurface
Ffigure_isosurface
 この 3 次元描画スタイルには、値の入っているボクセル格子データが必要で
 す (以下参照: `set vgrid`, `vfill`)。要求する値レベルに対応する非整数
 格子座標を評価する際は、ボクセル格子値の線形補間を使用します。それらの
 点は、モザイク型曲面を生成するのに使用します。その曲面を構成する切片は、
 `set pm3d` で色、透過、境界属性などが制御できるよう pm3d 多角形として
 描画します。一般に、その曲面は、その切片が細い境界で与えられ、その境界
 が塗り潰しの色よりも暗い色であれば、見た目がわかりやすくなります。デフ
 ォルトでは、モザイク型曲面は四角形と三角形を混ぜて使いますが、三角形の
 みを使いたい場合は、以下参照: `set isosurface`。
 例:
      set style fill solid 0.3
      set pm3d depthorder border lc "blue" lw 0.2
      splot $helix with isosurface level 10 fc "cyan"

2 3 次元での曲線間の塗り潰し (Zerrorfill)
?plotting styles zerrorfill
?style zerrorfill
?with zerrorfill
?zerrorfill
 書式:

      splot DATA using 1:2:3:4[:5] with zerrorfill {fc|fillcolor <colorspec>}
                 {lt|linetype <n>} {<line properties>}

 描画スタイル `zerrorfill` は、2 次元の描画スタイルの一つの変種のような
 ものです。これは、2 つの関数の間、または同じ x, y に対して 2 つの z の
 値を点を与えて得られるデータの折れ線の間の領域を塗り潰します。これは、
 4 列か 5 列の入力が必要です。

      4 列:  x  y  z  zdelta
      5 列:  x  y  z  zlow  zhigh

Ffigure_zerror
 zlow と zhigh の間の領域を塗り潰し、その後 z の値のところに線を描きま
 す。デフォルトでは、その線と塗り潰しには同じ色を使いますが、その色は
 splot コマンド上で変更できます。塗り潰しの設定は、大域的な fill style
 の影響も受けます。以下参照 `set style fill`。

 splot コマンドに複数の曲線を指定した場合は、後に描いた曲線が、前のすべ
 ての曲線を隠してしまう可能性があります。見る人側の手前の曲線のみが隠す
 ように適切な深さ順の並べかえを行うには、`set pm3d depthorder base` を
 使用してください。残念ながら、これは z の値に対応するすべての折れ線を
 描いた後に、すべての領域の塗り潰しを行います。よって、折れ線を見えるよ
 うにして、かつ領域の塗り潰しの深さ順の並べかえを行うには、領域の塗り潰
 しは部分的に透過 (transparent) させるか、単色塗り (solid fill) の代わ
 りにパターン塗り (pattern fill) を使用するといいかもしれません。

 以下の最初の 2 つの例の塗り潰し領域は、同じものになります。

      splot 'data' using 1:2:3:4 with zerrorfill fillcolor "grey" lt black
      splot 'data' using 1:2:3:($3-$4):($3+$4) with zerrorfill
      splot '+' using 1:(const):(func1($1)):(func2($1)) with zerrorfill
      splot for [k=1:5] datafile[k] with zerrorfill lt black fc lt (k+1)

 この描画スタイルは、柵グラフ (fence plot) を作成するのにも使えます。
 以下参照: `fenceplots`。

2 アニメーション (Animation)
?animation
 gnuplot の対話型出力形式 (qt, win, wxt, x11, aqua) ではいずれも、コマ
 ンドラインやスクリプトから連続するフレームの描画を行うことでアニメーシ
 ョンを表示することができます。

 マウスが使えない出力形式でも、ある種のアニメーションをサポートするもの
 があります。以下参照: `term sixelgd animate`, `term domterm animate`。

 アニメーションをファイルとして保存して、後で手元で再生したり Web ペー
 ジに埋め込んだりできる出力形式が 2 つあります。以下参照:
 `term gif animate`, `term webp`。

^    <p align="center">
^      <picture>
^        <source srcset="figure_spinning_d20.webp" type="image/webp">
^        <img src="figure_static_d20.png">
^      </picture>

 例:

      unset border; unset tics; unset key; set view equal xyz
      set pm3d border linecolor "black"

      set term webp animate delay 50
      set output 'spinning_d20.webp'
      do for [ang=1:360:2] {
          set view 60, ang
          splot 'icosahedron.dat' with polygons fc "gold"
      }
      unset output

1 コマンド (Commands)
?commands
 このセクションでは `gnuplot` が受け付けるコマンドをアルファベット順に
 並べています。このドキュメントを紙に印刷したものは全てのコマンドを含ん
 でいますが、対話型で参照できるドキュメントの方は完全ではない可能性があ
 ります。実際、この見出しの下に何のコマンドも表示されないシステムがあり
 ます。

 ほとんどの場合、コマンド名とそのオプションは、紛らわしくない範囲で省略
 することが可能です。すなわち、"`plot f(x) with lines`" の代わりに
 "`p f(x) w li`" とすることができます。

 書式の記述において、中カッコ ({}) は追加指定できる引数を意味し、
 縦棒 (|) は互いに排他的な引数を区切るものとします。
2 Break
?commands break
?break
 コマンド `break` は、`do`, `while` 文の繰り返し実行部分のカッコ内での
 み意味を持ちます。このコマンドは、その中カッコ内の残りの命令をスキップ
 し、繰り返しを中断し、その閉じカッコの次の文から実行を再開します。以下
 も参照: `continue`。
2 cd
?commands cd
?cd
 `cd` コマンドはカレントディレクトリを変更します。

 書式:
       cd '<ディレクトリ名>'

 ディレクトリ名は引用符に囲まれていなければなりません。

 例:
       cd 'subdir'
       cd '..'

 バックスラッシュ (\) は二重引用符内 (") では特別な意味を持ってしまうた
 めにエスケープする必要がありますので、Windows ユーザには単一引用符を使
 うことを勧めます。例えば、
       cd "c:\newdata"
 では失敗しますが、
       cd 'c:\newdata'
       cd "c:\\newdata"
 なら期待通りに動くでしょう。
2 call
?commands call
?call
 `call` コマンドは、読み込むファイル名の後ろに、9 つまでのパラメータを
 与えることができることを除けば `load` コマンドと等価です。

      call "inputfile" <param-1> <param-2> <param-3> ... <param-9>

 現在の gnuplot は、文字列変数 ARG0, ARG1, ..., ARG9 と、整数変数 ARGC
 を提供します。`call` コマンドを実行すると、ARG0 には入力ファイル名が、
 ARGC にはパラメータ数が設定され、ARG1 から ARG9 にはコマンドラインに並
 べられたパラメータの値が読み込まれます。

 通常パラメータ ARG1 ... ARG9 は文字列値として保存されるので、それをマ
 クロ展開して参照することもできます。しかし、多くの場合、それらは他の変
 数と同様に利用する方がより自然でしょう。

 パラメータ ARG1 ... ARG9 の文字列表現と平行して、そのパラメータ自身を
 配列 ARGV[9] にも保存します。以下参照: `ARGV`。

 非推奨: 5.0 以前のバージョンでは、<param-1> ... 等の内容を、特別な記号
 $0, $1, ..., $9 をマクロのように置換することで表現していました。この古
 い仕組みは、もはやサポートしていません。

 試験段階: 関数ブロック (このバージョンからの新機能) は、`call` に代わ
 るより柔軟な機能を提供します。以下参照: `function blocks`。

3 ARGV[ ]
?argv
?ARGV
?call argv
?call ARGV
 `call` コマンドにより gnuplot スクリプトに入った場合、呼び出し側からの
 パラメータは、2 つの仕組みで利用できます。各パラメータは、まず文字列と
 して変数 ARG1, ARG2, ... ARG9 に保存します。さらにそれらは配列 ARGV[9]
 の各要素としても保存します。こちらは、数値は複素変数値として保存します
 が、それ以外はすべて文字列として保存します。ARGC はパラメータの個数を
 保持します。よって、以下の call 後には

      call 'routine_1.gp'  1 pi "title"

 以下の 3 つの引数を routine_1.gp 内で以下の値として利用できます:

      ARGC = 3
      ARG1 = "1"         ARGV[1] = 1.0
      ARG2 = "3.14159"   ARGV[2] = 3.14159265358979...
      ARG3 = "title"     ARGV[3] = "title"

 この例では、ARGV[1] と ARGV[2] は可能な限りの精度を持つ浮動小数値とな
 りますが、ARG2 は書式 "%g" による文字列として保存されるため精度が落ち
 ています。
3 例 (Example)
?call example
?commands call example
      以下を call すると:
          MYFILE = "script1.gp"
          FUNC = "sin(x)"
          call MYFILE FUNC 1.23 "This is a plot title"
      呼び出されたスクリプト内では以下のようになり:
          ARG0 は "script1.gp"
          ARG1 は文字列値 "sin(x)"
          ARG2 は文字列値 "1.23"
          ARG3 は文字列値 "This is a plot title"
          ARGC は 3
      そのスクリプト内では以下のようなものを実行できる:
          plot @ARG1 with lines title ARG3
          print ARG2 * 4.56, @ARG2 * 4.56
          print "This plot produced by script ", ARG0

 この例の ARG1 は文字列なので、それはマクロとして参照しなければいけませ
 んが、ARG2 はマクロ参照でも (数値定数になる)、変数のままでも (文字列
 "1.23" が実数値に自動的に変換された後の同じ数値になる) 構わないことに
 注意してください。

 シェルスクリプトで gnuplot をコマンドラインオプション `-c` つきで実行
 することで、これと同じことを直接行うこともできます:

      gnuplot -persist -c "script1.gp" "sin(x)" 1.23 "This is a plot title"

2 clear
?commands clear
?clear
=inset
?inset
 `clear` コマンドは、`set terminal` や `set output` で選択した画面、出
 力装置をクリアします。ハードコピー装置に対しては通常改ページを行います。

 いくつかの出力装置は `clear` コマンドでは `set size` で定義された描画
 領域のみを消去します。そのため、`set multiplot` とともに使用することで
 挿入図を一つ作ることができます。

 例:
       set multiplot
       plot sin(x)
       set origin 0.5,0.5
       set size 0.4,0.4
       clear
       plot cos(x)
       unset multiplot

 詳細については、以下参照: `set multiplot`, `set size`, `set origin`。
2 Continue
?commands continue
?continue
 コマンド `continue` は、`do`, `while` 文の繰り返し実行部分のカッコ内で
 のみ意味を持ちます。このコマンドは、その中カッコ内の残りの命令をスキッ
 プし、次の繰り返しに進みます (もしループの残りがあれば)。以下も参照:
 `break`。
2 Do
?commands do
?do
 書式:
       do for <iteration-spec> {
            <commands>
            <commands>
       }
 これは、コマンド列を複数回実行します。コマンドは中カッコ {} で囲み、か
 つ開始カッコ "{" は、キーワード `do` と同じ行に置く必要があります。こ
 のコマンドは、古い形式 (かっこなし) の if/else 構文と一緒に使うことは
 できません。繰り返し指定 <iteration-spec> の例については、以下参照:
 `iteration`。例:
       set multiplot layout 2,2
       do for [name in "A B C D"] {
           filename = name . ".dat"
           set title sprintf("Condition %s",name)
           plot filename title name
       }
       unset multiplot
 以下も参照: `while`, `continue`, `break`。
2 evaluate
?commands evaluate
?evaluate
 コマンド `evaluate` は、文字列、または関数ブロックに含まれる gnuplot
 コマンドを実行します。その文字列中に改行文字を入れてはいけません。

      evaluate "commands in a string constant"
      evaluate string_valued_function( ... arguments ... )
      evaluate $functionblock( ... arguments ... )

 これは、特に同様のコマンドの繰り返しに有用です。

 例:
       set_label(x, y, text) \
         = sprintf("set label '%s' at %f, %f point pt 5", text, x, y)
       eval set_label(1., 1., 'one/one')
       eval set_label(2., 1., 'two/one')
       eval set_label(1., 2., 'one/two')

 gnuplot コマンドを持つ文字列を構成したり実行する他の仕組みについては、
 以下参照: `function blocks`, `substitution macros`。
2 exit
?commands exit
?exit
      exit
      exit message "エラーメッセージ文字列"
      exit status <整数のエラーコード>

 `exit` と `quit` の両コマンドは END-OF-FILE 文字 (通常 Ctrl-D) 同様、
 現在の入力ストリーム、すなわち端末の対話やパイプ入力、ファイル入力 (パ
 イプ) からの入力を終了させます。入力ストリームが入れ子 (階層的な
 `load` のスクリプトで) になっている場合、読み込みは親のストリームで継
 続されます。トップレベルのストリームが閉じられると、プログラムはそれ自
 身終了します。

 コマンド `exit gnuplot` は、直ちに、無条件に、そして例え入力ストリーム
 が多段階にネストされていても、gnuplot を終了させます。その場合、開かれ
 ていた全ての出力ファイルはきれいに完全な形では閉じられない可能性があり
 ます。使用例:

       bind "ctrl-x" "unset output; exit gnuplot"

 コマンド `exit error "error message"` は、疑似プログラムエラーを行いま
 す。対話型モードでは、そのエラーメッセージを表示し、すべのネストされた
 ループや call を中断してコマンドラインに帰ります。非対話型モードでは、
 プログラムを終了します。

 gnuplot が終了しシェルの制御に戻る場合、その返り値は意味のないものにな
 ることがありますが、このコマンドを以下のように実行すれば、シェルに特定
 の値を返すことが可能です。

      exit status <value>

 詳細は、以下参照: `batch/interactive`。
2 fit
?commands fit
?fit
?least-squares
?Marquardt
 コマンド `fit` は、Marquardt-Levenberg 法による非線形最小自乗法 (NLLS)
 を用いて、データ点の集合にユーザが与える式を当てはめます。独立変数は
 12 まで許されていて、従属変数は常に 1 つで、任意個数のパラメータを当て
 はめることができます。さらに追加で、データ点の重み付け用に誤差評価を入
 力することも可能です。

 `fit` の最も基本的な使用法は、以下の単純な例が示しています。ここで、フ
 ァイルから読み込む x と y の計測値 (measured) の集合は、関数 y = f(x)
 のモデル化に使います。

       f(x) = a + b*x + c*x**2
       fit f(x) 'measured.dat' using 1:2 via a,b,c
       plot 'measured.dat' u 1:2, f(x)

 書式:
       fit {<ranges>} <expression>
           '<datafile>' {datafile-modifiers}
           {{unitweights} | {y|xy|z}error | errors <var1>{,<var2>,...}}
           via '<parameter file>' | <var1>{,<var2>,...}

 範囲 (xrange, yrange 等) は、当てはめに使用するデータを制限する目的で
 使うことができ、その範囲を超えたデータは無視します。その書式は `plot`
 コマンド同様
       [{dummy_variable=}{<min>}{:<max>}],
 です。以下参照: `plot ranges`。

 <expression> は、通常はあらかじめユーザ定義された f(x) または f(x,y)
 の形の関数ですが、`gnuplot` で有効などんな数式でも指定できます。ただし
 実数値関数でなければいけません。
 独立変数の名前は、コマンド `set dummy` で設定するか、fit の範囲指定部
 分 (<rangse>) で設定します (以下を参照)。デフォルトでは、最初の 2 つは
 x, y となります。
 さらに、その数式は、当てはめの作業により決定する値を持つ 1 つ以上の変
 数 (パラメータ) に依存すべきです。

 <datafile> は `plot` コマンドと同様に扱われます。`plot datafile` の修
 飾子 (`using`, `every`,...) は、`smooth` を除いて、全て `fit` に使うこ
 とができます。以下参照: `plot datafile`。

 データファイルの内容は、plot コマンドに使用するのと同じ `using` 指定を
 使うことで柔軟に解釈させることができます。例えば、独立変数 x を2 列目
 と 3 列目の和として生成し、z の値を 6 列目から取り、重みを 1 としたい
 場合は以下のようにします:

       fit ... using ($2+$3):6

 `using` 指定がない場合、fit は暗黙に独立変数は 1 つだけと仮定します。
 ファイル自身、または using 指定が 1 列だけのデータを持つ場合、その行番
 号を独立変数値として使用します。
 `using` 指定を与えた場合、最大 12 個 (指定してコンパイルしていればさら
 にそれ以上) の独立変数を利用できます。

 オプション `unitweights` (これがデフォルト) は、すべてのデータ点が等し
 い重みを持つとみなします。これは、キーワード `error` を使用することで
 変更でき、これはデータファイルから 1 つ以上の変数の誤差評価を読み込み、
 その誤差評価を対応する変数値の標準偏差 s とみなし、各データに 1/s**2
 の重みを計算するのに使用します。

 独立変数の誤差評価において、その重みには、"有効分散法" (effective
 variance method; Jay Orear, Am. J. Phys., Vol. 50, 1982) に従って、さ
 らに当てはめ関数の微分係数をかけます。

 キーワード `errors` には、その後ろに、入力がどの変数の誤差であるのかを
 示すコンマ区切りの 1 つ以上の変数名のリストが付きます。従属変数 z は常
 にその中になければいけませんが、独立変数は必須ではありません。
 そのリストの各変数に対し、ファイルからその分の、各変数の誤差評価を持つ
 追加の列を読み込みます。繰り返しになりますが、`using` 指定により柔軟な
 解釈が可能になります。
 よって、独立変数の数は暗黙に、`using` 指定内の列の数から 1 を引いて
 (従属変数分)、さらに `errors` 指定内の変数の個数を引いた数になることに
 注意してください。

 例として、2 つの独立変数があり、そして 1 つ目の独立変数と従属変数の誤
 差データがある場合は、`errors x,z` 指定と 5 列の `using` 指定を使うこ
 とになりますが、それは x:y:z:sx:sz のように解釈されます (x, y は独立変
 数、z が従属変数、sx, sz は x, z の標準偏差)。

 `errors` 指定のちょっとした略記法も 2,3 用意されています:
 `yerrors` (独立変数が 1 列ある当てはめ用)、
 `zerrors` (より一般の場合) は、いずれも `errors z` と同値で、1 列だけ
 追加の従属変数用の誤差列があることを意味しています。

 `xyerrors` は、独立変数は 1 列で、その独立変数と従属変数の両方の 2 列
 の誤差列が追加されることを意味します。この場合、x と y の誤差は Orear
 の有効分散法 (effective variance method) で処理されます。

 `yerror` と `xyerror` の形式および解釈は、それぞれ 2 次元描画スタイル
 の `yerrorlines` と `xyerrorlines` に同等であることに注意してください。

 コマンド `set fit v4` を使用すると、fit のコマンド書式は `gnuplot` バ
 ージョン 4 と互換の書式になります。その場合、`using` には、独立変数が
 2 つ以上ならば、独立変数の数より 2 つ (z と s) 多い指定が必要で、
 `gnuplot` は、`using` 指定で与えられた列の数に応じて、以下の書式に従い
 ます:

       z                           # 独立変数は 1 つ (行番号)
       x:z                         # 独立変数は 1 つ (第 1 列)
       x:z:s                       # 独立変数は 1 つ (全部で 3 列)
       x:y:z:s                     # 独立変数は 2 つ (全部で 4 列)
       x1:x2:x3:z:s                # 独立変数は 3 つ (全部で 5 列)
       x1:x2:x3:...:xN:z:s         # 独立変数は N 個 (全部で N+2 列)

 これは、2 つ以上の独立変数で fit をする場合、z-誤差 s を与える必要があ
 ることを意味することに注意してください。重みを 1 にしたい場合は、それ
 を、例えば x:y:z:(1) のような書式を using に指定することで明示的に与え
 る必要があります。

 仮変数名は、下で紹介するように範囲指定で指定することで変更できます。最
 初の範囲は `using` 指定の最初のものに対応し、以下同様です。従属変数で
 ある z の範囲指定もできますが、それは、f(x,...) の値をその範囲外にして
 しまうようなデータ点が、残差を最小化することには寄与しない場合に有効で
 す。

 複数のデータ集合も複数の 1 変数関数に同時に当てはめることも、y を '仮
 変数' とすれば可能です。例えばデータ行番号を使い、2 変数関数への当ては
 め、とすればいいでしょう。以下参照: `fit multi-branch`。

 `via` 指定子は、パラメータの最適化を、直接行うか、またはパラメータファ
 イルを参照することによって行うかを指定します。

 例:
       f(x) = a*x**2 + b*x + c
       g(x,y) = a*x**2 + b*y**2 + c*x*y
       set fit limit 1e-6
       fit f(x) 'measured.dat' via 'start.par'
       fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
       fit f(x) './data/trash.dat' using 1:2:3 yerror via a, b, c
       fit g(x,y) 'surface.dat' using 1:2:3 via a, b, c
       fit a0 + a1*x/(1 + a2*x/(1 + a3*x)) 'measured.dat' via a0,a1,a2,a3
       fit a*x + b*y 'surface.dat' using 1:2:3 via a,b
       fit [*:*][yaks=*:*] a*x+b*yaks 'surface.dat' u 1:2:3 via a,b

       fit [][][t=*:*] a*x + b*y + c*t 'foo.dat' using 1:2:3:4 via a,b,c

       set dummy x1, x2, x3, x4, x5
       h(x1,x2,x3,x4,s5) = a*x1 + b*x2 + c*x3 + d*x4 + e*x5
       fit h(x1,x2,x3,x4,x5) 'foo.dat' using 1:2:3:4:5:6 via a,b,c,d,e

 反復の個々のステップの後で、当てはめの現在の状態についての詳細な情報が
 画面に表示されます。そし最初と最後の状態に関する同じ情報が "fit.log"
 というログファイルにも書き出されます。このファイルは前の当てはめの履歴
 を消さないように常に追加されていきます。これは望むなら削除、あるいは別
 な名前にできます。コマンド `set fit logfile` を使ってログファイルの名
 前を変更することもできます。

 `set fit errorvariables` を使用した場合、各当てはめパラメータの誤差は
 そのパラメータと似た名前 ("_err" が追加された名前) の変数に保存されま
 すので、その誤差をその後の計算の入力として使用することができます。

 `set fit prescale` とした場合、当てはめパラメータを、それらの初期値か
 らスケール変換します。これにより、個々のパラメータの大きさにかなり違い
 があるような場合でも、Marquardt-Levenberg ルーチンがより早く、より信頼
 性のある値に収束させられるようになります。

 当てはめの反復は Ctrl-C (wgnuplot では Ctrl-Break) を押すことで中断で
 きます。現在の反復が正常に終了した後、以下のいずれかを選ぶことができま
 す:
 (1) 当てはめを止めて現在のパラメータの値を採用する
 (2) 当てはめを続行する
 (3) `set fit script` か、環境変数 `FIT_SCRIPT` で指定した `gnuplot` コ
 マンドを実行する。そのデフォルトは `replot` で、もしデータと当てはめ関
 数を一つのグラフにあらかじめ描画してあれば、現在の当てはめの状態を表示
 することができます。

 `fit` が終了した後は、最後のパラメータの値を保存するのに `save fit` コ
 マンドを使います。その値は再びパラメータの値として使うことができます。
 詳細は、以下参照: `save fit`。
3 パラメータの調整 (adjustable parameters)
?commands fit parameters
?fit parameters
?commands fit adjustable_parameters
?fit adjustable_parameters
?fit_parameters
 `via` はパラメータを調節するための 2 つの方法を指定できます。一つは
 コマンドラインから直接指示するもので、もう一つはパラメータファイルを
 参照して間接的に行うものです。この 2 つは初期値の設定で違った方法を取
 ります。

 調整するパラメータは、`via` キーワードの後ろにコンマで区切られた変数名
 のリストを書くことで指定できます。定義されていない変数は初期値 1.0 と
 して作られます。しかし当てはめは、変数の初期値があらかじめ適切な値に設
 定されている方が多分速く収束するでしょう。

 パラメータファイルは個々のパラメータを、個別に 1 行に一つずつ、初期値を
 次のような形で指定して書きます。
       変数名 = 初期値

 '#' で始まるコメント行や空行も許されます。特別な形式として
       変数名 = 初期値       # FIXED

 は、この変数が固定されたパラメータであることを意味し、それはこのファイ
 ルで初期化されますが、調節はされません。これは、`fit` でレポートされる
 変数の中で、どれが固定された変数であるかを明示するのに有用でしょう。な
 お、`# FIXED` と言うキーワードは厳密にこの形でなくてはなりません。

3 fit の概略 (fit beginners_guide)
?commands fit beginners_guide
?fit beginners_guide
?fit guide
?fitting
 `fit` は、与えられたデータ点を与えられたユーザ定義関数にもっとも良く
 当てはめるようなパラメータを見つけるのに使われます。その当てはめは、
 同じ場所での入力データ点と関数値との自乗誤差、あるいは残差 (SSR:Sum
 of the Squared Residuals) の和を基に判定されます。この量は通常χ(カイ)
 自乗と呼ばれます。このアルゴリズムは SSR を 最小化することをしようと
 します。もう少し詳しく言うと、データ誤差の重みつき残差の自乗和 (WSSR)
 の最小化を行っています。ここで、残差は、二乗する前に入力データ誤差で
 重みづけします。詳細は、以下参照: `fit error_estimates`。

 これが、(非線形) 最小自乗当てはめ法と呼ばれるゆえんです。`非線形` が
 何を意味しているのかを見るための例を紹介しますが、その前にいくつかの
 仮定について述べておきます。ここでは簡単のため、1 変数のユーザー定義
 関数は z=f(x), 2 変数の関数は z=f(x,y) のようにし、いずれも従属変数と
 して z を用いることにします。パラメータとは `fit` が調整して適切な値を
 決定するユーザ定義変数で、関数の定義式中の未知数です。ここで言う、線形
 性/非線形性とは、従属変数 z と `fit` が調整するパラメータとの関係に対
 するものであり、z と独立変数 x (または x と y) との関係のことではあり
 ません (数学的に述べると、線形最小自乗問題では、当てはめ関数のパラメー
 タによる 2 階 (そして更に高階の) 導関数は 0、ということになります)。

 線形最小自乗法では、ユーザ定義関数は単純な関数の和であり、それぞれは一
 つのパラメータの定数倍で他のパラメータを含まない項になります。非線形最
 小自乗法では、より複雑な関数を扱い、パラメータを色々な使い方をします。
 フーリエ級数は線形と非線形の最小自乗法の違いを表す一つの例です。フーリ
 エ級数では一つの項は
      z=a*sin(c*x) + b*cos(c*x).
 のように表されます。もし、a と b が未知なパラメータで c は定数だとすれば
 パラメータの評価は線形最小自乗問題になります。しかし、c が未知なパラメー
 タならばそれは非線形問題になります。

 線形の場合、パラメータの値は比較的簡単な線形代数の直接法によって決定で
 きます。しかし、'gnuplot' が使用する反復法は、その特別な線形の場も含め
 て、より一般的な非線形の問題を解くことができます。`fit` は検索を行うこ
 とで最小値を探そうとします。反復の各ステップは、パラメータの新しい値の
 組に対して WSSR を計算します。Marquardt-Levenberg のアルゴリズムは次の
 ステップのパラメータの値を選択します。そしてそれはあらかじめ与えた基準、
 すなわち、(1) 当てはめが "収束した" (WSSR の相対誤差がある限界値より小
 さくなった場合。以下参照: `set fit limit`)、または (2) あらかじめ設定
 された反復数の限界に達した場合 (以下参照: `set fit maxiter`)、のいずれ
 かを満たすまで続けられます。キーボードからその当てはめの反復は中断でき
 ますし、それに続いて中止することもできます (以下参照: `fit`)。ユーザ変
 数 FIT_CONVERGED は、 直前の fit コマンドが収束により終了した場合は 1
 を持ち、それ以外の理由で中断した場合は 0 を持ちます。FIT_NITER は、直
 前の当てはめで行われた繰り返しの回数を持ちます。

 当てはめに使われる関数はしばしばあるモデル (またはある理論) を元にして
 いて、それはデータの振舞を記述したり、あるいは予測しようとします。よっ
 て `fit` は、データがそのモデルにどれくらいうまく当てはまっているのかを
 決定するため、そして個々のパラメータの誤差の範囲を評価するために、モデ
 ルの自由なパラメータの値を求めるのに使われます。以下参照:
 `fit error_estimates`。

 そうでなければ、曲線による当てはめにおける関数は、モデルとは無関係に選
 ばれています (それは十分な表現力と最も少ない数のパラメータを持ち、デー
 タの傾向を記述しそうな関数として経験に基づいて選ばれるでしょう)。

 しかし、もしあなたが全てのデータ点を通るような滑らかな曲線を欲しいなら
 `fit` ではなく、むしろ `plot` の `smooth` オプションでそれを行うべきで
 しょう。
3 誤差評価 (error estimates)
?commands fit error_estimates
?fit error_estimates
?fit errors
 `fit` において "誤差" という用語は 2 つの異なった文脈で用いられます。
 一つはデータ誤差、もう一つはパラメータ誤差です。

 データ誤差は、平方残差の重み付きの和 WSSR、すなわちχ自乗を決定する際
 個々のデータ点の相対的な重みを計算するのに用いられます。それらはパラメ
 ータの評価に影響を与えます。それは、それらが、当てはめられた関数からの
 個々のデータ点の偏差が最終的な値に与える影響の大きさを決定することによ
 ります。正確なデータ誤差評価が与えられている場合には、パラメータの誤差
 評価等の `fit` が出力する情報はより役に立つでしょう。

 `statistical overview` では `fit` の出力のいくつかを説明し、
 'practical guidelines' に対する背景を述べています。
4 統計的な概要 (statistical overview)
?commands fit error statistical_overview
?statistical_overview
 非線形最小自乗法 (Non-Linear Least-Squares) の理論は、誤差の正規分布の
 点から一般的に記述されています。すなわち、入力データは与えられた平均と
 その平均に対する与えられた標準偏差を持つガウス (正規) 分布に従う母集団
 からの標本と仮定されます。十分大きい標本、そして母集団の標準偏差を知る
 ことに対しては、χ自乗分布統計を用いて、通常「χ自乗」と呼ばれる値を調
 べることにより「当てはめの良さ」を述べることができます。減らされた自由
 度のχ自乗 (χ自乗の自由度は、データ点の数から当てはめられるパラメータ
 の個数だけ引いた数) が 1.0 である場合は、データ点と当てはめられた関数
 との偏差の重みつき自乗和が、現在のパラメータ値に対する関数と与えられた
 標準偏差によって特徴付けられた母集団の、ランダムなサンプルに対する自乗
 和とが全く同じであることを意味します。

 分散 = 総計である数え上げ統計学同様、母集団の標準偏差が定数でない場合、
 各点は観測される偏差の和と期待される偏差の和を比較するときに個別に重み
 づけされるべきです。

 最終段階で `fit` は 'stdfit'、すなわち残差の RMS (自乗平均平方根) で求
 められる当てはめの標準偏差と、データ点が重みづけられている場合に '減ら
 されたχ自乗' とも呼ばれる残差の分散をレポートします。自由度 (データ点
 の数から当てはめパラメータの数を引いたもの) はこれらの評価で使用されま
 す。なぜなら、データ点の残差の計算で使われるパラメータは同じデータから
 得られるものだからです。データ点が重みを持つ場合、`gnuplot` はいわゆる
 p-値を計算します。それはその自由度と結果のχ自乗値に対するχ自乗分布の
 累積分布関数値を 1 から引いた値です。以下参照:
 `fit practical_guidelines`。
 これらの値は以下の変数に代入されます:
       FIT_NDF = 自由度の数
       FIT_WSSR = 重みつき残差の自乗和
       FIT_STDFIT = sqrt(WSSR/NDF)
       FIT_P = p-値

 パラメータに関する信頼レベルを評価することで、当てはめから得られる最小
 のχ自乗と、要求する信頼レベルのχ自乗の値を決定するためのχ自乗の統計
 を用いることが出来ます。しかし、そのような値を生成するパラメータの組を
 決定するには、相当のさらなる計算が必要となるでしょう。

 `fit` は信頼区間の決定よりむしろ、最後の反復後の分散-共分散行列から直
 ちに得られるパラメータの誤差評価を報告します。これらの評価は、標準偏差
 として計算される量の指定に関する統計上の条件が、一般には非線形最小自乗
 問題では保証されないのですが、線形最小自乗問題での標準誤差 (各パラメー
 タの標準偏差) と同じ方法で計算されます。そしてそのため慣例により、これ
 らは "標準誤差" とか "漸近標準誤差" と呼ばれています。漸近標準誤差は一
 般に楽観過ぎ、信頼レベルの決定には使うべきではありませんが、定性的な指
 標としては役に立つでしょう。

 最終的な解は、解の範囲におけるパラメータの相関を示す相関行列も生成しま
 す: その主対角要素、すなわち自己相関は常に 1 で、全てのパラメータが独
 立ならば非対角要素はすべて 0 に近い値になります。完全に他を補いあう 2
 つの変数は、大きさが 1 で、関係が正の相関か負の相関かによって正か負に
 なる符号を持つ非対角要素を持ちます。非対角要素の大きさが小さいほど、各
 パラメータの標準偏差の評価は、漸近標準誤差に近くなります。
4 実用的なガイドライン (practical guidelines)
?commands fit error practical_guidelines
?fit practical_guidelines
?fit guidelines
 個々のデータ点への重みづけの割り当ての基礎を知っているなら、それが測定
 結果に対するより詳しい情報を使用させようとするでしょう。例えば、幾つか
 の点は他の点より当てになるということを考慮に入れることが可能です。そし
 て、それらは最終的なパラメータの値に影響します。

 データの重み付けは、最後の反復後の `fit` の追加出力に対する解釈の基礎
 を与えます。各点に同等に重み付けを行なうにしても、重み 1 を使うことよ
 りもむしろ平均標準偏差を評価することが、χ自乗が定義によりそうであるよ
 うに、WSSR を 無次元変数とすることになります。

 当てはめ反復の各段階で、当てはめの進行の評価に使うことが出来る情報が表
 示されます ('*' はより小さい WSSR を見つけられなかったこと、そして再試
 行していることを意味します)。'sum of squares of residuals' (残差の自乗
 和) は、'chisquare' (χ自乗) とも呼ばれますが、これはデータと当てはめ
 関数との間の WSSR を意味していて、`fit` はこれを最小化しようとします。
 この段階で、重み付けされたデータによって、χ自乗の値は自由度 (= データ
 点の数 - パラメータの数) に近付くことが期待されます。WSSR は補正された
 χ自乗値 (WSSR/ndf; ndf = 自由度)、または当てはめ標準偏差 (stdfit =
 sqrt(WSSR/ndf)) を計算するのに使われます。それらは最終的な WSSR に対し
 てレポートされます。

 データが重み付けされていなければ、stdfit は、ユーザの単位での、データ
 と当てはめ関数の偏差の RMS (自乗平均平方根) になります。

 もし妥当なデータ誤差を与え、データ点が十分多く、モデルが正しければ、
 補正χ自乗値はほぼ 1 になります (詳細は、適当な統計学の本の 'χ自乗分
 布' の項を参照してください)。この場合、この概要に書かれていること以外
 に、モデルがデータにどれくらい良く当てまっているかを決定するための追加
 の試験方法がいくつかあります。

 補正χ自乗が 1 よりはるかに大きくなったら、それは不正なデータ誤差評価、
 正規分布しないデータ誤差、システム上の測定誤差、孤立した標本値
 (outliers)、または良くないモデル関数などのためでしょう。例えば
 `plot 'datafile' using 1:($2-f($1))` などとして残差を描画することは、
 それらのシステム的な傾向を知るための手がかりとなります。データ点と関数
 の両者を描画することは、他のモデルを考えための手がかりとなるでしょう。

 同様に、1.0 より小さい補正χ自乗は、WSSR が、正規分布する誤差を持つラ
 ンダムなサンプルと関数に対して期待されるものよりも小さいことを意味しま
 す。データ誤差評価が大きすぎるのか、統計的な仮定が正しくないのか、また
 はモデル関数が一般的すぎて、内在的傾向に加えて特殊なサンプルによる変動
 の当てはめになっているのでしょう。最後の場合は、よりシンプルな関数にす
 ればうまく行くでしょう。

 当てはめの p-値は、自由度と結果のχ自乗値に対するχ自乗分布の累積分布
 関数値を 1 から引いた値です。これは、当てはめの良さのものさしを提供し
 ます。p-値の範囲は 0 から 1 までで、p-値がとても小さい、あるいはとても
 大きい場合は、モデルがデータとその誤差をちゃんと記述していないことを意
 味します。上で述べたように、これはデータに問題があるか、誤差かモデルに
 問題がある、またはそれらの組み合わせなのだろうと思います。p-値が小さい
 ことは、誤差が過小評価されているので、よって最終的なパラメータ誤差をス
 ケール変換すべきだろうということを意味するでしょう。以下も参照:
 `set fit errorscaling`。

 標準的なエラーを、パラメータの不確定性に関する、あるより現実的な評価に
 関係付けること、および相関行列の重要性を評価することができるようになる
 前に、あなたは `fit` と、それを適用しようとするある種の問題に慣れてお
 く必要があるでしょう。

 `fit` は、大抵の非線形最小自乗法の実装では共通して、距離の自乗
 (y-f(x))**2 の重み付きの和を最小化しようとすることに注意してください。
 それは、x の値の "誤差" を計算に関してはどんな方法も与えてはおらず、単
 に y に関する評価のみです。また、"孤立点" (正規分布のモデルのから外れ
 ているデータ点) は常に解を悪化させる可能性があります。
3 制御 (control)
?commands fit control
?fit control
=FIT_LOG
=FIT_SCRIPT
 `fit` に影響を与えるように定義できる環境変数が 2 つあります。これらの
 環境変数は `gnuplot` が立ち上がる前に定義しなければなりません。その設
 定方法はオペレーティングシステムに依存します。

       FIT_LOG
 は、当てはめのログが書かれるファイル名 (およびパス) を変更します。デフ
 ォルトでは、作業ディレクトリ上の "fit.log" となっています。これは、実
 行時にコマンド `set fit logfile` を使って上書きできます。

       FIT_SCRIPT
 は、ユーザが中断した後に実行するコマンドを指定します。デフォルトでは
 `replot` ですが、`plot` や `load` コマンドとすれば、当てはめの進行状
 況の表示をカスタマイズするのに便利でしょう。これは、実行時にコマンド
 `set fit script` を使って上書きできます。

 fit の動作におけるその他多くの実行時の調整については、以下参照:
 `set fit`。
3 エラー処理 (error recovery)
?commands fit error_recovery
?fit error_recovery
 gnuplot バージョン 6 より、コマンド `fit` は、フィッティング処理の成功
 失敗に関わらず、常にコマンド入力行の次に戻るようになりました。これは、
 fit のエラーから復帰するスクリプトを可能にします。変数 FIT_ERROR は、
 成功すれば 0 に、エラーの場合は 0 以外の値になります。以下の例は、5 つ
 のデータ集合のうちどれだけ多くのものが正常に fit できても描画します。
 例えば 2 番目のデータ集合で失敗しても、それが 3 番目から 5 番目のデー
 タ集合に対する fit を妨げることはありません。

      do for [i=1:5] {
          DATA = sprintf("Data_%05d.dat", i)
          fit f(x) DATA via a,b,c
          if (FIT_ERROR || !FIT_CONVERGED) {
              print "Fit failed for ", DATA
              continue
          }
          set output sprintf("dataset_%05.png", i)
          plot DATA, f(x)
          unset output
      }

3 複数の当てはめ (multi-branch)
?commands fit multi-branch
?fit multi-branch
?multi-branch
?branch
 複数当てはめ法 (multi-branch fitting) では、複数のデータ集合を、共通の
 パラメータを持つ複数の 1 変数の関数に、WSSR の総和を最小化することによ
 って同時に当てはめることが出来ます。各データ集合に対する関数とパラメー
 タ (枝) は '疑似変数' を使うことで選択できます。例えば、データ行番号
 (-1; 'データ列' の番号) またはデータファイル番号 (-2) を 2 つ目の独立
 変数とします。

 例: 2 つの指数減衰形 z=f(x) が与えられていて、それぞれ異なるデータ集合
 を記述しているが、共通した減衰時間を持ち、そのパラメータの値を評価する。
 データファイルが x:z:s の形式であったとすると、この場合以下のようにす
 ればよい。
      f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
      fit f(x,y) 'datafile' using  1:-2:2:3  via a, b, tau

 より複雑な例については、デモファイル "fit.dem" で使われる "hexa.fnc"
 を参照してください。

 もし従属変数のスケールに差がある場合、単位の重み付けでは 1 つの枝が支
 配してしまう可能性があるので、適当な重み付けが必要になります。各枝をバ
 ラバラに当てはめるのに複数当てはめ法の解を初期値として用いるのは、全体
 を合わせた解の各枝に対する相対的な影響に関する表示を与えることになるで
 しょう。
3 初期値 (starting values)
?commands fit starting_values
?fit starting_values
?starting_values
 非線形当てはめは、大域的な最適値 (残差の自乗和 (SSR) の最小値を持つ解)
 への収束は保証はしませんが、局所的な極小値を与えることはできます。その
 サブルーチンはそれを決定する方法を何も持ち合わせていないので、これが起
 こったかどうかを判断するのはあなたの責任となります。

 `fit` は、解から遠くから始めると失敗するかも知れませんし、しばしばそれ
 は起こり得ます。遠くというのは、SSR が大きく、パラメータの変化に対して
 その変化が小さい、あるいは数値的に不安定な領域 (例えば数値が大きすぎて
 浮動小数の桁あふれを起こす) に到達してしまって、その結果 "未定義値
 (undefined value)" のメッセージか `gnuplot` の停止を引き起こしてしまう
 ような場合を意味します。

 大域的な最適値を見つける可能性を改善するには、最初の値をその解に少なく
 ともほぼ近くに取るべきでしょう。例えば、もし可能ならば一桁分の大きさの
 範囲内で。最初の値が解に近いほど不正な解で終了してしまう可能性は低くな
 ります。最初の値を見つける一つの方法は、データと当てはめ関数を同じグラ
 フの上に描画して適当な近さに達するまで、パラメータの値を変更して
 `replot` することを繰り返すことです。その描画は、不正な極小値を見つけ
 たことで当てはめが終了したかどうかをチェックするのにも有用です。

 もちろん、見た目が良い当てはめが見つかっても、それは "それよりよい" 当
 てはめ (ある改良された当てはめの良さの基準によって特徴付けられた統計学
 的な意味で、あるいはそのモデルのより適切な解である、という物理的な意味
 で) が存在しないことの証明にはなりません。問題によっては、各パラメータ
 の意味のある範囲をカバーするような様々な初期値の集合に対して `fit` す
 ることが望ましいかも知れません。
3 時刻データ (time data)
?commands fit time_data
?fit time_data
 時刻データの当てはめでは、gnuplot は 1970 1 月 1 日からの秒数として時
 刻を表現していることを思い出すことが重要です。例えば、2023 年のある 1
 日の間に計測したなんらかの時間に依存したデータに対して、2 次関数モデル
 での当てはめをしたい場合、以下のようにそれができると期待するでしょう:
      T(x) = a + b*x + c*x*x
      set xdata time
      fit T(x) 'hits.dat' using 1:3 via a,b,c

 しかしそれは多分失敗します。なぜならそのある日に対応する内部での x の
 の値は [1.67746e+09 : 1.67754e+09] のような範囲になってしまうからです。
 計測データの x の小さな変更はわずかに 1.e-05 程度なので、収束を保証す
 るためには、初期パラメータ評価で多分ずっと先の小数第何位の精度が必要に
 なってしまうでしょう。

 一つの解決策は、時間を測定の開始時間からの時間に変更して問題を作り変え
 てしまうことです。
      set xdata time       # データ書式は "27-02-2023 12:00:00 計測値"
      timefmt  = "%d-%m-%Y %H:%M:%S"
      set timefmt timefmt
      t0 = strptime( timefmt, "27-02-2023 00:00:00" )
      fit T(x) 'temperature.dat' using ($1-t0):3 via a,b,c

 これはデータの範囲を [0 : 86400] に変え、より扱いやすくなります。
 この場合の他の方法としては、1 列目の日付を無視し、2 列目に相対時刻形式
 (tH/tM/tS) を使用することです。
      set timefmt "%tH:%tM:%tS"
      fit T(x) 'temperature.dat' using 2:3 via a,b,c

3 ヒント (tips)
?commands fit tips
?fit tips
?tips
 ここでは、`fit` を最大限に利用するためにいくつか覚えておくべきヒントを
 紹介します。それらは組織的ではないので、その本質がしみ込むまで何回もよ
 く読んでください。

 `fit` の引数の `via` には、2 つの大きく異なる目的のための 2 つの形式が
 あります。`via "file"` の形式は、バッチ処理 (非対話型での実行が可能)
 で最も良く使われ、そのファイルの中で初期値を与えることができます。

 `via var1, var2, ...` の形式は対話型の実行で良く使われ、コマンドヒスト
 リの機構が使ってパラメータリストの編集を行い、当てはめを実行したり、あ
 るいは新しい初期値を与えて次の実行を行なったりします。これは難しい問題
 に対しては特に有用で、全てのパラメータに対して 1 度だけ当てはめを直接
 実行しても、良い初期値でなければうまくいかないことが起こり得るからです。
 それを見つけるには、いくつかのパラメータのみに対して何回か反復を行ない、
 最終的には全てのパラメータに対する 1 度の当てはめがうまくいくところに
 十分近くなるまでそれを繰り返すことです。

 当てはめを行なう関数のパラメータ間に共通の依存関係がないことは確認して
 おいてください。例えば、a*exp(x+b) を当てはめに使ってはいけません。そ
 れは a*exp(x+b)=a*exp(b)*exp(x) だからです。よってこの場合は a*exp(x)
 または exp(x+b) を使ってください。

 技術的なお話: 絶対値が最も大きいパラメータと最も小さいパラメータの比が
 大きい程当てはめの収束は遅くなります。その比が、マシンの浮動小数の精度
 の逆数に近いか、またはそれ以上ならば、ほぼずっと収束しないか収束する前
 に実行が中断するでしょう。よってそのような場合は、その関数の定義で例え
 ば 'parameter' を '1e9*parameter' にするとか、最初の値を 1e9 で割ると
 かしてこれを避けるように改良するか、または `set fit prescale` でパラメ
 ータの初期値に従ってそのスケール変換を内部でやらせる機能を用いるか、の
 いずれかが必要でしょう。

 もし、関数を、当てはめるパラメータを係数とする、単純な関数の線形結合で
 書けるなら、それはとてもいいので是非そうしてください。何故なら、問題が
 もはや非線形ではないので、反復は少ない回数で収束するでしょう。もしかし
 たらたった一回ですむかもしれません。

 実際の実験の講義ではデータ解析に対するいくつかの指示が与えられ、それで
 データへの最初の関数の当てはめが行なわれます。もしかすると、基礎理論の
 複数の側面にひとつずつ対応する複数回のプロセスが必要かも知れませんが、
 そしてそれらの関数の当てはめのパラメータから本当に欲しかった情報を取り
 出すでしょう。しかし、`fit` を使えば、求めるパラメータの視点から直接モ
 デル関数を書くことにより、それはしばしば 1 回で済むのです。時々はより
 難しい当てはめ問題の計算コストがかかりますが、データ変換もかなりの割合
 で避けることが出来ます。もしこれが、当てはめ関数の単純化に関して、前の
 段落と矛盾してると思うなら、それは正解です。

 "singular matrix" のメッセージは、この Marquardt-Levenberg アルゴリズ
 ムのルーチンが、次の反復に対するパラメータの値の計算が出来ないことを意
 味します。この場合、別な初期値から始めるか、関数を別な形で書き直すか、
 より簡単な関数にしてみてください。

 最後に、他の当てはめパッケージ (fudgit) のマニュアルから、これらの文書
 を要約するようないい引用を上げます: "Nonlinear fitting is an art! (非
 線形当てはめ法は芸術だ !)"
#TeX \newpage
2 関数ブロック (function blocks)
?commands function
?function blocks
?functionblocks
 コマンド `function` は、gnuplot コードからなる名前付きブロックのヒアド
 キュメント形式による定義を意味する符号で、それは関数として呼び出すこと
 が可能です。
 データブロックと同様、関数 (function) ブロックの名前は '$' で始まる必
 要があります。その定義には、最大 9 つの名前付きの引数を指定できます。
 それらの名前は、その関数ブロック内で局所変数として扱われます。以下参照:
 `local`, `scope`。

 一度関数ブロックを定義すると、それを通常の関数を呼び出すのと同じように
 どこでもその名前で呼び出すことができます。返り値が適切でない場合、関数
 ブロックを、数式の一部としてでなく、コマンド "evaluate" で呼び出すこと
 ができます。

 例:
      function $sinc(arg) << EOF
          if (arg == 0) { return 1.0 }
          return sin(arg) / arg
      EOF

      gnuplot> plot $sinc(x) with lines title "sinc(x) as a function block"

 名前付き引数の一覧は、関数ブロックの宣言時に指定する必要はありません。
 コマンドラインで指定した関数の引数は、関数ブロックの内部から、コマンド
 `call` でそうするように ARGV[1] などの形でアクセスできます。これにより、
 可変な個数の引数を操作できる関数ブロックを定義することができます。

 例:
      function $max << EOF
          local max = real("-Inf")
          if (ARGC == 0) { return NaN }
          do for [i=1:ARGC] {
              if (max < ARGV[i]) {
                  max = ARGV[i]
              }
          }
          return max
      EOF
      gnuplot> foo = $max( f(A), 2.0, C, Array[3] )
      gnuplot> baz = $max( foo, 100. )

 関数ブロックをサポートする一番の目的は、複雑な関数を gnuplot 内部で直
 接定義できるようにすることです。もちろん、同じ関数を C や Fortran で直
 接コードした場合よりも実行速度は遅くなりますが、これは色々な目的に答え
 ることを可能にします。実行速度が重要な場合は、代わりにその関数を別にプ
 ラグインとして実装すればいいでしょう (以下参照: `plugins`)。

 関数ブロックを使う自明でない例として、複素対数ガンマ関数 lngamma に対
 する 15 項 Lanczos 近似の実装とグラフがデモコレクション内にあります。
^ <a href="http://www.gnuplot.info/demo_6.0/function_block.html">
      function_block.dem
^ </a>
 この関数ブロックによる実装は、同じアルゴリズムで C で直接コードされて
 いる組み込み関数の lnGamma と比べて、だいたい 25 倍位遅いですが、それ
 でも対話型での 3 次元グラフの回転には十分な位の速さです。
#TeX デモにある関数定義は以下の通り。
#TeX \newline
#TeX \begin{center}
#TeX \begin{minipage}{5in}
#TeX {
#TeX \hrule
#TeX ~\newline
#TeX \small
#TeX \begin{verbatim}
#TeX array coef[15] = [ ... ]
#TeX
#TeX function $Lanczos(z) << EOD
#TeX     local Sum = coef[1] + sum [k=2:15] coef[k] / (z + k - 1)
#TeX     local temp = z + 671./128.
#TeX     temp = (z + 0.5) * log(temp) - temp
#TeX     temp = temp + log( sqrt(2*pi) * Sum/z )
#TeX     return temp
#TeX EOD
#TeX
#TeX function $Reflect(z) << EOD
#TeX     local w = $Lanczos(1.0 - z)
#TeX     local temp = log( sin(pi * z) )
#TeX     return log(pi) - (w + temp)
#TeX EOD
#TeX
#TeX my_lngamma(z) = (z == 0) ? NaN : (real(z) < 0.5) ? $Reflect(z) : $Lanczos(z)
#TeX \end{verbatim}
#TeX \hrule
#TeX }
#TeX \end{minipage}
#TeX \end{center}

 関数ブロックの使用は試験段階です。
 詳細は、リリース版に含まれる前に変更される可能性があります。
#TeX \newpage
2 help
?commands help
?help
 `help`コマンドは、組み込みヘルプを表示します。ある項についての説明を指
 定したいときには、次の書式を使って下さい:

       help {<項目名>}

 もし <項目名> が指定されなかった場合は、`gnuplot` についての簡単な説明
 が表示されます。指定した項目についての説明が表示された後、それに対する
 細目のメニューが表示され、その細目名を入力することで細目に対するヘルプ
 を続けることができます。そして、その細目の説明が表示された後に、さらな
 る細目名の入力を要求されるか、または 1 つ前の項目のレベルへ戻ります。
 これを繰り返すとやがて、`gnuplot` のコマンドラインへと戻ります。

 また、疑問符 (?) を項目として指定すると、現在のレベルの項目のリストが
 表示されます。
2 history
?commands history
?history
 コマンド `history` は、コマンド履歴の一覧を表示したり、保存したり、一
 覧の中のコマンドを再実行したりします。このコマンドの挙動、および履歴フ
 ァイルの保存場所を変えるには、以下参照: `set history`。

 `history` コマンドで始まる入力行は、コマンド履歴には保存しません。

 例:

       history               # 履歴全体を表示
       history 5             # 履歴内の直前の 5 つを表示
       history quiet 5       # エントリ番号なしで直前の 5 つを表示
       history "hist.gp"     # 履歴全体をファイル hist.gp に書き出す
       history "hist.gp" append # 履歴全体をファイル hist.gp に追加する
       history 10 "hist.gp"  # 直前の 10 個をファイル hist.gp に出力
       history 10 "|head -5 >>diary.gp" # パイプで履歴を 5 つ書き出す
       history ?load         # 履歴内の "load" で始まるものすべてを表示
       history ?"set c"      # 上と同様 (複数の語は引用符で囲む)
       hist !"set xr"        # 上と同様 (複数の語は引用符で囲む)
       hist !55              # 55 番目の履歴項目のコマンドを再実行
2 if
?commands if
?if
 書式:
       if (<condition>) { <commands>;
              <commands>
              <commands>
       } else if (<condition>) {
              <commands>
       } else {
              <commands>
       }

 このバージョンの gnuplot は、if/else のブロック形式をサポートしていま
 す。キーワード `if`, `else` の後ろに開始カッコ "{" が続く場合、"}" で
 終了するブロックまでのすべての文 (複数の入力行も可) に条件的な実行が適
 用されます。if コマンドは入れ子にすることもできます。

 バージョン 4 からの古い 1 行形式の if/else 文もまだサポートしています
 が、新しいブロック形式の書式とは混ぜてはいけません。以下参照: `if-old`。
3 if-old
?if if-old
?if-old
 以前の書式:
       if (<条件>) <コマンド行> [; else if (<条件>) ...; else ...]

 gnuplot バージョン 4.4 までは、if/else コマンドの通用範囲は 1 行内に留
 まっていましたが、現在は複数行を中カッコ { } で囲んで書くことができま
 す。古い形式も一応残されていますが、それは中カッコのブロック内で使うこ
 とはできません。

 キーワード `if` が "{" をともなわない場合は、<条件> が真 (ゼロでない)
 ならば <コマンド行> のコマンド (複数も可) が実行され、偽 (ゼロ) ならば
 スキップされます。いずれの場合も入力行の最後になるか、`else` が現れる
 ところまでそれが行われます。`;` を使うと同じ行に複数のコマンド置くこと
 が可能ですが、条件付きのコマンド (`if` の構文自体) はそこでは終らない
 ことに注意してください。

 例:
       pi=3
       if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi
 を実行すると、
       ?Fixing pi!
       3.14159265358979
 と表示されますが、
       if (1==2) print "Never see this"; print "Or this either"
 とすると、何も表示されません。

2 for
?for
 `plot`, `splot`, `set`, `unset` コマンドでは、繰り返しの節を使うことも
 できます。これは、基本的なコマンドを複数回実行する効果を持ち、そのおの
 おのの実行では繰り返し制御変数によって数式は再評価されます。`do` コマ
 ンドでは、どんなコマンド列でも繰り返し実行させることができます。繰り返
 し節は現在は以下の 2 つの形式をサポートしています:

       for [intvar = start:end{:increment}]
       for [stringvar in "A B C D"]

 例:

       plot for [filename in "A.dat B.dat C.dat"] filename using 1:2 with lines
       plot for [basename in "A B C"] basename.".dat" using 1:2 with lines
       set for [i = 1:10] style line i lc rgb "blue"
       unset for [tag = 100:200] label tag

 繰り返しの入れ子もサポートしています:

       set for [i=1:9] for [j=1:9] label i*10+j sprintf("%d",i*10+j) at i,j

 さらなる説明については、以下参照: `iteration`, `do`。
2 import
?commands import
?import
=plugins
 コマンド `import` は、ユーザ定期関数名を外部共有オブジェクトから取り込
 まれる関数に結びつけます。これは、gnuplot で利用可能な関数の設定を拡張
 するプラグイン機構を構成します。

 書式:
       import func(x[,y,z,...]) from "sharedobj[:symbol]"

 例:
       # 関数 myfun を "mylib.so" か "mylib.dll" から取り込んで作成する
       # gnuplot では描画、または数値計算で利用可能
       import myfun(x) from "mylib"
       import myfun(x) from "mylib:myfun"    # 上と同様

       # "theirlib.so" か "theirlib.dll" で定義済の関数 theirfun を作成
       # 異なる名前で利用可能
       import myfun(x,y,z) from "theirlib:theirfun"

 プログラムは共有オブジェクトとして与えられた名前に、オペレーティングシ
 ステムに従って ".so" か ".dll" を追加し、まずそれをフルパス名として検
 索し、次にカレントディレクトリからの相対パス名として検索します。オペレ
 ーティングシステム自体も LD_LIBRARY_PATH か DYLD_LIBRARY_PATH の任意の
 ディレクトリを検索します。以下参照: `plugins`。

2 load
?commands load
?load
 `load` コマンドは、指定された入力ファイルの各行を、それが対話的に入力
 されたかのように実行します。`save` コマンドでつくられたファイルは、
 `load` することができます。有効な gnuplot コマンドの書かれたテキストフ
 ァイルは、`load`コマンドによって、実行することができます。`load` 中の
 ファイルの中にさらに `load` または `call` コマンドがあっても構いません。
 `load` するファイルに引数を与えるには、以下参照: `call`。

 書式:
       load "<入力ファイル名>"
       load $datablock

 入力ファイル名は引用符で囲まなければなりません。

 `load` コマンドは、標準入力からのコマンドの入力のために、特別なファイ
 ル名 "-" を用意しています。これは、`gnuplot` のコマンドファイルが、い
 くつかのコマンドを標準入力から受け付けることを意味します。詳細について
 は、以下参照: `batch/interactive`。

 popen 関数をサポートするようなシステムでは、'<' で始まるファイル名にす
 ることで、入力ファイルをパイプから読み込むことができます。

 例:
       load 'work.gnu'
       load "func.dat"
       load "< loadfile_generator.sh"

 `gnuplot` への引数として与えられたファイル名は、暗黙のうちに `load` コ
 マンドによって実行されます。これらは、指定された順にロードされ、その後
 `gnuplot` は終了します。

 試験段階: 内部で保存したテキストの行からコマンドを実行することも可能で
 す。以下参照: `function blocks`。関数ブロックは、コマンドラインで、あ
 るいは外部ファイルで定義できます。一度関数ブロックを定義されば、そのコ
 マンドは、あらためてファイルから読み込むのでなく内部のコピーに対して
 `evaluate` を使うことで繰り返し実行できます。

2 local
?local
?commands local
 書式:
      local foo = <expression>
      local array foo[size]

 キーワード `local` は、変数の宣言を導入し、その変数の有効範囲 (scope)
 を、その宣言が含まれるコードブロック内の実行のみに制限します。変数宣言
 は必須ではありませんが、それがなければすべての変数は大域 (global) 変数
 となります。局所 (local) 変数の名前が大域変数と重なった場合は、局所変
 数の有効範囲から抜けるまでは、大域変数は隠します。以下参照: `scope`。

 local の宣言は、`call` や `load` 文によって大域変数の値が意識せずに上
 書きされてしまうことを避けるために使います。これは特に関数ブロック内で
 有用です。コマンド `local` は、`if`, `else`, `do for`, `while` に続く
 中括弧のコードブロック内でも有効です。

 例: データ集合の一群を描画するコマンドからなる以下のようなスクリプト
 "plot_all_data.gp" を書くとします。この便利なスクリプトは、"file" や
 "files" や "dataset" や "outfile" の名前の任意の変数が破壊される心配を
 せずにコマンドライン、あるいは他のスクリプトから呼び出せます。
 変数 "file" は本質的に局所的で、それはそれが繰り返し変数だからです
 (以下参照: `scope`) が、他の 3 つは、それらを保護するにはキーワード
 `local` が必要です。

 plot_all_data.gp:
      local files = system("ls -1 *.dat")
      do for [file in files] {
         local dataset = file[1:strstrt(file,".dat")-1]
         local outfile = dataset . ".png"
         set output outfile
         plot file with lines title dataset
      }
      unset output

2 lower
 以下参照: `raise`。
2 pause
?commands pause
?pause
?pause mouse
 `pause` コマンドは、コマンドに続く任意の文字列を表示した後、指定され
 た時間または、改行キーが押されるまで待ちます。`pause` コマンドは、
 `load` 用のファイルと共に使用すると、便利になるでしょう。

 書式:
       pause <time> {"<string>"}
       pause mouse {<endcondition>}{, <endcondition>} {"<string>"}
       pause mouse close

 <time> は、任意の定数または実数値の式です。`pause -1` は改行キーが押さ
 されるまで待ち、0 を指定すると一切待たず、正の数を指定するとその秒数だ
 け待ちます。

 使用している出力形式が `mousing` (マウス機能) をサポートしている場合、
 `pause mouse` は、マウスクリックがあるか ctrl-C が押されるまで待つよう
 になります。そうでない出力形式、またはマウス機能が有効になってない場合
 `pause mouse` は `pause -1` と同じです。

 一つ、あるいは複数の終了条件 (endcondition) が `pause mouse` の後に与
 えられた場合、そのうちのどの一つでも pause は終了します。指定できる終
 了条件は、`keypress`, `button1`, `button2`, `button3`, `close`, `any`
 のいずれかです。pause がキー入力によって終了した場合、押されたキーの
 ASCII コードは MOUSE_KEY に保存され、文字それ自身は、1 文字の文字列値
 として MOUSE_CHAR に返されます。`keypress` が終了条件の一つであれば、
 ホットキー (キー割り当てコマンド) は無効になります。`buttons3` が終了
 条件の一つであれば、拡大機能は無効になります。

 どの場合でもマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2, MOUSE_Y2 に
 保存されます。以下参照: `mouse variables`。

 注意: `pause` コマンドは OS へのコマンドであり描画の一部ではないので、
 異なる出力装置では異なる動作をする可能性があります。(これは、テキスト
 とグラフィックスが、どのように混在するかによります。)

 例:
       pause -1    # 改行キーが押されるまで待つ
       pause 3     # 3 秒待つ
       pause -1  "続けるには return を打ってください"
       pause 10  "これは美しくないですか ? 3 次の spline です"
       pause mouse "選択したデータ点上で任意のボタンをクリックしてください"
       pause mouse keypress "有効なウィンドウ内で A-F の文字を入力してください"
       pause mouse button1,keypress
       pause mouse any "任意のキー、ボタンで終了します"

 亜種である "pause mouse key" は、有効な描画ウィンドウ内での任意のキー
 入力によって再開されます。特別なキー入力まで待つようにしたい場合は、以
 下のようなループを使うことができます:

       print "描画ウィンドウ内で Tab キーを打つと復帰します。"
       plot <something>
       pause mouse key
       while (MOUSE_KEY != 9) {
           pause mouse key
       }
3 pause mouse close
?commands pause mouse close
?pause mouse close
?pause close
 コマンド `pause mouse close` は、外部イベントを待つために中断する特徴
 的な例の一つです。この場合、gnuplot は描画ウィンドウから "close" イベ
 ントが来るのを待ちます。デスクトップ環境、構成毎に正確にそのイベントを
 生成する方法は異なりますが、通常は、ウィンドウの境界にあるなんらかの部
 品をマウスクリックするか、<alt><F4> や <ctrl>q のようなホットキー列を
 タイプすることで描画ウィンドウを close できます。それに適切な枠の部品
 や、ホットキーを利用可能であるかわからない場合、gnuplot 自身の仕組みで
 ホットキー列を定義することもできます。以下参照: `bind`。

 以下のコマンド列は、gnuplot をコマンドラインからでなくスクリプトから実
 行している場合に有用です。

      plot <...whatever...>
      bind all "alt-End" "exit gnuplot"
      pause mouse close

2 plot
?commands plot
?plot
 `plot` と `splot` は `gnuplot` で図を描くための基本的なコマンドです。
 それらは関数やデータの、多くの種類のグラフ表現を提供します。`plot` は
 2 次元の関数やデータを描き、`splot` は 3 次元の曲面やデータの 2 次元投
 影を描きます。

 書式:
       plot {<ranges>} <plot-element> {, <plot-element>, <plot-element>}

 各描画要素 (plot-element) は、定義 (definition) か関数 (function) かデ
 ータ (data source) のいずれか 1 つに、オプションの属性、修正子などがつ
 いたものです:
       描画要素 (plot-element):
            {<iteration>}
            <definition> | {sampling-range} <function> | <data source>
                         | keyentry
            {axes <axes>} {<title-spec>}
            {with <style>}

 各描画要素のグラフ表現形式は、例えば `with lines` や `with boxplot` な
 どのようにキーワード `with` で決定します。以下参照: `plotting styles`。

 描画するデータは、1 つの関数から生成されるもの (媒介変数モード
 (parametric) では 2 つの関数から)、または一つのデータファイルから読み
 込まれるもの、または事前に定義された名前付きデータブロックから読み込ま
 れるもの、または配列から抜き出したもの、のいずれかです。コンマで区切る
 ことで、複数のデータファイル、データブロック、配列、関数などを 1 つの
 plot コマンドで描画できます。以下参照: `data`, `inline data`,
 `functions`。

 関数、変数の定義の描画要素は、画像出力を生成しません。下の 3 つ目の例
 を参照してください。

 例:
       plot sin(x)
       plot sin(x), cos(x)
       plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
       plot "datafile.1" with lines, "datafile.2" with points
       plot [t=1:10] [-pi:pi*2] tan(t), \
            "data.1" using (tan($2)):($3/$4) smooth csplines \
                     axes x1y2 notitle with lines 5
       plot for [datafile in "spinach.dat broccoli.dat"] datafile

 以下参照: `show plot`。
3 軸 (axes)
?commands plot axes
?plot axes
?axes
 軸 (axes) は、4 種類の組が利用できます; キーワード <axes> は、特定の直
 線をどの軸に尺度を合わせるか、ということを選択するのに使われます。
 `x1y1` は下の軸と左の軸を指定; `x2y2` は上と右の軸の指定; `x1y2` は下
 と右の軸の指定; `x2y1` は上と左の軸の指定です。`plot` コマンドで指定さ
 れた範囲は、この最初の軸の組 (下と左) にのみ適用されます。
3 binary
?binary
?data binary
?datafile binary
?plot data binary
 バイナリデータファイル:

 ファイル名の後ろに `binary` のキーワードを与えなければいけません。ファ
 イル形式に関する十分詳細な情報は、ユーザがコマンドラインから与えるか、
 またはサポートしている `filetype` のバイナリ形式のファイルそれ自身から
 抜き出されるかする必要があります。バイナリファイルには、大きく 2 つの
 形式、binary matrix 形式と binary general 形式があります。

 `binary matrix` 形式は、32 ビット IEEE 規格の浮動小数値 (float) が 2
 次元配列の形で並び、それらの座標値を表す行と列が追加されています。plot
 コマンドの `using` 指定において、1 番目 (column(1)) は行列の行の座標を
 参照し、2 番目 (column(2)) は列の座標を参照し、3 番目 (column(3)) は、
 配列のそれらの座標の場所に保存されている値を参照します。

 `binary general` 形式は、任意個の列のデータを含み、それらの情報はコマ
 ンドラインで指定する必要があります。例えば `array`, `record`, `format`,
 `using` などでサイズや形式、データの次元を指定できます。他にも、ファイ
 ルヘッダ読み飛ばしたり、エンディアン (endian) を変更するための有用なコ
 マンドがありますし、配置、データの変換を行なうコマンドの組があります。
 それは、一様に標本化されたデータの場合、その座標がファイルには含まれな
 いことが良くあるからです。matrix バイナリファイルやテキストデータから
 の入力と違うところですが、general バイナリは 1,2,3 といった `using` リ
 ストで生成される列番号を使わず、代わりに 1 列目はファイルの 1 列目、あ
 るいは `format` リストで指定されたもの、になります。

 さまざまな binary オプションに対する大域的なデフォルトの設定も可能で、
 それは `(s)plot <filename> binary ...` コマンドに与えるオプションと全
 く同じ書式で指定できます。その書式は `set datafile binary ...` です。
 一般的な規則として、デフォルトのパラメータはファイルから抜き出されたパ
 ラメータで上書きされ、それはコマンドラインで指定された共通なパラメータ
 で上書きされます。

 例えば `array`, `record`, `format`, `filetype` の `binary general` 形
 式を特定するようなキーワードが何もついていなければ、デフォルトのバイナ
 リ形式は `binary matrix` です。

 general バイナリデータは、特別なファイル名 '-' を使ってコマンドライン
 から入力することもできます。しかし、これはキーボードからの入力を意図し
 たものではなく、パイプを使ってプログラムにバイナリ形式を変換させるため
 のものです。バイナリデータには最後を表す記号がありませんので、gnuplot
 はパイプからデータを読み込む場合、`array` 指定子で指定した数の点数にな
 るまでデータを読み込み続けます。詳細に関しては、以下参照:
 `binary matrix`, `binary general`。

 `index` キーワードは、ファイルフォーマットが 1 つのファイルにつき 1 つ
 の曲面しか許さないため、サポートされません。`every` や `using` 指定は
 サポートされます。`using` は、データがあたかも上の 3 つ組の形で読まれ
 たかのように働きます。
^ <a href="http://www.gnuplot.info/demo/binary.html">
 バイナリファイルの splot のデモ。
^ </a>
4 general
?commands plot binary general
?commands splot binary general
?plot binary general
?splot binary general
?datafile binary general
?data binary general
?binary general
 キーワード `binary` を単独で指定した場合は、非一様な格子を形成する座標
 情報と、各格子点での値の両方を持つバイナリデータであることを意味し (以
 下参照: `binary matrix`)、他の形式のバイナリデータの場合は、そのデータ
 の形式を意味する追加キーワードを指定する必要があります。残念ながら、こ
 れらの追加キーワードの書式は単純ではありませんが、それでも general バ
 イナリモードは、特に多量のデータを gnuplot に送るようなアプリケーショ
 ンに取っては有用です。

 書式:
       plot '<file_name>' {binary <binary list>} ...
       splot '<file_name>' {binary <binary list>} ...

 general バイナリ形式は、ファイル構造に関する情報に関連するキーワード、
 すなわち `array`, `record`, `format`, `filetype` などを <binary list>
 内に与えることで有効になります。それ以外の場合は、非一様な matrix バイ
 ナリ形式と見なします。(詳細に関しては、以下参照: `binary matrix`)

 gnuplot は、例えば PNG 画像のように完全に自己記述される標準的なバイナ
 リファイル形式の読み込み方法をいくつか知っています。その一覧は、対話画
 面で `show datafile binary` と入力することで参照できます。それら以外の
 ものについては、概念上はバイナリデータはテキストデータと同様に考えるこ
 とができます。各点には、`using` 指定で選択される情報の列があります。
 `format` 文字列を指定しなかった場合、gnuplot はバイナリ数値の数を
 `<using list>` で与えられる最大の列番号に等しく取ります。例えば、
 `using 1:3` とすると 3 列ずつデータが読み取られ、2 番目のものは無視し
 ます。各描画スタイルにはデフォルトの using 指定があります。例えば
 `with image` はデフォルトで `using 1` を、`with rgbimage` はデフォルト
 で `using 1:2:3` を使います。
4 array
?binary array
 バイナリファイルの標本の配列の大きさを設定します。座標は gnuplot が生
 成してくれます。各方向の次元を表す数を指定しなければいけません。例えば
 `array=(10,20)` は、2 次元で最初の次元方向 (x) には 10 点、2 番目の次
 元方向 (y) には 20 点の標本化データがあることを意味します。ファイルの
 終了までデータが続くことを示すのに負の値を使えます。データ次元が 1 の
 場合は、カッコは省略できます。複数のデータのサイズ指定を分離するのに、
 コロンを使うことができます。例えば `array=25:35` は 2 つの 1 次元デー
 タがファイルの中にあることを意味します。
4 record
?binary record
 このキーワードは `array` と同じ書式で、同じ機能を提供します。しかし
 `record` は gnuplot に座標情報を自動生成させません。これは、そのような
 座標情報が、バイナリデータファイルのある列に含まれている場合のためのも
 のです。
4 skip
?binary skip
 このキーワードは、バイナリファイルのある区画のスキップを可能にします。
 例えば、そのファイルがデータ領域の開始位置の前に 1024 バイトのヘッダを
 持つような場合には、以下のようにしたいと思うでしょう:
       plot '<file_name>' binary skip=1024 ...
 ファイルに複数のレコードがある場合、そのそれぞれに対する先頭のずらし位
 置を指定することができます。例えば、最初のレコードの前の 512 バイトを
 スキップし、2 番目、3 番目のレコードの前の 256 バイトをスキップするに
 は以下のようにします:
       plot '<file_name> binary record=356:356:356 skip=512:256:256 ...
4 format
?binary format
 デフォルトのバイナリ形式は、単精度浮動小数 (float) が一つ、です。それ
 をより柔軟に設定するために、この format で変数のサイズに関する詳細な情
 報を指定できます。例えば `format="%uchar%int%float"` は、最初の using
 列として符号なし文字型変数 (unsigned char) を、2 番目の列は符号つき整
 数 (int) を、3 番目の列は単精度浮動小数 (float) を指定しています。もし
 サイズ指定子の数が最大列数より小さい場合は、残りの列の変数サイズは暗黙
 のうちに最後に与えた変数サイズに等しく取られます。

 さらに `using` 指定同様、`*` 文字がついた読み捨てる列を書式に指定する
 こともできますし、繰り返しフィールドへの回数指定によって暗黙の繰り返し
 を指定することもできます。例えば、`format="%*2int%3float"` は、3 つの
 実数データを読む前に、2 つの整数データを読み捨てます。使用できる変数サ
 イズの一覧は、`show datafile binary datasizes` で見ることができます。
 それらは、それぞれのコンパイルによってそのバイトサイズとともにマシンに
 依存する変数名のグループと、マシンに依存しない変数名のグループに分かれ
 ています。
4 endian
?binary endian
 ファイルのバイナリデータのエンディアンは、gnuplot が動作するプラットホ
 ームのエンディアンとは異なる場合も良くあります。いくつかの指定で
 gnuplot がバイトをどのように扱うかを制御できます。例えば
 `endian=little` は、バイナリファイルを、そのバイトの並びが小さい桁から
 大きい桁へ並んでいると見なされます。オプションは以下のものが使えます。

               little:  小さい桁から大きな桁へ並ぶ
                  big:  大きな桁から小さな桁へ並ぶ
              default:  compiler と同じエンディアンと見なす
          swap (swab):  エンディアンを変更する (おかしいようならこれを
                        使ってみてください)

 gnuplot は、コンパイル時にオプションが指定されていれば、"middle" (や
 "pdp") エンディアンもサポートできます。
4 filetype
?binary filetype
?filetype
 gnuplot は、いくつか標準的なバイナリファイル形式については必要な情報を
 そのファイルから抜き出すことができます。例えば "format=edf" は ESRF ヘ
 ッダーファイル形式のファイルとして読み込みます。現在サポートしているフ
 ァイル形式については、`show datafile binary filetypes` で見てください。

 特別なファイル形式として `auto` があり、この場合 gnuplot はバイナリフ
 ァイルの拡張子が、サポートされている形式の標準的な拡張子であるかをチェ
 ックします。

 コマンドラインキーワードはファイルから読み取る設定を上書きするのに使わ
 れ、ファイルから読み取る設定はデフォルトの設定を上書きします。以下参照:
 `set datafile binary`。
5 avs
?binary filetype avs
?filetype avs
?avs
 `avs` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。AVS は非常単純なフォーマットで、アプリケーション間でやりとり
 するのに最も適しています。これは、2 つの long (xwidth と ywidth) と、
 その後続くピクセルの列から成り、その各ピクセルは alpha/red/green/blue
 の 4 バイトから成ります。
5 edf
?binary filetype edf
?filetype edf
?edf
?filetype ehf
?ehf
 `edf` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。EDF は ESRF データフォーマット (ESRF Data Format) を意味して
 いて、それは edf と ehf の両方の形式をサポートしています (後者は ESRF
 Header Format)。画像の使用に関する詳しい情報は以下で見つかるでしょう:

   http://www.edfplus.info/specs
5 png
?binary filetype png
?binary filetype gif
?binary filetype jpeg
?filetype png
?filetype gif
?filetype jpeg
 gnuplot が png/gif/jpeg 出力用に libgd ライブラリを使うようにインスト
 ールされている場合、それらの画像形式をバイナリファイルとして読み込むこ
 ともできます。以下のような明示的なコマンド
       plot 'file.png' binary filetype=png
 を使うこともできますし、あらかじめ以下のように設定して、拡張子から自動
 的に画像形式を自動的に認識させることもできます。
       set datafile binary filetype=auto
4 keywords
?binary keywords
 以下のキーワード (keyword) は、バイナリファイルから座標を生成するとき
 にのみ適用されます。つまり、binary array, matrix, image の個々の要素を
 特定の x,y,z の位置への配置の制御のためのものです。
5 scan
?binary keywords scan
?scan
 gnuplot がバイナリファイルをどのように走査するか、ということと実際の描
 画で見られる軸の方向との間の関係については多くの混乱が起こり得ます。そ
 の混乱を減らすには、gnuplot はバイナリファイルを "常に" 点/線/面、また
 は速い/普通/遅い、と走査すると考えるといいでしょう。このキーワードは
 gnuplot に、その走査の方向を描画内のどの座標方向 (x/y/z) に割り当てる
 かを指定します。指定は 2 つ、または 3 つの文字の並びで表現し、最初の文
 字が点に、次の文字が線に、3 つ目の文字が面に対応します。例えば、
 `scan=yx` は、最も速い走査 (点の選択) は y 方向に対応し、普通の速さの
 走査 (線の選択) が x 方向に対応することを意味します。

 描画モードが `plot` の場合、指定には x と y の 2 つの文字を使うことが
 でき、`splot` に対しては x, y, z の 3 つの文字を使うことができます。

 割り当てに関しては、点/線/面から直交座標方向へのみに制限する内部事情は
 別にありません。この理由で、円柱座標への割り当てのための指定子も用意さ
 れていて、それらは直交座標の x, y, z に類似した形で t (角度), r, z と
 なっています。
5 transpose
?binary keywords transpose
?transpose
 `scan=yx`、または `scan=yxz` と同じです。すなわち、これは入力時の走査
 行のピクセルへの割り当てに影響を与えます。表示する際に画像を転置するに
 は、以下のようにしてみてください:
      plot 'imagefile' binary filetype=auto flipx rotate=90deg with rgbimage
5 dx, dy, dz
?binary keywords dx
?binary keywords dy
?dx
?dy
 gnuplot が座標を生成する場合、その間隔はこれらのキーワードで指定された
 ものが使用されます。例えば `dx=10 dy=20` は x 方向に 10、y 方向に 20
 の間隔で標本化されたことを意味します。`dy` は `dx` がなければ使えませ
 ん。同様に `dz` は `dy` がなければ使えません。もしデータの次元が指定し
 たキーワードの次元よりも大きい場合、残りの次元方向の間隔は、指定された
 最も高い次元のものと同じ値が使用されます。例えば画像がファイルから読み
 込まれ、`dx=3.5` のみ指定された場合、gnuplot は x 方向の間隔も y 方向
 の間隔も 3.5 を使用します。

 以下のキーワードも座標の生成時にのみ適用されます。しかし、以下のものは
 matrix バイナリファイルにも使われます。
5 flipx, flipy, flipz
?binary keywords flipx
?flipx
?flipy
?flipz
 バイナリデータファイルの走査方向が gnuplot の走査方向と一致しないこと
 がたまにあります。これらのキーワードは、それぞれ x, y, z 方向のデータ
 の走査方向を逆向きにします。
5 origin
?binary keywords origin
?binary origin
 gnuplot は転置 (transpose) や反転 (flip) において座標を生成する場合、
 常に配列の左下の点が原点になるようにします。すなわち、データが、転置や
 反転の行なわれた後の直交座標系の第 1 象限に来るようにします。

 配列をグラフのその他の場所に配置したい場合、`origin` キーワードで指定
 した場所に gnuplot は配列の左下の点を合わせます。その指定は、`plot` で
 は 2 つの座標の組、`splot` では 3 つの座標の組を指定してください。例え
 ば `origin=(100,100):(100,200)` は、一つのファイルに含まれる 2 つのデ
 ータに対する指定で、2 次元の描画に対する指定です。2 つ目の例として
 `origin=(0,0,3.5)` をあげると、これは 3 次元描画用の指定です。
5 center
?binary keywords center
?keywords center
?center
 `origin` と似ていますが、このキーワードは、配列の中心がこのキーワード
 で指定した点になるように配置します。例えば `center=(0,0)` のようにしま
 す。配列のサイズが `Inf` のときは center は適用されません。
5 rotate
?binary keywords rotate
?keywords rotate
?rotate
 転置 (transpose) と反転 (flip) コマンドは座標の生成と座標軸の方向にあ
 る種の柔軟性を与えてくれます。しかし、角度に関する完全な制御は、2 次元
 の回転角を記述した回転角ベクトルを与えることにより行なうことが可能にな
 ります。

 キーワード `rotate` は, `plot`, `splot` の両方で、2 次元面に対して適用
 されます。回転は座標平面の正の角度に関して行なわれます。

 角度は、ラジアン単位ですが、pi や degrees の倍数としてのラジアンでも表
 現できます。例えば、`rotate=1.5708`, `rotate=0.5pi`, `rotate=90deg` は
 すべて同じ意味です。

 `origin` が指定された場合、回転は平行移動の前に左下の点を中心にして行
 なわれます。それ以外では回転は配列の中心 (`center`) に関して行なわれま
 す。
5 perpendicular
?binary keywords perpendicular
?perpendicular
 `splot` に関して回転ベクトルの設定が、ベクトルを表現する 3 つの数字の
 組を指定することで実装されていて、このベクトルは 2 次元の xy 平面に対
 して向き付けられた法線ベクトル (perpendicular) を表しています。もちろ
 んそのデフォルトは (0,0,1) です。rotate と perpendicular の両方を指定
 することにより、3 次元空間内で無数の方向へデータを向き付けられることに
 なります。

 まず最初に 2 次元の回転が行なわれ、その次に 3 次元の回転が行なわれます。
 つまり、R' をある角による 2 x 2 の回転行列とし、P を (0,0,1) を
 (xp,yp,zp) へ子午線方向に回転させる 3 x 3 の行列とし、R' を左上の部分
 行列として持ち 3,3 成分が 1 でその他の成分が 0 であるような行列 (つま
 り z 軸周りの回転行列) とすれば、この変換を表す行列による関係式は
 v' = P R v となります。ここで、v はデータファイルから読み込まれた
 3 x 1 の位置ベクトルです。ファイルのデータが 3 次元的なものでない場合
 は、論理的なルールが適用されて 3 次元空間内のデータと見なされます (例
 えば、通常は z 座標は 0 とされ、xy 平面内の 2 次元データと見なされます)。
3 データ (data)
?commands plot datafile
?plot datafile
?data-file
?datafile
?data
?file
 ファイル内にあるデータは、`plot` コマンドライン上で、そのデータファイ
 ル名を単一引用符または二重引用符で囲んで指定することで表示できます。
 データはファイルではない、入力ストリームから受け取ることもできます。
 以下参照: `special-filenames`, `piped-data`, `datablocks`。

 書式:
       plot '<file_name>' {binary <binary list>}
                          {{nonuniform|sparse} matrix}
                          {index <index list> | index "<name>"}
                          {every <every list>}
                          {skip <number-of-lines>}
                          {using <using list>}
                          {convexhull} {concavehull}
                          {smooth <option>}
                          {bins <options>}
                          {mask}
                          {volatile} {zsort} {noautoscale}

 修正子の `binary`, `index`, `every`, `skip`, `using`, `smooth`, `bins`,
 `mask`, `convexhull`, `concavehull` `zsort` をそれぞれに分けて説明しま
 す。簡単に言うと以下の通り。
#start
#b `skip N` は入力ファイルの先頭 N 行を無視するよう gnuplot に指示
#b `binary` はファイルがテキストでなくバイナリデータを持つと指示
#b `index` は複数のデータ集合からどのデータ集合を描画するかを選択
#b `every` は一つのデータ集合からどの点を描画するかを選択
#b `using` はファイルのどの列をどの順で使うかを指定
#b `smooth` は描画の前にデータに単純なフィルタリング、補間、曲線補間を
## 実行
#b `convexhull` 単独、または with `smooth` との組み合わせは、入力データ
## 点集合を、その境界多角形の頂点を構成する新しい点集合に置き換えます。
#b `bins` は個々の入力点を x 軸に沿う等幅の区間に仕分け、各区間毎の単
## 一の累積値として描画
#b `mask` は、事前に定義されたマスクを通して、画像内のピクセルの選択さ
## れた部分集合、または pm3d 曲面の選択された領域のみを描画するようフィ
## ルタします。
#b `volatile` はファイルの内容が後で再読み込みすることはできず、よって
## 再使用のためには内部に保持しておかなければいけないことを指示
#end

 `splot` もよく似た書式を使いますが、`bins` はサポートしていませんし、
 平滑化については、2,3 の `smooth` オプションしかサポートしていません。

 キーワード `noautoscale` は、自動的に軸の範囲が決定される機能が有効で
 ある場合に、この描画を構成するデータ点については、それを無視させる (自
 動縮尺機能の計算対象から外す) ようにします。

 テキストデータファイル:

 データファイルの空でない各行は、一つのデータ点を記述しますが、`#` で始
 まる行は例外で、これはコメントとして扱われ無視されます。

 描画スタイルと指定したオプションに依存し、各行から 1 つ以上 8 個以下の
 値を読み込み、単一のデータ点に関連付けます。以下参照: `using`。

 データファイルの単一行中の個々の値は、ホワイトスペース (一つまたは複数
 の空白かタブ) か、またはコマンド `set datafile` で指定した特別なフィー
 ルド区切り文字で区切られている必要があります。フィールド全体が二重引用
 符で囲まれている場合、またはフィールド区切り文字りがホワイトスペース以
 外になっている場合は、そのフィールドがホワイトスペースを含むことが可能
 です。二重引用符内のホワイトスペースは列数の勘定の際には無視されるので、
 次のデータ行は 3 列と見なされます:
       1.0 "second column" 3.0

 データは、指数部に e, E の文字をつけた指数表記で書かれていても構いませ
 ん。コマンド `set datafile fortran` が有効な場合は、fortran の指数指定
 子 d, D, q, Q も使えます。

 データファイルの空行は重要です。
 1 行のブランク行は、`plot` に不連続を指示します; ブランク行によって区
 切られた点は線で結ばれることはありません (line style で書かれている場
 合には)。
 2 行のブランク行は、別々のデータ集合間の区切りを示します。以下参照:
 `index`。

 もし autoscale の状態であれば (以下参照: `set autoscale`)、軸は全ての
 データポイントを含むように自動的に引き伸ばされて、目盛りが書かれる状態
 ならば全ての目盛りがマークされます。これは、2 つの結果を引き起こします:
 i) `splot` では、曲面の角は底面の角に一致していないことがあります。こ
 の場合、縦の線は書かれることはありません。ii) 2 種類の軸での、同じ x
 の範囲のデータの表示の際、もし x2 の軸に対する目盛りが書かれていない場
 合は、x 座標があっていないことがあります。これは x 軸 (x1) は全ての目
 盛りにまで自動的に引き延ばされるのに対し、x2 軸はそうではないからです。
 次の例でその問題を見ることができます:

       reset; plot '-', '-' axes x2y1
       1 1
       19 19
       e
       1 1
       19 19
       e

 これを避けるには、`set autoscale` コマンドか `set [axis]range` コマン
 ドの `noextend` オプションを使うことができます。これは、次の目盛りの刻
 みを入れるような軸の範囲の拡張機能を無効にします。

 ラベルの座標と文字列もデータファイルから読み込むことができます (以下
 参照: `labels`)。
4 columnheaders
?commands plot datafile columnheaders
?data-file columnheaders
?datafile columnheaders
?columnheaders
 コマンド plot のキーワード `skip` を使うことで、データファイルの先頭の
 追加行 (複数行も可) を、明示的に無視させることができます。データファイ
 ルには、文字列の列ヘッダを含む追加の単一行がある場合もあります。コマン
 ド plot が列ヘッダ (column header) を、例えばタイトルとして使用するな
 どのように明示的に参照する場合は、その行を自動的にスキップします。そう
 でなければ、スキップ数に 1 を追加するか、`set datafile columnheaders`
 の属性を設定することで明示的にその行をスキップする必要があるでしょう。
 以下参照: `skip`, `columnhead`, `autotitle columnheader`。
4 カンマ区切りファイル (csv files)
?csv files
?datafile csv
 書式:
      set datafile separator {whitespace | tab | comma | "chars"}

 "csv" は、本来はカンマ区切り ("comma-separated values") の略語ですが、
 ここでの「csv ファイル」 ("csv file") という言葉は、その中のデータフィ
 ールドが、必ずしもカンマである必要はない特定の文字で区切られているよう
 なファイルとします。csv ファイルからデータを読むためには、gnuplot にフ
 ィールド区切り文字がなんであるかを示す必要があります。例えば、フィール
 ド区切り文字としてセミコロンを使うファイルから読む場合は:

      set datafile separator ";"

 以下参照: `set datafile separator`。これは、入力用のファイルにのみ適用
 されます。出力として CSV ファイルを生成するには、`set table` にオプシ
 ョン `separator` を使用してください。
4 every
?commands plot datafile every
?plot datafile every
?plot every
?data-file every
?datafile every
?every
 キーワード `every` は、描画するデータをデータ集合から周期的にサンプリ
 ングすることを可能にします。

 通常のファイルに対しては、「ポイント」は 1 つの行、データの「ブロック」
 は、前後のブロックと空行で区切られる連続した行のまとまりを意味すること
 とします。

 matrix データに対しては、「ブロック」と「ポイント」は、それぞれ「行」
 と「列」に対応します。以下参照: `matrix every`。

 書式:
       plot 'file' every {<ポイント増分>}
                           {:{<ブロック増分>}
                             {:{<開始ポイント>}
                               {:{<開始ブロック>}
                                 {:{<終了ポイント>}
                                   {:<終了ブロック>}}}}}

 描画するデータポイントは、<開始ポイント> から <終了ポイント> まで <ポ
 イント増分> の増加で選び、ブロックは <開始ブロック> から <終了ブロック>
 まで <ブロック増分> の増加で選びます。

 各ブロックの最初のデータは、ファイル中の最初のブロックと同じように、
 「0 番」と数えます。

 プロットできない情報を含む行もカウントすることに注意して下さい。

 いくつかの数字は省略できます; 増分のデフォルトは 1 、開始の値は最初の
 ポイントか最初のブロック、そして終了の値は最後のポイントか最後のブロッ
 クに設定します。`every` のオプションが ':' で終わるのは許されていませ
 ん。`every` を指定しなければ、全ての行の全てのポイントをプロットします。

 例:
       every :::3::3    # 4 番目のブロックだけ選びます (0 番が最初)
       every :::::9     # 最初の 10 ブロックを選びます
       every 2:2        # 1 つおきのブロックで 1 つおきのポイントを選び
                        # ます
       every ::5::15    # それぞれのブロックでポイント 5 から 15 までを
                        # 選びます

 以下も参照
^ <a href="http://www.gnuplot.info/demo/simple.html">
 単純な plot デモ (simple.dem)
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface1.html">
 非媒介変数モードでの splot デモ
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface2.html">
 媒介変数モードでの splot デモ
^ </a>
 。
4 データファイルの例 (example)
?commands plot datafile example
?plot datafile example
?plot example
?datafile example
?data-file example
?example
 次の例は、ファイル "population.dat" 中のデータと理論曲線を図にするもの
 です。

       pop(x) = 103*exp((1965-x)/10)
       set xrange [1960:1990]
       plot 'population.dat', pop(x)

 ファイル "population.dat" は次のようなファイルです。

       # Gnu population in Antarctica since 1965
          1965   103
          1970   55
          1975   34
          1980   24
          1985   10

=skip
 binary の例:

       # 2 つの float の値を選択し (2 つ目の値は無意味)、一方を読み捨て、
       # 一つおきの float 値を無限に長く続く 1 次元データとして使用
       plot '<file_name>' binary format="%float%*float" using 1:2 with lines

       # データファイルから座標を生成するのに必要な情報をすべてそのヘッ
       # ダに含んでいる EDF ファイルの場合
       plot '<file_name>' binary filetype=edf with image
       plot '<file_name>.edf' binary filetype=auto with image

       # 3 つの符号なし文字型整数値 (unsigned char) を生の RGB 画像の色
       # 成分として選択し、y 方向は反転させ画像の方向を座標平面上で変更
       # する (左上が原点になるように)。ピクセルの間隔も指定し、ファイ
       # ルには 2 つの画像が含まれていて、そのうち一つは origin で平行
       # 移動する。
       plot '<file_name>' binary array=(512,1024):(1024,512) format='%uchar' \
            dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage

       # 4 つの別のデータからなり、座標情報もデータファイルに含まれてい
       # る。ファイルは gnuplot が実行されているシステムとは異なるエン
       # ディアンで生成されている。
       splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3

       # 同じ入力ファイルで、今回は 1 番目と 3 番目のレコードをスキップ
       splot '<file_name>' binary record=30:26 skip=360:348 endian=swap u 1:2:3


 以下参照: `binary matrix`。
4 フィルター (filters)
?commands plot datafile filters
?plot datafile filters
?plot filters
?data-file filters
?datafile filters
?filters
 入力データを読み込んだ直後、他の smooth 処理やスタイル固有の処理オプシ
 ョンを適用する前に、フィルター (filters) 操作を直ちに適用します。一般
 にフィルターの目的は、元々の入力点集合全体を、多分変形や再グループ化、
 再整列化を行い、そこから抜き出した部分集合に置き換えます。
 現在サポートしているフィルターは `bins`, `convexhull`, `concavehull`,
 `mask`, `sharpen`, `zsort` です。
5 度数分布 (bins)
?commands plot datafile filters bins
?plot datafile filters bins
?plot filters bins
?data-file filters bins
?datafile filters bins
?filters bins
?bins
 書式:
      plot 'DATA' using <XCOL> {:<YCOL>} bins{=<NBINS>}
           {binrange [<LOW>:<HIGH>]} {binwidth=<width>}
           {binvalue={sum|avg}}

 `plot` コマンドに対するオプション `bins` は、最初に元のデータを、x 軸
 上で等しい幅を持ついくつかの階級 (ビン) に割り当て、そして階級毎に一つ
 の値のみを描画します。階級の数のデフォルト値は、`set samples` で決定し
 ますが、これは plot コマンドでビンの数を明示的に指定することで変更でき
 ます。

 binrange を指定しないと、範囲は 'DATA' 内の値の両端を取ります。

 階級幅は、指定した範囲と階級の数から自動的に計算し、各点を 0 から
 NBINS-1 までの階級に割り当てます:
      BINWIDTH = (HIGH - LOW) / (NBINS-1)
      xmin = LOW - BINWIDTH/2
      xmax = HIGH + BINWIDTH/2
      first bin holds points with (xmin <= x < xmin + BINWIDTH)
      最初の階級は (xmin <= x < xmin + BINWIDTH) の範囲の点を保持
      最後の階級は (xmax-BINWIDTH <= x < xman) の範囲の点を保持
      各点は i = floor(NBINS * (x-xmin)/(xmax-xmin)) 番の階級に割り当て

 それとは別に、固定幅の階級を指定することも可能です。その場合、階級の数
 (nbins) は、点の範囲全体にわたる最小の階級の数となります。

 階級の出力は、その中点で描画、または表にされます。例えば gnuplot が上
 のように階級の幅を計算する場合、最初の階級の x 座標の出力は x=LOW であ
 り、x=xmin ではありません。

 using 命令で一つの列のみを指定した場合、各データ点は、その x 座標値に
 対する階級の合計値に 1 だけ寄与します。2 列目を指定すると、その階級の
 合計値には 2 列目の値が追加されます。よって、以下の 2 つの plot コマン
 ドは同じになります:
      plot 'DATA" using N bins=20
      set samples 20
      plot 'DATA' using (column(N)):(1)

 デフォルトでは、各階級に対して描画される y の値は、その階級内のすべて
 の点に関する y の値の和になります。これは、オプション `binvalue=sum`
 に対応します。これに対して、`binvalue=avg` ではその階級内のすべての点
 に対する y の値の平均を描画します。

 関連する処理オプションに関しては、以下参照: `smooth frequency`,
 `smooth kdensity`。
5 凸包 (convexhull)
?commands plot datafile filters convexhull
?commands plot datafile convexhull
?plot datafile filters convexhull
?datafile filters convexhull
?plot filters convexhull
?filters convexhull
?plot convexhull
?convexhull

 convexhull は描画スタイルではありません。これは、フィルターキーワード
 として単独で、または `smooth path` や `expand <increment>` との組み合
 わせとして使います。

      plot FOO using x:y convexhull
      plot FOO using x:y convexhull smooth path
      plot FOO using x:y convexhull expand <increment> {smooth path}

Ffigure_convex_hull
 これは、FOO 内の点を、それを包含する凸多角形を構成する一意的な部分集合、
 すなわち凸包 (convex hull) で置き換えます。この多角形の頂点集合は、時
 計回りの閉曲線となるように出力します。よってその曲線の始点と終点は一致
 し、`lines` や `polygons`, `filledcurves` の描画スタイルで適切に描画で
 きるようにしています。凸包は、画像や元々のデータ点すべてを含む pm3d 曲
 面のある領域を選択的に描画するマスクとしても便利に使えます。以下参照:
 `masking`。

 キーワード `smooth` をつけると、その頂点は滑らかな曲線を生成するための
 ガイド点として使います (以下参照: `smooth path`)。デフォルトでは、その
 平滑化曲線はガイド点を通ります。

 オプションのキーワード `expand` と増分値 (<increment>) は、凸包の辺の
 線分を増分値の距離だけ内部から遠ざけます。そして移動した線分を留め継ぎ
 (mitered) でつなぎます。これは、元々の凸包の各頂点を 2 つの頂点で置き
 変えることを意味しますが、それは隣接する辺との間に隙間ができてしまうか
 らです。

5 凹包 (concavehull)
?commands plot datafile filters concavehull
?commands plot datafile concavehull
?plot datafile filters concavehull
?datafile filters concavehull
?plot filters concavehull
?filters concavehull
?concavehull

 試験段階 (実装の詳細は将来のリリースで変更するかもしれません)。あなた
 の gnuplot が --enable-chi-shapes 付きでビルドされた場合のみ利用可能。

 凹包 (concavehull) は、描画スタイルではありません。これは、入力データ
 点の境界多角形「閉包」(hull) を見つけるフィルタの一つで、これは、元の
 点集合を、この多角形の周上の順序づけられた部分集合で置き換えます。凸包
 は任意の点集合に対して一意に決定しますが、これはそれとは違い、複数の凹
 包がありえます。そこから一つの凹包を選択する仕組みはさまざまありますが、
 gnuplot は Duckham ら (2008; Patttern Recognition 41:3224-3236) によっ
 て定義されたχ-形状の閉包を生成します。

Ffigure_concave_hull_1
 与えられた点集合に対し、ドロネー三角形分割から三角形を反復削除すること
 でχ-形状を生成します。各反復では、以下の基準に従って三角形を一つ削除
 します: (1) 一点で接触する境界形状の連結度を減らさない場合は削除に望ま
 しい、(2) 三角形の一つの辺が現在の周囲の最も長い線分である場合、(3) こ
 の辺が事前に選択した、χ-形状を完全に決定する特性長パラメータより長い
 場合。gnuplot では、この特性長パラメータは、ユーザー変数 `chi_length`
 から取ります。反復は、取り除ける三角形がなくなったら停止します。
 `chi_length` が大きい場合、三角形は一つも取り除けず、χ-形状は元の周で
 ある凸包になります。`chi_length` を小さくするとその分多くの三角形が削
 除され、最終的な形状は凸性がより低くなります。小さすぎる `chi_length`
 は望ましくありません。

Ffigure_concave_hull_2
 `chi_length` の適切な選択は、入力データ点の分布と密度に強く依存します。
 ユーザが `chi_length` を設定しなければ、gnuplot はそれを自動的に選択し
 ますが、それがあなたのデータに対し適切である保証はありません。この図に
 示されてるデータに対しては、gnuplot は chi_length=22.6 をデフォルトで
 選択し、これは凸包の最長辺の 0.6 倍の長さです。デフォルトで使用される
 この最長辺に対する比率は、コマンド `set chi_shape fraction <value>` で
 変更できます。

 現在のグラフで使った、ユーザ定義か gnuplot が選択した `chi_length` の
 値は、変数 GPVAL_CHI_LENGTH に保存します。

 オプションキーワード `expand` と増分値 (<increment>) は、閉包の各辺を
 固定した距離だけ内部から遠ざけます。これは、元のすべての点の外側にある
 閉曲線を構成する、新たな点集合を生成します。それは、`smooth path` と組
 み合わせることが可能です。

5 マスキング (mask)
?commands plot datafile filters mask
?plot datafile filters mask
?plot filters mask
?data-file filters mask
?datafile filters mask
?filters mask
?mask
      plot FOO using 1:2:3 mask with {pm3d|image}

 マスクを一度定義すると、image 描画、または pm3d 描画から点の部分集合を
 選択するのにそれを利用できます。
 以下参照: `masking`。

5 先鋭化 (shapen)
?plot filters sharpen
?filters sharpen
?sharpen

 フィルタ `sharpen` は、関数描画にのみ適用します。それは描画する関数の
 極を探しますが、それは、そのグラフを構成する線分要素を作る標本点のいず
 れかの x 値の上に正しく乗っているとは限りません。これは、本当の極を二
 分法によって、見つけそしてそれを標本点の集合に追加します。これは、ピー
 クの鋭い先端の切り捨てを減らしますが、粗い標本化ではそれを完全には取り
 除けません。

 例:
      set samples 150
      set xrange [-8:8]
      plot abs(sqrt(sin(x))) sharpen

 キーワード "sharpen" なしでは、結果のグラフは連続曲線で、π毎に極小と
 なり、その極小値は 0 に達するべきものですが、人為的に切り捨てられ、そ
 の y の極小値は見た目には 0.02 から 0.20 の間になります。
 キーワード "sharpen" をつけることで、その関数の正しい見た目である、周
 期的で鋭く y=0 に達する極小値を持つグラフを生成します。
D sharpen 1

5 z ソート (zsort)
?commands plot datafile filters zsort
?plot datafile filters zsort
?plot filters zsort
?data-file zsort
?datafile zsort
?filters zsort
?zsort
      plot FOO using x:y:z:color zsort with points lc palette

 入力データを、他の smooth オプションを適用する前に入力後直ちにソートし
 ます。他の smooth オプションがデータを再ソートして、`zsort` の効果がグ
 ラフには全く現れない場合もあることに注意してください。
 z 軸が自動縮尺でない場合、範囲外の z の値の点はフラグ付けされますが、
 削除はされません。

 この機能は、とても膨大な点数データの 2 次元の散布図の表示を、高得点の
 分布がわかる形であり続けるようにフィルタするような使い方を意図していま
 す。z 保証値によるソートにより、高い z 値を持つような点が、低い z 値の
 点で覆い隠されることはなくなります。

4 index
?commands plot datafile index
?plot datafile index
?plot index
?data-file index
?datafile index
?index
 キーワード `index` は、描画用に複数のデータ集合を持つファイルから、特
 定のデータ集合を選択することを可能にします。配列の添字としての index
 については、以下参照: `arrays`。

 書式:
       plot 'file' index { <m>{:<n>{:<p>}} | "<name>" }

 データ集合は 2 行の空白で分離されています。`index <m>` は <m> 番目の集
 合だけを選択します; `index <m>:<n>` は <m> から <n> までのデータ集合の
 選択; `index <m>:<n>:<p>` は、<m>, <m>+<p>, <m>+2<p>, など、<p> おきの
 集合を選択し、集合 <n> で終了します。C 言語の添字 (index) の付け方に従
 い、index 0 はそのファイルの最初のデータ集合を意味します。大きすぎる
 index の指定にはエラーメッセージが返されます。<p> を指定し、<n> を空欄
 にした場合、<p> 毎のデータをファイルの最後まで読み込みます。`index` を
 指定しない場合は、ファイルのデータ全体を単一のデータ集合として描画しま
 す。

 例:
       plot 'file' index 4:5

 ファイルの各点に対して、それが含まれるデータ集合の index 値は、疑似列
 `column(-2)` で利用できます。これは、以下に見るように、そのファイル内
 の個々のデータ集合を区別する別の方法を提供します。これは、描画用に 1
 つのデータ集合の選択しかしない場合は `index` コマンドよりも不恰好です
 が、個々のデータ集合に異なる属性を割り当てたい場合にはとても便利です。
 以下参照: `pseudocolumns`, `lc variable`。

 例:
       plot 'file' using 1:(column(-2)==4 ? $2 : NaN)        # とても不恰好
       plot 'file' using 1:2:(column(-2)) linecolor variable # とても便利 !

 `index '<name>'` は、データ集合を名前 '<name>' で選択します。名前はコ
 メント行に書いてデータ集合に割り当てます。コメント文字とそれに続く空白
 をそのコメント行から取り除いて、その結果が <name> から始まっていれば、
 それに続くデータ集合に <name> という名前がつけられて、それを指定できま
 す。

 例:
       plot 'file' index 'Population'

 <name> で始まるすべてのコメントがそれに続くデータ集合の名前になること
 に注意してください。問題を避けるために、例えば '== Popolation ==' や
 '[Population]' などの命名法を選択すると便利でしょう。

^ <p>以下の Web ページも参照
^ <a href="http://www.gnuplot.info/demo/multimsh.html">
^ index を使った splot のデモ
^ </a></p>
4 skip
?plot datafile skip
?data-file skip
?datafile skip
?skip
 キーワード `skip` は、プログラムにテキストデータファイル (バイナリデー
 タは不可) の先頭の数行をスキップさせます。スキップする行は、`every` キ
 ーワード処理での行数にはカウントしません。`every ::N` はそのファイル内
 のデータのすべてのブロックの先頭をスキップしますが、`skip N` はそのフ
 ァイルの先頭部分の行のみをスキップすることに注意してください。バイナリ
 データファイルに適用される同様のオプションについては、以下参照:
 `binary skip`。
4 smooth
?commands plot datafile smooth
?plot datafile smooth
?plot smooth
?data-file smooth
?datafile smooth
?smooth
?splines
 `gnuplot` は、元々の入力データがそうであったかのように補間や他の操作を
 データに適用するルーチンをいくつか持っています。これらは `smooth` オプ
 ション内にグループ化されています。さらに洗練されたデータ処理をしたけれ
 ば、gnuplot の外でデータの前処理をするか、または適切なモデルでの `fit`
 を使うのがいいでしょう。以下も参照: `plot filters`。

 書式:
       smooth {unique | frequency | fnormal | cumulative | cnormal
              | csplines | acsplines | mcsplines  bezier | sbezier
              | path
              | kdensity {bandwidth} {period}
              | unwrap}

 オプション `unique`, `frequency`, `fnormal`, `cumulatie`, `cnormal` は、
 x 座標に関してデータをソートし、そしてその x の値に対する分布のある種
 の様子を描画します。

 spline 系、Bezeir 系のオプションは、データの端と端を結ぶ連続曲線の係数
 を決定します。この曲線は関数グラフと同じ方法、すなわちその値を x 座標
 に沿う同じ幅の区間ごとに選び (以下参照: `set samples`)、それらの点を
 線分でつなぐことで描画します。データ集合が空行や未定義値で切られてい
 る場合、切られていないそれぞれの部分を別々の連続曲線としてつなぎます。
 これらの別々につないだ部分同士は、曲線として切れたり、不連続になった
 りするかもしれません。

 `unwrap` は、データがπより大きなジャンプをしないように、2πの整数倍を
 加える操作をします。

 もし `autoscale` の状態であれば、軸の範囲は元のデータからではなく、そ
 こから作られる最終的な曲線に対して計算されます。

 もし `autoscale` の状態でなく、かつスプライン曲線を生成する場合、その
 スプライン曲線の標本化は、入力データを含むような x の範囲と、
 `set xrange` で定義される固定した横座標の範囲の共通部分の上で行なわれ
 ます。

 要求する平滑化オプションを適用するにはデータの点数が少なすぎる場合は、
 エラーメッセージが表示されます。

 `smooth` オプションは、関数の描画のときには無視されます。極座標モード
 では、`smooth path` のみ有効です。

 3 次元 plot (splot) での平滑化は、現在は 3 次元の点の集合を通る自然 3
 次スプライン曲線の生成に限定されています。一般的には、軌道
 (`smooth path`) にスプラインを沿って生成します。3 次元データの 2 次元
 射影に対しては、`smooth csplines` はそれが 2 次元データであるかのよう
 に作用します。一つの `splot` コマンドでは、いずれか一つのキーワードの
 みが許されています。

      splot $DATA using 1:2:3 smooth path with lines

5 acsplines
?commands plot datafile smooth acsplines
?plot datafile smooth acsplines
?data-file smooth acsplines
?datafile smooth acsplines
?plot smooth acsplines
?plot acsplines
?splot smooth acsplines
?splot acsplines
?smooth acsplines
?acsplines
 オプション `smooth acsplines` は自然な滑らかなスプラインでデータを近似
 します。データが x に関して単調にされた後 (以下参照: `smooth unique`)、
 1 つの曲線が、いくつかの 3 次多項式の一部分により区分的に構成されます。
 それらの 3 次式の係数は、個々のデータ点に合うように求められますが、
 using 指定によって 3 列目の値が与えられた場合は、その値で個々の点に重
 みをつけます。デフォルトは、以下と同じです:
       plot 'data-file' using 1:2:(1.0) smooth acsplines

 性質上、重みの絶対的な大きさは、曲線を構成するのに使われる区分の数を決
 定します。もし重みが大きければ、個々のデータの影響は大きくなり、そして
 その曲線は、隣り合う点同志を自然 3 次スプラインでつないで得られるもの
 に近づきます。もし重みが小さければ、その曲線はより少ない区分で構成され、
 それによってより平滑的になります。その最も極端な場合はただ 1 つの区分
 からなる場合であり、それは全てのデータに重みの付き線形最小 2 乗近似に
 よって作られます。誤差の立場から言えば、平滑さの重みは、その曲線に対す
 る「平滑化因子」によって分割された各点への、統計的な重みと見ることがで
 きます。それにより、そのファイル中の (標準的な) 誤差は平滑さの重みとし
 て使うことができます。

 例:
       sw(x,S)=1/(x*x*S)
       plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines
       splot 'data_file' using 1:2:3:(sw($4,100)) smooth acsplines

 `splot ... smooth acsplines with lines` は、連続するデータ点の x, y, z
 座標にスプライン曲線を当てはめます。2 次元の場合とは違い、点を最初にソ
 ートしませんので、当てはめるスプラインの軌道はループを持つ可能性があり
 ます。
 警告: 一般の 3 次元の場合、たくさんのスプライン曲線が当てはまるので、
 似たような効果を得るには、重み値をかなり大きくしなければいけません。
 また、実数の経路長が暗黙の制御値として使われるので、重みづけされるその
 区間は、一つの軸への射影とは一致しないことに注意してください。

5 bezier
?commands plot datafile smooth bezier
?plot datafile smooth bezier
?plot smooth bezier
?data-file smooth bezier
?datafile smooth bezier
?plot bezier
?smooth bezier
?bezier
 オプション `smooth bezier` は、n 次 (データ点の個数) のベジェ曲線でデ
 ータを近似します。この曲線は両端の点をつなぎます。
5 bins
?data-file smooth bins
?datafile smooth bins
?smooth bins
 `smooth bins` は `bins` と同じです。以下参照: `bins`。
5 csplines
?commands plot datafile smooth csplines
?plot datafile smooth csplines
?plot smooth csplines
?data-file smooth csplines
?datafile smooth csplines
?plot csplines
?smooth csplines
?csplines
?splot smooth csplines
 オプション `smooth csplines` はデータを x 上で単調に揃えた後で (以下
 参照: `smooth unique`) 自然 3 次スプライン曲線で引き続く点をつなぎます。
 その平滑化曲線は常にデータ点を通るので、よって点同士の間隔が近い場合、
 その滑らかな曲線に所々がたつきや遠回りができてしまうかもしれません。

 `splot ... smooth csplines with lines` は、連続するデータ点の x, y, z
 座標にスプライン曲線を当てはめます。2 次元の cspline とは違い、点を最
 初にソートしませんので、当てはめるスプラインの軌道はループを持つ可能性
 があります。一般に、スプライン係数の別々な 3 つの集合を生成し、それぞ
 れが一つの座標 x, y, z を、共通の明示的でない軌道パラメータの関数値と
 して扱います。これは、2 次元の `plot ... smooth path` オプションと同等
 です。

 その曲線が xy, yz, xy のいずれかの平面上にあるような特別な場合は、単一
 の係数集合のみを生成します。これにより、3 次元空間内の平滑化曲線を、座
 標を射影した 2 次元グラフのスプライン曲線の当てはめのコピーの積み重ね
 で生成できるようになります。
5 mcsplines
?commands plot datafile smooth mcsplines
?plot datafile smooth mcsplines
?plot smooth mcsplines
?data-file smooth mcsplines
?datafile smooth mcsplines
?plot mcsplines
?smooth mcsplines
?mcsplines
 オプション `smooth mcsplines` は、平滑化された関数が元の点の単調性と凸
 性を保存するような 3 次スプライン曲線で引き続く点をつなぎます。これは、
 外れ値の影響を低減します。
 FN Fritsch & RE Carlson (1980) "Monotone Piecewise Cubic Interpolation",
 SIAM Journal on Numerical Analysis 17: 238-246.

5 path
?plot datafile smooth path
?plot smooth path
?smooth path
?datafile smooth path
?path
#TeX ~
Ffigure_smooth_path
 オプション `smooth path` は、入力データ内で現れる順、すなわち最初に x
 でソートしたりせずに、3 次元スプライン曲線で引き続く点をつなぎます。
 これは、閉曲線や、ループを含む軌道向きの滑らかなスプラインを生成します。
 この平滑モードは、2 次元, 3 次元の両方の描画コマンドでサポートしていま
 す。入力ファイルの空行で区切られた各点集合に対して別々の曲線を作ります。
 `smooth path with filledcurves closed` による描画は、各点集合から閉曲
 線を描くことを保証し、`smooth path with lines` による描画は、始点と終
 点が同じであれば閉曲線を、そうでなければ開いた曲線を描くことを保証しま
 す。以下も参照してください。
^ <a href="http://www.gnuplot.info/demo_6.0/smooth_path.html">
 smooth_path.dem
^ </a>
5 sbezier
?commands plot datafile smooth sbezier
?plot datafile smooth sbezier
?plot smooth sbezier
?data-file smooth sbezier
?datafile smooth sbezier
?plot sbezier
?smooth sbezier
?sbezier
 オプション `smooth sbezier` は、最初にデータを単調に揃え (以下参照:
 `unique`) そして `bezier` アルゴリズムを適用します。
5 unique
?commands plot datafile smooth unique
?plot datafile smooth unique
?plot smooth unique
?data-file smooth unique
?datafile smooth unique
?plot unique
?smooth unique
?unique
 オプション `smooth unique` は、データを x 方向に単調にします。同じ x
 を持つデータ点は y の値を平均して一つの点で置き換えます。そしてその結
 果として得られる点を線分で結びます。
5 unwrap
?commands plot datafile smooth unwrap
?plot datafile smooth unwrap
?plot smooth unwrap
?data-file smooth unwrap
?datafile smooth unwrap
?plot unwrap
?smooth unwrap
?unwrap
 オプション `smooth unwrap` は、2 つの続く点がπを越える違いが出ないよ
 うにデータを修正します: y の値がその範囲を越えるような点に対しては、前
 の点との差がπの範囲に収まるように 2πの整数倍を加えます。この操作は、
 巻き戻しを持つ系の値を時間的に連続にさせるのに有用です。
5 frequency
?commands plot datafile smooth frequency
?plot datafile smooth frequency
?plot smooth frequency
?data-file smooth frequency
?datafile smooth frequency
?plot frequency
?smooth frequency
?frequency
=histogram
 オプション `smooth frequency` は、データを x に関して単調にします。x
 座標が同じ点は、それらの y の値の合計を y の値として持つ一つの点に置き
 換えます。多くの値のデータのヒストグラムを一定の階級幅 (bin) で描くに
 は、それらの y の値を 1.0 にして、それでその和が同じ階級幅内の点の個数
 を表すようにします。これは、データ 1 列だけを指定した場合は、暗黙のう
 ちに行なわれます。
 例:
      binwidth = <適当な値>  # x の値の各階級幅
      bin(val) = binwidth * floor(val/binwidth)
      plot "datafile" using (bin(column(1))):(1.0) smooth frequency
      plot "datafile" using (bin(column(1))) smooth frequency  # 同上
 以下も参照
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 fnormal
?commands plot datafile smooth fnormal
?plot datafile smooth fnormal
?plot smooth fnormal
?data-file smooth fnormal
?datafile smooth fnormal
?plot fnormal
?smooth fnormal
?fnormal
 オプション `smooth fnormal` は、オプション `frequency` と同様の動作を
 しますが、正規化したヒストグラムを生成します。すなわち、データを x に
 関して単調にして、y の値はそのすべての和が 1 になるように正規化します。
 x 座標が同じ点は、それらの y の値の合計を y の値として持つ一つの点に置
 き換えます。多くの値のデータのヒストグラムを一定の階級幅 (bin) で描く
 には、それらの y の値を 1.0 にして、それでその和が同じ階級幅内の点の個
 数を表すようにします。これは、データ 1 列だけを指定した場合は、暗黙の
 うちに行なわれます。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 cumulative
?commands plot datafile smooth cumulative
?plot datafile smooth cumulative
?plot smooth cumulative
?data-file smooth cumulative
?datafile smooth cumulative
?plot cumulative
?smooth cumulative
?cumulative
 オプション `smooth cumulative` は、データを x に関して単調にします。x
 座標が同じ点は、それ以下の x の値を持つすべての点 (すなわち現在のデー
 タ点の左側の点) に対する y の値の累積的な合計を y の値として持つ一つの
 点に置き換えられます。これは、データから累積分布関数を得るのに利用でき
 ます。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 cnormal
?commands plot datafile smooth cnormal
?plot datafile smooth cnormal
?plot smooth cnormal
?data-file smooth cnormal
?datafile smooth cnormal
?plot cnormal
?smooth cnormal
?cnormal
 オプション `smooth cnormal` は、x に関して単調で、y の値は [0:1] に正
 規化されたデータを生成します。同じ x の値を持つ点が複数ある場合は、そ
 れより小さい x の値を持つすべてのデータ点 (すなわち現在のデータ点より
 も左にある点) の累積和を、すべての y の値の和で割った値を y の値として
 持つような一点のデータに置き変えられます。これは、データから正規化され
 た累積分布関数を得るのに使えます (特に標本点数の異なるデータ集合を比較
 するのに有用です)。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>

5 kdensity
?commands plot datafile smooth kdensity
?plot datafile smooth kdensity
?plot smooth kdensity
?data-file smooth kdensity
?datafile smooth kdensity
?plot kdensity
?smooth kdensity period
?smooth kdensity
?kdensity
 オプション `smooth kdensity` は、描画された値集合の分布に対するガウス
 核による核密度評価を生成し描画します。値は最初のデータ列から取り、オプ
 ションとして重みを第 2 列から取ります。ガウス核は、各点の位置に置かれ、
 これらのガウス核すべての和が関数として描画されます。正規化されたヒスト
 グラムを得るには、各重みを 1/(点の個数) とすべきです。

 バンド幅:
 デフォルトでは、gnuplot は正規分布のデータ値に対して最適となるようなバ
 ンド幅を計算し使用します。
      default_bandwidth = sigma * (4/3N) ** (0.2)
 これは通常はとても保守的で、すなわち幅広いバンド幅です。バンド幅は、明
 示的に指定することもできます。
      plot $DATA smooth kdensity bandwidth <value> with boxes
 前の描画で使用したバンド幅は、GPVAL_KDENSITY_BANDWIDTH に保存します。

 周期:
 周期的なデータに対しては、個々のガウス核成分は、1 周期の区間を繰り返す
 ように扱う必要があります。その一例は、角の関数として測定されたデータで、
 これは周期が 2πです。他の例は、複数年に渡って、各年の日付毎に取られた
 データで、この周期は 365 です。
 このような場合、その周期を描画コマンドで渡す必要があります。
      plot $ANGULAR_DAT smooth kdensity period 2*pi with lines

4 特別なファイル名 (special-filenames)
?special-filenames
?special_filenames
?commands plot datafile special-filenames
?plot datafile special-filenames
?plot special-filenames
?datafile special-filenames
?data special-filenames
?special-filenames ++
?special-filenames +
?+
?++
 特別な意味を持つファイル名として、次のものがあります: '', '-', '+',
 '++'

 空のファイル名 '' は、同じ plot コマンド上で、直前の入力ファイルを再び
 使用することを gnuplot に指示します。よって、同じ入力ファイルの 2 つの
 データ列を描画するには以下のようにします:

       plot 'filename' using 1:2, '' using 1:3

 この filename は、この後の plot コマンドでも '' で再利用できますが、
 その場合に `save` すると、コメントとしてその名前を記録するのみです。

 '+' と '++' という特別なファイル名は、`using` 指定の全体と描画スタイル
 にインライン関数を使えるようにするための仕組みです。通常、関数描画はサ
 ンプル点毎に単一の y (または z) の値しか持てません。しかし疑似ファイル
 '+' はそれがあたかも実際の入力ファイルであるように、`using` 指定による
 1 列目の値を標本点として扱い、さらに追加の列の値を指定することも可能で
 す。標本点数は `set samples` で制御できます。標本点は、デフォルトでは
 `set trange` で設定した範囲全体に渡りますが、trange が設定されていなけ
 れば `set xrange` の範囲全体に渡ります。

 注意: trange の使用は、以前の版の gnuplot の仕様とは異なりますが、これ
 により x 軸の範囲とは異なる標本範囲が使用できることになります。

       plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves

 '+' の直前に、独立な標本範囲を指定することもできます。通常の関数描画の
 と同様、独立変数に名前を割り当てることもできます。plot の最初の要素に
 与える場合、標本範囲にはそれを明示するキーワード `sample` を前置する必
 要があります (以下も参照: `plot sampling`)。

       plot sample [beta=0:2*pi] '+' using (sin(beta)):(cos(beta)) with lines

 さらに、`+` の範囲指定には、標本増分を与えることもできます。

       plot $MYDATA, [t=-3:25:1] '+' using (t):(f(t))

 疑似ファイル '++' は、u 方向は `set samples` で制御される点の数、v 方
 向は `set isosamples` で制御される点の数の、標準的な [u,v] 座標の格子
 を生成する 2 列のデータを返します。よって、'++' の描画の前に、urange
 と vrange を設定する必要がありますが、x と y の範囲は自動的に設定され
 るか、または明示的に urange, vrange とは違う値に設定できます。
 例:

       splot '++' using 1:2:(sin($1)*sin($2)) with pm3d
       plot '++' using 1:2:(sin($1)*sin($2)) with image

 `'-'` という特別なファイル名は、データがインラインであることを指示し
 ます。すなわち、データをコマンドの後に続けて指定します。このときはデ
 ータのみがコマンドに続き得ます。よって、`plot` コマンドに対するフィル
 ター、タイトル、ラインスタイルといったオプションは、`plot` のコマンド
 ラインの方に書かないといけません。これは、unix シェルスクリプトにおけ
 る << (ヒアドキュメント) と同様です。そのデータは、それらがファイルか
 ら読み込まれたかのように、1 行につき 1 つのデータ点を入力します。そし
 てデータの終りは、1 列目の始めに文字 "e" を置くことで指示します。

 `'-'` は、データとコマンドを一緒に持つことが有用である場合のためにあり
 ます。例えば、別々のアプリケーションから `gnuplot` にその両方がパイプ
 入力される場合です。例えば、デモファイルの中にはこの機能を使うものがあ
 るでしょう。`index` や `every` のような `plot` のオプションが与えられ
 ていると、それらは使われることのないデータの入力を要求してきます。ごく
 単純な場合を除くすべての場合で、`'-'` からデータを読み込むよりも、最初
 にデータブロックを定義してそれを読み込む方が多分簡単です。以下参照:
 `datablocks`。

 もし、`replot` コマンドで `'-'` を使うなら、あなたは 1 度以上データを
 入力する必要があるでしょう。以下参照: `replot`, `refresh`。繰り返しま
 すが、データブロックを使う方がいいです。

 空のファイル名 ('') は、直前のファイル名が再び使われることを指示しま
 す。これは、

       plot 'ある/とても/長い/ファイル名' using 1:2, '' using 1:3, '' using 1:4

 のようなときに便利です。(もし同じ plot コマンド上で、`'-'` と `''` の
 両方を使用すると、上の例にあるように、インラインデータの 2 つの集合を
 与える必要があります。)

4 パイプによる入力データ (piped-data)
?commands plot datafile piped-data
?plot datafile piped-data
?datafile piped-data
?data piped-data
?plot piped-data
?piped-data
?pipes
=pipes
 popen 関数を持っているシステム上では、データファイルは、'<' で始まるフ
 ァイル名によって、シェルコマンドからパイプ入力することができます。例え
 ば

       pop(x) = 103*exp(-x/10)
       plot "< awk '{print $1-1965, $2}' population.dat", pop(x)

 は、最初の人口の例と同じ情報を描画します。ただし、x 座標は 1965 年か
 らの経過年を表すようになります。この例を実行するときは、上のデータフ
 ァイルのコメント行をすべて削除しなければなりませんが、または上のコマ
 ンドの最初の部分を次のように変えることもできます (コンマに続く部分):

       plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"

 このアプローチは最も柔軟性がありますが、`using` キーワードを用いた単純
 なフィルタリングで行うことも可能です。

 fdopen() 関数を持つシステムでは、データを、ファイルかパイプに結びつけ
 られた任意のファイルデスクリプタから読み込むことができます。`n` 番のフ
 ァイルデスクリプタから読み込むには、`'<&n'` としてください。これにより、
 1 回の POSIX shell からの呼び出しの中で、複数のデータファイルからのパ
 イプ入力が容易に行えるようになります:

       $ gnuplot -p -e "plot '<&3', '<&4'" 3<data-3 4<data-4
       $ ./gnuplot 5< <(myprogram -with -options)
       gnuplot> plot '<&5'

4 using
?commands plot datafile using
?plot datafile using
?plot using
?data-file using
?datafile using
?using
 最もよく使われるデータファイルの修飾子は `using` で、これは入力ファイ
 ルのどの行を描画するのかを指示します。

 書式:
       plot 'file' using <entry> {:<entry> {:<entry> ...}} {'format'}

 各 <entry> は、入力ファイルの一つのフィールドを選択するための単なる列
 の番号か、一つのデータ集合の最初の行の列のラベルに一致する文字列、カッ
 コで囲まれた数式、xticlabels(2) のようにカッコで囲まない特別な関数、の
 いずれかです。

 そのエントリがカッコで囲まれた数式の場合、N 列目の値を指定するのに関数
 column(N) を使用できます。つまり、column(1) は読み込まれた最初の項目を
 参照し、column(2) は次の項目、といった具合です。column(1), column(2),
 ... の略記として、特別な記号 $1, $2, ... を使用できます。

 特別な記号 $# は、現在の入力行の全列数と評価しますので、column($#) や
 stringcolumn($#) は、列数が不明な場合、あるいは行によって異なる個数の
 列を含むファイルからの入力の場合でも、必ず最終列の内容を返します。

 関数 `valid(N)` で、N 番目の列が有効な数字であるかどうかテストできます。
 その列の値が欠けていたり、解釈できなかったり、NaN の場合は 0 を返しま
 す。
=column
=columnheader
 入力ファイルの最初の行の各列に、データの値ではなくラベルを持っている場
 合、このラベルを入力列の特定や plot タイトルに使用できます。関数
 column() は、列番号以外にラベルで入力列を選択できます。例えば、データ
 ファイルが以下のような場合:
       Height    Weight    Age
       val1      val1      val1
       ...       ...       ...
 以下の plot コマンドは同じ意味になります:
       plot 'datafile' using 3:1, '' using 3:2
       plot 'datafile' using (column("Age")):(column(1)), \
                    '' using (column("Age")):(column(2))
       plot 'datafile' using "Age":"Height", '' using "Age":"Weight"

 指定文字列が完全に一致する必要がありますし、大文字小文字も区別します。
 列のラベルを plot タイトルに使うには、`set key autotitle columnhead`
 とするか、または個別にタイトルを指定する場合は関数 `columnhead(N)` を
 使ってください。

 入力データファイルの 1...N という実際の列に加えて、gnuplot は管理情報
 を持ついくつかの "疑似列" を提供します。例えば、$0 または column(0) は、
 データ集合内のそのデータ行の行番号を返します。以下参照:
 `pseudocolumns`。

 <entry> に何も書かなければ、そのエントリのリストの順にデフォルトの値が
 使われます。例えば `using ::4` は、`using 1:2:4` と解釈されます。

 `using` にただ一つのエントリを指定した場合は、その <entry> は y の値と
 して使われ、データ点の番号 (疑似列 $0) が x として使われます。例えば
 "`plot 'file' using 1`" は "`plot 'file' using 0:1`" と同じ意味です。
 `using` に 2 つのエントリを与えた場合、それらは x, y として使われます。
 さらにエントリを追加して、入力からのデータを利用するような描画スタイル
 の詳細については、以下参照: `set style`, `fit`。
C using の書式 (format)
5 format
?using format
?plot using format
 format を指定すると、それを C ライブラリ関数 'scanf' に適用してデータ
 ファイルの各行を読みます。そうでなければ、各行はホワイトスペース (スペ
 ースやタブ) で区切られたデータの列 (フィールド) からなるとみなしますが
 以下も参照: `datafile separator`。

 'scanf' 関数では色々なデータ形式の数値入力が使えますが、`gnuplot` は全
 ての入力データを倍精度浮動小数とみなしますから、`gnuplot` では `%lf`
 が本質的に唯一の数値入力指定、ということになります。その書式文字列には
 少なくとも一つ、そして 7 つ以下の、そのような入力指定子を入れる必要が
 あります。
 'scanf' は数と数の間にホワイトスペース、すなわち空白、タブ ("\t")、改行
 ("\n")、または改ページ ("\f") があると期待します。それ以外の入力は明ら
 かにスキップしなければいけません。

 "\t", "\n", "\f" を使うときは単一引用符よりむしろ二重引用符を使うべき
 であることに注意してください。
5 using の例 (using_examples)
?commands plot datafile using examples
?plot datafile using examples
?datafile using examples
?using examples
 次の例は、1 番目のデータに対する 2 番目と 3 番目の和の値を plot します。
 書式文字列は、各列データがスペース区切りでなく、コンマ区切りであること
 を指示していますが、同じことが `set datafile separator comma` を指定す
 ることでも可能です。
       plot 'file' using 1:($2+$3) '%lf,%lf,%lf'

 次の例は、より複雑な書式指定でデータをファイル "MyData" から読み込み
 ます。
       plot 'MyData' using "%*lf%lf%*20[^\n]%lf"

 この書式指定の意味は以下の通りです:

       %*lf        数値を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは x の値)
       %*20[^\n]   20 個の改行以外の文字を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは y の値)

=filter
=NaN
 3 項演算子 `?:` を使ってデータをフィルタする一つの芸当を紹介します。

       plot 'file' using 1:($3>10 ? $2 : 1/0)

 これは、1 列目のデータに対して、3 列目のデータが 10 以上であるような
 2 列目のデータを plot します。`1/0` は未定義値であり、`gnuplot` は未定
 義の点を無視するので、よって適切でない点は隠されることになります。
 または、あらかじめ定義されている値 NaN を使っても同じことになります。

 カッコで始まっていない限りは定数式を列番号として使うことができます。
 例えば `using 0+(複雑な式)` の様なことができます。そして、その数式は、
 カッコでスタートしていなければ数式の値が一度評価され、カッコでスタート
 していれば個々のデータ点を読み込むためにその値が一度評価される、という
 点が重要です。

 時系列フォーマットデータを使っている場合、その時間のデータは複数の列に
 渡らせることができます。その場合、他のデータの開始位置を計算するとき、
 時間のデータに空白が含まれていることに注意してください。例えば、データ
 行の最初の要素がスペースが埋め込まれた時間データであるならば、y の値は
 3 列目の値として指定されるべきです。

 (a) `plot 'file'` と、(b) `plot 'file' using 1:2`、そして
 (c) `plot 'file' using ($1):($2)` には微妙な違いがあることに注意してく
 ださい。以下参照: `missing`。

 最初に単に

       plot 'file' using 1:2

 と指定することで、大抵の場合どんなにゴミのデータを含む行を持つファイル
 をも plot することが可能になります。しかし、どうしてもデータファイルに
 文字列を残しておきたいならば、そのテキスト行の第一列にコメント文字 (#)
 を置く方がより安全でしょう。
5 疑似列 (pseudocolumns)
?pseudocolumns
?commands plot datafile using pseudocolumns
?plot datafile using pseudocolumns
?datafile using pseudocolumns
?using pseudocolumns
 plot 文の `using` 項目内の式では、入力ファイルに含まれる実際のデータ値
 に加えて管理情報も参照でき、これらは "疑似列" (pseudocolumns) に含まれ
 ています。
       column(0)   データ集合内での各点の順番。順番は 0 から始まり、空
                   行やコメント行でない行で増え、2 行の連続する空行でリ
                   セットされます。非一様な matrix データ形式では、
                   column(0) は各 matrix 要素の線形順序になります。
                   略記 $0 も使用可。
       column(-1)  この番号は 0 から始まり、1 行の空行で増え、2 行の連
                   続する空行でリセットされます。これは、行列、または格
                   子状データ内のデータ行に対応します。また、データ集合
                   内の別々の線分や多角形を区別するのにも使えます。
       column(-2)  0 から始まり、2 行の連続する空行で増えます。これは、
                   複数のデータ集合を持つファイル内の、現在のデータ集合
                   の index 番号です。以下参照: `index`。
       column($#)  特別な記号 $# は、存在する全列数と評価されますので、
                   よって column($#) は、現在の入力行の最終列 (最右列)
                   を参照します。同様に column($# - 1) は、最終列の一つ
                   手前の列、などとなります。
5 配列 (arrays)
?using arrays
?plot using arrays
 描画するデータが配列か、または配列値関数である場合、`using` 指定の中の
 "列 (column)" は以下のように解釈します。詳細については以下参照:
 `arrays`。
        1 列目    配列の添字
        2 列目    配列の数値要素の実数部分、または文字列配列の文字列値
        3 列目    配列の数値要素の虚数部分
5 key
?using key
?plot using key
 ある描画スタイル (列積み上げ型ヒストグラムやクモの巣グラフ) では、デー
 タ列の先頭から描画タイトルを生成することが無意味なレイアウトになってい
 ます。(`using 2:3:xticlabels(1)` のように) データ列の内容から軸目盛り
 ラベルを生成することも無意味になっています。それらの描画スタイルでは、
 代わりに `using 2:3:key(1)` の形式を使ってデータ列に含まれる文字列から
 凡例 (key) の描画タイトルを生成します。通常は、行の先頭の第 1 列目を取
 ります。`spiderplot` で提示されている例を参照してください。
5 xticlabels
?xticlabels
?using xticlabels
?plot using xticlabels
 軸の刻みの見出し (ticlabel) は文字列関数によって作ることもでき、それは
 通常は引数としてデータ列から取得します。最も単純な形式は、データ列自身
 の文字列としての利用で、xticlabels(N) は xticlabels(stringcolumn(N))
 の省略形として使えます。以下の例は 3 列目の要素を x 軸の刻みの見出しと
 して使用します。

       plot 'datafile' using <xcol>:<ycol>:xticlabels(3) with <plotstyle>

 軸の目盛りの見出しは、任意の描画軸 x,x2,y,y2,z 用に生成できます。
 `ticlabels(<labelcol>)` 指定は、`using` 指定の中で、そのデータの座標指
 定が全て済んだ後に行う必要があります。有効な X,Y[,Z] 座標の組を持つ各
 データ点に対して、xticlabels() に与える文字列値は、それに対応する点の
 x 座標と同じ場所の x 軸の見出しのリストに追加されます。`xticlabels()`
 は `xtic()` と省略することもでき、他の軸に関しても同様です。

 例:

       splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)

 この例では、x 軸、y 軸の見出しは x,y 座標値とは別の列から取り出されま
 すが、z 軸の見出しは、対応する点の z 座標値から生成されます。

 例:

       plot "data" using 1:2:xtic( $3 > 10. ? "A" : "B" )

 この例は、x 軸の見出しの生成に文字列値関数を使用したもので、データファ
 イルの各点の x 軸の刻みの見出しは、3 列目の値によって "A" か "B" かの
 いずれかとなります。
5 x2ticlabels
?using x2ticlabels
?plot using x2ticlabels
 以下参照: `plot using xticlabels`。
5 yticlabels
?using yticlabels
?plot using yticlabels
 以下参照: `plot using xticlabels`。
5 y2ticlabels
?using y2ticlabels
?plot using y2ticlabels
 以下参照: `plot using xticlabels`。
5 zticlabels
?using zticlabels
?plot using zticlabels
 以下参照: `plot using xticlabels`。
5 cbticlabels
?using cbticlabels
 試験段階の機能 (細かい部分は将来のリリースで変更の可能性あり)。
 2 次元グラフ: "lc palette z" による変数配色では、色見本 (colorbox) の
 ラベルを、グラフで使用するパレット座標に配置します。
 3 次元グラフ: 色見本のラベルを、点の z 座標に配置します。
 z には一致しない変数配色での 3 次元色地図の場合、これは正しいラベルに
 はならない可能性があることに注意してください。
 以下も参照: `plot using xticlabels`。
4 volatile
?datafile volatile
?data volatile
?plot datafile volatile
?plot volatile
?volatile
 plot コマンドのキーワード `volatile` は、入力ストリームかファイルから
 以前に読み込んだデータが、再読み込み時には有効ではないことを意味します。
 これは、`replot` コマンドの代わりに、可能な限り `refresh` コマンド
 を使うよう gnuplot に指示します。以下参照: `refresh`。
3 関数描画 (functions)
?commands plot functions
?plot functions
?functions
 コマンド `plot`, `splot` では、ファイルから読み込んだデータの描画だけ
 でなく、組み込み関数やユーザ定義関数を描画することもできます。関数の値
 は、独立な軸の通常の範囲に渡ってデータサンプルを取ることで評価します。
 以下参照: `set samples`, `set isosamples`。
 例:
       approx(ang) = ang - ang**3 / (3*2)
       plot sin(x) title "sin(x)", approx(x) title "approximation"

 関数のデフォルトの描画スタイルを設定する方法については、以下参照:
 `set style function`。組み込み関数の情報については、以下参照:
 `expressions functions`。自前で関数を定義する方法については、以下参照:
 `user-defined`。
3 媒介変数モード描画 (parametric)
?commands plot parametric
?commands splot parametric
?plot parametric
?splot parametric
 媒介変数モード (`set parametric`) では、`plot` では 2 つの数式の組を、
 `splot` では 3 つの数式の組を与える必要があります。

 例:
       plot sin(t),t**2
       splot cos(u)*cos(v),cos(u)*sin(v),sin(u)

 データファイルは前と同じように描画されます。ただし、データファイルが
 描画のために与えられる前に、任意の媒介変数関数が先に完全に指定された
 場合を除いてです。言い換えると、x の媒介変数関数 (上の例では `sin(t)`)
 と y の媒介変数関数 (上の例では `t**2`) との間に、他の修飾子やデータ
 関数をはさみこんではいけません。そのようなことをすると、構文エラーにな
 り、媒介変数関数が完全には指定されていない、と表示されます。

 `with` や `title` のような他の修飾子は、媒介変数関数の指定が完了した
 後に指定しなければいけません。

       plot sin(t),t**2 title 'Parametric example' with linespoints

 以下も参照
^ <a href="http://www.gnuplot.info/demo/param.html">
 媒介変数モードのデモ。
^ </a>
3 範囲 (ranges)
?commands plot ranges
?commands splot ranges
?plot ranges
?splot ranges
?ranges
 このセクションでは、コマンド `plot`, `splot` の一番最初の項目として書
 く、軸の範囲のオプションについてのみ説明します。これを指定すると、その
 範囲は、それ以前のどの `set range` による範囲の制限よりも優先して扱わ
 れます。コマンド `plot` の別な場所に指定する、個々の描画要素の範囲の制
 限ためのオプションについては以下参照: `sampling`。

 書式:
       [{<dummy-var>=}{{<min>}:{<max>}}]
       [{{<min>}:{<max>}}]

 1 つ目の形式の範囲指定は独立変数の範囲 (`xrange`、または媒介変数モード
 での `trange`) 用で、2 つ目の形式は従属変数の範囲用です。オプションの
 <dummy-var> で独立変数の新しい名前を利用できます (デフォルトの変数名は
 `set dummy` で変更できます)。

 媒介変数モード (parametric) でなければ、範囲指定は以下の順に与えなけれ
 ばいけません:
       plot [<xrange>][<yrange>][<x2range>][<y2range>] ...

 媒介変数モード (parametric) では、範囲指定は以下の順に与えなければいけ
 ません:
       plot [<trange>][<xrange>][<yrange>][<x2range>][<y2range>] ...
 以下の `plot` コマンドは、`trange` を [-pi:pi], `xrange` を [-1.3:1.3],
 `yrange` を [-1:1] に設定する例です:

       plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2

 `*` は、min (最小値) や max (最大値) に自動範囲指定 (autoscale) の機能
 を使うことを可能にします。指定順番のためだけに必要な範囲指定には、空の
 範囲 `[]` を使ってください。

 `plot` や `splot` のコマンド行で指定された範囲はそのグラフ一つにのみ影
 響を及ぼします。よって、その後のグラフのデフォルトの範囲を変更するには
 `set xrange` や `set yrange` を使用してください。

 リンクされた軸に対しては、plot コマンドでの一時的な範囲指定の使用は、
 期待する結果を生まないかもしれません (以下参照: `set link`)。

 時間データに対しては、範囲は、データファイルから読み込むのに使用するの
 と同じ書式で、引用符で囲んで指定する必要があります。以下参照:
 `set timefmt`。

 例:

 以下は現在の範囲を使用します:
       plot cos(x)

 以下は x の範囲のみの指定です:
       plot [-10:30] sin(pi*x)/(pi*x)

 以下は上と同じですが、仮変数として t を使います:
       plot [t = -10 :30]  sin(pi*t)/(pi*t)

 以下は x と y の両方の範囲の指定です:
       plot [-pi:pi] [-3:3]  tan(x), 1/x

 以下は、y の範囲のみの指定です:
       plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)

 以下は x の最大値と y の最小値のみの指定です。
       plot [:200] [-pi:]  $mydata using 1:2

 以下は x の範囲を時系列データとして指定しています:
       set timefmt "%d/%m/%y %H:%M"
       plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'

3 サンプリング (sampling)
?sampling
?commands plot sample
?plot sample
?plot sampling
=sample
4 1 次元のサンプリング (x または t 軸) (1D sampling)
?sampling 1D
?plot sampling 1D
 デフォルトでは、関数や疑似ファイル "+" で生成されるデータは、描画範囲
 全体にわたって標本 (サンプル) が取られます。この範囲は、事前にコマンド
 `set xrange` で設定するか、plot コマンドか splot コマンドの最初の場所
 で大域範囲を明示的に指定するかしなければ、そのグラフのすべての要素を含
 む範囲内にデータ全体が入るよう x の範囲を自動縮尺 (autoscaling) します。
 しかし、その標本化範囲は個々の描画要素毎にさらに制限して割り当てること
 もできます。

 例:

 以下は、x 全体の範囲を 0 から 1000 としてファイルのデータを描画し、2
 つの関数を全体の範囲の一部分だけそれぞれ描画します:
       set xrange [0:1000]
       plot 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下は、上とほぼ同様ですが、全体の範囲はデータファイルの内容によって決
 定します。この場合、標本化される関数は、全体がグラフ内に収まるかもしれ
 ませんし、収まらないかもしれません:
       set autoscale x
       plot 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下のコマンドにはあいまいさが含まれます。先頭の範囲は、多分最初の関数
 の標本化のみに向けたのだと思いますが、実際はそうではなく、すべての描画
 要素に適用するように解釈されます:
       plot [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下のコマンドは、上の例のあいまいさを除くためにキーワード `sample` を
 追加したもので、その範囲指定を plot 全体に適用しないようにしています:
       plot sample [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下の例は、3 次元グラフにらせんの曲線を描く一つの方法を提示します:
       set xrange [-2:2]; set yrange [-2:2]
       splot sample [h=1:10] '+' using (cos(h)):(sin(h)):(h)

4 2 次元のサンプリング (u と v 軸) (2D sampling)
?sampling 2D
?plot sampling 2D
 疑似ファイル '++' に対して計算する関数値や生成されたデータは、u, v 軸
 に沿って標本化 (サンプリング) を行います。これは、5.2 より前のバージョ
 ンからの仕様の「変更」で、従来は x, y 軸に沿って標本化していました。以
 下参照: `special-filenames ++`。2 次元のサンプリングは `plot`, `splot`
 コマンドで使用できます。

 以下は、2 次元の `plot` コマンドに対する 2 次元サンプリングの例です。
 これは、描画スタイル `with vectors` で表示されるグラフを生成します。
 以下参照: `vectors`。
      set urange [ -2.0 : 2.0 ]
      set vrange [ -2.0 : 2.0 ]
      plot '++' using ($1):($2):($2*0.4):(-$1*0.4) with vectors

 以下は 3 次元の `splot` コマンドに対する 2 次元サンプリングの例です。
 これは、`sampling.dem` で使用されているものに似たコマンド列です。この
 2 つの曲面は、生成されるグラフの範囲全体よりも狭い u, v の範囲で標本
 化を行うことに注意してください。
      set title "3D sampling range distinct from plot x/y range"
      set xrange [1:100]
      set yrange [1:100]
      splot sample [u=30:70][v=0:50] '++' using 1:2:(u*v) lt 3, \
            [u=40:80][v=30:60] '++' using (u):(v):(u*sqrt(v)) lt 4

 u, v のサンプリングの範囲指定には、サンプリングデータの数とスペースを
 制御する、明示的なサンプリング間隔を入れることもできます:
      splot sample [u=30:70:1][v=0:50:5] '++' using 1:2:(func($1,$2))

3 plot コマンドの for ループ (for loops in plot command)
?commands plot for
?commands splot for
?plot for
?splot for
?for loops
=iteration
 多くの同等のファイルや関数を同時に描画する場合は、それぞれの plot コマ
 ンドの繰り返し (iteration) でそれを行うのが便利です。

 書式:
       plot for [<variable> = <start> : <end> {:<increment>}]
       plot for [<variable> in "string of words"]

 繰り返しの適用範囲 (scope) は、次のコンマ (,) かコマンドの終わり、のい
 ずれか先に現れたところまでです。ただし、描画する項目の前に定義式 (複数
 も可) が並んでいる場合は、コンマが間に入っていてもその例外となります。
 繰り返しは媒介変数モード (parametric) では機能しないことに注意してくだ
 さい。

 例:
       plot for [j=1:3] sin(j*x)

 例:
       plot for [dataset in "apples bananas"] dataset."dat" title dataset

 この例では、繰り返しはファイル名と対応するタイトルの生成の両方で使われ
 ています。

 例:
       file(n) = sprintf("dataset_%d.dat",n)
       splot for [i=1:10] file(i) title sprintf("dataset %d",i)

 この例は、ファイル名で生成される文字列値関数を定義し、そのような 10 個
 のファイルを同時に描画します。繰り返しの変数 (この例では 'i') は一つの
 整数として扱われ、それを 2 度以上使用できます。

 例:
       set key left
       plot for [n=1:4] x**n sprintf("%d",n)

 この例は、関数の組を描画します。

 例:
       list = "apple banana cabbage daikon eggplant"
       item(n) = word(list,n)
       plot for [i=1:words(list)] item(i).".dat" title item(i)
       list = "new stuff"
       replot

 この例では、リストに従って各ステップが進行し、その各項目に対して一つの
 描画が行われます。この各項目は動的に取得されますので、そのリストを変更
 し、そのまま replot することができます。

 例:
       list = "apple banana cabbage daikon eggplant"
       plot for [i in list] i.".dat" title i
       list = "new stuff"
       replot

 この例は、整数の繰り返し変数ではなく、文字列の繰り返し変数形式を用いて
 いること以外は前の例と全く同じです。

 <end> の整数の代わりに記号 * を使用すれば、繰り返しはすべての有効なデ
 ータがなくなるまでの繰り返しとなります。これは、各行に含まれるすべての
 列の処理、あるいはファイル内のすべてのデータセット (2 行の空行で区切ら
 れる) の処理、指定に当てはまるすべてのファイルなどを一度に処理するのに
 便利です。

 例:
       plot for [file in "A.dat B.dat"] for [column=2:*] file using 1:column
       splot for [i=0:*] 'datafile' index i using 1:2:3 with lines
       plot for [i=1:*] file=sprintf("File_%03d.dat",i) file using 2 title file

 警告:
 この最初の例のように、繰り返しはかっこなしの形でも入れ子にできます。し
 かしかっこのない繰り返しを他のかっこのない繰り返しの中に入れ子にするの
 多分有益ではありません。それは、データが見つからなかった場合に両者が同
 時に終了してしまうからです。gnuplot はこれが起きると警告を発します。

3 title
?commands plot title
?commands splot title
?plot title
?splot title
?columnheader
 デフォルトでは各曲線は、対応する関数やファイル名でキーの中に一覧表示さ
 れますが、plot のオプション `title` を使うことで、明示的なタイトルを与
 えることもできます。

 書式:
       title <text> | notitle [<ignored text>]
       title columnheader | title columnheader(N)
             {at {beginning|end}} {{no}enhanced}

 ここで <text> は、引用符で囲まれた文字列か、文字列と評価される式のいず
 れかです。引用符はキーには表示されません。

 入力データの列の最初の項目 (すなわち列の先頭) を文字列フィールドと解釈
 し、それをキータイトルとして利用するオプションもあります。以下参照:
 `datastrings`。これは、`set key autotitle columnhead` を指定すればデフ
 ォルトの挙動となります。

 曲線タイトルとサンプルは予約語 `notitle` を使うことでキーから削除でき
 ます。何もないタイトル (`title ''`) は `notitle` と同じ意味を持ちます。
 サンプルだけが欲しいときは、一つ以上の空白をタイトルの後ろに入れてく
 ださい (`tilte ' '`)。`notilte` の後ろに文字列をつけた場合、その文字列
 は無視されます。

 `key autotitles` が設定されて (デフォルト)、かつ `title` も `notitle`
 も指定されなかった場合、曲線のタイトルは `plot` コマンド上にある関数名
 かデータファイル名になります。ファイル名の場合は、指定される任意のデー
 タファイル修飾子もそのデフォルトタイトルに含まれます。

 位置やタイトルの位置揃えなどの凡例のレイアウトは、`set key` で制御でき
 ます。

 キーワード `at` により、曲線のタイトルを、自動的に作られる key の箱の
 外にでも置くことができるようになります。`at {beginning|end}` を使用し
 た場合は、曲線のタイトルをグラフの曲線自身の直前、あるいは直後に置きま
 す。このオプションは、`with lines` で描画する場合は有用ですが、他の描
 画スタイルでは無意味です。

 `at <x-position>,<y-position>` の形式を使用すれば、曲線のタイトルをペ
 ージ内の任意の位置に置くことができます。デフォルトでは、その位置指定は
 スクリーン座標と解釈します。例えば `at 0.5, 0.5` は、グラフの軸に縮尺
 や境界には関係なく、常にスクリーンのど真ん中を意味します。この方法で配
 置するタイトルの書式は、key のオプション指定の影響を受けます。以下参照:
 `set key`。

 例:

 以下は y=x をタイトル 'x' で表示します:
       plot x

 以下は、x の 2 乗をタイトル "x^2" で、ファイル "data.1" をタイトル
 "measured data" で表示します:
       plot x**2 title "x^2", 'data.1' t "measured data"

 以下は、ファイルの先頭行の各列にタイトルを含む複数列のデータを描画しま
 す。各タイトルは、独立した凡例ではなく、対応する曲線の後ろに置きます:
       unset key
       set offset 0, graph 0.1
       plot for [i=1:4] 'data' using i with lines title columnhead at end

 以下は、2 つの別々のグラフの key の場所を 1 箇所にします:
       set key Left reverse
       set multiplot layout 2,2
       plot sin(x) with points pt 6 title "Left plot is sin(x)" at 0.5, 0.30
       plot cos(x) with points pt 7 title "Right plot is cos(x)" at 0.5, 0.27
       unset multiplot

3 with
?commands plot with
?commands splot with
?commands plot style
?commands splot style
?plot with
?plot style
?splot with
?splot style
?style
?with
 関数やデータの表示にはたくさんのスタイルのうちの一つを使うことができます。
 キーワード `with` がその選択のために用意されています。

 書式:
       with <style> { {linestyle | ls <line_style>}
                      | {{linetype  | lt <line_type>}
                         {linewidth | lw <line_width>}
                         {linecolor | lc <colorspec>}
                         {pointtype | pt <point_type>}
                         {pointsize | ps <point_size>}
                         {arrowstyle | as <arrowstyle_index>}
                         {fill | fs <fillstyle>} {fillcolor | fc <colorspec>}
                         {nohidden3d} {nocontours} {nosurface}
                         {palette}}
                    }


 ここで、<style> は以下のいずれか:
      lines        dots       steps     vectors      yerrorlines
      points       impulses   fsteps    xerrorbar    xyerrorbars
      linespoints  labels     histeps   xerrorlines  xyerrorlines
      financebars  surface    arrows    yerrorbar    parallelaxes
 または、
      boxes         boxplot        ellipses       histograms  rgbalpha
      boxerrorbars  candlesticks   filledcurves   image       rgbimage
      boxxyerror    circles        fillsteps      pm3d        polygons
      isosurface    zerrorfill
 または
      table         mask

 最初のグループのスタイルは、線、点、文字の属性を持ち、第 2 のグループ
 のスタイルは、さらに塗り潰し属性も持っています。以下参照: `fillstyle`。
 さらにサブスタイルを持つスタイルもあります。個々のスタイルの詳細につい
 ては、以下参照: `plotting styles`。
 最後の特別なスタイル 2 つは、すぐに描画するものではありません。以下
 参照: `set table`, `with mask`。スタイル `table` は、表形式の出力をテ
 キストファイルかデータブロックの形で生成します。スタイルが `with mask`
 である plot コマンドの要素は、多角形領域の集合を定義し、それはその
 plot コマンドのその後に続く要素をマスクするのに使えます。

 デフォルトのスタイルは、`set style function` と `set style data` で選
 択できます。

 デフォルトでは、それぞれの関数やデータファイルは、使うことができる型の
 最大数に達するまで異なる線種、点種を使います。すべての端末用ドライバは
 最低 6 つの異なる点種をサポートしていて、もしたくさん要求された場合、
 それらを順に再利用していきます。使用中の出力形式での線種、点種の集合全
 体を見たければ、`test` としてください。

 一つの描画で線種や点種を選びたいならば、<line_type> や <point_type> を
 指定してください。これらの値は、その描画で使われる線種や点種を指定する
 正の整定数 (または数式) です。使用する端末で使える線種、点種を表示する
 には `test` コマンドを使ってください。

 描画の線の幅や点の大きさは <line_width> や <point_size> で変更できます。
 これらはその各々の端末のデフォルトの値に対する相対的な値として指定しま
 す。点の大きさは全体に通用するように変更できます。詳細は、以下参照:
 `set pointsize`。しかし、ここでセットされる <point_size> と、
 `set pointsize` でセットされる大きさは、いずれもデフォルトのポイントサ
 イズに掛けられることに注意してください。すなわち、それらの効果は累積は
 しません。例えば、`set pointsize 2; plot x with points ps 3` は、デフ
 ォルトのサイズの 3 倍であって、6 倍ではありません。

 ラインスタイルの一部分、あるいは各 plot において `pointsize variable`
 という指定も可能です。この場合、入力には追加の 1 列が要求されます。例
 えば 2D 描画では 3 列、3D 描画では 4 列のデータが必要になります。個々
 の点のサイズは、全体を通しての pointsize に、データファイルからの入力
 による値をかけたものとして決定されます。

 `set style line` を使って線種/線幅、点種/点幅の組を定義すれば、そのス
 タイルの番号を <line_style> にセットすることでそれらを使うことができま
 す。

 2 次元、3 次元両方の描画で (`plot` と `splot` コマンド)、事前にコマン
 ド `set palette` で設定した滑らかなパレットからの色を使えます。色の値
 は、点の z 座標の値か、または `using` によるオプションの追加列で与える
 個別の色座標に対応します。色の値は、小数値 (`palette frac`) か、または
 カラーボックスの範囲へ対応づけられた座標値 (`palette` か `palette z`)
 のいずれかで指定できます。以下参照: `colorspec`, `set palette`,
 `linetypes`。

 キーワード `nohidden3d` は、`splot` コマンドで生成される描画にのみ適用
 されます。通常、グローバルなオプション `set hidden3d` はグラフ上の全て
 の描画に適用されますが、各々の描画に `nohidden3d` オプションをつけるこ
 とで、それを hidden3d の処理から除外することができます。`nohidden3d`
 がマークされた曲面以外の個々の描画要素 (線分、点、ラベル等) は、通常は
 他の何らかの描画要素で隠されてしまう場合も全て描画されます。

 同様に、キーワード `nocontours` は、グローバルに `set contour` 指定が
 有効な場合でも、個別の plot に対する等高線描画機能をオフにします。

 同様に、キーワード `nosurface` は、グローバルに `set surface` 指定が有
 効な場合でも、個別の plot に対する 3 次元曲面描画をオフにします。

 キーワードは暗示するような形で省略可能です。

 `linewidth`, `pointsize`, `palette` オプションは全ての端末装置でサポー
 トされているわけではないことに注意してください。

 例:

 以下は、sin(x) を鉛直線で描画します:
       plot sin(x) with impulses

 以下は、x を点で描画し、x**2 をデフォルトの方式で描画します:
       plot x w points, x**2

 以下は、tan(x) を関数のデフォルトの方式で、"data.1" を折れ線で描画します:
       plot tan(x), 'data.1' with l

 以下は、"leastsq.dat" を鉛直線で描画します:
       plot 'leastsq.dat' w i

 以下は、データファイル "population" を矩形で描画します:
       plot 'population' with boxes

 以下は、"exper.dat" をエラーバー付きの折れ線で描画します (エラーバーは
 3 列、あるいは 4 列のデータを必要とします):
       plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars

 もう一つの "exper.dat" のエラーバー付きの折れ線 (errorlines) での描画
 方法 (エラーバーは 3 列、あるいは 4 列のデータが必要):
       plot 'exper.dat' w errorlines

 以下は、sin(x) と cos(x) をマーカー付きの折れ線で描画します。折れ線は
 同じ線種ですが、マーカーは異なったものを使います:
       plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4

 以下は、"data" を点種 3 で、点の大きさを通常の 2 倍で描画します:
       plot 'data' with points pointtype 3 pointsize 2

 以下は、"data" を描画しますが、4 列目から読んだデータを pointsize の値
 として使用します:
       plot 'data' using 1:2:4 with points pt 5 pointsize variable

 以下は、2 つのデータ集合に対して、幅のみ異なる線を用いて描画します:
       plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1

 以下は、x*x の曲線の内部の塗りつぶしと色の帯を描画します:
       plot x*x with filledcurve closed, 40 with filledcurve y=10

 以下は、x*x の曲線と色の箱を描画します:
       plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y=10 lt 8

 以下は、滑らかに変化する色の線で曲面を描画します:
       splot x*x-y*y with line palette

 以下は、2 つの色のついた曲面を、異なる高さで表示します:
       splot x*x-y*y with pm3d, x*x+y*y with pm3d at t

2 print
?commands print
?print
  書式:
        print <式> {, <式>, ...}

 `print` コマンドは、1 つ、または複数の式の値を出力します。出力は、コマ
 ンド `set print` でリダイレクトされていない限り、画面へ行われます。以
 下参照: `expressions`。以下も参照: `printerr`。

 <式> は、gnuplot で有効な任意の式で、数値でも、文字列定数でも、数字や
 文字列を返す関数でも、配列でも、または変数名でも入れることができます。
 データブロックを出力することも可能です。`print` に sprintf や gprintf
 関数を組み合わせて、さらに柔軟な書式の出力を行うことも可能です。

 print コマンド内で繰り返しを使うことで、単一行に複数の値を入れることも
 可能です。

 例:
      print 123 + 456
      print sinh(pi/2)
      print "rms of residuals (FIT_STDFIT) is ", FIT_STDFIT
      print sprintf("rms of residuals is %.3f after fit", FIT_STDFIT)
      print "Array A: ", A
      print "Individual elements of array A: ", for [i=1:|A|] A[i]
      print $DATA

2 printerr
?commands printerr
?printerr
 `printerr` は `print` コマンドとほぼ同じですが、その前の `set print`
 コマンドの効果が続いている状態でも出力を常に stderr に送るところだけが
 違います。
2 pwd
?commands pwd
?pwd
 `pwd` コマンドはカレントディレクトリの名前を画面に表示します。

 カレントディレクトリを文字列変数に保存したり、文字式の中で使いたい場合
 は、変数 GPVAL_PWD を使うことができることに注意してください。以下参照:
 `show variables all`。
2 quit
?commands quit
?quit
 `quit` は、コマンド `exit` と同義です。以下参照: `exit`。
2 raise
?commands raise
?commands lower
?raise
?lower
 書式:
       raise {plot_window_id}
       lower {plot_window_id}

 コマンド `raise` と `lower` は、出力形式のいくつかにしか機能せず、そし
 てあなたが使用するウィンドウマネージャや表示優先機能の設定にも依存する
 可能性があります。
       set term wxt 123     # 最初の描画ウィンドウを生成
       plot $FOO
       lower                # 存在する描画ウィンドウのみを下に
       set term wxt 456     # 2 つ目を生成 (1 つ目の上にかぶる)
       plot $BAZ
       raise 123            # 1 つ目の描画ウィンドウを上に
 これらのコマンドは、あまり当てにならないと思ってください。
2 refresh
?commands refresh
?refresh
 コマンド `refresh` は、`replot` に似ていますが、主に 2 つの点で違いが
 あります。`refresh` は、既に読み込んだデータを用いて、現在の描画を再整
 形し再描画します。これは、`refresh` を (疑似デバイス '-' からの) イン
 ラインデータの描画、および内容が変化しうるデータファイルからの描画に使
 えるということを意味します。ただし、コマンド `refresh` は、既に存在す
 る描画に新しいデータを追加するのには使えません。

 マウス操作、特にズームインとズームアウトでは、適切な場合は `replot` の
 代わりにむしろ `refresh` を使用します。例:

       plot 'datafile' volatile with lines, '-' with labels
       100 200 "Special point"
       e
       # 色んなマウス操作をここで実行
       set title "Zoomed in view"
       set term post
       set output 'zoom.ps'
       refresh

2 replot
?commands replot
?replot
 `replot` コマンドを引数なしで実行すると、最後に実行した `plot` または
 `splot` コマンドを再実行します。これは、あるプロットを異なる `set` オ
 プションでみたり、同じプロットを異なる装置に出力したりするときに便利
 でしょう。

 `replot` コマンドに対する引数は最後に実行した `plot` または `splot`
 コマンドの引数に (暗黙の ',' と共に) 追加され、それから再実行されます。
 `replot` は、範囲 (range) を除いては、`plot` や `splot` と同じ引数を
 とることができます。よって、直前のコマンドが `splot` ではなく `plot`
 の場合は、関数をもう一つの軸刻みでプロットするのに `replot` を使うこと
 ができます。

 注意:

       plot '-' ; ... ; replot

 は推奨されません。それは、これがあなたに再び同じデータすべての入力を要
 求することになるからです。たいていの場合、代わりにコマンド `refresh`
 を使えます。これは、以前に読み込んだデータを使ってグラフを再描画します。

 `multiplot` モードでは、`replot` コマンドはすべての plot ではなく、直
 前の plot 部分だけしか再実行しないことに注意してください。

 最後に実行した `plot` (`splot`) コマンドの内容を修正する方法については
 以下も参照: `command-line-editing`。

 直前の描画コマンドの全体を表示させることや、それを `history` の中に
 コピーする方法については、以下も参照: `show plot`。
2 reread
?commands reread
?reread
 [バージョン 5.4 では非推奨]

 明示的な繰り返し (iteration) を支持し、このコマンドは非推奨とします。
 以下参照: `iterate`。
 `reread` コマンドは、`load` コマンドで指定した `gnuplot` のコマンドフ
 ァイルからの実行を、直ちにそのファイルの先頭から再び開始することを行い
 ます。これは、コマンドファイルの最初から `reread` コマンドまでのコマン
 ドの無限ループを本質的に実装していることになります。標準入力から対話型
 の入力の際は、`reread` コマンドは何の効力も持ちません。
2 reset
?commands reset
?reset
      reset {bind | errors | session}

 コマンド `reset` は、`set` コマンドで定義できる、グラフに関する全ての
 オプションをデフォルトの値に戻します。このコマンドは、load したコマン
 ドファイルを実行した後でデフォルトの設定を復帰したり、設定をたくさん変
 更した後で元の状態に戻したいときなどに便利です。

 以下のものは、`reset` の影響を受けません:
      `set term` `set output` `set loadpath` `set linetype` `set fit`
      `set datafile` `set encoding` `set decimalsign` `set locale`
      `set psdir` `set overflow` `set multiplot`

 `reset` は、必ずしもプログラム立ち上がった初期状態には戻さないことに注
 意してください。それは、初期設定ファイル gnuplotrc や $HOME/.gnuplot、
 $XDG_CONFIG_HOME/gnuplot/gnuplotrc 内のコマンドでデフォルトの値を変更
 した場合は、それもリセットされてしまうからです。しかし `reset session`
 とすれば、それらのコマンドも再実行します。

?reset session
=session
 `reset session` は、ユーザ定義変数、ユーザ定義関数すべてを削除し、デフ
 ォルトの設定を復帰し、システム全体の初期設定ファイル gnuplotrc と個人
 用の初期設ファイル $HOME/.gnuplot、$XDG_CONFIG_HOME/gnuplot/gnuplotrc
 を再実行します。以下参照: `initialization`。

?reset errors
=error state
 `reset errors` は、エラー状態変数 GPVAL_ERRNO と GPVAL_ERRMSG のみをク
 リアします。

?reset bind
=bind
 `reset bind` は、キー定義をデフォルトの状態に復帰します。
2 return
?commands return
?return
 書式:
      return <expression>

 コマンド `return` は、 コマンド `exit` や `quit` が、現在のコードブロ
 ックの実行や入力ストリームを終了するのと同じ方法で作用します。返り値は
 関数ブロック内の実行コードの状況でのみ意味があります。以下参照:
 `function blocks`。

 例:
      function $myfun << EOF
      local result = 0
      if (error-condition) { return -1 }
      ... body of function ...
      return result
      EOF
2 save
?commands save
?save set
?save
?save fit
 書式:
       save  {functions | variables | terminal | set | fit | datablocks}
             '<filename>' {append}

 どれも指定しなかった場合は、`gnuplot` は、ユーザ定義関数、ユーザ変数、
 set で設定するオプション、一番最後に実行した `plot` か `splot` コマン
 ドの全てを保存します。`set term` と `set output` の現在の状態は、コメ
 ントとして書き出します。

 保存ファイルにはテキスト形式で出力し、それは `load` コマンドで読み込む
 ことができます。

 `save terminal` は、`terminal` の状態を、コメント記号をつけずに書き出
 します。これは主に、ちょっとの間だけ `terminal` の設定を入れ替え、その
 後保存しておいた `terminal` の状態を読み込むことで以前の terminal の設
 定に戻す場合などに役立ちます。ただ、単一の gnuplot セッションでは、現
 在の terminal を保存/復元する他の方法であるコマンド `set term push` と
 `set term pop` を使う方がむしろいいかもしれません。以下参照:
 `set term`。

 `save variables` は、すべてのユーザ変数を書き出しますが、データブロッ
 クと内部変数 GPVAL_* GPFUN_* MOUSE_* ARG* は書き出しません。

 `save fit` は、直近の `fit` コマンドで使用した変数のみを保存します。そ
 の保存ファイルは、後で `via` キーワードを使うことで fit コマンドの初期
 化用のパラメータファイルとして利用できます。

 ファイル名は引用符に囲われていなければなりません。

 特別なファイル名 "-" により `save` コマンドに標準出力に出力させること
 ができます。popen 関数をサポートするようなシステム (Unix など) では、
 save の出力をパイプ経由で他の外部プログラムに渡すことができます。その
 場合、ファイル名としてコマンド名の先頭に '|' をつけたものを使います。
 これは、`gnuplot` とパイプを通して通信するプログラムに、`gnuplot` の内
 部設定に関する首尾一貫したインターフェースを提供します。詳細は、以下
 参照: `batch/interactive`。

 例:
       save 'work.gnu'
       save functions 'func.dat'
       save var 'state.dat'; save datablocks 'state.dat' append
       save set 'options.dat'
       save term 'myterm.gnu'
       save '-'
       save '|grep title >t.gp'
2 set-show
?commands set
?commands show
?set
?show
?show all
 `set` コマンドは実に多くのオプションを設定するのに使われます。しかし、
 `plot`, `splot`, `replot` コマンドが与えられるまで何のグラフも描きませ
 ん。

 そのほとんどのオプションに対して、コマンド `show` がそれに対応する現在
 の設定を表示します。`show palette` や `show colornames` などのごく少数
 のコマンドのみ、個別に説明しています。

 `set` コマンドで変更されたオプションは、それに対応する `unset` コマン
 ドを実行することでデフォルトの状態に戻すことができます。以下も参照:
 `reset`。これは全てのパラメータの設定をデフォルトの値に戻します。

=iteration
 `set` と `unset` コマンドには繰り返し節も利用できます。以下参照:
 `plot for`。

3 角の単位 (angles)
?commands set angles
?commands show angles
?set angles
?show angles
?angles
?commands set angles degrees
?set angles degrees
?angles degrees
?degrees
 デフォルトでは `gnuplot` は極座標グラフの独立変数の単位はラジアンを仮定
 します。`set polar` の前に `set angles degrees` を指定すると、その単位
 は度になり、デフォルトの範囲は [0:360] となります。これはデータファイル
 の描画で特に便利でしょう。角度の設定は、`set mapping` コマンドを設定す
 ることにより 3 次元でも有効です。

 書式:
       set angles {degrees | radians}
       show angles

 `set grid polar` で指定される角度も、`set angles` で指定した単位で読まれ
 表示されます。

 `set angles` は組み込み関数 sin(x), cos(x), tan(x) の引数や asin(x),
 acos(x), atan8x), atan2(x), arg(x) の出力にも影響を与えます。双曲線関
 数や、ベッセル関数の引数には影響を与えません。しかし、複素数を引数とす
 る逆双曲線関数の出力には影響が出ます。それらの関数が使われるときは、
 `set angles radians` は入出力の引数の間に一貫性を持った管理を実現して
 いなければなりません。

       x={1.0,0.1}
       set angles radians
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{1.0, 0.1} と表示
 しかし、
       set angles degrees
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{57.29578, 5.729578} と表示
 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 poldat.dem: `set angles` を用いた極座標描画のデモ
^ </a>
3 矢印 (arrow)
?commands set arrow
?commands unset arrow
?commands show arrow
?set arrow
?unset arrow
?show arrow
?arrow
?noarrow
 `set arrow` コマンドを使うことにより、グラフ上の任意の位置に矢印を表示
 することができます。

 書式:
       set arrow {<tag>} from <position> to <position>
       set arrow {<tag>} from <position> rto <position>
       set arrow {<tag>} from <position> length <coord> angle <ang>
       set arrow <tag> arrowstyle | as <arrow_style>
       set arrow <tag> {nohead | head | backhead | heads}
                       {size <headlength>,<headangle>{,<backangle>}} {fixed}
                       {filled | empty | nofilled | noborder}
                       {front | back}
                       {linestyle | ls <line_style>}
                       {linetype | lt <line_type>}
                       {linewidth | lw <line_width>}
                       {linecolor | lc <colorspec>}
                       {dashtype | dt <dashtype>}

       unset arrow {<tag>}
       show arrow {<tag>}

 タグ <tag> は各矢印を識別する整数です。タグを指定しない場合は、その時
 点で未使用の最も小さい数が自動的に割り当てられます。タグを使うことで、
 特定の矢印を変更したり、削除したりできます。既に存在する矢印の属性を変
 更する場合は、タグを明示した `set arrow` コマンドで変更したい属性を指
 定してください。

 矢印の最初の端点の位置は、常に "from" で指定しますが、もう一つの端点は
 以下で説明する 3 つの異なる仕組みのいずれかで指定できます。<position>
 は  x,y あるいは x,y,z で指定します。そしてその前に座標系を選択するた
 めに `first`, `second`, `graph`, `screen`, `character` を置くことがで
 きます。座標を指定しなければデフォルトでは 0 と見なされます。詳細は以
 下参照: `coordinates`。最初の端点に対する座標指定子は、2 番目の端点に
 は影響しません。

 1) "to <position>" は、もう一つの端点の絶対座標を指定します。

 2) "rto <position>" は、"from" の位置からのずれを指定します。この場合、
 線形軸 (非対数軸)、および `graph`, `screen` 座標に対しては、始点と終点
 の距離が与えられた相対的な値に対応します。一方、対数軸に対しては、与え
 られた相対的な値は、始点から終点への倍数に対応します。よって、対数軸の
 場合、相対的な値として 0 や負の値を与えることは許されません。

 3) "length <coordinate> angle <angle>" は、グラフ平面内での矢印の方向
 を指定します。length には任意の座標系を適用できます。angle の単位は常
 に度になっています。

 矢印の他の属性も、あらかじめ定義した矢のスタイルで、またはコマンド
 `set arrow` でそれぞれ与えることが可能です。矢印の他の属性の詳細につい
 ては以下参照: `arrowstyle`。

 例:

 原点から (1,2) への矢印をユーザ定義済のラインスタイル 5 で描くには:
       set arrow to 1,2 ls 5

 描画領域の左下角から (-5,5,3) へタグ番号 3 の矢印を描くには:
       set arrow 3 from graph 0,0 to -5,5,3

 矢印の端を 1,1,1 に変更し、矢先を外して幅を 2 にするには:
       set arrow 3 to 1,1,1 nohead lw 2

 x=3 の所へグラフの下から上まで鉛直線を描くには:
       set arrow from 3, graph 0 to 3, graph 1 nohead

 T 字型の矢先を両端に持つ鉛直方向の矢を描くには:
       set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90

 始点からの相対的な距離をグラフ座標で与えて矢を描くには:
       set arrow from 0,-5 rto graph 0.1,0.1

 x の対数軸に相対的な終点を指定して矢を描く場合:
       set logscale x
       set arrow from 100,-5 rto 10,10
 これは 100,-5 から 1000,5 までの矢を描きます。線形軸 (y) に対しては相
 対的な座標 10 が "差 10" を意味するのに対し、対数軸 (x) に対しては相対
 的な座標 10 は "倍数 10" として働きます。

 2 番の矢印を消すには:
       unset arrow 2

 全ての矢印を消すには:
       unset arrow

 全ての矢印の情報を (タグの順に) 見るには:
       show arrow

^ <a href="http://www.gnuplot.info/demo/arrowstyle.html">
 矢印のデモ
^ </a>

3 自動縮尺 (autoscale)
?commands set autoscale
?commands unset autoscale
?commands show autoscale
?set autoscale
?unset autoscale
?show autoscale
?autoscale
?noautoscale
 自動縮尺機能 (autoscale) は x, y, z の各軸に対して独立に、または一括し
 て指定できます。デフォルトでは全ての軸に対して自動縮尺設定を行います。
 図の中の一部の描画 (`plot`) の組のみを autoscale したい場合は、除外す
 るものの plot コマンドにフラグ `noautoscale` をつければいいでしょう。
 以下参照: `datafile`。

 書式:
       set autoscale {<axis>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
       set autoscale noextend
       unset autoscale {<axis>}
       show autoscale

 ここで、<axis> (軸) は `x`, `y`, `z`, `cb`, `x2`, `y2`, `xy`,
 `paxis <p>` のいずれかです。軸名の後ろに `min` または `max` を追加する
 と、それは `gnuplot` にその軸の最小値、または最大値のみを自動縮尺させ
 ることになります。

 軸名を指定しない場合は、全ての軸が自動縮尺の対象となります。

 独立変数軸 (`plot` のときは x 軸、`splot` のときは x,y 軸) の自動縮尺
 機能は、描画されるデータに合うようにそれらの軸の範囲を調整します。描画
 が関数のみ (入力データなし) の場合、これらの軸の自動縮尺機能は、なんの
 効果も持ちません。

 従属変数軸 (`plot` のときは y 軸、`splot` のときは z 軸) の自動縮尺機
 能は、描画されるデータや関数に合うようにそれらの軸の範囲を調整します。

 軸の範囲の調整は、次の目盛り刻みへの延長を行うことがあります。例えば、
 端のデータの座標が目盛り刻みに丁度一致する場合、データと描画境界との間
 には何もないスペースができることになります。`noextend` を使うことで、
 この余計なスペースの作成を抑制できます。コマンド `set offset` を使うこ
 とで、それをより増やすこともできます。さらなる情報については、以下参照:
 `set xrange`, `set offsets`。

 媒介変数モード (parametric) でも自動縮尺機能は有効です (以下参照:
 `set parametric`)。この場合、より多くの従属変数があるので、x, y, z 各
 軸に関して、より多くの制御が行われます。媒介変数モードでの独立変数 (仮
 変数) は `plot` では t で `splot` では u, v です。そして媒介変数モード
 では、自動縮尺機能は (t, u, v, x, y, z) の全ての描画範囲を制御し、x,
 y, z の範囲の自動設定を完全に行います。

 目盛りが第 2 の軸に表示され、しかもこれらの軸に対する描画が行われなか
 った場合には、x2range と y2range は xrange と yrange の値を受け継ぎま
 す。これは、範囲のずらしの実行や、範囲を整数個の目盛り幅に自動伸縮する
 「前」に行いますので、場合によって予期しない結果をもたらす可能性があり
 ます。これを避けるのに、第 2 軸の範囲を第 1 軸の範囲に明示的にリンク
 (link) する方法があります。以下参照: `set link`。
4 noextend
?set autoscale noextend
?set autoscale keepfix
?set autoscale fix
?autoscale noextend
?noextend
?keepfix
?fix
      set autoscale noextend

 デフォルトでは、自動縮尺機能は軸の範囲の限界を、描画データ全体を含む、
 最も近い目盛りラベル位置に設定します。キーワード `fixmin`, `fixmax`,
 `fix`, `noextend` は、次の目盛り位置までの範囲の自動拡大を gnuplot に
 行わせないようにします。その場合軸の範囲の限界は、一番端にあるデータ点
 の座標値に完全に一致します。`set autoscale noextend` は、
 `set autscale fix` と同じです。軸の範囲指定コマンドの後ろにキーワード
 `noextend` を追加すれば、一つの軸の範囲の延長機能だけ無効にすることも
 できます。例:
      set yrange [0:*] noextend

 `set autoscale keepfix` は、fix の設定を変更せずに残したまま、すべての
 軸を自動縮尺にします。

4 例 (examples)
?autoscale examples
?set autoscale examples
 例:

 以下は y 軸の自動縮尺機能を指定します (他の軸には影響を与えません):
       set autoscale y

 以下は y 軸の最小値に対してのみ自動縮尺機能を指定します (y 軸の最大値、
 および他の軸には影響を与えません):
       set autoscale ymin

 以下は x2 軸の隣の目盛りへの自動範囲拡大機能を無効にし、よって描画デー
 タ内、または関数に対する丁度の描画範囲を維持します:
       set autoscale x2fixmin
       set autoscale x2fixmax

 以下は x, y 両軸の自動縮尺機能を指定します:
       set autoscale xy

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を指定します:
       set autoscale

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を禁止します:
       unset autoscale

 以下は z 軸のみについて自動縮尺機能を禁止します:
       unset autoscale z
4 極座標モード (polar)
?commands set autoscale polar
?set autoscale polar
 極座標モード (`set polar`) では、xrange と yrange は自動縮尺モードでは
 なくなります。動径軸の範囲制限用に `set rrange` を使用した場合、xrange
 と yrange はそれに合うように自動的に調整されます。しかし、さらにそれを
 調整したければ、その後に明示的に xrange や yrange コマンドを使うことが
 できます。以下参照: `set rrange`。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標のデモ。
^ </a>
3 bind
?commands show bind
?show bind
=bind
 `show bind` は、現在のホットキーの割り当て (binding) を表示します。以
 下参照: `bind`。
3 bmargin
?commands set bmargin
?set bmargin
?bmargin
 コマンド `set bmargin` は、下部の余白のサイズを設定します。詳細は
 以下参照: `set margin`。
3 グラフの枠線 (border)
?commands set border
?commands unset border
?commands show border
?set border
?set border polar
?unset border
?show border
?border
?noborder
 `set border` と `unset border` は `plot` や `splot` でのグラフの枠の
 表示を制御します。枠は必ずしも軸とは一致しないことに注意してください。
 `plot` では大抵一致しますが、`splot` では大抵一致していません。

 書式:
       set border {<integer>}
                  {front | back | behind}
                  {linestyle | ls <line_style>}
                  {linetype | lt <line_type>} {linewidth | lw <line_width>}
                  {linecolor | lc <colorspec>} {dashtype | dt <dashtype>}
                  {polar}
       unset border
       show border

 `set view 56,103` のように任意の方向で表示されうる `splot` では、 x-y
 平面上の 4 つの角は 手前 (`front`), 後ろ (`back`) , 左 (`left`), 右
 (`right`) のように呼ばれます。もちろんこの同じ 4 つの角は天井の面にも
 あります。よって、例えば x-y 平面上の後ろと右の角をつなぐ境界を
 "底の右後ろ (bottom right back)" と言い、底と天井の手前の角をつなぐ境
 界を "鉛直手前 (front vertical)" と呼ぶことにします (この命名法は、読
 者が下の表を理解するためだけに使われます)。

 枠は、12 ビットの整数に符号化されています: 下位 4 ビットは `plot` に対
 する外枠、`splot` に対しては底面の外枠、次の 4 ビットは `splot` の鉛直
 な外枠、そして上位 4 ビットは `splot` の天井面の外枠を制御します。よっ
 て外枠の設定は、次の表の対応する項目の数字の和になります:

@start table - first is interactive cleartext form
          ビット     plot        splot
               1      下      底の左手前
               2      左      底の左後ろ
               4      上      底の右手前
               8      右      底の右後ろ
              16    効果なし  鉛直左
              32    効果なし  鉛直後ろ
              64    効果なし  鉛直右
             128    効果なし  鉛直手前
             256    効果なし  天井の左後ろ
             512    効果なし  天井の右後ろ
            1024    効果なし  天井の左手前
            2048    効果なし  天井の右手前
            4096    極座標系  効果なし
#\begin{tabular}{|c|c|c|} \hline
#\multicolumn{3}{|c|}{グラフ境界の符号化} \\ \hline \hline
# ビット & plot & splot \\ \hline
# 1 & 下 & 底の左手前 \\
# 2 & 左 & 底の左後ろ  \\
# 4 & 上 & 底の右手前  \\
# 8 & 右 & 底の右後ろ  \\
# 16 & 効果なし & 鉛直左  \\
# 32 & 効果なし & 鉛直後ろ  \\
# 64 & 効果なし & 鉛直右  \\
# 128 & 効果なし & 鉛直の手前  \\
# 256 & 効果なし & 天井の左後ろ \\
# 512 & 効果なし & 天井の右後ろ  \\
# 1024 & 効果なし & 天井の左手前  \\
# 2048 & 効果なし & 天井の右手前  \\
# 4096 & 極座標系 & 効果なし \\
%c c c .
%ビット @plot@splot
%_
%1@下@底の左手前
%2@左@底の左後ろ
%4@上@底の右手前
%8@右@底の右後ろ
%16@効果なし@鉛直左
%32@効果なし@鉛直後ろ
%64@効果なし@鉛直右
%128@効果なし@鉛直手前
%256@効果なし@天井の左後ろ
%512@効果なし@天井の右後ろ
%1024@効果なし@天井の左手前
%2048@効果なし@天井の右手前
%4096@極座標系@効果なし
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="right">
^  <col align="center">
^  <col align="center">
^</colgroup>
^<thead>
^<tr>    <th>ビット</th>    <th>plot</th>    <th>splot</th></tr>
^</thead>
^<tbody>
^<tr>    <td>1</td>    <td>下</td>    <td>底の左手前</td></tr>
^<tr>    <td>2</td>    <td>左</td>    <td>底の左後ろ</td></tr>
^<tr>    <td>4</td>    <td>上</td>    <td>底の右手前</td></tr>
^<tr>    <td>8</td>    <td>右</td>    <td>底の右後ろ</td></tr>
^<tr>    <td>16</td>    <td>効果なし</td>    <td>鉛直左</td></tr>
^<tr>    <td>32</td>    <td>効果なし</td>    <td>鉛直後ろ</td></tr>
^<tr>    <td>64</td>    <td>効果なし</td>    <td>鉛直右</td></tr>
^<tr>    <td>128</td>    <td>効果なし</td>    <td>鉛直手前</td></tr>
^<tr>    <td>256</td>    <td>効果なし</td>    <td>天井の左後ろ</td></tr>
^<tr>    <td>512</td>    <td>効果なし</td>    <td>天井の右後ろ</td></tr>
^<tr>    <td>1024</td>    <td>効果なし</td>    <td>天井の左手前</td></tr>
^<tr>    <td>2048</td>    <td>効果なし</td>    <td>天井の右手前</td></tr>
^<tr>    <td>4096</td>    <td>極座標系</td>    <td>効果なし</td></tr>
^</tbody>
^</table>

 デフォルトの設定値は 31 で、これは `plot` では 4 方向の外枠全て、
 `splot` では底面の枠線全部と z 軸を描くことを意味します。

 3 次元の 4 本の鉛直な境界線とは別に、コマンド `splot` はデフォルトで、
 曲面のそれぞれの角からグラフの床面への鉛直線を描画します。`set border`
 はこの鉛直線を制御しません。代わりに、`set/unset cornerpoles` を使って
 ください。

 2 次元描画では境界はすべての描画要素の一番上に描かれます (`front`)。
 もし境界を描画要素の下に描かせたい場合は、`set border back` としてくだ
 さい。

 3 次元隠線処理 (hidden3d) 描画では、通常は境界を構成する線も描画要素と
 同様に隠線処理の対象になります。`set border behind` とするとこのデフォ
 ルトの挙動が変わります。

 <linestyle>, <linetype>, <linewidth>, <linecolor>, <dashtype> を指定し
 て、枠線の描画にそれらを反映させることができます (現在の出力装置がサポ
 ートするものに限定されます)。
 さらに、軸の刻み (tics) を描画する際も、それらを境界線上で描画するか、
 軸上で描画するかに関わらず、このラインスタイルを使用します。

 `plot` では、第 2 軸を有効にすることで、下と左以外の境界に目盛りを描く
 ことができます。詳細は、以下参照: `xtics`。

 "`unset surface; set contour base`" などによって `splot` で底面にのみ
 描画する場合、鉛直線や天井はそれらが指定されていても描画されません。

 `set grid` のオプション 'back', 'front', 'layerdefault' でも、描画出力
 の境界線を書く順番を制御できます。

 キーワード `polar` は、極座標グラフに円形の境界をつけます。

 例:

 以下は、デフォルトの枠線を描きます:
       set border

 以下は、`plot` では左と下、`splot` では底面の左手前と左後ろの枠線を描
 きます:
       set border 3

 以下は、`splot` で周りに完全な箱を描きます:
       set border 4095

 以下は、手前の鉛直面と天井のない箱を描きます:
       set border 127+256+512 # または set border 1023-128

 以下は、`plot` に対して上と右枠線のみを描き、それらを軸として目盛りづ
 けします:
       unset xtics; unset ytics; set x2tics; set y2tics; set border 12

3 棒グラフ幅 (boxwidth)
?commands set boxwidth
?commands show boxwidth
?set boxwidth
?show boxwidth
?boxwidth
 コマンド `set boxwidth` は `boxes`, `boxerrorbars`, `boxplot`,
 `candlesticks`, `histograms` スタイルにおける棒のデフォルトの幅を設定
 するために使います。

 書式:
       set boxwidth {<width>} {absolute|relative}
       show boxwidth

 デフォルトでは、隣り合う棒が接するように各々の棒の幅が広げられます。そ
 れとは異なるデフォルトの幅を設定するには `set boxwidth` コマンドを使用
 します。`relative` の場合の幅は、デフォルトの幅に対する比であると解釈
 されます。

 修飾子 `relative` を指定しなかった場合、棒の幅 (boxwidth) として指定さ
 れた明示的な値は、現在の x 軸の単位での数字 (`absolute`) であると解釈
 されます。x 軸が対数軸 (以下参照: `set log`) である場合、boxwidth の値
 は実際には x=1 でのみ "絶対的" となり、その物理的な長さが軸全体を通じ
 て保持されます (すなわち、棒は x 座標の増加にともなって狭くなったりは
 しません)。対数軸の x 軸の範囲が x=1 から離れている場合は、適切な幅を
 見出すには何度か試してみる必要があるかも知れません。

 デフォルトの値は、`boxes` や `boxerrorbars` スタイルの幅指定用の追加の
 データ列の明示的な値があればそれによって置き換えられます。
 詳細は、以下参照: `style boxes`, `style boxerrorbars`。

 棒の幅を自動的にセットするには
       set boxwidth

 棒の幅を自動的な値の半分にするには
       set boxwidth 0.5 relative

 棒の幅を絶対的な値 2 にするには
       set boxwidth 2 absolute
3 3 次元箱の奥行き (boxdepth)
?commands set boxdepth
?commands show boxdepth
?set boxdepth
?show boxdepth
?boxdepth
      set boxdepth {<y extent>} | square
 コマンド `set boxdepth` は、`splot with boxes` で作った 3 次元グラフに
 のみ影響します。これは、y 軸方向の各箱の奥行き (箱の太さ) を設定します。
 `set boxdepth square` は、y 軸方向の奥行きを、x と y の軸の縮尺とは無
 関係に、見た目が正方形の断面になるように選択しようとします。
3 χ-形状 (chi_shapes)
?command set chi_shapes
?set chi_shapes
?command unset chi_shapes
?unset chi_shapes
?chi_shapes
      set chi_shapes fraction <value>
      unset chi_shapes

 凹包 (concave hull) フィルタは、特性長 chi_length で定義されるχ-形状
 (chi-shapes) を生成します。chi_length 変数が設定されていなければ、それ
 は境界多角形 (凸包) における最長の辺の比率に等しい値を選択します。この
 比率のデフォルトは 0.6 ですが、それはこのコマンドで変更できます。その
 値を 1.0 にすると結果の閉包は凸包に縮まります。より小さくすると、凹部
 分がより増える閉包になります。以下参照: `concavehull`。
 コマンド `unset chi_shapes` は比率 0.6 を復帰し、chi_length 変数を未定
 義にします。
3 カラーモード (color)
?commands set color
?set color
 gnuplot は、`plot` や `splot` コマンドの各要素に、事前に定義した列から
 取り出した新しい線属性集合を割り当てます。デフォルトでは、色を変更する
 ことで引き続く曲線同士を区別できるようにしますが、`set monochrome` に
 よるもう一つの方法は、線幅か点線/破線パターンで区別できる黒い曲線の列
 を使用します。コマンド `set color` は、この白黒モードを中断し、デフォ
 ルトのカラー曲線の集合に戻ります。
 以下参照: `set monochrome`, `set linetype`, `set colorsequence`。
3 カラーマップ (colormap)
?commands set colormap
?set colormap
?colormap
?show colormap
=alpha channel
=transparency
=palette
 書式:

      set colormap new <colormap-name>
      set colormap <colormap-name> range [<min>:<max>]
      show colormaps

 `set colormap new <name>` は、カラーマップ配列 <name> を作成し、現在の
 パレット設定をそれに書き出します。この保存したカラーマップは、32bit の
 ARGB カラー値の配列としてのさらなる操作も可能ですし、その後の plot で
 名前を指定して使用することもできます。

 以下は、暗い赤から白へ連続するパレットを生成し、それを 'Reds' という名
 前のカラーパレット配列に保存し、カラーマップのすべてのエントリを少しだ
 け透明化する例です。この名前付きカラーマップは、後で pm3d 曲面に色付け
 するのに使っています。名前付きカラーマップのアルファチャンネル値は、
 ARGB 線属性に従う、すなわち 0 が不透明、0xff が完全な透明であることに
 注意してください。

      set palette defined (0 "dark-red", 1 "white")
      set colormap new Reds
      do for [i=1:|Reds|] { Reds[i] = Reds[i] | 0x3F000000 }
      splot func(x,y) with pm3d fillcolor palette Reds

 z の値からこのカラーマップへの写像は、端の値に対応する z の最小値と最
 大値を指定することで調整できます。例:

      set colormap Reds range [0:10]

 範囲を設定しない場合、あるいは最小値と最大値が同じ値の場合は、現在の
 cbrange の限界値を使用します。以下参照: `set cbrange`。

 カラーマップは、長方形領域をグラデーション塗りするのにも使えます。
 以下参照: `pixmap colormap`。

3 色巡回列 (colorsequence)
?commands set colorsequence
?set colorsequence
?colorsequence
 書式:
      set colorsequence {default|classic|podo}

 `set colorsequence default` は、出力形式に依存しない 8 色の巡回列を選
 択します。以下参照: `set linetype`, `colors`。

 `set colorsequence classic` は、出力形式別にそのドライバが用意する線色
 の列を選択します。色の種類は、4 色から 100 色超まで幅がありますが、そ
 の多くは、赤、緑、青、紫、水色、黄色、で始まります。これがバージョン 5
 以前のデフォルトの挙動です。

 `set colorsequence podo` は、Wong (2011) [Nature Methods 8:441] で推奨
 されている、P 型、D 型 (Protanopia, Deuteranopia) の色弱者が容易に区別
 できる 8 色の組を選択します。

 いずれの場合でも、色列の長さとその色についてはさらにカスタマイズできま
 す。以下参照: `set linetype`, `colors`。
3 clabel
?commands set clabel
?commands unset clabel
?commands show clabel
?set clabel
?unset clabel
?show clabel
?clabel
 このコマンドは非推奨です。代わりに `set cntrlabel` を使用してください。
 `set clabel "format"` は `set cntrlabel format "format"` に、
 `unset clabel` は `set cntrlabel onecolor` に置き換わっています。
3 クリッピング (clip)
?commands set clip
?commands unset clip
?commands show clip
?set clip
?unset clip
?show clip
?clip
 書式:
       set clip {points|one|two|radial}
       unset clip {points|one|two|radial}
       show clip

 デフォルトの状態:
       unset clip points
       set clip one
       unset clip two
       unset clip radial

 グラフ領域の境界内に中心があるデータ点は、その点を表す記号のサイズがそ
 の記号を境界線の外にはみだしてしまうような場合でも、通常は描画します。
 `set clip points` は、2 次元描画でそのような点の中心がグラフ領域内にあ
 る場合でも、そのような点をクリッピングします (つまり描画しません)。点
 の中心がグラフ領域外にあるようなデータ点は、決して描画しません。

 `unset clip` の場合は、線分の一方の端点が描画範囲 (xrange と yrange)
 の外にあれば、その線分は描画しないようにします。

 `set clip one` の場合は、一方の端点が描画範囲内にあって、かつもう一方
 の端点が範囲外にあるような線分の、範囲内に含まれる部分を描画するように
 `gnuplot` に指示します。
 `set clip two` は、両方の端点が描画範囲外にある線分の、範囲内の部分を
 描画するように `gnuplot` に指示します。
 線分全体が描画範囲外であるような線分は決して描画しません。

 `set clip radial` は、極座標モードでのみ効力を持ちます。これは、線のク
 リッピングを、`set rrange [0:MAX]` で確定する円状境界に対して行います。
 この仕組みは、`set clip {one|two}` と組み合わせて使用します。すなわち、
 R > RMAX である 2 つの点の間の線が R = RMAX の円によって切り取られる部
 分は、`clip two` と `clip radial` の両方が設定されている場合のみ描画さ
 れます。

 注意:

 * `set clip` は、描画スタイル `lines`, `linespoints`, `points`,
 `arrows`, `vectors` で生成される点、線分のみに影響します。

 * `pm3d` 曲面や他の中身の詰まったオブジェクトの描画に使用する色長方形
 のクリッピングの制御は、`set pm3d clipping` で行います。デフォルトは、
 現在の zrange に対する滑らかなクリッピングです。

 * オブジェクトのクリッピングは、個々のオブジェクト (object) の
 `clip` か `noclip` 属性で制御します。

 * 現在の gnuplot の版では、極座標モードの "plot with vectors" は、テス
 トしていませんし、最大半径に対するクリッピングもしません。

3 等高線ラベル (cntrlabel)
?commands set cntrlabel
?commands show cntrlabel
?set cntrlabel
?show cntrlabel
?cntrlabel
 書式:
       set cntrlabel {format "format"} {font "font"}
       set cntrlabel {start <int>} {interval <int>}
       set cntrlabel onecolor

 `set cntrlabel` は、凡例内 (デフォルト) か、`splot ... with labels` の
 際のグラフ上の等高線のラベルを制御します。後者の場合、ラベルはラベル記
 述属性の `pointinterval` か `pointnumber` に従って各等高線に沿って配置
 されます。デフォルトではラベルは等高線を構成する 5 番目の線分の上に置
 かれ、20 個の線分毎に繰り返されます。このデフォルトは、以下と同じです:
       set cntrlabel start 5 interval 20
 これらの値はコマンド `set cntrlabel` で、あるいは `splot` コマンドに間
 隔を指定することで変更できます:
       set contours; splot $FOO with labels point pointinterval -1
 間隔を負の値に設定すると、ラベルは各等高線に 1 つだけつきます。しかし
 `set samples` か `set isosamples` が大きな値の場合は多くの等高線をラベ
 ル一つだけで描きます。

 凡例 (key) には、等高線ラベルをそれぞれの線種 (linetype) を使用して書
 きます。デフォルトでは、線種自身が各等高線のレベルを与えるので、それぞ
 れに対する別々のラベルが現れます。コマンド `set cntrlabel onecolor` は
 すべての等高線を同じ線種で描画するので、凡例には一つのラベルのみを書き
 ます。このコマンドは、古いコマンド `unset clabel` を置き換えるものです。
3 等高線制御 (cntrparam)
?commands set cntrparam
?commands show cntrparam
?set cntrparam
?show cntrparam
?cntrparam
 `set cntrparam` は等高線の生成方法、およびそれを滑らかに描画する方法を
 制御します。`show contour` は現在の `contour` の設定だけでなく `cntrparam`
 の設定をも表示します。

 書式:
       set cntrparam { { linear
                       | cubicspline
                       | bspline
                       | points <n>
                       | order <n>
                       | levels { <n>
                                  | auto {<n>}
                                  | discrete <z1> {,<z2>{,<z3>...}}
                                  | incremental <start>, <incr> {,<end>}
                                }
                         {{un}sorted}
                         {firstlinetype N}
                       }
                     }
       show cntrparam

 このコマンドは 2 つの機能を持っています。一つは等高線上の点を決めるた
 めの z の値の設定です。等高線のレベルの数 <n> は整数型の定数式でなけれ
 ばいけません。<z1>, <z2> ... は実数値の数式です。
 もう一つは、個々の等高線の見た目の制御です。

 等高線の平滑化を制御するキーワード:

 `linear`, `cubicspline`, `bspline` --- 近似 (補間) 方法を指定します。
 `linear` ならば、等高線は曲面から得られた値を区分的に直線で結びます。
 `cubicspline` (3 次スプライン) ならば、区分的な直線はいくぶんなめらか
 な等高線が得られるように補間されますが、多少波打つ可能性があります。
 `bspline` (B-spline) は、より滑らかな曲線を描くことが保証されますが、
 これは z の等しい点の位置を近似しているだけです。

 `points` --- 最終的には、全ての描画は、区分的な直線で行われます。ここ
 で指定する数は、`bspline` または `cubicspline` での近似に使われる線分
 の数を制御します。実際には cubicspline と bspline の区間 (曲線線分) の
 数は `points` と線分の数の積に等しくなります。

 `order` --- bspline 近似の次数です。この次数が大きくなるにつれて、等高
 線はなめらかになります (もちろん、高次の bspline 曲線になるほど、元の
 区分的直線からは離れていきます)。このオプションは `bspline` モードでの
 み有効です。指定できる値は、2 (直線) から 10 までの整数です。

 等高線レベルの選択を制御するキーワード:

 `levels auto` --- これがデフォルトです。<n> は仮のレベルの数であり、実
 際のレベルの数は、簡単なラベルを生成するように調節されます。曲面の z
 座標が zmin から zman の範囲にあるとき、等高線はその間の dz の整数倍に
 なるように生成されます。ここで、dz は 10 のあるべき乗の 1, 2, 5 倍、の
 いずれかです (2 つの目盛りの間を丁度割り切るように)。

 `levels discrete` --- 等高線は指定された z = <z1>, <z2> ... に対して生
 成されます。指定した個数が等高線のレベルの個数となります。`discrete`
 モードでは、`set cntrparams levels <n>` という指定は常に無視されます。

 `levels incremental` --- 等高線は z = <start> から始まり、<increment>
 ずつ増えて行き限界の個数に達するまで書かれます。<end> はその等高線の数
 を決定するのに使いますが、これは後の `set cntrparam levels <n>` によっ
 て常に変更されます。z 軸が対数軸の場合、`set ztics` の場合と同様に、
 <increment> は倍数として解釈し、<end> は使用しません。

 等高線の線種の割り当てを制御するキーワード:

 デフォルトでは、等高線は指定の逆順に生成します (`unsorted`)。すわなち、
 `set cntrparam levels increment 0, 10, 100` は、100 から始まって、0 で
 終わる 11 本の等高線を作ります。キーワード `sorted` を追加すると、数値
 の増加方向の順の生成に変更し、例えば今の例では、最初に 0 の等高線を書
 くようになります。

 デフォルトでは、等高線は、対応する曲面に使用した線種の、次からの線種列
 で描きます。すなわち、`splot x*y lt 5` の最初の等高線は線種 6 です。
 `hidden3d` モードが有効な場合、各曲面には 2 つの線種を使うので、デフォ
 ルトの設定では、最初の等高線と曲面の裏面の描画に同じ線種を使ってしまい
 ますが、これは望ましくありません。これを避けるには、以下の 2 つの方法
 があります。
 (1) `set hidden3d offset N` により、曲面の裏面の線種を変更すること。
 `offset -1` とするのがいいですが、これならすべての等高線の線種とぶつか
 りません。
 (2) オプション `set cntrparam firstlinetype N` により、曲面で使用する
 線種とは独立な、等高線で使用する線種群を指定すること。これは、特に等高
 線の線種をカスタマイズしたい場合には有用でしょう。N <= 0 の場合はデフ
 ォルトに戻ります。

 コマンド `set cntrparam` を引数無しで使用すると、指定したすべてのオプ
 ション値をデフォルトにリセットします。
       set cntrparam order 4 points 5
       set cntrparam levels auto 5 unsorted
       set cntrparam firstlinetype 0

4 cntrparam の例 (cntrparam examples)
?commands set cntrparam examples
?set cntrparam examples
?cntrparam examples
 例:
       set cntrparam bspline
       set cntrparam points 7
       set cntrparam order 10

 以下はレベルの基準が合えば 5 個のレベルがに自動的に選択されます:
       set cntrparam levels auto 5

 以下は .1, .37, .9 にレベルを設定します:
       set cntrparam levels discrete .1,1/exp(1),.9

 以下は 0 から 4 まで、1 ずつ増やすレベルを設定します:
       set cntrparam levels incremental  0,1,4

 以下はレベルの数を 10 に設定します (増加の最後の値 (end) または自動で
 設定されるレベルの数は変更されます):
       set cntrparam levels 10

 以下はレベルの数は保持したままレベルの開始値と増分値を設定します:
       set cntrparam levels incremental 100,50

 以下はカスタマイズした等高線の線種群を定義し、使用します:
       set linetype 100 lc "red" dt '....'
       do for [L=101:199] {
           if (L%10 == 0) {
               set linetype L lc "black" dt solid lw 2
           } else {
               set linetype L lc "gray" dt solid lw 1
           }
       }
       set cntrparam firstlinetype 100
       set cntrparam sorted levels incremental 0, 1, 100

 等高線を描く場所の制御に関しては、以下参照: `set contour`。等高線のラ
 ベルの書式と線種の制御に関しては、以下参照: `set cntrlabel`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
D contours 5
D discrete 3
3 カラーボックス (colorbox)
?commands set colorbox
?commands show colorbox
?commands unset colorbox
?set colorbox
?show colorbox
?unset colorbox
?colorbox

 パレットでの色付けを使用するグラフにおいて、特に pm3d でのグラフでは、
 パレットのグラデーションを、`unset colorbox` でスイッチがオフになって
 いない限り、グラフの横のカラーボックス (colorbox) 内に描きます。

       set colorbox
       set colorbox {
                  { vertical | horizontal } {{no}invert}
                  { default | bottom | user }
                  { origin x, y }
                  { size x, y }
                  { front | back }
                  { noborder | bdefault | border <linestyle> }
                    {cbtics <linestyle>}
                }
       show colorbox
       unset colorbox

 グラデーションの方向は、オプション `vertical` (縦) と `horizontal`
 (横) で設定します。

 カラーボックスの位置は、`default`, `bottom`, `user` のいずれかを指定で
 きます。キーワード `bottom` は、以下と同等の便利なショートカットです:

      set colorbox horizontal user origin screen 0.1, 0.07 size 0.8, 0.03.

 `bottom` で指定した場合のようにカラーボックスがグラフの下にあるときは、
 それ用に追加スペースを取ると便利でしょう: `set bmargin screen 0.2`。

 `origin x, y` と `size x, y` は、`user` か `bottom` の配置での正確な位
 置合わせのために使います。x, y の値は、デフォルトではスクリーン座標と
 解釈しますが、これは 3 次元グラフに関しては形式的なオプションに過ぎま
 せん。`set view map` による splot を含む 2 次元描画では、任意の座標系
 が使えます。

 `back`/`front` は、カラーボックスをグラフより前に書くか、後で書くかを
 制御します。

 `border` は境界描画を ON にします (デフォルト) し、`noborder` は境界描
 画を OFF にします。`border` の後ろに正の整数を与えると、それを境界を描
 画する時の line style のタグとして使います。例えば:
     set style line 2604 linetype -1 linewidth .4
     set colorbox border 2604
 は line style `2604`、すなわち細い線のデフォルトの境界色 (-1) で境界を
 描画します。`bdefault` (デフォルト) は、カラーボックスの境界の描画にデ
 フォルトの境界の line style を使います。

 `cbtics` は、カラーボックスの目盛り (cbtics) に対して、境界のラインス
 タイルとは異なる線種を指定するのに使えます。

 カラーボックスの軸は `cb` と呼ばれ、通常の軸のコマンドで制御されます。
 すなわち `set/unset/show` で `cbrange`, `[m]cbtics`, `format cb`,
 `grid [m]cb`, `cblabel` などが、そして多分 `cbdata`, `[no]cbdtics`,
 `[no]cbmtics` なども使えるでしょう。

 パラメータ無しの `set colorbox` はデフォルトの位置へ切替えます。
 `unset colorbox` はカラーボックスのパラメータをデフォルト値にリセット
 し、その上でカラーボックスを OFF にします。

 以下も参照: `set pm3d`, `set palette`, `set style line`。
3 色名 (colornames)
?colornames
Ffigure_colornames
 gnuplot は限定された個数の色の名前を持っています。これらは、pm3d パレ
 ットでつながれる色の範囲を定義するのに、あるいは個々の線種やラインスタ
 イルの色を定義しするのに、または現在のカラーパレットに対するグラデーシ
 ョンを定義するのに使えます。コマンド `show colornames` を使用すること
 で、持っている色名の一覧とその RGB 成分の定義を見ることができます。
 例:
       set style line 1 linecolor "sea-green"
       set palette defined (0 "dark-red", 1 "white")
       print sprintf("0x%06x", rgbcolor("dark-green"))
             0x006400

3 等高線 (contour)
?commands set contour
?commands unset contour
?commands show contour
?set contour
?unset contour
?show contour
?contour
?contours
?nocontour
 コマンド `set contour` は曲面の等高線を引くことを指示します。このオプ
 ションは `splot` でのみ有効です。これは、格子状データ (grid data) を必
 要とします。詳細は、以下参照: `grid_data`。非格子状データで等高線を描
 きたい場合は、格子を生成するために `set dgrid3d` を使用します。

 書式:
       set contour {base | surface | both}
       unset contour
       show contour

 これらの 3 つのオプションは等高線をどこに引くかを指定します。`base` で
 は等高線を x/y 軸の刻みのある底面に描かれ、`surface` では等高線はその
 曲面自体の上に描かれ、`both` では底面と曲面上の両方に描かれます。オプ
 ションが指定されていない場合は `base` であると仮定されます。

 等高線の描画に影響を与えるパラメータについては、以下参照:
 `set cntrparam`。等高線のラベルの制御に関しては、以下参照:
 `set cntrlabel`。

 等高線のみのグラフを得るために、曲面自身の描画をしないようにすることも
 できます (以下参照: `unset surface`)。`set size` を使って、グラフを画
 面一杯に描画することも可能ですが、そういった出力形式よりも、等高線のデ
 ータをデータブロックに書き出し、それを再び 2 次元データとして読み込ん
 で描画すればよりよい制御が可能になります:

       unset surface
       set contour
       set cntrparam ...
       set table $datablock
       splot ...
       unset table
       # 等高線の情報は今 $datablock の中にある
       set term <whatever>
       plot $datablock

 等高線を描くためには、データは格子状データ ("grid data") である必要が
 あります。そのようなファイルでは、一つの y-孤立線上の全ての点が順に
 並べられていきます。そして隣の y-孤立線上の点が順に並べられ、そして隣、
 と続いていきます。y-孤立線同士を分離するには一行の空行 (空白、復帰、改
 行以外の文字を含まない行) を挟みます。

 `set contour` が有効な場合、`splot with <style>` で points, lines,
 impulses, labels 等の描画要素を等高線に沿って配置できます。`with pm3d`
 は、pm3d 曲面を生成し、さらに等高線も書きます。
 `set contour` が有効な際に生成する等高線に、ファイルから読み込んだラベ
 ルなどのその他の描画要素も混ぜたい場合は、splot コマンド内のその命令の
 後ろにキーワード `nocontours` を追加しないといけません。

 以下参照: `splot datafile`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
3 グラフ角の支柱 (cornerpoles)
?command set cornerpoles
?set cornerpoles
?cornerpoles
 デフォルトで、splot は 3 次元曲面のそれぞれの角から床面への鉛直線を描
 画します。これらの鉛直線は、`unset cornerpoles` で消すことができます。
3 点線/破線設定 (dashtype)
?commands set dashtype
?commands show dashtype
?set dashtype
?show dashtype
 コマンド `set dashtype` は、点線/破線パターンを番号で参照できるように
 登録します。これはとても便利で、その点線/破線パターンをその番号で受け
 つけてくれる場所ならば、どこでも明示的な点線/破線パターンも受けつけて
 くれます。
 例:
      set dashtype 5 (2,4,2,6)   # 5 番の dashtype を定義または再定義
      plot f1(x) dt 5            # その dashtype を使って plot
      plot f1(x) dt (2,4,2,6)    # 上と全く同じグラフ
      set linetype 5 dt 5        # このパターンを linetype 5 で常に使う
      set dashtype 66 "..-"      # 文字列で新しい dashtype を定義
 以下参照: `dashtype`。
D dashtypes 2
3 datafile
?set datafile
?show datafile
 コマンド `set datafile` は、`plot`, `splot`, `fit` コマンドで入力デー
 タを読む場合に、その列 (field) の解釈の仕方を制御するオプションを持ち
 ます。
 現在は、そのようなオプションがいくつか実装されています。
4 set datafile columnheaders
?set datafile columnheaders
=columnheaders
 コマンド `set datafile columnheaders` は、入力の最初の行を、データ値と
 してではなく、columnheader として解釈することを保証します。これは、
 plot, splot, fit, stats の各コマンドの入力データ源すべてに影響します。
 この設定を `unset datafile columnheaders` で無効にすると、明示的な
 columnheader() 関数が using 指定にあるか、plot タイトルがファイルに関
 連づけされている場合、同じ効果がファイル毎にオンにされます。以下参照:
 `set key autotitle`, `columnheader`。
4 set datafile fortran
?set datafile fortran
?show datafile fortran
?fortran
 コマンド `set datafile fortran` は、入力ファイルの Fortran D 型、Q 型
 の定数値の特別なチェックを可能にします。この特別なチェックは入力処理を
 遅くしますので、実際にそのデータファイルが Fortran D 型、Q 型の定数を
 持っている場合にのみこれを選択すべきです。このオプションは、その後で
 `unset datafile fortran` を行えば無効にできます。
4 set datafile nofpe_trap
?set datafile nofpe_trap
?fpe_trap
?nofpe_trap
=floating point exceptions
 コマンド `set datafile nofpe_trap` は、入力ファイルからデータの読み込
 みの際に、すべての数式の評価の前に浮動小数点例外ハンドラの再初期化をし
 ないように gnuplot に命令します。これにより、とても大きなファイルから
 のデータの入力がかなり速くなりますが、浮動小数点例外が起きた場合にプロ
 グラムが異常終了してしまう危険はあります。
4 set datafile missing
?set datafile missing
?show datafile missing
?set missing
?missing
 書式:
       set datafile missing "<string>"
       set datafile missing NaN
       show datafile missing
       unset datafile

 コマンド `set datafile missing` は、入力データファイル中で欠損データを
 記述する特別な文字列があることを `gnuplot` に指示します。`missing` に
 関するデフォルト値 (文字) はありません。gnuplot は「欠損データ」と「無
 効な値」(例えば "NaN" や 1/0) を区別します。例えば、連続するデータ点に
 対するグラフの折れ線描画は、無効な値によってそこで切れますが、欠損デー
 タの場合はそうではありません。

 数値が期待される場面で数値ではない文字が現れた場合は、それが `missing`
 で指定する文字列にマッチする場合を除いて、通常欠損データではなく、無効
 な値として解釈します。

 逆に、`set datafile missing NaN` とすると、数式やデータ中の数値ではな
 い値 (NaN) はすべて欠損データとして扱います。

 以下のデモも参照してください。
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 imageNaN デモ。
^ </a>

 gnuplot バージョン 5.4 より、plot コマンドで using 指定が直接列の値を
 `using N`, `using ($N)`, `using (function($N))` のように参照した場合は
 列 N に欠損値フラグを通知します。直接参照におけるそのような場合は、数
 式、例えば func($N) は一切評価されません。これは、浮動小数点エラーや他
 の副作用により gnuplot がエラー停止してしまいかねないことを未然に防ぐ
 ためのものです。

 現在のバージョンの gnuplot は、(column(N)) の形式の直接参照も通知しま
 すが、式が "missing" (欠損値) のフラグがついた列の値に間接的に依存する
 場合でも、評価の最中に通知します。

 これらすべての場合で、gnuplot は入力データ行全体をそれが全くなかったも
 のとして扱います。しかし、式が真に欠けているデータ値に (例えば csv フ
 ァイルの空フィールドのように) 依存している場合、それはこれらのチェック
 をすりぬけるかもしれません。それを NaN 値と評価すれば、それは欠損デー
 タ点ではなく、不正なデータとして扱います。もしそのような不正値をすべて
 欠損値として等しく扱いたい場合は、コマンド `set datafile missing NaN`
 を使用してください。

4 set datafile separator
?set datafile separator
?show datafile separator
?datafile separator
?separator
 コマンド `set datafile separator` は、この後の入力ファイルのデータ列の
 分離文字が、空白 (whitespace) でなくて、ここで指定する文字であると
 `gnuplot` に指示します。このコマンドの最も一般的な使用例は、表計算ソフ
 トやデータベースソフトが作る csv (コンマ区切り) ファイルを読む場合でし
 ょう。デフォルトのデータ列の分離文字は空白 (whitespace) です。

 書式:
       set datafile separator {whitespace | tab | comma | "<chars>"}

 例:
       # タブ区切りのファイルを入力
       set datafile separator "\t"

       # コンマ区切りのファイルを入力
       set datafile separator comma

       # 入力ファイルが * か | のいずれかで区切られた列を持つ場合
       set datafile separator "*|"
4 set datafile commentschars
?set datafile commentschars
?commentschars
 コマンド `set datafile commentschars` は、データファイル中のコメント行
 の開始文字としてどの文字を使うかを指定します。指定した文字の中の一つが
 データ行の最初の非空白文字として現われた場合、そのデータ行のそれ以降の
 部分を無視します。デフォルト文字列は、VMS では "#!"、それ以外では "#"
 です。

 書式:
       set datafile commentschars {"<string>"}
       show datafile commentschars
       unset commentschars

 よって、データファイルの以下の行は完全に無視されます:
     # 1 2 3 4
 が、以下の行
     1 # 3 4
 は、2 列目にゴミがあり、その後に有効なデータが 3 列目と 4 列目にあると
 認識されます。

 例:
       set datafile commentschars "#!%"
4 set datafile binary
?set datafile binary
 コマンド `set datafile binary` は、データファイルの読み込み時にバイナ
 リファイルをデフォルトと設定するのに使われます。書式は、それが `plot`
 または `splot` コマンドで使われるのと正確に同じです。<binary list> に
 書けるキーワードに関しては、詳しくは、以下参照: `binary matrix`,
 `binary general`。

 書式:
       set datafile binary <binary list>
       show datafile binary
       show datafile
       unset datafile

 例:
       set datafile binary filetype=auto
       set datafile binary array=(512,512) format="%uchar"

?show datafile binary
       show datafile binary   # 現在の設定の一覧表示
3 小数点設定 (desimalsign)
?commands set decimalsign
?commands show decimalsign
?commands unset decimalsign
?set decimalsign
?show decimalsign
?unset decimalsign
?decimalsign
=locale
 コマンド `set decimalsign` は、目盛りの見出し、あるいは `set label` 文
 字列に書かれる数の小数点記号を選択します。

 書式:
       set decimalsign {<value> | locale {"<locale>"}}
       unset decimalsign
       show decimalsign

 引数 <value> は、通常の小数点記号に置き換えて使う文字列です。典型的な
 ものはピリオド '.' やコンマ ',' ですが他にも有用なものがあるでしょう。
 引数 <value> を省略すると、小数点の区切りはデフォルト (ピリオド) から
 変更されません。unset decimalsign も <value> を省略するのと同じ効果を
 持ちます。

 例:

 多くのヨーロッパ諸国での正しい出力形式を得るには:
       set decimalsign ','

 次のことに注意してください: 明示的な文字列を設定した場合、これは軸の目
 盛りなどの gnuplot の gprintf() 書式関数で出力される数値のみに影響し、
 入力データの書式指定や sprintf() 書式関数で出力される数値には影響しま
 せん。それらの入力や出力の形式の挙動も変更したい場合は、代わりに以下を
 使用してください:

       set decimalsign locale

 これは、gnuplot に、入力と出力の書式を、環境変数 LC_ALL, LC_NUMERIC,
 LANG の現在の設定に従ったものを使わせるようにします。

       set decimalsign locale "foo"

 これは、gnuplot に、入力と出力の書式を、ロケール "foo" に従ったものに
 しますが、そのロケールがインストールされている必要があります。もしロケ
 ール "foo" が見つからなかった場合、エラーメッセージが出力され、小数点
 の設定は変更されません。linux システム上では、そこにインストールされて
 いるロケールの一覧は "locale -a" で見ることができます。linux のロケー
 ル文字列はだいたい "sl_SI.UTF-8" のような形式をしていますが、Windows
 のロケール文字列は "Slovenian_Slovenia.1250"、または "slovenian" のよ
 うな形式です。ロケール文字列の解釈は、C のランタイムライブラリが行うこ
 とに注意してください。古い C ライブラリでは、ロケール設定のサポート
 (例えば数字の 3 桁毎の区切り文字など) を部分的にしか提供していないかも
 しれません。

       set decimalsign locale; set decimalsign "."

 これは、現在のロケールに合ったどんな小数点でも、全ての入出力に対して使
 用するように設定しますが、gnuplot の内部関数 gprintf() を使って書式化
 する数値は明示的に指定された '.' になります (上書き)。
3 格子状データ処理 (dgrid3d)
?commands set dgrid3d
?commands unset dgrid3d
?commands show dgrid3d
?set dgrid3d
?unset dgrid3d
?show dgrid3d
?dgrid3d
?nodgrid3d
=kdensity
?nogrid
 コマンド `set dgrid3d` は、非格子状データから格子状データへの写像機能
 を有効にし、そのためのパラメータを設定します。格子状データの構造につい
 ての詳細は、以下参照: `splot grid_data`。この処理は、3 次元曲面への当
 てはめで利用できること以外に、2 次元温度分布図を生成するのにも使えます。
 その場合、各点の 'z' の値は局所的な重み付けに寄与します。

 書式:
       set dgrid3d {<rows>} {,{<cols>}} splines
       set dgrid3d {<rows>} {,{<cols>}} qnorm {<norm>}
       set dgrid3d {<rows>} {,{<cols>}} {gauss | cauchy | exp | box
                       | hann} {kdensity} {<dx>} {,<dy>}
       unset dgrid3d
       show dgrid3d

 デフォルトでは `dgrid3d` は無効になっています。有効な場合は、ファイル
 から読み込まれる 3 次元のデータ点は、格子曲面に当てはめるのに使用する
 「散在した」データ (非格子状データ) であると見なされます。格子の寸法は、
 `set dgrid3d` 文で与えるパラメータ row_size/col_size の行数、列数で再
 分割する散在データを囲む矩形 (bounding box) から求めます。格子は x 方
 向 (行) と y 方向 (列) に等間隔です。z の値は散在するデータの z の値の
 重み付きの平均、またはスプライン補間として計算します。言い変えれば、規
 則的な間隔の格子を生成し、全ての格子点で元データの滑かな近似値を評価し
 ます。そして元データの代わりにこの曲面を描画します。

 dgrid3d モードが有効な間は、これを使用せずに格子曲面を生成する個々の点
 や線分を描きたい場合は、対応する splot コマンドにキーワード `nogrid`
 を追加する必要があります。

 デフォルトの列の数は行の数に等しく、そのデフォルトの値は 10 です。

 元のデータから近似値を計算するためのいくつかのアルゴリズムが用意されて
 いて、追加のパラメータを指定できるものもあります。これらの補間は、格子
 点に近いデータ点ほど、その格子点に対してより強い影響を与えます。

 `splines` アルゴリズムは、薄いつぎ板を元にした補間計算を行います。これ
 は追加パラメータを取りません。

 `qnorm` アルゴリズムは各格子点で入力データの重み付き平均を計算します。
 各点には、格子点からの距離の逆数のあるベキ乗で重み付けします。そのベキ
 は追加パラメータの整数値として指定できますが、デフォルトは 1 です。
 このアルゴリズムがデフォルトになっています。

 最後に、重み付き平均の計算用に、いくつかの平滑化重み付け関数 (kernel)
 が用意されています: z = Sum_i w(d_i) * z_i / Sum_i w(d_i), ここで z_i
 は i 番目のデータの値で、d_i は現在の格子点と i 番目のデータ点の位置と
 の距離です。すべての重み付け関数が、現在の格子点に近い方のデータ点には
 大きな重み、遠い方のデータ点には小さい重みを付けます。

 以下の重み付け関数が使用できます:
       gauss :     w(d) = exp(-d*d)
       cauchy :    w(d) = 1/(1 + d*d)
       exp :       w(d) = exp(-d)
       box :       w(d) = 1                     d<1 の場合
                        = 0                     その他
       hann :      w(d) = 0.5*(1+cos(pi*d))     d<1 の場合
                   w(d) = 0                     その他

 これら 5 つの平滑化重み付け関数のうち一つを使用する場合、2 つまでの追
 加パラメータ dx と dy を指定できます。これらは、距離の計算時に座標の違
 いをスケール変換するのに使えます:
 d_i = sqrt( ((x-x_i)/dx)**2 + ((y-y_i)/dy)**2 ), ここで、x,y は現在の
 格子点の座標で、x_i,y_i は i 番目のデータ点の座標です。dy のデフォルト
 の値は dx で、そのデフォルトの値は 1 になっています。パラメータ dx と
 dy は、データ点が格子点へ「データそれ自身の単位で」の寄与を行う範囲の
 制御を可能にします。

 オプションキーワード `kdensity` は、重み付け関数名の後ろでオプションの
 スケール変換のパラメータの前に置くもので、これはアルゴリズムを変更して、
 格子点用に計算する値を重みの和 ( z = Sum_i w(d_i) * z_i ) では割らない
 ようにします。z_i がすべて定数の場合、これは事実上 2 変数の重み付け評
 価を描画します: (上の 5 つのうちの一つの) 重み付け関数が各データ点に置
 かれ、それらの重みの和がすべての格子点で評価され、そして元のデータの代
 わりにこの滑らかな曲面が描画されます。これは、1 次元のデータ集合に対す
 る `smooth kdensity` オプションが行うこととおおまかには同じです。使用
 例に関しては、kdensity2d.dem, heatmap_points.dem を参照してください。

Ffigure_dgrid3d
 オプション `dgrid3d` は、散在するデータを重み付き平均で規則的な格子に
 置き変える単純な仕組みに過ぎません。この問題に対するより洗練された手法
 が存在しますので、この単純な方法が不十分であれば、`gnuplot` の外でその
 ような方法でデータを前処理するべきでしょう。

 ネット上の以下のデモも参照
 ^ <a href="http://www.gnuplot.info/demo/dgrid3d.html">
 dgrid3d
 ^ </a>
 ^ <a href="http://www.gnuplot.info/demo/scatter.html">
 scatter
 ^ </a>
^ <a href="http://www.gnuplot.info/demo/heatmap_points.html">
 heatmap_points
^ </a>
D heatmap_points 1
D heatmap_points 2
D heatmap_points 3

3 仮変数 (dummy)
?commands set dummy
?commands show dummy
?set dummy
?show dummy
?unset dummy
?dummy
 コマンド `set dummy` はデフォルトの仮変数名を変更します。

 書式:
       set dummy {<dummy-var>} {,<dummy-var>}
       show dummy

 デフォルトでは、`gnuplot` は `plot` では、媒介変数モード、あるいは極座
 標モードでは "t", そうでなければ "x" を独立変数 (仮変数) とし、同様に
 `splot` では、媒介変数モードでは (`splot` は極座標モードでは使えません)
 "u" と "v", そうでなければ "x" と "y" を独立変数とします。

 仮変数は、物理的に意味のある名前、あるいはより便利な名前として使う方が
 便利でしょう。例えば、時間の関数を描画する場合:

       set dummy t
       plot sin(t), cos(t)

 例:
       set dummy u,v
       set dummy ,s

 第二の例は、2 番目の変数を s とします。仮変数名をデフォルトの値に戻す
 には以下のようにしてください。

       unset dummy
3 文字エンコード (encoding)
?commands set encoding
?commands show encoding
?set encoding
?show encoding
?encoding
?encodings
?utf8
?sjis
=UTF-8
=SJIS
 コマンド `set encoding` は文字のエンコード (encoding) を選択します。

 書式:
       set encoding {<value>}
       set encoding locale
       show encoding

 有効な値 (value) は以下の通りです。
    default     - 出力形式にデフォルトのエンコードの使用を命令
    iso_8859_1  - UTF-8 より最も一般的な西ヨーロッパエンコード。このエ
                  ンコードは PostScript の世界での 'ISO-Latin1' です。
    iso_8859_15 - ユーロ記号を含む iso_8859_1 の亜種
    iso_8859_2  - 中央/東ヨーロッパで使用されるエンコード
    iso_8859_9  - (Latin5 として知られる) トルコで使用されるエンコード
    koi8r       - 良く使われる Unix のキリル文字エンコード
    koi8u       - Unix のウクライナ地方のキリル文字エンコード
    cp437       - MS-DOS のコードページ
    cp850       - 西ヨーロッパの OS/2 のコードページ
    cp852       - 中央/東ヨーロッパの OS/2 のコードページ
    cp950       - MS 版の Big5 (emf terminal のみ)
    cp1250      - 中央/東ヨーロッパの MS Windows のコードページ
    cp1251      - ロシア、セルビア、ブルガリア、マケドニア語 (8 ビット)
    cp1252      - 西ヨーロッパの MS Windows のコードページ
    cp1254      - トルコの MS Windows のコードページ (Latin5 の拡張)
    sjis        - Shift_JIS 日本語エンコード
    utf8        - 各文字の Unicode エントリポイントの、可変長 (マルチバ
                  イト) 表現

 コマンド `set encoding locale` は、他のオプションとは違い、これは現在
 のロカールを実行時の環境から決定しようとします。たいていのシステムでは
 これは環境変数 LC_ALL, LC_CTYPE, LANG のいずれかによって制御されます。
 この仕組みは、例えば wxt, pdf 出力形式で、UTF-8 や EUC-JP のようなマル
 チバイト文字エンコードを通すために必要です。このコマンドは日付や数字な
 どのロカール特有の表現には影響を与えません。
 以下も参照: `set locale`, `set decimalsign`。

 一般にエンコードの設定は、それがフォントの選択に影響を与えるように、出
 力形式の設定の前に行なう必要があります。
3 誤差線の端 (errorbars)
?commands set errorbars
?commands show errorbars
?set errorbars
?show errorbars
?errorbars
?commands set bars
?commands show bars
?set bars
?show bars
?bars
 コマンド `set errorbars` は、誤差グラフ (errorbar) の両端、および
 boxplot につく箱ひげの両端のマークを制御します。

 書式:
       set errorbars {small | large | fullwidth | <size>} {front | back}
                     {line-properties}
       unset errorbars
       show errorbars

 `small` は 0.0 (交差線なし)、`large` は 1.0 と同じです。サイズを指定し
 なければデフォルトの値は 1.0 です。

 キーワード `fullwidth` は、errorbar を伴う boxplot と histograms にの
 み関連します。これは errorbar の両端の幅を、対応する箱の幅と同じに設定
 しますが、箱の幅自体を変更することはありません。

 キーワード `front`, `back` は、塗り潰し長方形のついた errorbar のみに
 関連します (boxes, candlesticks, histograms)。

 誤差線 (errorbar) は、デフォルトでは関連する箱の境界線と同じ線属性で描
 画しますが、これを誤差線用に用意した線属性に変更できます。

      set errorbars linecolor black linewidth 0.5 dashtype '.'
3 非線形関数回帰 (fit)
?commands set fit
?commands show fit
?set fit
?show fit
?set fit quiet
?set fit verbose
?set fit brief
?set fit results
?set fit prescale
?set fit limit
?set fit maxiter
?set fit errorscaling
?set fit errorvariables
?set fit logfile
?set fit script
?set fit v4
?set fit v5
 コマンド `set fit` は、`fit` コマンド用のオプションを制御します。

 書式:
       set fit {nolog | logfile {"<filename>"|default}}
               {{no}quiet|results|brief|verbose}
               {{no}errorvariables}
               {{no}covariancevariables}
               {{no}errorscaling}
               {{no}prescale}
               {maxiter <value>|default}
               {limit <epsilon>|default}
               {limit_abs <epsilon_abs>}
               {start-lambda <value>|default}
               {lambda-factor <value>|default}
               {script {"<command>"|default}}
               {v4 | v5}
       unset fit
       show fit

 オプション `logfile` は、`fit` コマンドがその出力を書き出す場所を定義
 します。 引数 <filename> は、単一引用符か二重引用符で囲む必要がありま
 す。ファイル名を指定しなかった場合、または `unset fit` を使用した場合
 は、ログファイルはデフォルトの値である "fit.log"、または環境変数
 `FIT_LOG` の値にリセットされます。与えられたログファイル名が / か \ で
 終っている場合、それはディレクトリ名と解釈され、ログファイルはそのディ
 レクトリの "fit.log" となります。

 デフォルトでは、そのログファイルに書かれる情報は、対話型出力にも出力し
 ます。`set fit quiet` はその対話型出力をオフにし、`results` は最終結果
 のみを出力します。`brief` は、追加で fit のすべての繰り返しに関して 1
 行の要約を提供します。`verbose` は、バージョン 4 のような詳細な繰り返
 しの報告を行います。

 オプション `errorvariables` を ON にすると、`fit` コマンドで計算された
 個々の当てはめパラメータの誤差が、そのパラメータの名前に "_err" をつけ
 た名前のユーザ定義変数にコピーされます。これは主に、当てはめ関数とデー
 タの描画グラフの上にパラメータとその誤差を参照用に出力するのに使われま
 す。例:

        set fit errorvariables
        fit f(x) 'datafile' using 1:2 via a, b
        print "error of a is:", a_err
        set label 1 sprintf("a=%6.2f +/- %6.2f", a, a_err)
        plot 'datafile' using 1:2, f(x)

 オプション `errorscaling` を指定すると (デフォルト)、パラメータの計算
 誤差を補正χ自乗 (reduced χ-square) で伸縮します。これは、結果として
 補正χ自乗値になる、当てはめ計算の標準偏差 (FIT_STDFIT) に等しいデータ
 誤差を提供することと同等になります。オプション `noerrorscaling` では、
 評価誤差は、伸縮されない当てはめパラメータの標準偏差になります。
 データの重みを指定しなければ、パラメータの誤差は常に伸縮されます。

 オプション `prescale` をオンにすると、Marquardt-Levenberg ルーチンに渡
 す前に、各パラメータの値をそれらの初期値に従って事前にスケール変換しま
 す。これは、各パラメータの大きさにかなり大きな違いがある場合に、大変有
 効です。ただし、初期値が完全に 0 の当てはめパラメータには、決してこの
 スケール変換は行いません。

 反復数の限界値は、オプション `maxiter` で制限できます。それを 0 か
 `default` とすると、それは限界がないことを意味します。

 オプション `limit` は、収束を検出するためのもっとも小さい数字の限界
 (1e-5) のデフォルトの値を変更するのに使えます。自乗残差の和がこの数値
 未満の比率の変化しかしない場合は、当てはめは「収束した」と判断されます。
 オプション `limit_abs` は、自乗残差の和の変化の限界 (絶対値) を追加し
 ます。デフォルトは 0 です。

 アルゴリズムに関する別の制御をしたい場合、そして Marquardt-Levenberg
 アルゴリズムを良く知っている場合、それに影響を与える以下のオプションが
 利用できます: `lambda` の初期値は、通常自動的に ML-行列から計算されま
 すが、必要ならばオプション `start_lambda` を使ってそれを与えることがで
 きます。それを `default` とすると、再び自動設定が有効になります。オプ
 ション `lambda_factor` は、対象とする関数のχ自乗値が意味ありげに増加
 する/減少するときは常に `lambda` を増加させる/減少させる因子を設定しま
 す。それを `default` とすると、デフォルトの因子である 10.0 にします。

 オプション `script` は、fit を中断したときに実行する `gnuplot` コマン
 ドを指定するものです。以下参照: `fit`。この設定はデフォルトの `replot`
 や環境変数 `FIT_SCRIPT` よりも優先順位は上です。

 オプション `covariancevariables` をオンにすると、最終的なパラメータ間
 の共分散をユーザ定義変数に保存します。各パラメータの組に対してその共分
 散を保存する変数名は、"FIT_COV_" に最初のパラメータ名と "_" と 2 つ目
 のパラメータをつなげた名前になります。例えばパラメータ "a" と "b" に対
 しては、その共分散変数名は "FIT_COV_a_b" となります。

 バージョン 5 では、コマンド fit の書式は変更され、キーワード `error`
 が指定されていない場合は単位重み (`unitweights`) がデフォルトになりま
 した。オプション `v4` で gnuplot バージョン 4 のデフォルトの挙動に戻り
 ます。以下も参照: `fit`。
3 フォントパス (fontpath)
?commands set fontpath
?commands show fontpath
?set fontpath
?show fontpath
?fontpath
 書式:
       set fontpath "/directory/where/my/fonts/live"
       set term postscript fontfile <filename>

 [version 5.4 では非推奨]

 `fontpath` のディレクトリは、postscript 出力形式が作る PostScript 出力
 内に埋め込むフォントにのみ関係します。
 他の gnuplot 出力形式には何の影響も与えません。
 あなたがフォントを埋めこまなければ、このコマンドはあなたには必要ありま
 せんし、埋めこむ場合でも、以下に示す他のパスにフォントが見つからない場
 合にのみ必要なだけです。

 以前の版の gnuplot は、フォントを含む複数のディレクトリツリーを探索す
 ることでフォント管理ソフトをまねていました。
 しかし現在は、以下の場所を検索する方法に置き換わっています。
 (1) `set term postscript fontfile` コマンドで与えた絶対パス
 (2) 現在のディレクトリ (カレントディレクトリ)
 (3) `set loadpath` で指定したディレクトリのすべて
 (4) `set fontpath` で指定したディレクトリ
 (5) 環境変数 GNUPLOT_FONTPATH に指定されているディレクトリ

 注意: libgd の出力形式 (png gif jpeg sixel) 用にファイル名で指定するフ
 ォントの検索パスは、環境変数 GDFONTPATH で制御できます。
3 軸の刻み書式 (format)
?commands set format
?commands show format
?set format
?show format
?format
?format cb
 座標軸の刻みの見出しは、コマンド `set format` または `set tics format`
 または個別にコマンド `set {軸}tics format` で書式を設定できます。入力
 データに対する明示的な書式の使用法については、以下参照: `using format`。

 書式:
       set format {<axes>} {"<format-string>"} {numeric|timedate|geographic}
       show format

 ここで、<axes> (軸) は `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb`、または何
 も指定しないか (その場合その書式はすべての軸に適用されます) のいずれか
 です。以下の 2 つのコマンドは全く同等です:
       set format y "%.2f"
       set ytics format "%.2f"

 書式文字列の長さは 100 文字まで、と制限されています。デフォルトの書式
 文字列は "% h" で、LaTeX 系の出力形式では "$%h$" です。他に "%.2f" や
 "%3.0em" のような書式が好まれることも多いでしょう。"set format" の後ろ
 に何もつけずに実行すると、デフォルトに戻します。

 空文字列 "" を指定した場合、刻み自身は表示しますが見出しはつけません。
 刻み自身を消すには、 `unset xtics` または `set tics scale 0` を使用し
 てください。

 書式文字列では、改行文字 (\n) や拡張文字列処理 (enhanced text) 用のマ
 ークアップも使えます。 この場合は、単一引用符 (') でなく (") を使って
 ください。以下も参照: `syntax`。
 "%" が頭につかない文字はそのまま表示されます。よって、書式文字列内に
 スペースや文字列などを入れることができます。例えば "%g m" とすれば、
 数値の後に " m" が表示されます。"%" 自身を表示する場合には "%g %%" の
 ように 2 つ重ねます。

 刻みに関するより詳しい情報については、以下も参照: `set xtics`。また、
 この方法で出力される数字にデフォルト以外の小数分離文字を使うやり方につ
 いては、以下参照: `set decimalsign`。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/electron.html">
 エレクトロン (電子) デモ (electron.dem).
^ </a>
4 gprintf
?gprintf
 文字列関数 gprintf("format",x) は、gnuplot コマンドの `set format`,
 `set timestamp` などと同様の、gnuplot 独自の書式指定子を使います。これ
 らの書式指定子は、標準的な C 言語の関数である sprintf() のものと全く同
 じではありません。gprintf() は、整形化される引数は一つしか受けつけませ
 ん。そのために、gnuplot には sprintf("format",x1,x2,...) 関数も用意さ
 れています。gnuplot の書式オプションの一覧については、以下参照:
 `format specifiers`。
4 書式指定子 (format specifiers)
?commands set format specifiers
?set format specifiers
?format specifiers
?format_specifiers
 使用可能な書式 (時間/日付モードでない場合) は以下の通りです:

@start table - first is interactive cleartext form
       書式       説明
       %f         固定小数点表記
       %e, %E     指数表記; 指数の前に "e", "E" をつける
       %g, %G     %e (または %E) と %f の略記
       %h, %H     %g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける
       %x, %X     16 進表記
       %o, %O     8 進表記
       %t         10 進の仮数部
       %l         現在の対数尺の底を基数とする仮数部
       %s         現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
       %T         10 進の指数部
       %L         現在の対数尺の底を基数とする指数部
       %S         補助単位の指数部 (scientific power)
       %c         補助単位文字
       %b         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
       %B         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
       %P         πの倍数
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{目盛りラベルの数値書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%f@ & 固定小数点表記 \\
#\verb@%e@, \verb@%E@ & 指数表記; 指数の前に "e", "E" をつける \\
#\verb@%g@, \verb@%G@ & \verb@%e@ (または \verb@%E@) と \verb@%f@ の略記 \\
#\verb@%h@, \verb@%H@ & \verb@%g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける@\\
#\verb@%x@, \verb@%X@ & 16 進表記 \\
#\verb@%o@, \verb@%O@ & 8 進表記 \\
#\verb@%t@ & 10 進の仮数部 \\
#\verb@%l@ & 現在の対数尺の底を基数とする仮数部 \\
#\verb@%s@ & 現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power) \\
#\verb@%T@ & 10 進の指数部 \\
#\verb@%L@ & 現在の対数尺の底を基数とする指数部 \\
#\verb@%S@ & 補助単位の指数部 (scientific power) \\
#\verb@%c@ & 補助単位文字 \\
#\verb@%b@ & ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部\\
#\verb@%B@ & ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞\\
#\verb@%P@ & πの倍数 \\
%c l .
%書式@説明
%_
%%f@固定小数点表記
%%e, %E@指数表記; 指数の前に "e", "E" をつける
%%g, %G@%e (または %E) と %f の略記
%%h, %H@%g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける
%%x, %X@16 進表記
%%o, %O@8 進表記
%%t@10 進の仮数部
%%l@現在の対数尺の底を基数とする仮数部
%%s@現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
%%T@10 進の指数部
%%L@現在の対数尺の底を基数とする指数部
%%S@補助単位の指数部 (scientific power)
%%c@補助単位文字
%%b@ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
%%B@ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
%%P@πの倍数
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%f</tt></td>    <td>固定小数点表記</td></tr>
^<tr>    <td><tt>%e</tt>, <tt>%E</tt></td>    <td>指数表記; 指数の前に "e", "E" をつける</td></tr>
^<tr>    <td><tt>%g</tt>, <tt>%G</tt></td>    <td><tt>%e</tt> (または <tt>%E</tt>) と <tt>%f</tt>の略記</td></tr>
^<tr>    <td><tt>%h</tt>, <tt>%H</tt></td>    <td><tt>%g</tt> に "e%S" の代わりに "x10^{%S}" か "*10^{%S}" をつける</td></tr>
^<tr>    <td><tt>%x</tt>, <tt>%X</tt></td>    <td>16 進表記</td></tr>
^<tr>    <td><tt>%o</tt>, <tt>%O</tt></td>    <td>8 進表記</td></tr>
^<tr>    <td><tt>%t</tt></td>    <td>10 進の仮数部</td></tr>
^<tr>    <td><tt>%l</tt></td>    <td>現在の対数尺の底を基数とする仮数部</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)</td></tr>
^<tr>    <td><tt>%T</tt></td>    <td>10 進の指数部</td></tr>
^<tr>    <td><tt>%L</tt></td>    <td>現在の対数尺の底を基数とする指数部</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>補助単位の指数部 (scientific power)</td></tr>
^<tr>    <td><tt>%c</tt></td>    <td>補助単位文字</td></tr>
^<tr>    <td><tt>%b</tt></td>    <td>ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞</td></tr>
^<tr>    <td><tt>%P</tt></td>    <td>&pi; の倍数</td></tr>
^</tbody>
^</table>

 補助単位 ('scientific' power) は、指数が 3 の倍数であるようなものです。
 補助単位指数 (`"%c"`) の文字への変換は -18 から +18 までの指数に対して
 サポートされています。この範囲外の指数の場合、書式は通常の指数形式に
 戻ります。

 ほかに使うことのできる修飾詞 ("%" と書式指定子の間に書くもの) には、
 次のいくつかがあります: "-" は数字を左詰めにし、"+" は正の数にも符号を
 つけ、" " (空白一つ) は負の数に "-" をつけるべき場所に正の数の場合に空
 白を一つつけ、"#" は小数点以下の数字が 0 だけであっても小数点をつけ、
 正の整数は出力幅を定め、出力幅指定の直前の "0" (文字でなく数字) は先頭
 に空いた部分を空白で埋める代わりに 0 で埋め、小数点の後に非負の整数を
 書いたものは精度を意味します (整数の場合は最小桁、小数の場合は小数点以
 下の桁数)。

 これらの全ての修飾詞をサポートしていない OS もあるでしょうし、逆にこれ
 以外のものをもサポートする OS もあるでしょう。疑わしい場合は、適切な資
 料を調べ、そして実験してみてください。

 例:
       set format y "%t"; set ytics (5,10)          # "5.0" と "1.0"
       set format y "%s"; set ytics (500,1000)      # "500" と "1.0"
       set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
       set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
       set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
       set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
       set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
       set format y "%.0f%%"; set ytic(50)          # "50%"

       set log y 2; set format y '%l'; set ytics (1,2,3)
       #"1.0", "1.0", "1.5" と表示される (3 は 1.5 * 2^1 なので)

 丸めと指数が必要となるような書式で 9.999 の様な数字が書かれる場合は
 問題が起こることがあります。

 軸のデータ型が日時データ (time/date) の場合、書式文字列は 'strftime'
 関数 ('gnuplot' 外。"man strftime" としてみてください) に関する有効な
 指定を行う必要があります。使える入力書式指定の一覧に関しては、以下参照:
 `set timefmt`。
4 日時データ指定子 (time/date specifiers)
?commands set format date_specifiers
?commands set format time_specifiers
?set format date_specifiers
?set format time_specifiers
?set date_specifiers
?set time_specifiers
?date_specifiers
?time_specifiers
 日時書式指定には、日時指定と相対時刻の 2 つのグループがあります。これ
 らは、 軸の刻みのラベルを生成したり、時刻を文字列にエンコードするのに
 使われます。以下参照: `set xtics time`, `strftime`, `strptime`。

 日時書式は以下の通りです。

@start table - first is interactive cleartext form
       書式         説明
       %a           曜日名の省略形 (Sun,Mon,...) (入力では無視)
       %A           曜日名 (Sunday,Monday,...) (入力では無視)
       %b, %h       月名の省略形 (Jan,Feb,...)
       %B           月名 (January,February,...)
       %d           日 (01--31)
       %D           "%m/%d/%y" の簡略形 (出力のみ)
       %F           "%Y-%m-%d" の簡略形 (出力のみ)
       %k           時 (0--23; 1 桁または 2 桁)
       %H           時 (00--23; 常に 2 桁)
       %l           時 (1--12; 1 桁または 2 桁)
       %I           時 (01--12; 常に 2 桁)
       %j           その年の通算日 (001--366)
       %m           月 (01--12)
       %M           分 (00--60)
       %p           "am" または "pm"
       %r           "%I:%M:%S %p" の簡略形 (出力のみ)
       %R           "%H:%M" の簡略形 (出力のみ)
       %S           秒 (出力では 00--60 の整数、入力では実数)
       %s           1970 年最初からの秒数
       %T           "%H:%M:%S" の簡略形 (出力のみ)
       %U           その年の通算週 (CDC/MMWR 疫学的週) (入力では無視)
       %w           曜日番号 (0--6, 日曜 = 0) (入力では無視)
       %W           その年の通算週 (ISO 8601 の週番号) (入力では無視)
       %y           西暦 (2000-2068 年は 0-68、1969-1999 年は 69-99)
       %Y           西暦 (4 桁)
       %z           タイムゾーン、[+-]hh:mm
       %Z           タイムゾーン名、文字列は無視
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{日付指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%a@ & 曜日名の省略形 (Sun,Mon,...) \\
#\verb@%A@ & 曜日名 (Sunday,Monday,...) \\
#\verb@%b@, \verb@%h@ & 月名の省略形 (Jan,Feb,...) \\
#\verb@%B@ & 月名 (January,February,...) \\
#\verb@%d@ & 日 (01--31) \\
#\verb@%D@ & \verb@"%m/%d/%y"@ の簡略形 (出力のみ)\\
#\verb@%F@ & \verb@"%Y-%m-%d"@ の簡略形 (出力のみ)\\
#\verb@%k@ & 時 (0--23; 1 桁または 2 桁) \\
#\verb@%H@ & 時 (00--23; 常に 2 桁) \\
#\verb@%l@ & 時 (1--12; 1 桁または 2 桁) \\
#\verb@%I@ & 時 (01--12; 常に 2 桁) \\
#\verb@%j@ & その年の通算日 (001--366) \\
#\verb@%m@ & 月 (01--12) \\
#\verb@%M@ & 分 (00--60) \\
#\verb@%p@ & "am" または "pm" \\
#\verb@%r@ & \verb@"%I:%M:%S %p"@ の簡略形 (出力のみ)\\
#\verb@%R@ & \verb@"%H:%M"@ の簡略形 (出力のみ)\\
#\verb@%S@ & 秒 (出力では 00--60 の整数、入力では実数)\\
#\verb@%s@ & 1970 年最初からの秒数 \\
#\verb@%T@ & \verb@"%H:%M:%S"@ の簡略形 (出力のみ)\\
#\verb@%U@ & その年の通算週 (CDC/MMWR 疫学的週) (入力では無視)\\
#\verb@%w@ & 曜日番号 (0--6, 日曜 = 0) \\
#\verb@%W@ & その年の通算週 (ISO 8601 の週番号) (入力では無視)\\
#\verb@%y@ & 西暦 (0-99、1969-2068 年の下 2 桁) \\
#\verb@%Y@ & 西暦 (4 桁) \\
#\verb@%z@ & タイムゾーン、[+-]hh:mm \\
#\verb@%Z@ & タイムゾーン名、文字列は無視 \\
%c l .
%書式@説明
%_
%%a@曜日名の省略形 (Sun,Mon,...)
%%A@曜日名 (Sunday,Monday,...)
%%b, %h@月名の省略形 (Jan,Feb,...)
%%B@月名 (January,February,...)
%%d@日 (01--31)
%%D@"%m/%d/%y" の簡略形 (出力のみ)
%%F@"%Y-%m-%d" の簡略形 (出力のみ)
%%k@時 (0--23; 1 桁または 2 桁)
%%H@時 (00--23; 常に 2 桁)
%%l@時 (1--12; 1 桁または 2 桁)
%%I@時 (01--12; 常に 2 桁)
%%j@その年の通算日 (1--366)
%%m@月 (01--12)
%%M@分 (0--60)
%%p@"am" または "pm"
%%r@"%I:%M:%S %p" の簡略形 (出力のみ)
%%R@"%H:%M" の簡略形 (出力のみ)
%%S@秒 (出力では 0--60 の整数、入力では実数)
%%s@1970 年最初からの秒数
%%T@"%H:%M:%S" の簡略形 (出力のみ)
%%U@その年の通算週 (CDC/MMWR 疫学的週)
%%w@曜日番号 (0--6, 日曜 = 0)
%%W@その年の通算週 (ISO 8601 の週番号)
%%y@西暦 (0-99、1969-2068 年の下 2 桁)
%%Y@西暦 (4 桁)
%%z@タイムゾーン、[+-]hh:mm
%%Z@タイムゾーン名、文字列は無視
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>日付書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%a</tt></td>    <td>曜日名の省略形 (Sun,Mon,...)</td></tr>
^<tr>    <td><tt>%A</tt></td>    <td>曜日名 (Sunday,Monday,...)</td></tr>
^<tr>    <td><tt>%b</tt>, <tt>%h</tt></td>    <td>月名の省略形 (Jan,Feb,...)</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>月名 (January,February,...)</td></tr>
^<tr>    <td><tt>%d</tt></td>    <td>日 (01&ndash;31)</td></tr>
^<tr>    <td><tt>%D</tt></td>    <td><tt>%m/%d/%y</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%F</tt></td>    <td><tt>%Y-%m-%d</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%k</tt></td>    <td>時 (0&ndash;23; 1 桁または 2 桁)</td></tr>
^<tr>    <td><tt>%H</tt></td>    <td>時 (00&ndash;23; 常に 2 桁)</td></tr>
^<tr>    <td><tt>%l</tt></td>    <td>時 (1&ndash;12; 1 桁または 2 桁)</td></tr>
^<tr>    <td><tt>%I</tt></td>    <td>時 (01&ndash;12; 常に 2 桁)</td></tr>
^<tr>    <td><tt>%j</tt></td>    <td>その年の通算日 (1&ndash;366)</td></tr>
^<tr>    <td><tt>%m</tt></td>    <td>月 (01&ndash;12)</td></tr>
^<tr>    <td><tt>%M</tt></td>    <td>分 (0&ndash;60)</td></tr>
^<tr>    <td><tt>%p</tt></td>    <td>"am" または "pm"</td></tr>
^<tr>    <td><tt>%r</tt></td>    <td><tt>%I:%M:%S %p</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%R</tt></td>    <td><tt>%H:%M</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>秒 (出力では 0&ndash;60 の整数、入力では実数)</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>1970 年最初からの秒数</td></tr>
^<tr>    <td><tt>%T</tt></td>    <td><tt>%H:%M:%S</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%U</tt></td>    <td>その年の通算週 (CDC/MMWR 疫学的週)</td></tr>
^<tr>    <td><tt>%w</tt></td>    <td>曜日番号 (0&ndash;6, 日曜 = 0)</td></tr>
^<tr>    <td><tt>%W</tt></td>    <td>その年の通算週 (ISO 8601 の週番号)</td></tr>
^<tr>    <td><tt>%y</tt></td>    <td>西暦 (0-99、1969-2068 年の下 2 桁)</td></tr>
^<tr>    <td><tt>%Y</tt></td>    <td>西暦 (4 桁)</td></tr>
^<tr>    <td><tt>%z</tt></td>    <td>タイムゾーン、[+-]hh:mm</td></tr>
^<tr>    <td><tt>%Z</tt></td>    <td>タイムゾーン名、文字列は無視</td></tr>
^</tbody>
^</table>

 書式 %W (ISO の週番号) に関する詳細は、以下参照: `tm_week`。
 書式 %U (CDC/MMWR: アメリカ疾病予防管理センター疫学週報の疫学的週番号)
 は、週が月曜開始でなく日曜開始であることを除けば %W と同様です。
 警告: バージョン 5.4.2 より前の gnuplot では、書式 %W と %U はいずれも
 信頼できません。"week_date.dem" の単位テストを参照してください。

 相対時刻書式は、時刻 0 地点のいずれかの側の時間間隔の長さを表現します。
 相対時刻書式は以下の通りです。

@start table - first is interactive cleartext form
       書式         説明
       %tD          時刻 0 への相対的な正負の日付
       %tH          時刻 0 への相対的な正負の時 (24 での巻戻しなし)
       %tM          時刻 0 への相対的な正負の分
       %tS          直前の tH, tM 項目に対応する正負の秒数
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{時刻指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%tD@ & 時刻 0 への相対的な正負の日付 \\
#\verb@%tH@ & 時刻 0 への相対的な正負の時 (24 での巻戻しなし) \\
#\verb@%tM@ & 時刻 0 への相対的な正負の分 \\
#\verb@%tS@ & 直前の tH, tM 項目に対応する正負の秒数 \\
%c l .
%書式@説明
%_
%%tD@時刻 0 への相対的な正負の日付
%%tH@時刻 0 への相対的な正負の時 (24 での巻戻しなし)
%%tM@時刻 0 への相対的な正負の分
%%tS@直前の tH, tM 項目に対応する正負の秒数
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>時刻書式</th>        <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%tD</tt></td>    <td>時刻 0 への相対的な正負の日付</td></tr>
^<tr>    <td><tt>%tH</tt></td>    <td>時刻 0 への相対的な正負の時 (24 での巻戻しなし)</td></tr>
^<tr>    <td><tt>%tM</tt></td>    <td>時刻 0 への相対的な正負の分</td></tr>
^<tr>    <td><tt>%tS</tt></td>    <td>直前の tH, tM 項目に対応する正負の秒数</td></tr>
^</tbody>
^</table>

 数字を表す書式には、先頭に 0 を埋めるために "0" (ゼロ) を前につけるこ
 とができ、また最小の出力幅を指定するために正の整数を前につけることもで
 きます。書式 %S と %t は精度指定も受けつけるので、小数の時/分/秒を書く
 こともできます。

5 例 (Examples)
?commands set format date_specifiers examples
?commands set format time_specifiers examples
?set format date_specifiers examples
?set format time_specifiers examples
?set date_specifiers examples
?set time_specifiers examples
?date_specifiers examples
?time_specifiers examples

 日付書式の例:

 x の値が、1976 年 12 月 25 日の深夜少し前の時刻に対応する秒数であると
 仮定します。この位置の軸の刻みラベル文字列は、以下のようになります:

       set format x                 # デフォルトでは "12/25/76 \n 23:11"
       set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
       set format x "%r %D"         # "11:11:11 pm 12/25/76"
       set xtics time format "%B"   # "December"

 時刻書式の例:

 日付書式指定は、秒数での時間の値を、ある特定の日の時計の時刻にエンコー
 ドします。よって、時は 0 から 23 まで、分は 0 から 59 までのみを動きま
 すが、それらの負の値は、エポック (1970 年 1 月 1 日) より前の日付に対
 応します。秒数での時間の値を、時間 0 に対する相対的な時/分/秒の数値と
 して出力させるには、時間書式 %tH %tM %tS を使用します。-3672.50 秒の値
 は以下のように出力されます。

       set format x                 # デフォルトでは "12/31/69 \n 22:58"
       set format x "%tH:%tM:%tS"   # "-01:01:12"
       set format x "%.2tH hours"   # "-1.02 hours"
       set format x "%tM:%.2tS"     # "-61:12.50"

3 格子線 (grid)
?commands set grid
?commands unset grid
?commands show grid
?set grid
?set grid vertical
?unset grid
?show grid
?grid
 コマンド `set grid` は格子線を描きます。

 書式:
       set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                {{no}{m}x2tics} {{no}{m}y2tics} {{no}{m}rtics}
                {{no}{m}cbtics}
                {polar {<angle>}}
                {layerdefault | front | back}
                {{no}vertical}
                {<line-properties-major> {, <line-properties-minor>}}
       unset grid
       show grid

 格子線は任意の軸の任意の大目盛り/小目盛りに対して有効/無効にでき、その
 大目盛りと小目盛りに対する線種、線幅も指定でき、現在の出力装置がサポー
 トする範囲で、あらかじめ定義したラインスタイルを使用することもできます
 (以下参照: `set style line`)。

 2 次元描画では極座標格子も選択できます。これは、gnuplot が極座標モード
 (polar) のときの `set grid` のデフォルトの挙動ですが、明示的に
 `set grid polar <angle> rtics` とすれば、極座標モードであるなしに関わ
 らず実行できます。同心円は r 軸の主目盛/副目盛で交差するように描き、動
 径は <angle> の角を空けて描きます。同心円の周囲の目盛りの刻みは、
 `set ttics` で制御しますが、これは動径の格子線を新たには生成しません。

 `set grid` が描く前に、必要な目盛りは有効になっていなければなりません。
 `gnuplot` は、存在しない目盛りに対する格子の描画の命令は単に無視します。
 しかし、後でその目盛りが有効になればそれに対する格子も描きます。

 小格子線に対する線種を何も指定しなければ、大格子線と同じ線種が使われま
 す。デフォルトの極座標の角度は 30 度です。

 `front` を指定すると、格子線はグラフのデータの上に描かれます。`back`
 が指定された場合は格子線はグラフのデータの下に描かれます。`front` を使
 えば、密集したデータで格子線が見えなくなることを防ぐことができます。デ
 フォルトでは `layerdefault` で、これは 2D 描画では `back` と同じです。
 3D 描画のデフォルトは、格子とグラフの枠を 2 つの描画単位に分離し、格子
 は後ろに、枠は描画データまたは関数の前に書きます。ただし、`hidden3d`
 モードでは、それがそれ自身の並び換えをしていますので、格子線の順番のオ
 プションは全て無視され、格子線も隠線処理にかけられます。これらのオプシ
 ョンは、実際には格子線だけでなく、`set border` による境界線とその目盛
 りの刻み (以下参照: `set xtics`) にも影響を及ぼします。

 3 次元描画では、x 軸と y 軸の刻み位置に対する格子線は、デフォルトでは
 z=0 に平行な底面上にしか描きませんが、キーワード `vertical` は、格子線
 を xz 面と yz 面にも zmin から zmax まで描くようにします。

 z の格子線は描画の底面に描かれます。これは描画の周りに部分的な箱が描画
 されている場合にはいいでしょう。以下参照: `set border`。
3 隠線処理 (hidden3d)
?commands set hidden3d
?commands unset hidden3d
?commands show hidden3d
?set hidden3d
?unset hidden3d
?show hidden3d
?hidden3d
?nohidden3d
 `set hidden3d` コマンドは曲面描画 (以下参照: `splot`) で隠線処理を行な
 うように指示します。その処理の内部アルゴリズムに関する追加機能もこのコ
 マンドで制御できます。

 書式:
       set hidden3d {defaults} |
                    { {front|back}
                      {{offset <offset>} | {nooffset}}
                      {trianglepattern <bitpattern>}
                      {{undefined <level>} | {noundefined}}
                      {{no}altdiagonal}
                      {{no}bentover} }
       unset hidden3d
       show hidden3d

 gnuplot の通常の表示とは異なり、隠線処理では与えられた関数、またはデー
 タの格子線を、実際の曲面がその曲面の背後にあって隠されている描画要素は
 見せないのと同じように処理します。これが機能するためには、その曲面が
 '格子状' (以下参照: `splot datafile`) である必要があり、またそれらは
 `with lines` か `with linespoints` で描かれていなければいけません。

 `hidden3d` が有効なときは、格子線だけでなく、面部分や土台の上の等高線
 (以下参照: `set contour`) も隠されます。複数の面を描画している場合は、
 各曲面は自分自身と他の曲面で隠される部分も持ちます。曲面上への等高線の
 表示 (`set contour surface`) は機能しません。

 グラフ上に曲面が一つもない状態でも、hidden3d は `points`, `labels`,
 `vectors`, `impulses` の 3 次元の描画スタイルに影響を与えます。
 `vectors` は、隠されない部分は線分 (矢先なし) として表示されます。グラ
 フ内の各々の描画をこの処理から明示的に除外したいときは、`with` 指定に
 特別のオプション `nohidden3d` を追加してください。

 hidden3d は、pm3d モードで描画された、単色塗りの曲面には影響を与えませ
 ん。pm3d の曲面に対して同様の効果を純粋に得たいならば、これの代わりに
 `set pm3d depthorder` を使ってください。複数の pm3d 曲面に通常の
 `hidden3d` 処理を組み合わせるには、オプション `set hidden3d front` を
 使用してください。これは、hidden3d 処理の全ての要素を、pm3d 曲面を含む
 残りの他の描画要素の後に強制的に描画するものです。

 関数値は格子孤立線の交点で評価されます。見ることの出来る線分を求めると
 きは個々の関数値、あるいはデータ点の間はそのアルゴリズムによって線形補
 間されます。これは、`hidden3d` で描画する場合と `nohidden3d` で描画す
 る場合で関数の見かけが異なることを意味します。なぜならば、後者の場合関
 数値は各標本点で評価されるからです。この違いに関する議論については、
 以下参照: `set samples`, `set isosamples`。

 曲面の隠される部分を消去するのに使われるアルゴリズムは、このコマンドで
 制御されるいくつかの追加オプションを持っています。`defaults` を指定す
 ればそれらはすべて、以下で述べるようなデフォルトの値に設定されます。
 `defaults` が指定されなかった場合には、明示的に指定されたオプションの
 みが影響を受け、それ以外のものは以前の値が引き継がれます。よって、それ
 らのオプションの値をいちいち修正することなく、単に `set {no}hidden3d`
 のみで隠線処理をオン/オフできることになります。

 最初のオプション `offset` は '裏側' の線を描画する線の線種に影響を与え
 ます。通常は曲面の表裏を区別するために、裏側の線種は、表側の線種より一
 つ大きい番号の線種が使われます。`offset <offset>` によって、その追加す
 る値を、デフォルトの 1 とは異なる増分値に変更できます。`nooffset` オプ
 ションは `offset 0` を意味し、これは表裏で同じ線種を使うことになります。

 次のオプションは `trianglepattern <bitpattern>` です。<bitpattern> は
 0 から 7 までの数字で、ビットパターンと解釈されます。各曲面は三角形に
 分割されますが、このビットパターンの各ビットはそれらの三角形の各辺の表
 示を決定します。ビット 0 は格子の水平辺、ビット 1 は格子の垂直辺、ビッ
 ト 2 は、元々の格子が 2 つの三角形に分割されるときの対角辺です。デフォ
 ルトのビットパターンは 3 で、これは全ての水平辺と垂直辺を表示し、対角
 辺は表示しないことを意味します。対角辺も表示する場合は 7 を指定します。

 オプション `undefined <level>` は、定義されていない (欠けているデータ
 または未定義の関数値) か、または与えられた x,y,z の範囲を超えているデ
 ータ点に適用させるアルゴリズムを指示します。そのような点は、それでも
 表示されてしまうか、または入力データから取り除かれます。取り除かれて
 しまう点に接する全ての曲面要素は同様に取り除かれ、よって曲面に穴が生
 じます。<level> = 3 の場合、これは `noundefined` と同じで、どんな点も
 捨てられません。これは他の場所であらゆる種類の問題を引き起こし得るので
 使わないべきです。<level> = 2 では未定義の点は捨てられますが、範囲を超
 えた点は捨てられません。<level> = 1 では、これがデフォルトですが、範囲
 を超えた点も捨てられます。

 `noaltdiagonal` を指定すると、`undefined` が有効のとき (すなわち <level>
 が 3 でない場合) に起こる以下の場合のデフォルトでの取扱いを変更できま
 す。入力曲面の各格子状の部分は一方の対角線によって 2 つの三角形に分割
 されます。通常はそれらの対角線の全てが格子に対して同じ方向を向いていま
 す。もし、ある格子の 4 つの角のうち一つが `undefined` 処理によりとり除
 かれていて、その角が通常の方向の対角線に乗っている場合は、その両方の三
 角形が取り除かれてしまいます。しかし、もしデフォルトの設定である
 `altdiagonal` が有効になっている場合、その格子については他方向の対角線
 が代わりに選択され、曲面の穴の大きさが最小になるようにします。

 `bentover` オプションは今度は `trianglepattern` とともに起こる別のこと
 を制御します。かなりしわくちゃの曲面では、下の ASCII 文字絵に書いたよ
 うに、曲面の 1 つの格子が 2 つに分けられた三角形の表と裏の反対側が見え
 てしまう場合 (すなわち、元の四角形が折り曲げられている ('bent over')
 場合) があります:

                                                               C----B
          元の 4 角形:     A--B      表示される 4 角形:        |\   |
       ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                           |/ |                                |  \ |
                           C--D                                |   \|
                                                               A    D

 曲面の格子の対角辺が <bitpattern> の 2 bit によって見えるようにはなっ
 てはいない場合、上の対角辺 CB はどこにも書かれないことになり、それが結
 果の表示を理解しにくいものにします。デフォルトで定義される `bentover`
 オプションは、このような場合それを表示するようにします。もしそうしたく
 ないなら、`nobentover` を選択してください。
D hidden 6
 以下も参照
^ <a href="http://www.gnuplot.info/demo/hidden.html">
 隠線処理のデモ (hidden.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/singulr.html">
 複雑な隠線のデモ (singulr.dem).
^ </a>
3 コマンド履歴 (history)
?commands set history
?set history
 書式:
    set history {size <N>} {quiet|numbers} {full|trim} {default}

 最近の gnuplot コマンド履歴を、デフォルトでは $HOME/.gnuplot_history
 に保存します。このファイルが見つからず、かつ XDG デスクトップサポート
 が有効な場合、gnuplot は代わりに $XDG_STATE_HOME/gnuplot_history を使
 用します。

 gnuplot の終了時にヒストリファイルに保存する行数を、history size の値
 に制限します。`set history size -1` とすると、ヒストリファイルに書き出
 す行数の制限がなくなります。

 デフォルトでは、コマンド `history` は各コマンドの前に行番号を出力しま
 す。`history quiet` は、今回の実行に対してのみ番号を省略しますが、
 `set history quiet` は、今後のすべての `history` の番号を省略します。

 オプション `trim` は、現在のコマンドに対する前の同じものを削除すること
 で、コマンド履歴内の重複する行の数を減らします。

 デフォルトの設定: `set history size 500 numbers trim`
3 孤立線サンプル数 (isosamples)
?commands set isosamples
?commands show isosamples
?set isosamples
?show isosamples
?isosamples
 関数を面として描画する場合の孤立線 (格子) の密度はコマンド `set isosamples`
 で変更できます。

 書式:
       set isosamples <iso_1> {,<iso_2>}
       show isosamples

 各曲面グラフは <iso_1> 個の u-孤立線と <iso_2> 個の v-孤立線を持ちます。
 <iso_1> のみ指定すれば、<iso_2> は <iso_1> と同じ値に設定されます。
 デフォルトでは、u, v それぞれ 10 本の標本化が行われます。標本数をもっと
 多くすればより正確なグラフが作られますが、時間がかかります。これらの
 パラメータは、データファイルの描画には何も影響を与えません。

 孤立線とは、曲面の一つの媒介変数を固定して、もう一つの媒介変数によって
 描かれる曲線のことです。孤立線は、曲面を表示する単純な方法を与えます。
 曲面 s(u,v) の媒介変数 u を固定することで u-孤立線 c(v) = s(u0,v) が
 作られ、媒介変数 v を固定することで v-孤立線 c(u) = s(u,v0) ができます。

 関数の曲面グラフが隠線処理なしで描かれている場合、`set samples` は
 各孤立線上で標本化される点の数を制御します。以下参照: `set samples`,
 `set hidden3d`。等高線描画ルーチンは、関数の点の標本化は各孤立線の交点
 で行われると仮定しているので、関数の曲面と等高線の解像度を変更するとき
 は、`isosamples` と同じように `samples` を変更するのが望ましいでしょう。
3 等値曲面 (isosurface)
?commands set isosurface
?commands show isosurface
?set isosurface
?show isosurface
 書式:
      set isosurface {mixed|triangles}
      set isosurface {no}insidecolor <n>
 コマンド `splot $voxelgrid with isosurface` で描かれる曲面は、デフォル
 トでは四角形と三角形の混合で構成されます。四角形を使用することで、見た
 目の複雑さの印象を減らす効果があります。このコマンドには、三角形のみで
 モザイク型曲面を描画するオプションも用意されています。

 デフォルトでは、等値曲面の内部は、個別の色で塗ります。色の選択法は、
 hidden3d 曲面の場合と同じで、基本となる線種にオフセットの <n> を追加し
 た値を使用します。曲面の内側と外側の両方を同じ色で塗るには、
 `set isosurface noinsidecolor` を使用してください。
3 isotropic
?commands set isotropic
?set isotropic
?isotropic
 書式:
      set isotropic
      unset isotropic
 `set isotropic` は、グラフのサイズとアスペクト比を、x, y, z 軸に沿う単
 位長さが全く同じになるように合わせます。これは次のコマンドと同値で、こ
 れの代わりに使えます: `set size ratio -1; set view equal xyz`。
 これは、2 次元、3 次元グラフの両方に影響します。

 `unset isotropic` は、2 次元、3 次元グラフの両方でその束縛を開放しま
 す。これは以下の古いコマンドと同値ですが、覚えるにはこれの方が簡単でし
 ょう: `set size noratio; set view noequal_axes`。
3 jitter
?commands set jitter
?set jitter
?jitter
=beeswarm
 書式:
       set jitter {overlap <yposition>} {spread <factor>} {wrap <limit>}
                  {swarm|square|vertical}
 例:
       set jitter                    # 1 文字幅内の点の jitter
       set jitter overlap 1.5        # 1.5 文字幅内の点の jitter
       set jitter over 1.5 spread 0.5  # 同上、しかし x の移動は半分幅

 データの 1 つ、または両方の座標が離散値に制限されている場合、多くの点
 が完全に互いの真上に乗っかる場合があります。jitter (揺らぎ) は、これら
 重なる点を、それらの座標にずらし値を与えることでその点を房状に広げます。
 点が重なっていると見なすための閾値は、文字幅単位、あるいは任意の座標オ
 プションを使って指定できます。以下参照: `coordinates`。jitter は、2 次
 元グラフの `with points` と `with impulses` に影響を与えます。これは、
 3 次元のボクセルデータの描画にも影響を与えます。

 デフォルトの jitter 動作は、点を x 方向のみ移動します。これは、「ビー
 スォームグラフ」(bee swarm plot) と呼ばれる独特のパターンを作ります。
 オプションのキーワード `square` は、移動する点の x 座標に加えて、
 `overlap` で指定した距離だけは少なくとも離れた別々の階層にいるように y
 座標も揃えます。

 jitter を x ではなく y (のみ) に沿わせるには、キーワード `vertical` を
 使用してください。

 文字単位での最大の移動距離は、キーワード `wrap` で制限をかけられます。

 重なりの判定基準と、揺らぎの大きさは、いずれもデフォルトでは 1 文字単
 位であることに注意してください。よってグラフの見た目は、出力形式のフォ
 ントサイズ、キャンバスサイズ、拡大率によって変更してしまいます。これを
 避けるには、重なりの判定基準を y 座標系の単位 (キーワード `first`) で
 指定し、点のサイズと拡大係数を適切な値に調整してください。以下参照:
 `coordinates`, `pointsize`。

 警告: jitter は、"pointsize variable" と両立しません。

 `set jitter` は、3 次元のボクセルデータでも有用です。ボクセル格子デー
 タは、均等に配置された点の規則正しい格子であるため、多くの視方向で、点
 が重なったり、モアレパターンを生成したりします。それらの副作用は、各格
 子点からランダムに移動させた場所に描画する記号を置くことで避けることが
 可能です。
3 凡例 (key)
?commands set key
?commands unset key
?commands show key
?set key
?unset key
?show key
?key
?nokey
?legend
 コマンド `set key` は、描画領域内の各グラフに対するタイトルとサンプル
 (線分、点、箱) を持つ凡例 (または表題) を有効にします。凡例の機能は、
 `set key off` か `unset key` とすることで無効にできます。凡例の個々の
 項目については、対応する plot コマンドでキーワード `notitle` を使用す
 ることで無効にできます。凡例のタイトル文字列は、オプション
 `set key autotitle` や、個々の `plot` や `splot` コマンド上の `title`
 キーワードで制御できます。

 凡例の配置に影響するオプションの書式については以下参照:
 `key placement`。
#TeX \\
 凡例の内容に影響するオプションの書式については以下参照:`key layout`。

 書式 (大域的オプション):
       set key {on|off} {default}
             {font "<face>,<size>"} {{no}enhanced}
             {{no}title "<text>" {<font or other text options>}}
             {{no}autotitle {columnheader}}
             {{no}box {<line properties>}} {{no}opaque {fc <colorspec>}}
             {width <width_increment>} {height <height_increment>}
       unset key

 デフォルトでは、凡例はグラフ領域の内側の右上の角に置きます。
 追加の `font` 指定は、凡例のすべての要素に対するデフォルトになります。
 凡例の頂上に、凡例の横幅全体に渡る、凡例全体用のオプションのタイトルを
 与えるこもできます。このタイトルには、個々の描画タイトルのフォント、色、
 位置合わせ、拡張文字列処理とは別のものを使うことができます。

 凡例内には、plot コマンドの各要素に対して、そのタイトル文字列と、その
 グラフの描画スタイルを示す線分か記号か形が 1 行で表現されます。タイト
 ル文字列は、自動的に生成しますが、plot コマンド中に `title "text"` を
 入れることで明示的に与えることもできます。plot コマンドでキーワード
 `notitle` を使うとそのグラフの凡例行を生成しませんが、タイトルだけを消
 したい場合は plot コマンドで `title ""` としてください。

 等高線描画では、凡例内に対応する行を追加します (以下参照: `cntrlabel`)。
 ファイル名や関数名の代わりにキーワード `keyentry` を与えたダミーの plot
 コマンドを使うことで、凡例内に余分に行を追加することができます。以下
 参照: `keyentry`。

 凡例の回りに枠を、ユーザ指定線属性で描くこともできます (`box {...}`)。
 `height` と `width` の増分は、文字幅単位で指定し、それはその分だけ凡例
 の箱のサイズを大きくしたり小さくしたりします。これは、主に凡例のエント
 リを囲む境界を大きくするのに有用です。

 デフォルトでは、凡例は一つのグラフと同時に作られます。すなわち、凡例の
 記号とタイトルは、それに対応するグラフと同時に描かれます。それは、新し
 いグラフが時には凡例の上に要素をかぶせて配置しうることを意味します。
 `set key opaque` は、凡例をすべてのグラフの描画が終った後に生成させま
 す。この場合、凡例の領域を背景色か指定した色で塗りつぶし、その後で凡例
 の記号とタイトルを書きます。
 `set key noopaque` でデフォルトに復帰できます。

 凡例の文字列は、デフォルトでは拡張文字列モード (`enhanced`) を使用しま
 す。これはオプション `noenhanced` で変更でき、凡例全体、あるいは凡例タ
 イトルのみ、あるいはグラフタイトル毎に変更することも可能です。

 `set key default` は、以下のデフォルトの key の設定を復帰します。
      set key notitle
      set key nobox noopaque
      set key fixed right top vertical Right noreverse enhanced autotitle
      set key noinvert samplen 4 spacing 1 width 0 height 0
      set key maxcolumns 0 maxrows 0

4 3 次元グラフの凡例 (3D key)
?set key 3D
?set key splot
?key 3D
?key splot
?set key fixed
?key fixed
 3 次元グラフ (`splot`) の凡例の配置は、デフォルトでは `fixed` オプショ
 ンを使用します。これは、`inside` による配置に似ていますが、重要な違い
 が一つあります。3 次元グラフの視点が回転したりスケールすると、それに伴
 なって描画の境界も変化します。凡例の配置が `inside` の場合は、視点が変
 更するときにこれらの境界が移動するため、凡例も移動します。`fixed` の場
 合は、視角やスケールの変更を無視して凡例を配置するので、グラフが回転し
 ても、凡例の位置はキャンバスの一つの場所に固定されたままになります。

 なお、2 次元グラフでは、`fixed` オプションは完全に `inside` と同じです。

 `splot` で等高線を書く場合、デフォルトでは異なる線種の個々の等高線レベ
 ルに対して、別々の凡例の項目を生成します。これを変更するには、以下参照:
 `set cntrlabel`。
4 凡例のサンプル (key examples)
?set key examples
?key examples
 以下はデフォルトの位置に凡例を表示します:
       set key default

 以下は、凡例をスクリーン座標での指定位置 (右上) に配置します。
       set key at screen 0.85, 0.85

 以下は、凡例をグラフより下 (奥) に置き、垂直方向の幅を最小化します。
       set key below horizontal

 以下は、凡例をグラフ領域の左下隅に置き、文字列は左揃えとし、上に凡例の
 タイトルを与え、回りを太い境界線の枠で囲みます。
       set key left bottom Left title 'Legend' box lw 3

4 凡例行の追加 (extra key entries)
?key entries
?keyentry
Ffigure_keyentry
 通常、各グラフに対して凡例内に 1 行のエントリが自動生成されます。凡例
 内に見た目をより細かく制御したい場合は、コマンド `plot`, `splot` にキ
 ーワード `keyentry` をつけることで、余分に凡例行を追加できます。plot
 にファイル名や関数名を与える代わりに、`keyentry` をその場所に指定し、
 スタイル情報 (凡例の記号を生成するのに使用される) とタイトルをその後ろ
 に指定します。通常のタイトルフォント、文字色、`at` 座標、拡張文字列処
 理に対するオプションは、すべて適用します。
 例:
      set key outside right center title "Outcomes"
      plot $HEATMAP matrix with image notitle, \
           keyentry with boxes fc palette cb 0 title "no effect", \
           keyentry with boxes fc palette cb 1 title "threshold", \
           keyentry with boxes fc palette cb 3 title "typical range", \
           keyentry with labels nopoint title "as reported in [12]", \
           keyentry with boxes fc palette cb 5 title "strong effect"
4 凡例の自動タイトル (key autotitle)
?commands set key autotitle
?set key autotitle
?key autotitle
?autotitle
?autotitle columnheader
?key autotitle columnheader
 `set key autotitle` は、凡例の各グラフを、plot コマンドで使用したデー
 タファイルや関数の名前によって特定するようにしますが、これがデフォルト
 の挙動です。`set key noautotitle` は、その自動的なグラフのタイトル付け
 を無効にします。
=columnheader
 コマンド `set key autotitle columnheader` は、各入力データの先頭行の各
 列のエントリをテキスト文字列と解釈し、対応する描画グラフのタイトルとし
 て使用します。描画される量が、複数の列データの関数である場合は、
 gnuplot はどの列をタイトルの描画に使えばいいのかわかりませんので、その
 場合、plot コマンド上で、例えば以下のように明示的にタイトルの列を指定
 する必要があります。

       plot "datafile" using (($2+$3)/$4) title columnhead(3) with lines

 注意: `set key autotitle columnheader` とすると、たとえ凡例 (key) が
 `unset key` で無効になっている場合でも、1 列目をデータとしてではなく、
 列のヘッダとして処理します。これは、`stats` や `fit` のように凡例を作
 らないコマンドに対しても同様です。データの先頭行をグラフのタイトルでは
 なく columnheader として使用したい場合は、`set datafile columnheaders`
 としてください。

 また、いずれの場合でも、plot コマンドに明示的な `title` や `notitle`
 キーワードを指定すれば、それは `set key autotitle` による設定より優先
 されます。
4 凡例のレイアウト (key layout)
?set key layout
?key layout
 凡例のレイアウト用オプション:
      set key {vertical | horizontal}
             {maxcols {<max no. of columns> | auto}}
             {maxrows {<max no. of rows> | auto}}
             {columns <exact no. of columns>}
             {keywidth [screen|graph] <fraction>}
             {Left | Right}
             {{no}reverse} {{no}invert}
             {samplen <sample_length>} {spacing <line_spacing>}
             {width <width_increment>} {height <height_increment>}
             {title {"<text>"} {{no}enhanced} {center | left | right}}
             {font "<face>,<size>"} {textcolor <colorspec>}

 凡例の要素を自動的に行、または列に並べるやり方は、上のキーワードの影響
 を受けます。デフォルトは、`vertical` で、これは可能な限り列数を少なく
 しようとします。各要素は、垂直方向に余裕があるうちは縦に揃えて並べます
 が、足りなくなれば新しい列に並べます。垂直方向の幅は、'maxrows' で上限
 を設定できます。
 `horizontal` の場合は、可能な限り行数を少なくしようとし、水平方向の幅
 は、'maxcols' で上限を設定できます。

 自動で選択される行数、列数には満足できないかもしれません。その場合、
 `set key columns <N>` で列数を明確に指定できます。この場合、サンプル幅
 (`samplen`) と全体の凡例幅 (`keywidth`) も調整する必要があるかもしれま
 せん。

 デフォルトでは、最初の描画のラベルが凡例の一番上に現われ、それに続くラ
 ベルがその下に並んで行きます。オプション `invert` は、最初のラベルを凡
 例の一番下に置き、それに続くラベルをその上に並べて行きます。このオプシ
 ョンは、凡例のラベルの縦の並びの順番を、積み上げ形式のヒストグラム
 (`histograms`) の箱の順番に合わせるときに便利でしょう。

 `set key title "text"` は、凡例の上に、全体に渡るタイトルを置きます。
 そのタイトルのフォント、文字列の行揃え、およびその他の文字属性は、この
 コマンドの `"text"` の直後に必要なキーワードを置くことで指定できます。
 他の場所で指定したフォントや文字列の属性は、凡例内のすべての文字列に適
 用します

 デフォルトのレイアウトは、スタイルサンプル (色、線、点、形状等) を凡例
 の各行の左に置き、タイトル文字列を右に置きます。このサンプルと文字列の
 位置は、`reverse` キーワードで逆転できます。凡例内のグラフタイトルの行
 揃えは、`Left`、`Right` (デフォルト) で指示します。スタイルサンプルの
 水平方向の幅は、ほぼ文字幅単位の数値で設定できます (`samplen`)。

  TeX, LaTeX 系の出力形式や、整形情報が文字列に埋め込まれる出力形式を使
 う場合は、`gnuplot` は必要な幅の見積りがうまくはできませんので、自動的
 な凡例のレイアウトは、見すぼらしいものになり得ます。凡例を左に置く場合
 は、`set key left Left reverse` という組合せがいいかもしれませんし、適
 切な列数や全体の凡例幅を強制的に設定するといいかもしれません。

4 凡例の配置 (key placement)
?commands set key placement
?set key placement
?key placement
 凡例の配置用オプション:
       set key {inside | outside | fixed}
               {lmargin | rmargin | tmargin | bmargin}
               {at <position>}}
               {left | right | center} {top | bottom | center}
               {offset <dx>,<dy>}

 この節では、自動的に生成される通常の凡例の配置の説明をします。二次的な
 凡例の構成や、他の場所への描画タイトルの配置については、以下参照:
 `multiple keys`。

#TeX \begin{minipage}{0.5\textwidth}
 配置の仕組みを理解ための最も重要な概念は、グラフ領域、すなわち内か外か
 ということと、グラフ領域の境界との間の余白 (margin) を考えることです。
 グラフ領域に沿って、キーワード `left/center/right` (l/c/r) と
 `top/center/bottom` (t/c/b) は、凡例 (key) をその領域の内側のどこに置
 くかを制御します。
 モード `inside` では、凡例はキーワード `left` (l), `right` (r), `top`
 (t), `bottom` (b), `center` (c) によって以下の図のように描画領域の境界
 に向かって出力されます:

#TeX \end{minipage}
#TeX \hspace{0.15\textwidth}
#TeX \begin{minipage}{0.35\textwidth}

      t/l   t/c   t/r

      c/l    c    c/r

      b/l   b/c   b/r

#TeX \end{minipage}

 モード `outside` でも上と同様に自動的に配置されますが、グラフ領域の境
 界に対して、というよりもむしろ見た目に対して、というべきでしょう。すな
 わち、グラフの境界は、グラフ領域の外の凡例の場所を作るために、内側に移
 動することになります。しかし、これは他のラベルの邪魔をしますし、もしか
 したら出力デバイスによってはエラーを引き起こすかもしれません。凡例の出
 力に合わせてどの描画境界が移動するかは、上に述べた凡例の位置、および重
 ね上げの方向に依存します。4 方向の中心揃えのオプション (`center`) に関
 しては、どの境界が動くのかに関するあいまいさはありませんが、角への出力
 のオプションについては、重ね上げ方向が `vertical` の場合は左または右の
 境界が、`horizontal` の場合は上または下の境界が、それぞれ内側に適切に
 移動します。

#TeX \begin{minipage}{0.5\textwidth}
 余白 (margin) の書き方は、重ね上げの方向にかかわない自動的な配置を可能
 にしています。`lmargin` (lm), `rmargin` (rm), `tmargin` (tm),
 `bmargin` (bm) のうちの一つを、矛盾しない 1 方向のキーワードと組み合わ
 せて使用した場合、凡例の位置は、以下の図に示すようにページの外側に沿っ
 て配置されます。
 キーワード `above` と `over` は `tmargin` と同じ意味で、キーワード
 `below` と `under` は `bmargin` と同じ意味です。

#TeX \end{minipage}
#TeX \hspace{0.1\textwidth}
#TeX \begin{minipage}{0.4\textwidth}

           l/tm  c/tm  r/tm

      t/lm                  t/rm

      c/lm                  c/rm

      b/lm                  b/rm

           l/bm  c/bm  r/bm


#TeX \end{minipage}

 以前のバージョンとの互換性のために、`above`, `over`, `below`, `under`
 に l/c/r や重ね上げ方向のキーワードがないと、`center` と `horizontal`
 を使用します。キーワード `outside` に t/b/c や重ね上げ方向のキーワード
 がないと、`top`, `right`, `vertical` (つまり上の t/rm と同じ) を使用し
 ます。

 凡例の位置 (<position>) は、以前のバージョンと同様単に x,y,z を指定し
 てもいいですが、その最初のサンプル行の座標の座表系を選択するための 5
 つのキーワード (`first`, `second`, `graph`, `screen`, `character`) を
 頭につけることもできます。詳細は、以下参照: `coordinates`。<position>
 が与えられた場合の `left`, `right`, `top`, `bottom`, `center` の効果は、
 label コマンドで配置される文字列の場合と同じように基準位置の位置揃えに
 使用されます。すなわち、`left` は凡例が <position> の右に置かれて左合
 わせで出力されます。他の場合も同様です。
4 凡例の位置の微調整 (key offset)
?commands set key offset
?set key offset
?key offset
 凡例 (key) の配置オプションとは無関係に、凡例の最終的な場所を、位置の
 ずれ (offset) を指定することでも手動で位置合わせすることができます。
 いつものように、ずれの x, y 成分は character, graph, screen のいずれの
 座標でも与えることができます。
4 凡例のサンプル (key samples)
?commands set key samples
?set key samples
?key samples
 デフォルトでは、グラフ上の各描画は凡例 (key) 内にそれぞれに対応するエ
 ントリを生成します。このエントリには、描画タイトルと、その描画で使われ
 るのと同じ色、同じ塗りつぶし属性による線/点/箱 のサンプルが入ります。
 font と textcolor 属性は、凡例内に現われる個々の描画タイトルの見た目を
 制御します。textcolor を "variable" にセットすると、凡例の各エントリの
 文字列は、描画グラフの線や塗りつぶし色と同じ色になります。これは、以前
 のある時期の gnuplot のデフォルトの挙動でした。

 グラフ曲線のサンプルの線分の長さは `samplen` で指定できます。その長さ
 は、目盛りの長さと <sample_length>*(文字幅) の和として計算します。
 点の記号は、サンプル線分の中央に書かれるため、これは凡例内の点のサンプ
 ル位置にも (線分は描かなくても) 影響を与えます。

 凡例のベースライン間隔は、現在のフォントサイズに対する「1 行空き」
 (single space) になっています。これは `set key spacing <line-spacing>`
 で変更できます。

 <width_increment> は、文字列の長さに加えたり減らしたりする幅 (何文字分
 か) を表す数値です。これは、凡例に外枠を書き、文字列に制御文字を使う場
 合にだけ有用でしょう。`gnuplot` は外枠の幅を計算するときは、ラベル文字
 列の文字数を単純に数えるだけなので、それを修正するのに使えます。
4 複数の凡例の集約 (multiple keys)
?multiple keys
?set key multiple keys
?key multiple keys
=legend
Ffigure_multiple_keys
 各グラフのタイトルを、すべて自動的に生成される凡例 (key) 内に表示させ
 る代わりに、表題や凡例を手動で配置することができます。これにより、例え
 ば多重描画モード (multiplot) での各グラフ要素に対する表題を 1 箇所に集
 約して作ることができるようになります。
        set multiplot layout 3,2 columnsfirst
        set style data boxes
        plot $D using 0:6  lt 1 title at 0.75, 0.20
        plot $D using 0:12 lt 2 title at 0.75, 0.17
        plot $D using 0:13 lt 3 title at 0.75, 0.14
        plot $D using 0:14 lt 4 title at 0.75, 0.11
        set label 1 at screen 0.75, screen 0.22 "Custom combined key area"
        plot $D using 0:($6+$12+$13+$14) with linespoints title "total"
        unset multiplot
3 ラベル (label)
?commands set label
?commands unset label
?commands show label
?set label
?unset label
?show label
?label
?nolabel
 `set label` コマンドを使うことによって任意の見出し (label) をグラフ中
 に表示することができます。

 書式:
       set label {<tag>} {"<label text>"} {at <position>}
                 {left | center | right}
                 {norotate | rotate {by <degrees>}}
                 {font "<name>{,<size>}"}
                 {noenhanced}
                 {front | back}
                 {textcolor <colorspec>}
                 {point <pointstyle> | nopoint}
                 {offset <offset>}
                 {nobox} {boxed {bs <boxstyle>}}
                 {hypertext}
       unset label {<tag>}
       show label

 位置 (<position>) は x,y か x,y,z のどちらかで指定し、座標系を指定する
 にはその座標の前に `first`, `second`, `polar`, `graph`, `screen`,
 `character` をつけます。詳細は、以下参照: `coordinates`。

 タグ (<tag>) は見出しを識別するための整数値です。タグを指定しなかった
 場合未使用のもので最も小さい値が自動的に割り当てられます。現在の見出し
 を変更するときはそのタグと変更したい項目を指定して `set label` コマン
 ドを使います。

 <label text> は文字列定数でも構いませんし、文字列変数、または文字列の
 値を持つ式でも構いません。以下参照: `strings`, `sprintf`, `gprintf`。

 デフォルトでは、指定した点 x,y,z に見出しの文章の左端が来るように配置
 されます。x,y,z を見出しのどこに揃えるかを変更するには変数
 <justification> を指定します。これには、`left`, `right`, `center` の
 いずれかが指定でき、それぞれ文章の左、右、真中が指定した点に来るよう
 に配置さるようになります。描画範囲の外にはみ出るような指定も許されま
 すが、座標軸の見出しや他の文字列と重なる場合があります。

 箱枠付きのラベルをサポートする出力形式もあります。以下参照:
 `set style textbox`。回転させた文字列の箱付けは、すべての出力形式が可
 能なわけではありません。

 `rotate` を指定するとラベルは縦書きになります。`rotate by <degrees>`
 を指定すると、文字列のベースラインを指定した角に設定します。ただし、文
 字列の回転をサポートしていない出力形式もあります。

 フォントとそのサイズは、出力形式がフォントの設定をサポートしていれば
 `font "<name>{,<size>}"` で明示的に選択できます。そうでない出力形式で
 は、デフォルトのフォントが使われます。

 通常は、現在の出力形式がサポートしていれば、ラベル文字列の全ての文字列
 に拡張文字列処理モード (enhanced text mode) が使用されます。
 `noenhanced` を使用することで、特定のラベルを拡張文字列処理から外すこ
 とができます。これは、ラベルが例えばアンダースコア (_) を含んでいる場
 合などに有用です。以下参照: `enhanced text`。

 `front` が与えられると、見出しはデータのグラフの上に書かれます。`back`
 が与えられると (デフォルト)、見出しはグラフの下に書かれます。`front`
 を使うことで、密なデータによって見出しが隠されてしまうことを避けること
 が出来ます。

 `textcolor <colorspec>` は見出し文字列の色を変更します。<colorspec> は
 線種、rgb 色、またはパレットへの割当のいずれかが指定できます。
 以下参照: `colorspec`, `palette`。`textcolor` は、`tc` と省略可能です。
    `tc default` は、文字色をデフォルトにします。
    `tc lt <n>` は、文字色を線種 <n> (line type)と同じものにします。
    `tc ls <n>` は、文字色を line style <n> と同じものにします。
    `tc palette z` は、見出しの z の位置に対応したパレット色になります。
    `tc palette cb <val>` は、色見本 (colorbox) の <val> の色になります。
    `tc palette fraction <val>` (0<=val<=1) は、[0:1] から `palette` の
        灰色階調/カラーへの写像に対応した色になります。
    `tc rgb "#RRGGBB"`, `tc rgb "0xRRGGBB"` は、任意の 24-bit RGB 色を
        設定します。
    `tc rgb 0xRRGGBB` も同じです (16 進定数値には引用符は不要)。

 <pointstyle> がキーワード `lt`, `pt`, `ps` とともに与えられると (以下
 参照: `style`)、与えられたスタイルと、与えられた線種の色で見出し位置に
 点 (point) が描画され、見出し文字列は少し移動されます。このオプション
 は `mouse` 拡張された出力形式でのラベルの配置に、デフォルトで使用され
 ています。見出し文字列近くの点の描画機能を off (これがデフォルト) にす
 るには、`nopoint` を使用してください。

 その移動は、デフォルトでは、<pointstyle> が与えられれば `pointsize` の
 単位で 1,1 で、<pointstyle> が与えられていなければ 0,0 です。移動は、
 追加の `offset <offset>` でも制御できます。ここで、<offset> は x,y か
 または x,y,z の形式ですが、それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。

 もし一つ (あるいはそれ以上の) 軸が時間軸である場合、座標は `timefmt`
 の書式にしたがって引用符で囲まれた文字列で与える必要があります。以下
 参照: `set xdata`, `set timefmt`。

 `set label` に関して有効なオプションは、描画スタイル `labels` でも有効
 です。以下参照: `labels`。この場合、`textcolor`, `rotate`, `pointsize`
 の属性の後ろにキーワード `variable` をつけて、それらを固定値でないよう
 にすることが可能です。その場合個々のラベルの対応する属性値は、`using`
 指定の追加列により決定します。

4 examples
?label examples
?set label examples
 例:

 (1,2) の位置に "y=x" と書く場合:
       set label "y=x" at 1,2

 Symbol フォントのサイズ 24 の "シグマ" (Σ) をグラフの真中に書く場合:
       set label "S" at graph 0.5,0.5 center font "Symbol,24"

 見出し "y=x^2" の右端が (2,3,4) に来るようにし、タグ番号として 3 を使う
 場合:
       set label 3 "y=x^2" at 2,3,4 right

 その見出しを中央揃えにする場合:
       set label 3 center

 タグ番号 2 の見出しを削除する場合:
       unset label 2

 全ての見出しを削除する場合:
       unset label

 全ての見出しをタグ番号順に表示する場合:
       show label

 x 軸が時間軸であるグラフに見出しを設定する例:
       set timefmt "%d/%m/%y,%H:%M"
       set label "Harvest" at "25/8/93",1

 データと、新たに当てはめられたパラメータによる当てはめ関数を描画したい
 場合、`fit` の後でかつ `plot` の前に以下を実行します:
       set label sprintf("a = %3.5g",par_a) at 30,15
       bfit = gprintf("b = %s*10^%S",par_b)
       set label bfit at 30,20

 当てはめられるパラメータのついた関数の定義式を表示したい場合:
       f(x)=a+b*x
       fit f(x) 'datafile' via a,b
       set label GPFUN_f at graph .05,.95
       set label sprintf("a = %g", a) at graph .05,.90
       set label sprintf("b = %g", b) at graph .05,.85

 見出し文字列を小さい点から少しだけ移動する場合:
       set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1

 pm3d を使った 3 次元のカラー曲面上のある点の位置に、その z の値 (この
 場合 5.5) に対応した色を見出し文字列につける場合:
       set label 'text' at 0,0,5.5 tc palette z
4 ハイパーテキスト (hypertext)
?hypertext
?label hypertext
?set label hypertext
 出力形式の中には (wxt, qt, svg, canvas, win) グラフ上の特定の位置やキ
 ャンバス内のその他の部分にハイパーテキストを貼り付けることができるもの
 があります。マウスをその場所に持っていくと、文字列を含む箱がポップアッ
 プされますが、ハイパーテキストをサポートしない出力形式では、それは何も
 表示しません。ハイパーテキストを貼り付けるには、そのラベルの `point`
 属性を有効にする必要があります。
 拡張文字列制御書式は、ハイパーテキストラベルには適用されません。
 例:
       set label at 0,0 "Plot origin" hypertext point pt 1
       plot 'data' using 1:2:0 with labels hypertext point pt 7 \
            title 'mouse over point to see its order in data set'

       # この pm3d 曲面上の任意の場所にマウスを置くとその Z 座標をハイ
       # パーテキストとして表示
       splot '++' using 1:2:(F($1,$2)) with pm3d, \
             '++' using 1:2:(F($1,$2)):(sprintf("%.3f", F($1,$2))) \
                   with labels \
                   hypertext point lc rgb "0xff000000" notitle

 wxt と qt 出力形式では、文字列が表示されたあとにハイパーテキスト部分を
 左クリックするとそのハイパーテキストがクリップボードにコピーされます。

^ <br><table class="button"><tr><td>
^     <a href="http://www.gnuplot.info/demo_svg_6.0/hypertext.html"
^      class="button">
^ hypertext demo を見るにはクリックしてください</a>
^ </td></tr></table>

 試験段階の機能 (仕様の細かい部分は変更の可能性あり) -
 "image{<xsize>,<ysize>}:<filename>{\n<caption text>}" の形式の文字列は
 ポップアップボックス内で画像ファイルを表示させるようにします。サイズ指
 定によりデフォルトのサイズ 300x200 を変更できます。認識する画像ファイ
 ルの型は出力形式によって違いますが、*.png は常に OK です。画像ファイル
 名の後ろに書いた文字列は、通常のハイパーテキストと同様に表示します。
 例:
       set label 7 "image:../figures/Fig7_inset.png\nFigure 7 caption..."
       set label 7 at 10,100 hypertext point pt 7

3 線種 (linetype)
?commands set linetype
?commands show linetype
?set linetype
?show linetype
 コマンド `set linetype` は各種描画に使用される基本的な線種 (linetype)
 を再定義することを可能にします。このコマンドのオプションは、
 "set style line" のものと全く同じです。ラインスタイルと違うところは、
 `set linetype` による再定義は永続的なことで、これは `reset` の影響を受
 けません。

 例えば、線種 1 と 2 を以下のように再定義してみます:

       set linetype 1 lw 2 lc rgb "blue" pointtype 6
       set linetype 2 lw 2 lc rgb "forest-green" pointtype 8

 すると、それらの線種の最初の見た目がどうであったかに関わらず、lt 1 を
 使用しているすべてのものが、その後は太い青線になります。この性質は、lt
 1 によって作られた一時的なラインスタイルの定義のようなものにも適用され
 ます。同様に、線種 2 は、その後は太い緑線になります。

 この仕組みは、gnuplot で使用する線種列に対する個人的な好みを設定するの
 にも使えます。それを行うには、実行時初期化ファイル ~/.gnuplot に、例え
 ば以下のようなそれ用のコマンド列を追加することをお勧めします:

       set linetype 1 lc rgb "dark-violet" lw 2 pt 1
       set linetype 2 lc rgb "sea-green"   lw 2 pt 7
       set linetype 3 lc rgb "cyan"        lw 2 pt 6 pi -1
       set linetype 4 lc rgb "dark-red"    lw 2 pt 5 pi -1
       set linetype 5 lc rgb "blue"        lw 2 pt 8
       set linetype 6 lc rgb "dark-orange" lw 2 pt 3
       set linetype 7 lc rgb "black"       lw 2 pt 11
       set linetype 8 lc rgb "goldenrod"   lw 2
       set linetype cycle 8

 こうすると、あなたが gnuplot を実行する度に線種はこれらの値に初期化さ
 れます。線種はあなたが好む数だけ初期化できます。再定義しない場合は、そ
 れはデフォルトの属性を持ち続けます。例えば線種 3 を再定義から外せば、
 それは青で pt 3, lw 1 となります。

 同様のスクリプトファイルで、テーマベースの色選択の定義を行ったり、特定
 の描画タイプ、あるいは特定の出力形式用に色をカスタマイズしたりすること
 も可能です。

=cycle
 コマンド `set linetype cycle 8` は、大きな番号の線種に対しては色や線幅
 に関するこれらの定義を再利用することを gnuplot に伝えます。すなわち、
 線種 (linetype) 9-16, 17-24 等に対しては、これと同じ色、幅の列を使用し
 ます。ただし、点の属性 (pointtype, pointsize, pointinterval) は、この
 コマンドの影響は受けません。`unset linetype cycle` はこの機能を無効に
 します。大きな線種番号の線の属性を明示的に定義した場合は、それは小さい
 番号の線種の属性の再利用よりも優先されます。
3 第 2 軸との対応 (link)
?commands set link
?set link
?link
 書式:
       set link {x2 | y2} {via <expression1> inverse <expression2>}
       unset link

 コマンド `set link` は、x 軸と x2 軸、または y 軸と y2 軸の間の対応を
 設定します。<expression1> は、第 1 軸の座標を第 2 軸に写像する数式です
 が、<expression2> は第 2 軸の座標を第 1 軸に写像する数式です。

 例:

       set link x2

 これは、このコマンドの最も単純な形式で、x2 軸を範囲 (range) も伸縮
 (scale) も方向も x 軸と全く同じにします。`set xrange`, `set x2range`
 や `set auto x` などのコマンドは、この場合 x 軸にも x2 軸にも作用しま
 す。

       set link x2 via x**2 inverse sqrt(x)
       plot "sqrt_data" using 1:2 axes x2y1, "linear_data" using 1:2 axes x1y1

 このコマンドは、x 軸と x2 軸の、順方向と逆方向の対応を設定しています。
 順方向の対応は、x2 軸の刻みラベルと、マウスの x2 座標を生成するのに使
 い、逆方向の対応は、x2 軸系で指定された座標を描画するのに使います。こ
 の対応は、非負の x 座標にのみ有効であることに注意してください。y2 軸に
 対応させた場合、<expression1> と <expression2> には仮変数として y を使
 う必要があります。
3 lmargin
?commands set lmargin
?set lmargin
?lmargin
 コマンド `set lmargin` は左の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 読み込み検索パス (loadpath)
?commands set loadpath
?commands show loadpath
?set loadpath
?show loadpath
?loadpath
 `loadpath` の設定は、`call`, `load`, `plot`, `splot` コマンドのデータ
 ファイル、コマンドファイルの検索パスを追加定義します。ファイルが現在の
 ディレクトリに見つからなかった場合、`loadpath` のディレクトリが検索さ
 れます。

 書式:
       set loadpath {"pathlist1" {"pathlist2"...}}
       show loadpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切り
 ます。`show loadpath`, `save`, `save set` コマンドは、OS 固有のパス区
 切りをスペース (' ') で置き換えます。

 環境変数 GNUPLOT_LIB が設定されている場合、その内容は `loadpath` に追
 加されますが、`show loadpath` は、`set loadpath` と GNUPLOT_LIB の値を
 別々に表示しますし、`save`, `save set` コマンドは、GNUPLOT_LIB の値の
 方は無視します。
3 ロケール (locale)
?commands set locale
?set locale
?locale
 `locale` の設定は `{x,y,z}{d,m}tics` が書く日付の言語を決定します。

 書式:
       set locale {"<locale>"}

 <locale> にはインストールされたシステムで使うことの出来る任意の言語を
 指定できます。可能なオプションについてはシステムのドキュメントを参照し
 てください。コマンド `set locale ""` は、環境変数 LC_TIME, LC_ALL, ま
 たは LANG からロカールの値を決定しようとします。

 小数点に関する locale を変更したい場合は、以下参照: `set decimalsign`。
 文字エンコードを現在のロカールのものに変更したい場合は、以下参照:
 `set encoding`。
3 対数軸 (logscale)
?commands set logscale
?commands unset logscale
?commands show logscale
?set logscale
?unset logscale
?show logscale
?set log
?logscale
?nologscale
 書式:
       set logscale <axes> {<base>}
       unset logscale <axes>
       show logscale

 ここで、<axes> (軸) は、`x`, `x2`, `y`, `y2`, `z`, `cb`, `r` の任意の
 順序の組み合せが可能です。<base> は、対数目盛りの底です (デフォルトの
 底は 10)。軸を指定しなかった場合は、`r` 以外のすべての軸が対象となりま
 す。コマンド `unset logscale` は、すべての軸の対数目盛りを解除します。
 対数軸に対してつけられる目盛りの刻みは、等間隔ではないことに注意してく
 ださい。以下参照: `set xtics`。

 例:

 x, z 両軸について対数目盛りを設定する:
       set logscale xz

 y 軸について底 2 とする対数目盛りを設定する:
       set logscale y 2

 pm3d plot 用に z と色の軸に対数目盛りを設定する:
       set logscale zcb

 z 軸の対数目盛りを解除する:
       unset logscale z
3 マクロ (macros)
?commands set macros
?set macros
 現在のバージョンの gnuplot では、マクロ置換は常に有効です。コマンドラ
 イン内の @<stringvariablename> の形式の部分文字列は、文字列変数
 <stringvariablename> に含まれるテキスト文字列に置き換えられます。以下
 参照: `substitution`。
3 3 次元座標系 (mapping)
?commands set mapping
?commands show mapping
?set mapping
?show mapping
?mapping
 データが `splot` に球面座標や円柱座標で与えられた場合、`set mapping`
 コマンドは `gnuplot` にそれをどのように扱うかを指定するのに使われます。

 書式:
       set mapping {cartesian | spherical | cylindrical}

 デフォルトではカーテシアン座標 (通常の x,y,z 座標) が使われます。

 球面座標では、データは 2 つか 3 つの列 (またはその個数の `using` エン
 トリ) として与えられます。最初の 2 つは、`set angles` で設定された単位
 での方位角 (theta) と仰角 (phi) (すなわち "経度" と "緯度") とみなされ
 ます。半径 r は、もし 3 列目のデータがあればそれが使われ、もしなければ
 1 に設定されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta) * cos(phi)
       y = r * sin(theta) * cos(phi)
       z = r * sin(phi)

 これは、"極座標系" というより、むしろ "地学上の座標系" (緯度、経度) に
 相当することに注意してください (すなわち、phi は z 軸となす角、という
 より赤道から計った仰角、になります)。

 円柱座標では、データはやはり 2 つか 3 つの列で与えられ、最初の 2 つは
 theta (`set angle` で指定された単位の) と z と見なされます。半径 r は
 球面座標の場合と同様、3 列目のデータがあればそれが、なければ 1 と設定
 されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta)
       y = r * sin(theta)
       z = z

 `mapping` の効果は、`splot` コマンド上の `using` 指定で実現することも
 可能ですが、多くのデータファイルが処理される場合は `mapping` の方が便
 利でしょう。しかし、`mapping` を使っていても、もしファイルのデータの順
 番が適切でなかったら結局 `using` が必要になってしまいます。

 `mapping` は `plot` では何もしません。
^ 以下も参照
^ <a href="http://www.gnuplot.info/demo/world.html">
 world.dem: mapping のデモ。
^ </a>
3 周囲の余白 (margin)
?commands set margins
?commands show margins
?set margin
?set margins
?show margins
?margins
 `margin` (周囲の余白) とは、描画領域の境界からキャンバスの一番外側まで
 の間隔のことです。この余白の大きさは自動的にとられますが、コマンド
 `set margin` で変更することもできます。`show margin` は現在の設定を表
 示します。描画領域の境界から内側の描画要素までの間隔を変更したい場合は
 以下参照: `set offsets`。

 書式:
       set lmargin {{at screen} <margin>}
       set rmargin {{at screen} <margin>}
       set tmargin {{at screen} <margin>}
       set bmargin {{at screen} <margin>}
       set margins <left>, <right>, <bottom>, <top>
       show margin

 <margin> のデフォルトの単位には、適切と思われる、文字の高さと幅が使わ
 れます。正の値は余白の絶対的な大きさを定義し、負の値 (または無指定) は
 `gnuplot` によって自動計算される値を使うことになります。3 次元描画では
 左の余白 (lmargin) のみが文字の大きさを単位として設定できます。

 キーワード `at screen` は、その余白の指定が全体の描画領域に対する割合
 であることを意味します。これは、多重描画 (multiplot) モードでの 2D, 3D
 グラフの角を正確に揃えるのに使えます。この配置は現在の `set origin` や
 や `set size` の値を無視するようになっていて、それは多重描画内のグラフ
 の配置の別の方法として使われることを意図しています。

 描画の余白は通常目盛り、目盛りの見出し、軸の見出し、描画のタイトル、
 日付、そして境界の外にある場合の凡例 (key) のサイズ等を元に計算されま
 す。しかし、目盛りの刻みが境界でなく軸の方についている場合 (例えば
 `set xtics axis` によって)、目盛りの刻み自身とその見出しは余白の計算に
 は含まれませんし、余白に書かれる他の文字列の位置の計算にも含まれません。
 これは、軸と境界が非常に近い場合、軸の見出しが他の文字列を上書きする可
 能性を示唆します。
3 micro
?commands set micro
?commands show micro
?commands unset micro
?set micro
?show micro
?unset micro
?micro
 デフォルトでは、軸の刻みラベルの生成に使用する科学系出力のための書式指
 定子 "%c" は、「マイクロ」(10^-6) を示す接頭辞として小文字の u を使い
 ます。コマンド `set micro` は、それとは異なる印字用文字 (unicode
 U+00B5) を使用するよう gnuplot に指示します。その文字を表現するのに使
 用されるバイト列は、現在の encoding に依存します。以下参照:
 `format specifiers`, `encoding`。

 現在のエンコーディングによるデフォルトが満足いかない場合、欲しい表現を
 生成する文字列をオプションとして与えることもできます。これは、latex 系
 の出力形式では有用で、例えば以下のようにできます。
      set micro "{\textmu}"

3 minussign
?commands set minussign
?commands show minussign
?commands unset minussign
?set minussign
?show minussign
?unset minussign
?minussign
 gnuplot はほとんどの書式付き入力は C 言語のライブラリルーチンである
 sprintf() で処理します。しかし、gnuplot には独自の書式化ルーチン
 `gprintf()` もあり、それは軸の刻み文字列の生成に使われています。C のラ
 イブラリルーチンは、-7 のような負の数の表示には常にハイフン文字 (ASCII
 \055) を使用しますが、むしろその目的では、それとは異なる印字用のマイナ
 ス符号文字 (Unicode U+2212) を使い −7 のように表示したいと多くの人々
 は思うでしょう (訳注: 原文では '7' の前は Unicode の「マイナス記号」が
 使われているが、ここでは JIS の全角マイナス記号 245D を用いた)。コマン
 ド

      set minussign

 は、gprintf() の数字の出力に、ハイフンの代わりにマイナス符号文字を使用
 するよう指示します。UTF-8 ロケールではそれは Unicode U+2212 に対応する
 マルチバイト文字列になり、Window コードページ 1252 ロケールでは、これ
 は 8 ビット文字の ALT+150 ("en dash") になります。コマンド
 `set minussign` は、軸の刻みのラベルと、gprintf を明示的に呼び出して生
 成された文字列に影響を与えますが、その他の場合のハイフンを含む文字列に
 は何ら影響を与えません。以下参照: `gprintf`。

 LaTeX は、それ自身が負の符号を自前で処理する仕組みを持っているため、こ
 のコマンドは、LaTeX 系の出力形式を使用している場合は無視されることに注
 意してください。postscript 出力形式を使用する場合も、gnuplot の
 postscript 用前処理ルーチンが ascii のハイフンコード \055 を `minus`
 という名前の異なる文字に変換するので、このコマンドは必要はありません。

 例 (utf8 ロケールを仮定):

      set minus
      A = -5
      print "A = ",A                 # ハイフンを含む文字列を出力
      print gprintf("A = %g",A)      # U+2212 文字を含む文字列を出力
      set label "V = -5"             # ハイフンを含むラベル
      set label sprintf("V = %g",-5) # ハイフンを含むラベル
      set label gprintf("V = %g",-5) # U+2212 を含むラベル
3 白黒モード (monochrome)
?commands set monochrome
?set monochrome
?monochrome
 書式:
      set monochrome {linetype N <linetype properties>}

 コマンド `set monochrome` は、線種群の別の設定法を選択しますが、それは
 色の違いではなく、点線/破線パターンや線幅の違いによるものです。このコ
 マンドは、gnuplot の以前のバージョンのある出力形式で monochrome オプシ
 ョンとして提供していたものに置き換わるもので、後方互換性のため、それら
 の出力形式で "mono" オプションを指定すると、暗黙で `set monochrome` を
 呼び出します。
 例えば、
      set terminal pdf mono
 は、以下と同等です。
      set terminal pdf
      set mono

 白黒モード (monochrome) の選択は、明示的な RGB 色、パレット色を使用し
 てのカラーの線の描画を妨げるものではありませんが、以下も参照:
 `set palette gray`。
 デフォルトでは 6 つの白黒線種が定義されていますが、それらの属性を変更
 したり、白黒線種を追加することは、フル形式でそのコマンドを使用すること
 でできます。白黒線種にほどこされた変更は、カラーの線種には影響を与えま
 せんし、その逆も同様です。カラー線種に復帰するには、`unset monochrome`
 か、`set color` としてください。
3 マウス (mouse)
?commands set mouse
?commands unset mouse
?set mouse
?unset mouse
?mousing
?mouse
?nomouse
 コマンド `set mouse` は、現在の対話型出力形式に対してマウス機能を有効
 にします。対話型モードでは通常デフォルトでこれは有効になっていますが、
 コマンドがファイルから読み込まれる場合はデフォルトでは無効になっていま
 す。

 マウスモードは 2 種類用意されています。2 次元モードは、`plot` コマンド
 と `splot` の 2 次元射影 (すなわち、z の回転角が 0, 90, 180, 270, 360
 度の `set view`、および `set view map`) で動作します。このモードでは、
 マウス位置が追跡され、マウスボタンや矢印キーを使って拡大したり視点移動
 したりできます。グラフに対応する凡例のタイトルや別なウィジェットアイコ
 ンなどをクリックすることで、個々のグラフの描画をオン/オフに切り替える
 ことをサポートする出力形式もあります。

 `splot` による 3 次元グラフに対しては、グラフの視方向 (view) と縮尺の
 変更が、それぞれマウスボタン 1 と 2 (によるドラッグ) で行えます。ボタ
 ン 2 の垂直方向のドラッグを shift キーと同時に行うと、z 軸の一番下の位
 置 (`xyplane`) を上下します。これらのボタンにさらに <ctrl> キーを押す
 と、座標軸は表示されますが、データの表示は消えます。これは大きなデータ
 に対して有用でしょう。マウスボタン 3 は、z 軸の向き (azimuth) を制御し
 ます (以下参照: `set view azimuth`)。

 マウスは多重描画 (multiplot) モード内では無効ですが、`unset multiplot`
 で多重描画が完結すれば、マウス機能は ON になります。ただし、その作用は
 multiplot 内の最後の描画 (replot で描画されるようなもの) に対してのみ
 です。

 書式:
       set mouse {doubleclick <ms>} {nodoubleclick}
                 {{no}zoomcoordinates}
                 {zoomfactors <xmultiplier>, <ymultiplier>}
                 {noruler | ruler {at x,y}}
                 {polardistance{deg|tan} | nopolardistance}
                 {format <string>}
                 {mouseformat <int> | <string> | function <f(x,y)>}
                 {{no}labels {"labeloptions"}}
                 {{no}zoomjump} {{no}verbose}
       unset mouse

 オプション `noruler` と `ruler` は、定規 (ruler) 機能を off, on にしま
 す。`ruler` には座標を与えて原点を設定することもできます。`ruler` が
 on の間、ruler の原点からマウスまでのユーザ単位での距離が連続的に表示
 されます。デフォルトでは、ruler のトグルスイッチは 'r' にキー割り当て
 されています。

 オプション `polardistance` は、マウスカーソルから定規 (ruler) までの距
 離を極座標でも表示 (距離、および角度または傾き) するかどうかを決定しま
 す。これはデフォルトのキー割り当て '5' に対応します。

=labels
 ボタン 2 の gnuplot の永続的なラベルを定義するには、オプション
 `labels` を使用します。デフォルトは `nolabels` で、ボタン 2 は単に一時
 的なラベルをマウス位置に描画します。ラベルは現在の `mouseformat` の設
 定に従って書かれます。`labeloptions` 文字列は、コマンド `set label` コ
 マンドに渡されます。そのデフォルトは "point pointtype 1" で、これはラ
 ベル位置に小さいプラス (`+`) を描画します。一時的なラベルは、その次の
 `replot`、またはマウスズーム操作では現れません。永続的なラベルは、ラベ
 ルの点の上で Ctrl キーを押してボタン 2 をクリックすることで消すことが
 できます。実際のラベルの位置にどれ位近くでクリックしなければいけないか
 の閾値も `pointsize` で決定されます。

 オプション `verbose` が ON の場合、実行時の報告コマンドが表示されます。
 このオプションはドライバウィンドウ上で `6` を打つことで ON/OFF がスイ
 ッチできます。デフォルトでは `verbose` は OFF になっています。

 ドライバウィンドウ上で 'h' を打つと、マウスとキー割り当ての説明を表示
 します。これは、ユーザ定義のキー割り当て、すなわち `bind` コマンドによ
 る `hotkeys` も表示します。ユーザ定義のキー割り当てはデフォルトのキー
 割り当てを無効にすることに注意してください。以下も参照: `bind`。
4 doubleclick
?set mouse doubleclick
?mouse doubleclick
 ダブルクリックの解像度はミリ秒 (ms) 単位で与えます。これは、ボタン 1
 用のもので、現在のマウス位置をクリップボード (`clipboard`) にコピーす
 るのに使う出力形式があります。デフォルトの値は 300 ms です。これを 0
 ms に設定するとシングルクリックでそのコピーを行うようになります。
4 format
?set mouse format
?mouse format
 コマンド `set mouse format` は、sprintf() に対する書式文字列の指定で、
 マウスカーソルの [x,y] 座標を描画ウィンドウとクリップボードにどのよう
 に表示するかを決定します。デフォルトは "% #g" です。

 この設定は、"set mouse mouseformat" を置き換えるものです。
4 mouseformat
?set mouse mouseformat
?mouseformat
 書式:
      set mouse mouseformat i
      set mouse mouseformat "custom format"
      set mouse mouseformat function string_valued_function(x, y)
 このコマンドは、現在のマウス位置を報告するのに使用する書式を制御します。
 整数を指定することで、下の表の書式オプションの一つを選択できます。
 文字列を指定すると、それを書式オプション 7 の sprintf() に対する書式と
 して使用しますが、x, y に対応する 2 つの実数指定子を持つ必要があります。

 最後の文字列を返すカスタム関数の指定は「試験段階」です。それは、スクリ
 ーン座標からグラフ座標への逆の対応が x, y の両方を組で考慮する必要があ
 るような座標系の読み出しを可能にします。例については、map_projection
 デモを参照してください。

 例:
      set mouse mouseformat "mouse x,y = %5.2g, %10.3f"
 この文字列をまたオフにするには、`set mouse mouseformat ""` とします。

 以下の書式が利用可能です:

  0   デフォルト (1 と同じ)
  1   軸の座標                            1.23, 2.45
  2   グラフ座標 (0 から 1 まで)         /0.00, 1.00/
  3   x = timefmt     y = 軸座標         [(`set timefmt` の設定), 2.45]
  4   x = 日付        y = 軸座標         [31. 12. 1999, 2.45]
  5   x = 時刻        y = 軸座標         [23:59, 2.45]
  6   x = 日付/時刻   y = 軸座標         [31. 12. 1999 23:59, 2.45]
  7   `set mouse mouseformat <format-string>` による書式
  8   `set mouse mouseformat function <func>` による書式
4 マウススクロール (scrolling)
?set mouse scrolling
?mouse scrolling
?mouse wheel
?scrolling
?mousewheel
 マウスホイールは、2 次元、3 次元の両方のグラフで、x 軸、y 軸の範囲を調
 節します。この調節は、デフォルトでは現在の範囲の 10% の増加ですが、こ
 れは、`set mouse zoomfactor <x-multiplier>,<y-multiplier>` で変更でき
 ます。
#start
#b <wheel-up> は y と y2 軸範囲を現在の範囲をわずかに上スクロール
#b <wheel-down> は y と y2 軸範囲を現在の範囲をわずかに下スクロール
#b <shift+wheel-up> は左スクロール (x と x2 軸範囲を減少)
#b <shift+wheel-down> は右スクロール (x と x2 軸範囲を増加)
#b <control+wheel-up> は現在のマウス位置中心にズームイン
#b <control+wheel-down> は現在のマウス位置中心にズームアウト
#b <shift+control+wheel-up> は x, x2 軸のみをズームイン
#b <shift+control+wheel-down> は x, x2 軸のみをズームアウト
#end
4 zoom
?mouse zoom
?zoom
 現在のマウス位置中心のズームイン/ズームアウトの比率は、マウスホイール
 で制御します (以下参照: `scrolling`)。

 2 次元グラフの選択した領域を広げるには、マウスのドラッグで拡大範囲の線
 引きを行い、そして左マウスボタンを押すことで行います。グラフウィンドウ
 上でホットキー 'u' をタイプすることで元のグラフに復元できます。ホット
 キー 'p' と 'n' は、拡大操作の履歴を後方と前方にたどります。

 オプション `zoomcoordinates` は、拡大の際に、拡大の枠の端にその座標を
 書くかどうかを決定し、デフォルトでは ON になっています。

 オプション `zoomjump` が ON の場合、ボタン 3 による拡大範囲の選択を開
 始すると、マウスポインタは自動的に少しだけずれた位置に移動します。これ
 は、ごく小さい (または空でさえある) 拡大範囲を選択してしまうことを避け
 るのに便利でしょう。デフォルトでは `zoomjump` は OFF です。

3 mttics
?commands set mttics
?commands unset mttics
?commands show mttics
?set mttics
?unset mttics
?show mttics
?mttics
?nomttics
 極座標グラフの周囲の小目盛り刻みの印は `set mttics` で制御されます。以
 下参照: `set mxtics`。
3 多重描画モード (multiplot)
?commands set multiplot
?commands unset multiplot
?set multiplot
?unset multiplot
?multiplot
?nomultiplot
?layout
 コマンド `set multiplot` は `gnuplot` を多重描画モードにします。これ
 は、複数のグラフを同じページや同じスクリーンウィンドウに隣り同士に並
 べて表示します。

 書式:
       set multiplot
           { title <page title> {font <fontspec>} {enhanced|noenhanced} }
           { layout <rows>,<cols>
             {rowsfirst|columnsfirst} {downwards|upwards}
             {scale <xscale>{,<yscale>}} {offset <xoff>{,<yoff>}}
             {margins <left>,<right>,<bottom>,<top>}
             {spacing <xspacing>{,<yspacing>}}
           }
       set multiplot {next|previous}
       unset multiplot

 出力形式 (terminal) によっては、コマンド `unset multiplot` が与えられ
 るまで何の描画も表示されないことがあります。この場合このコマンドにより
 ページ全体の描画が行なわれ、gnuplot は標準の単一描画モードになります。
 それ以外の出力形式では、各 `plot` コマンドがそれぞれ表示を更新します。

=inset
 コマンド `clear` は、次の描画に使う長方形領域を消すのに使えます。典型
 的には、大きいグラフの内部に小さなグラフを挿入するような場合に必要です。

 定義済の見出しやベクトルは、各描画において、毎回現在のサイズと原点に従
 って書かれます (それらが `screen` 座表系で定義されていない場合)。それ
 以外の全ての `set` で定義されるものも各描画すべてに適用されます。もし
 1 度の描画にだけ現われて欲しいものを作りたいなら、それが例えば日付
 (timestamp) だとしたら、`set multiplot` と `unset multiplot` で囲まれ
 たブロック内の `plot` (または `splot`, `replot`) 命令の一つを
 `set time` と `unset time` ではさんでください。

 multiplot のタイトルは、個々の描画タイトルがあったとしても、それとは別
 のもので、ページの上部にそのためのキャンバス全体の幅にわたるスペースが
 確保されます。

 layout が指定されていない場合、あるいはより良い位置決めをしたい場合は、
 コマンド `set origin` と `set size` 各描画で正しい位置に設定する必要が
 あります。詳細は、以下参照: `set origin`, `set size`。

 例:
       set multiplot
       set size 0.4,0.4
       set origin 0.1,0.1
       plot sin(x)
       set size 0.2,0.2
       set origin 0.5,0.5
       plot cos(x)
       unset multiplot

 これは、cos(x) のグラフを、sin(x) の上に積み重ねて表示します。

 `set size` と `set origin` は全体の描画領域を参照し、それは各描画で利
 用されます。以下も参照: `set term size`。描画境界を一列に揃えたいなら
 ば、`set margin` コマンドで、境界の外の余白サイズを同じサイズに揃える
 ことが出来ます。その使用に関しては、以下参照: `set margin`。余白サイズ
 は文字サイズ単位の絶対的な数値単位を使用することに注意してください。よ
 って残ったスペースに描かれるグラフは表示するデバイスの表示サイズに依存
 します。例えば、プリンタとディスプレイの表示は多分違ったものになるでし
 ょう。

 オプション `layout` により、各描画の前にそれぞれ与えていた `set size`
 や `set origin` コマンドなしに、単純な複数グラフの描画を作成できます。
 それらの設定は自動的に行なわれ、いつでもその設定を変更できます。
 `layout` では表示は <rows> 行と <cols> 列の格子に分割され、各格子は、
 その後に続く対応する名前のオプションによって行 (rowsfirst)、あるいは列
 (columnsfirst) が先に埋められて行きます。描画グラフの積み上げは下方向
 (`downwards`) に、または上方向 (`upwards`) に伸びるようにできます。デ
 フォルトは `rowsfirst` で `downwards` です。
 コマンド `set multiplot next` と `set multiplot previous` は、レイアウ
 トオプションを使用している場合のみに関係します。`next` は、格子内の次
 の位置をスキップし、空白を残します。`prev` は、直前に描画した位置の直
 前の格子位置に戻ります。

 各描画は `scale` で伸縮を、`offset` で位置の平行移動を行なうことができ
 ます。scale や offset の y の値が省略された場合は、x の値がそれに使用
 されます。`unset multiplot` により自動配置機能はオフになり、そして
 `set size` と `set origin` の値は `set multiplot layout` の前の状態に
 復帰されます。

 例:
       set size 1,1
       set origin 0,0
       set multiplot layout 3,2 columnsfirst scale 1.1,0.9
       [ ここには 6 つまでの描画コマンド ]
       unset multiplot

 上の例では 6 つの描画が 2 列の中に上から下へ、左から右へと埋められて行
 きます。各描画は水平サイズが 1.1/2、垂直サイズが 0.9/3 となります。

 他にも、そのレイアウト内のすべてのグラフに一様なマージンをオプション
 `layout margins` と `spacing` で設定することができますが、これは一緒に
 使う必要があります。`margins` は、格子配置の複数グラフ全体の外側に対す
 るマージンを設定します。

 `spacing` は、隣接する部分グラフ間の隙間を与えますが、`character` か
 `screen` 単位で指定することもできます。単一の値を指定すると、それは x,
 y の両方の方向に使用されますが、2 つの異なる値を指定することもできます。

 一つの値に単位がなければ、直前のマージン設定のものを使用します。

 例:
       set multiplot layout 2,2 margins 0.1, 0.9, 0.1, 0.9 spacing 0.0

 この場合、左にあるグラフの左の境界は、スクリーン座標の 0.1 に置かれ、
 右にあるグラフの右の境界はスクリーン座標 0.9 の場所に置かれる、等とな
 ります。各グラフの隙間は 0 に指定しているので、内側の境界線は重なりま
 す。

 例:
       set multiplot layout 2,2 margins char 5,1,1,2 spacing screen 0, char 2

 これは、左のグラフの境界は、キャンバスの左端から 5 文字幅の場所に、右
 のグラフの右の境界は、キャンバスの端から 1 文字幅の場所にあるようなレ
 イアウトを生成します。下のマージンは 1 文字分の高さ、上のマージンは 2
 文字分の高さになります。グラフ間の水平方向の隙間はありませんが、縦方向
 には 2 文字分の高さに等しい隙間があります。

 例:
       set multiplot layout 2,2 columnsfirst margins 0.1,0.9,0.1,0.9 spacing 0.1
       set ylabel 'ylabel'
       plot sin(x)
       set xlabel 'xlabel'
       plot cos(x)
       unset ylabel
       unset xlabel
       plot sin(2*x)
       set xlabel 'xlabel'
       plot cos(2*x)
       unset multiplot

 以下も参照
^ <a href="http://www.gnuplot.info/demo/multiplt.html">
 multiplot のデモ (multiplt.dem)
^ </a>
3 mx2tics
?commands set mx2tics
?commands unset mx2tics
?commands show mx2tics
?set mx2tics
?unset mx2tics
?show mx2tics
?mx2tics
?nomx2tics
 x2 (上) 軸の小目盛り刻みの印は `set mx2tics` で制御されます。以下参照:
 `set mxtics`。
3 小目盛り刻み (mxtics)
?commands set mxtics
?commands unset mxtics
?commands show mxtics
?set mxtics
?unset mxtics
?show mxtics
?mxtics
?nomxtics
 x 軸の小目盛り刻みの印は `set mxtics` で制御されます。`unset mxtics`
 によってそれを表示させなくすることが出来ます。同様の制御コマンドが各軸
 毎に用意されています。

 書式:
       set mxtics <freq>
       set mxtics default
       set mxtics time <N> <units>
       unset mxtics
       show mxtics

 これらの書式は `mytics`, `mztics`, `mx2tics`, `my2tics`, `mrtics`,
 `mttics`, `mcbtics` に対しても同じです。

 <freq> は、大目盛り間の、小目盛りによって分割される区間の数であり、小
 目盛りの数ではありません。通常の線形軸に対するデフォルトの値は、2 (目
 盛り 1 つ) か 5 (目盛り 4 つ) で、これは大目盛りの間隔によって決まりま
 す。

 `default` を指定すると小目盛りの数はデフォルトの値に戻ります。

 `set mxtics time <N> <units>` は、大目盛りが時刻モードの場合にのみ適用
 します。以下参照: `set mxtics time`。

 軸が対数軸である場合、分割区間の数はデフォルトでは有意な数にセットされ
 ます (10 個の長さを元にして)。<freq> が与えられていればそちらが優先さ
 れます。しかし、対数軸では通常の小目盛り (例えば 1 から 10 までの 2, 3,
 ..., 8, 9 の刻み) は、9 つの部分区間しかありませんが、<freq> の設定は
 10 とすることでそうなります。

 小目盛りを任意の位置に設定するには、("<label>" <pos> <level>, ...) の
 形式を `set {x|x2|y|y2|z}tics` で使用してください。ただし、<label> は
 空 ("") で、<level> を 1 にします。

 コマンド `set m{x|x2|y|y2|z}tics` は、大目盛りが一様の間隔の場合にのみ
 働きます。もし全ての大目盛りが `set {x|x2|y|y2|z}tics` によって手動で
 配置された場合は、この小目盛りのコマンドは無視されます。自動的な大目盛
 りの配置と手動の小目盛りの配置は、`set {x|x2|y|y2|z}tics` と
 `set {x|x2|y|y2|z}tics add` とを使うことで共存できます。

 例:
       set xtics 0, 5, 10
       set xtics add (7.5)
       set mxtics 5
 この場合、大目盛りは 0,5,7.5,10、小目盛りは 1,2,3,4,6,7,8,9 の場所
       set logscale y
       set ytics format ""
       set ytics 1e-6, 10, 1
       set ytics add ("1" 1, ".1" 0.1, ".01" 0.01, "10^-3" 0.001, \
                      "10^-4" 0.0001)
       set mytics 10
 この場合、大目盛りは指定された書式で、小目盛りは対数的に配置

 デフォルトでは小目盛りの表示は、線形軸ではオフで、対数軸ではオンになっ
 ています。その設定は、大目盛りに対する `axis|border` と `{no}mirror`
 の指定を継承します。これらに関する情報については、以下参照:
 `set xtics`。
4 mxtics time
?set mxtics time
?mxtics time
 書式:
      set mxtics time <N> {seconds|minutes|hours|days|weeks|months|years}

 これは、gnuplot バージョン 6 で導入された新しいコマンドオプションです。
 これは、小目盛りの刻みを、大目盛り区間に対する分割位置ではなく、時刻単
 位のある整数番号の場所に正確に配置します。

 大目盛りが時刻モード (`set xdata time` か `set xtics time`) の場合は、
 小目盛りを生成しないのが新しいデフォルトです。

 `set mxtics` や `set mxtics <freq>` で、6 より前のバージョンの挙動に戻
 せますが、これには常に問題を抱えていました。例えば、72 年間隔に対して
 自動分割機能は大目盛りを 12 年間隔に、小目盛りを 5 年間隔にしてしまっ
 ていました。

 しかし `set mxtics time 2 years` を使えば、正確に 1 年置きの年始めのと
 ころに小目盛り刻みを置きます。`set mxtics time 1 month` は、各月の日数
 が等しくないですが、1 月 1 日、2 月 1 日、3 月 1 日、... の各月 1 日の
 場所に正しく刻みを置きます。

3 my2tics
?commands set my2tics
?commands unset my2tics
?commands show my2tics
?set my2tics
?unset my2tics
?show my2tics
?my2tics
?nomy2tics
 y2 (右) 軸の小目盛り刻みの印は `set my2tics` で制御されます。以下参照:
 `set mxtics`。
3 mytics
?commands set mytics
?commands unset mytics
?commands show mytics
?set mytics
?unset mytics
?show mytics
?mytics
?nomytics
 y 軸の小目盛り刻みの印は `set mytics` で制御されます。以下参照:
 `set mxtics`。
3 mztics
?commands set mztics
?commands unset mztics
?commands show mztics
?set mztics
?unset mztics
?show mztics
?mztics
?nomztics
 z 軸の小目盛り刻みの印は `set mztics` で制御されます。以下参照:
 `set mxtics`。
3 nonlinear
?commands set nonlinear
?set nonlinear
?nonlinear
 書式:
       set nonlinear <axis> via f(axis) inverse g(axis)
       unset nonlinear <axis>

 このコマンドはコマンド `set link` に似ていますが、2 つのリンクされた軸
 の一方のみを表示する点が違います。隠される軸は線形軸のままです。表示す
 る軸に沿う座標は、g(x) を適用して隠れている軸の座標から割り当てられ、
 f(x) は表示する軸の座標を隠れている線形軸に対応させます。変換式と逆変
 換式の両方を指定する必要があります。

 これがどのように機能するかを理解するには、x2 軸が対数軸の場合を考えて
 みてください。

       set x2ange [1:1000]
       set nonlinear x2 via log10(x) inverse 10**x

 この例は、`set log x2` と同じ効果を生みます。この場合隠れている軸は、
 [log10(xmin):log10(xmax)] を計算することで [0:3] の範囲になります。

 変換関数 f(), g() は、非線形軸毎に適切なダミー変数を使って定義する必要
 があります。
     axis: x x2   dummy variable x
     axis: y y2   dummy variable y
     axis: z cb   dummy variable z
     axis: r      dummy variable r

?set nonlinear examples
?nonlinear examples
 例:

       set xrange [-3:3]
       set nonlinear x via norm(x) inverse invnorm(x)

 この例は確率スケール ("プロビット") の x 軸を作成し、累積正規分布関数
 Phi(x) のグラフが線形の y 軸に対して直線となります。

=logit
 例:

       logit(p) = log(p/(1-p))
       logistic(a) = 1. / (1. + exp(-a))
       set xrange [.001 : .999]
       set nonlinear y via logit(y) inverse logistic(y)
       plot logit(x)

 この例はロジットスケールの y 軸を作成し、線形の x 軸に対する logit(x)
 のグラフが直線になります。

=broken axis
 例:

       f(x) = (x <= 100) ? x : (x < 500) ? NaN : x-390
       g(x) = (x <= 100) ? x : x+390
       set xrange [0:1000] noextend
       set nonlinear x via f(x) inverse g(x)
       set xtics add (100,500)
       plot sample [x=1:100] x, [x=500:1000] x

 この例は "切断軸" を作成します。x 座標は左に 0 から 100、右に 500 から
 1000 が並び、その間に 10 幅の小さな隙間ができます。100 < x < 500 の間
 のデータは描画されず、これは期待通りの動作をします。
3 図形オブジェクト (object)
?objects
?commands set object
?commands show object
?set object
?object depthorder
?show object
 コマンド `set object` は、その後のすべてのグラフに現れる単一のオブジェ
 クトを定義します。オブジェクトはいくつでも定義できます。オブジェクトの
 型は、現在は `rectangle` (長方形)、`circle` (円)、`ellipse` (楕円) を
 サポートしています。長方形は、コマンド `set style rectangle` によって
 設定されたスタイルの属性の組 (塗り潰し、色、境界) をデフォルトとして受
 け継ぎます。個々のオジェクトは、定義時、または後からのコマンドで別々の
 スタイル属性を与えることが可能です。

 2 次元グラフのオブジェクトは、軸座標、グラフ座標 (`graph`)、極座標、ス
 クリーン座標 (`screen`) のいずれの組み合わせでも定義できます。
 3 次元グラフのオブジェクト指定では、グラフ座標は使えません。3 次元の長
 方形と楕円は、スクリーン座標だけに制限されています。

 書式:
     set object <index>
         <object-type> <object-properties>
         {front|back|behind|depthorder}
         {clip|noclip}
         {fc|fillcolor <colorspec>} {fs <fillstyle>}
         {default} {lw|linewidth <width>} {dt|dashtype <dashtype>}
     unset object <index>

 <object-type> は、`rectangle`, `ellipse`, `circle`, `polygon` のいずれ
 かです。個々のオブジェクトの型は、その型に特有の性質もいくつか持ってい
 ます。

 オプション `front`, `back`, `behind` は、グラフ自身の描画の前、あるい
 は後のどちらに描くかを制御します。以下参照: `layers`。
 `front` を指定すると、オブジェクトはすべての描画要素の前 (上) に描画さ
 れますが、`front` と指定されたラベルよりは後ろ (下) になります。`back`
 を指定すると、すべての描画要素、すべてのラベルの後ろに配置されます。
 `behind` は、軸や `back` の長方形を含むすべてのものの後ろに配置されま
 す。よって、
     set object rectangle from screen 0,0 to screen 1,1 behind
 は、グラフやページ全体の背景に色をつけるのに利用できます。

 デフォルトでは、オブジェクトは、少なくとも 1 つの頂点がスクリーン座標
 で与えられていない限り、グラフ境界でクリッピングされます。`noclip` と
 設定すると、グラフ境界でのクリッピングは無効になりますが、スクリーンサ
 イズに対するクリッピングは行われます。

 オブジェクトの塗り潰しの色は <colorspec> で指定します。`fillcolor` は
 `fc` と省略できます。塗り潰しスタイルは <fillstyle> で指定します。詳細
 は、以下参照: `colorspec`, `fillstyle`。キーワード `default` を指定す
 ると、これらの属性は描画が実際に行われるときのデフォルトの設定を受け継
 ぎます。以下参照: `set style rectangle`。
4 長方形 (rectangle)
?rectangle
?commands set object rectangle
?commands show object rectangle
?set object rectangle
?show object rectangle
 書式:
     set object <index> rectangle
         {from <position> {to|rto} <position> |
          center <position> size <w>,<h> |
          at <position> size <w>,<h>}

 長方形の位置は、対角に向かい合う 2 つの頂点 (左下と右上) の位置、ある
 いは中心点の位置と横幅 (<w>) と縦幅 (<h>) で指定できます。いずれの場合
 も点の位置は、軸の座標 (`first`, `second`)、グラフ領域内の相対座標
 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用できます
 (以下参照: `coordinates`)。オプション `at` と `center` は同じ意味です。

 例:
     # 座標軸で囲まれた領域全体の背景を水色に
     set object 1 rect from graph 0, graph 0 to graph 1, graph 1 back
     set object 1 rect fc rgb "cyan" fillstyle solid 1.0

     # 左下角が 0,0, 右上角が 2,3 の赤い四角を一つ置く
     set object 2 rect from 0,0 to 2,3 fc lt 1

     # 青い境界の空 (塗り潰さない) 長方形を置く
     set object 3 rect from 0,0 to 2,3 fs empty border rgb "blue"

     # 頂点は移動しないまま、塗り潰しと色をデフォルトに変更
     set object 2 rect default

 スクリーン座標で長方形の角を指定すると、それは現在のグラフ領域の端を越
 えることも可能ですが、その他の場合は長方形はグラフ内に収まるようにクリ
 ッピングされます。

4 楕円 (ellipse)
?ellipse
?commands set object ellipse
?commands show object ellipse
?set object ellipse
?show object ellipse
 書式:
     set object <index> ellipse {at|center} <position> size <w>,<h>
         {angle <orientation>} {units xy|xx|yy}
         {<other-object-properties>}

 楕円の位置は、中心を指定し、その後ろに幅と高さ (主軸と副軸) を指定しま
 す。キーワード `at` と `center` は同じ意味です。中心の位置の指定には、
 軸の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリ
 ーン座標 (`screen`) のいずれかを使用できます (以下参照: `coordinates`)。
 主軸と副軸の長さは、軸の座標で与えなければいけません。楕円の向き
 (orientation) は、水平軸と楕円の主軸との間の角度で指定します。角度を与
 えなければ、デフォルトの楕円の向きが代わりに使われます (以下参照:
 `set style ellipse`)。キーワード `units` は、楕円の軸の縮尺の制御に使
 用します。`units xy` は、主軸は x 軸の単位で、副軸は y 軸の単位で計算
 しますが、`units xx` は両軸とも x 軸の単位で縮尺し、`units yy` は両軸
 とも y 軸の単位になります。
 デフォルトは `xy` ですが、`set style ellipse units` の設定でいつでも変
 更できます。

 注意: x 軸と y 軸の縮尺が等しくない場合 (そして `units xy` の場合)、回
 転後の主軸と副軸の比は正しくはなりません。

 `set object ellipse size <2r>,<2r>` と `set object circle <r>` とは、
 一般には同じことにはならないことに注意してください。circle の半径は常
 に x 軸の単位で計られ、よって x 軸と y 軸の縮尺が違ったり、描画のアス
 ペクト比が 1 でなくても、常に円が生成されます。`units` が `xy` に設定
 されていれば、'set object ellipse' では、最初の <2r> は x 軸の単位で、
 後ろの <2r> は y 軸の単位で計られますが、これは x 軸と y 軸の縮尺が同
 じで、かつ描画のアスペクト比が 1 である場合のみ円を生成することを意味
 します。しかし、`units` を `xx` や `yy` にセットすれば、コマンド
 `set object` で指定した直径は同じ単位で計算されるので、楕円は正しいア
 スペクト比を持ち、描画をリサイズしてもそのアスペクト比は保持されます。

4 円 (circle)
?circle
?commands set object circle
?commands show object circle
?set object circle
?show object circle
 書式:
     set object <index> circle {at|center} <position> size <radius>
         {arc [<begin>:<end>]} {no{wedge}}
         {<other-object-properties>}

 円の位置は、中心を指定し、その後ろに半径を指定します。キーワード `at`
 と `center` は同じ意味です。2 次元グラフでは、位置と半径は任意の座標系
 で指定できます。以下参照: `coordinates`。3 次元グラフの円にはグラフ座
 標は使えません。そのどの場合でも、半径は軸、グラフ、スクリーンの水平方
 向の縮尺に対して計られ、水平方向と垂直方向の縮尺にずれがあっても、結果
 が常に正しく円になるように直されます。円をグラフの座標で描きたい (つま
 り水平軸と垂直軸のスケールが違う場合にはそれが楕円として表示されるよう
 にしたい) 場合は、代わりに `set object ellipse` を使ってください。

 デフォルトでは、完全な円が描画されます。オプションの `arc` に開始角と
 終了角を度を単位として指定すると円弧を描画します。円弧は、常に反時計回
 りに描かれます。

 以下も参照: `set style circle`, `set object ellipse`。

4 多角形 (polygon)
?polygon
?commands set object polygon
?commands show object polygon
?set object polygon
?show object polygon
 書式:
     set object <index> polygon
         from <position> to <position> ... {to <position>}
 または
         from <position> rto <position> ... {rto <position>}

 多角形の位置は、頂点の位置の列を与えることで指定できます。それらには、
 任意の座標系が使えます。相対的な座標 (rto) を指定する場合は、その座標
 系は前の頂点と同じ座標系でなければいけません。以下参照: `coordinates`。

 例:
     set object 1 polygon from 0,0 to 1,1 to 2,0
     set object 1 fc rgb "cyan" fillstyle solid 1.0 border lt -1
5 depthorder
?polygon depthorder
?set object depthorder
 オプション `set object N depthorder` は、3 次元多角形オブジェクトのみ
 に適用されます。オブジェクトを front/back/behind のレイヤではなく、ソ
 ートされた pm3d 四辺形のリストの中に入れ、`set pm3d depthorder` の深さ
 の順に描画します。pm3d 曲面で使う場合、両面の色付けは object fillcolor
 を linestyle で指定することで生成できます。この場合、多角形の最初の 3
 つの頂点の順序が「表裏」を決定します。

 3 次元多角形ではないオブジェクトにこの機能を設定すると、それは多分全く
 描画されません。
3 グラフ位置の調整 (offsets)
?commands set offsets
?commands unset offsets
?commands show offsets
?set offsets
?unset offsets
?show offsets
?offsets
?nooffsets
 自動縮尺は、x 軸と y 軸の範囲を描画されるデータの座標に合わせます。オ
 フセットは、この範囲を広げる仕組みを提供し、それによりデータと描画範囲
 の境界の間に隙間を作るようにします。そうすると、自動縮尺機能は、それが
 `set autoscale noextend` や `set xrange noextend` によって抑えられてい
 ない場合は、軸の次の目盛りに達っするまでさらにそれぞれの範囲を拡張しま
 す。以下参照: `noextend`。
 オフセットは、x1, y1 軸の縮尺にのみ影響を与えます。

 書式:
       set offsets <left>, <right>, <top>, <bottom>
       unset offsets
       show offsets

 各オフセットは定数、または数式が使え、それらのデフォルトの値は 0 です。
 デフォルトでは、左右のオフセットは x1 軸と同じ単位で指定し、上下のオフ
 セットは y1 軸と同じ単位で指定しますが、キーワード "graph" を用いるこ
 とで全グラフサイズに対する割合としてオフセットを指定することもできます。
 非線形軸 (nonlinear axes) に対しては、"graph" によるオフセットのみ可能
 です。

 正のオフセットの値は、軸の範囲を指定された方向へ伸ばします。例えば正の
 下方向のオフセットは y の最小値をより小さな値にします。負のオフセット
 値は、自動縮尺とクリッピングに対して悪く影響します。

 例:
       set autoscale noextend
       set offsets graph 0.05, 0, 2, 2
       plot sin(x)

 この sin(x) のグラフの y の範囲は [-3:3] になります。それは、関数の y
 の範囲は [-1:1] に自動縮尺されますが、垂直方向のオフセットが端にそれぞ
 れ 2 を追加するためです。x の範囲は [-11:10] になりますが、これはデフ
 ォルトが [-10:10] で、左に全範囲の 0.05 の割合分広げられるためです。
3 グラフ位置の指定 (origin)
?commands set origin
?commands show origin
?set origin
?show origin
?origin
 コマンド `set origin` はスクリーン上で曲面描画の原点を指定 (すなわち、
 グラフとその余白) するのに使用します。その座標系はスクリーン座標系
 (`screen`) で与えます。この座標系に関する情報については、以下参照:
 `coordinates`。

 書式:
       set origin <x-origin>,<y-origin>
3 出力先指定 (output)
?commands set output
?commands show output
?set output
?show output
?output
?output file
 書式:
       set output {"<filename>"}
       unset output
       show output

 非対話型出力形式では、デフォルトでは生成したグラフは `stdout` に送りま
 す。コマンド `set output` は、その出力を指定したファイルやデバイスにリ
 ダイレクトします。このコマンドで開いたファイルは、次の set/unset
 output コマンド、または次の出力形式の変更、または gnuplot を終了するま
 で開いたままになっています。

 対話型出力形式では、`set output` は無視します。

  ファイル名は引用符で囲まなければなりません。ファイル名を省略した場合、
 そのコマンドは `unset output` と同じになり、それは直前の `set output`
 で開いた任意の出力ファイルを閉じ、新しい出力は `stdout` に送ります。

 `set terminal` と `set output` の両方を指定する場合、`set terminal` を
 先に指定する方が安全です。それは、ある種の terminal では、OS が必要と
 するフラグをセットすることがあるからです。例えば、バイナリファイルに対
 して別々の open コマンドを必要とするような OS などがそれに該当します。

 パイプをサポートする環境では、パイプ出力も有用です。例えば以下の通りで
 す:

       set output "|lpr -Plaser filename"
       set term png; set output "|display png:-"

 MS-DOS では、`set output "PRN"` とすると標準のプリンタに出力されます。
3 overflow
?overflow
?commands set overflow
?commands unset overflow
?set overflow
?unset overflow
?show overflow
 書式:
      set overflow {float | NaN | undefined}
      unset overflow

 gnuplot のこのバージョンは、64 ビット整数演算をサポートします。これは、
 2^53 から 2^63 (おおまかには 10^16 から 10^19) の整数評価の方が、IEEE
 754 の浮動小数演算を使用する評価よりも精度の高い値を保持することを意味
 します。しかし IEEE 浮動小数表現は、精度は犠牲にする代わりに、おおまか
 には [-10^307 : 10^307] の全範囲をカバーしますが、整数演算は、その結果
 が [-2^63 : 2^63] の範囲外になる場合はオーバーフローします。そのオーバ
 ーフローが起きた場合に何をさせるかはコマンド `set overflow` により制御
 できます。そのオプションは、以下を参照してください。

 `set overflow` は、`set overflow float` と同じで、結果を整数として返す
 代わりに実数値として返します。これがデフォルトです。

 コマンド `unset overflow` は、整数演算のオーバーフローを無視するように
 します。エラーは出ません。32 ビット整数演算しかできない環境で、5.4 よ
 り前のバージョンの gnuplot の挙動に近づけたい場合は、これを使用すると
 いいでしょう。

 コマンド `reset` は、オーバーフロー処理の状態に影響を与えません。

 前のバージョンの gnuplot は、32 ビット演算に制限され、整数オーバーフロ
 ーは無視していました。しかし、組み込み演算の一部は、整数引数を与えても
 完全に整数演算を行うとは限らないことに注意してください。これには、指数
 演算 N**M や、和の演算 (以下参照: `summation`) などが含まれます。これ
 らの演算は、現在は整数引数を与えた場合は整数値を返し、それらを内在的に
 オーバーフローの影響を受けやすくすることで `set overflow` の状態に支配
 されるようにしています。
4 float
?set overflow float
?overflow float
 整数演算式が制限範囲 (64 ビット整数では [-2^63 : 2^63]) をオーバーフロ
 ーした場合、その結果は代わりに浮動小数値として返します。これは、エラー
 としては扱われません。
 例:
      gnuplot> set overflow float
      gnuplot> A = 2**62 - 1;  print A, A+A, A+A+A
      4611686018427387903 9223372036854775806 1.38350580552822e+19
4 NaN
?set overflow NaN
?overflow NaN
?overflow nan
 整数演算式が制限範囲 (64 ビット整数では [-2^63 : 2^63]) をオーバーフロ
 ーした場合、その結果は NaN (非数) を返します。これは、エラーとしては扱
 われません。
 例:
      gnuplot> set overflow NaN
      gnuplot> print 10**18, 10**19
      1000000000000000000 NaN
4 undefined
?set overflow undefined
?overflow undefined
 整数演算式が制限範囲 (64 ビット整数では [-2^63 : 2^63]) をオーバーフロ
 ーした場合、その結果は未定義値となります。これは、エラーとして扱われま
 す。
 例:
      gnuplot> set overflow undefined
      gnuplot> A = 10**19
                   ^
               undefined value
4 affected operations
?set overflow affected_operations
?overflow affected_operations
 `set overflow` の状態は、以下の整数演算
      + - * / **
 と、組み込みの和演算 `sum` に影響します。

 これらの演算はすべて、引数がすべて整数ならば、その評価でオーバーフロー
 が起きない限り、整数値の結果を返します。

 `set overflow` は、以下の論理演算、ビット演算には影響しません。
      << >>  | ^ &

 和の評価の過程のどこかでオーバーフローが起きた場合は、
 `set overflow float` とすると、最終的な和が整数の制限範囲内におさまる
 場合であっても、実数値を返すようになります。
3 パレット (palette)
?commands set palette
?set palette
=palette
 パレットは、色の集合で、通常は一つ以上の段階的なグラデーションの形式で
 順序づけられ、`pm3d` 曲面や温度分布図 (heatmap)、その他の描画要素を色
 付けするのに使われます。plot の z 座標か、追加のデータ列の灰色階調値が
 現在のパレットの色に自動的に写像されます。
 現在のパレットは、デフォルトでは描画スタイル `pm3d` を使用するグラフの
 隣に別のカラーボックス (`colorbox`) として表示されます。カラーボックス
 は、カスタマイズしたり無効にしたりできます。以下参照: `set colorbox`。
 以下も参照: `show palette`, `test palette`。

 書式:
       set palette
       set palette {
                  { gray | color }
                  { gamma <gamma> }
                  {   rgbformulae <r>,<g>,<b>
                    | defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }
                    | file '<filename>' {datafile-modifiers}
                    | colormap <colormap-name>
                    | functions <R>,<G>,<B>
                  }
                  { cubehelix {start <val>} {cycles <val>} {saturation <val>} }
                  { viridis }
                  { model { RGB | CMY | HSV {start <radians>} } }
                  { positive | negative }
                  { nops_allcF | ps_allcF }
                  { maxcolors <maxcolors> }
                }

 パレットは、いくつかの方法で定義できます。
Ffigure_palette1
 - 赤、緑、青の要素に対する公式を、0 から 1 の灰色階調変数の関数として
 与えること。
 `set palette rgbformulae` により、あらかじめ定義されている 36 個の公式
 から選ぶことができます。`set palette functions` により、あなた自身の関
 数を定義することもできます。
#TeX \\
 - z の範囲全体を、部分的に 1 つ、または複数の滑らかなグラデーションで
 覆うよう指定するために `set palette defined` を使うこと。
#TeX \\
 - 事前に保存したパレットを、現在のパレットに読み込む (load) こと。
 `set palette file` は、保存したパレットをファイルから読み込みます。
 `set palette colormap` は、保存したカラーマップから RGB の成分を展開し
 ます。
#TeX \\
 - 必要ならカスタマイズ用の追加パラメータ付きで名前付きパレットを指定。
 現在提供している名前付きパレットは、`cubehelix` (パターンの族でカスタ
 マイズ可能) と `viridis` です。

 オプションのない `set palette` は、デフォルト値に戻します。

 `set palette negative` は、パレットの方向を逆転します。例えば、
 `set palette viridis negative` は、青から黄色ではなく、黄色から青への
 グラデーションを作成します。

 `set palette gray` は、灰色階調のパレットに切り替えます。
 `set palette color` は最も最近のカラーパレットに戻します。

 `pm3d` カラー曲面では、各微小四辺形の 4 つの角の z 座標の平均値を、範
 囲 [min_z, max_z] から灰色階調値の範囲 (常に [0:1]) への写像で変換する
 ことにより、その四辺形の灰色階調値が得られます。パレットは、その灰色階
 調値から RGB 色への写像です。

 パレット色を、明示的な色指定でも言及できます (以下参照: `colorspec`)。
 これは、オブジェクトかラベルにパレット色を割り当てるときに便利です。

 パレットは、3 種類の色空間 RGB, CMY, HSV のいずれでも定義できます。以
 下参照: `set palette model`。
 いずれの色空間でも、その色成分はすべて [0,1] の範囲に制限されています。

4 rgbformulae
?commands set palette rgbformulae
?set palette rgbformulae
?palette rgbformulae
?rgbformulae
=colors
      set palette rgbformulae <function 1>, <function 2>, <function 3>
 この名前とは関係なく、このオプションは全ての色空間に適用されます。
 あなたは、各色成分に対して、あらかじめ登録されている 36 個の割り当て関
 数のうちの一つを指定しなければいけません。有効な割り当て関数の一覧は、
 `show palette rgbformulae` で見ることができます。デフォルトは、
 `set palette rgbformulae 7,5,15` です。RGB の色空間では、これは 7 番の
 関数を赤の成分の写像に使用し、5 番の関数を緑成分の写像、15 番の関数を
 青成分の写像に使用します。関数番号として負の値を使用すると、それは割り
 当てを逆、すなわち f(gray) でなく、f(1-gray) の写像による成分にします。

Ffigure_palette2
 RGB の色空間では、いくつかの良い割り当て公式があります:
    7,5,15   ... デフォルト (黒-青-赤-黄)
    3,11,6   ... 緑-赤-紫
    23,28,3  ... 海 (緑-青-白)
    21,22,23 ... 温度色 (黒-赤-黄-白)
    30,31,32 ... 黒-青-紫-黄-白
    33,13,10 ... 虹 (青-緑-黄-赤)
    34,35,36 ... AFM 温度色 (黒-赤-黄-白)

 HSV 色空間でのフルカラーパレット:
    3,2,2    ... 赤-黄-緑-水色-青-紫-赤

4 defined
?commands set palette defined
?set palette defined
?palette defined
=colors
 灰色から RGB への対応は `palette defined` を使うことで手動で設定できま
 す: グラデーションは RGB の値を与えるために定義され使用されます。
 グラデーションは、[0,1] の灰色値から [0,1]x[0,1]x[0,1] の RGB 空間への
 区分的に線形な写像です。その線形補間に使われる灰色値と RGB 値の組を指
 定する必要があります:

 書式:
       set palette  defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }

 ここで N ≧ 2 で、<grayN> は [0,1] に割り当てる灰色値です。それに対応
 する RGB 色 <colorN> は、3 種類の方法で指定できます:

      <color> :=  { <r> <g> <b> | '<color-name>' | '#rrggbb' }

 赤、緑、青に対応する空白で区切られた 3 つの値 (それぞれ [0,1] 内)、引
 用符でくくられた色名、または引用符でくくられた X 形式の指定方式、のい
 ずれかです。グラデーションの定義では、これらの 3 種の型を自由に組み合
 わせることができますが、色空間として RGB でないものが選択された場合色
 名 "red" は少し違ったものになるでしょう。使用できる色名は
 `show colornames` でその一覧を見ることができます。

 <gray> の値は実数の昇順に並べる必要があります。その列の値は自動的に
 [0,1] に変換されます。

 カッコつきのグラデーションの定義なしで `set palette defined` とした場
 合、RGB 色空間にし、あらかじめ設定されたフルスペクトルグラデーションを
 使用します。グラデーションを表示するには `show palette gradient` を使
 用してください。

 例:

 灰色のパレット (役に立たないが教訓的な) を生成するには:
       set palette model RGB
       set palette defined ( 0 "black", 1 "white" )

 青-黄-赤のパレット (全てが等価の) を生成するには:
       set palette defined ( 0 "blue", 1 "yellow", 2 "red" )
       set palette defined ( 0 0 0 1, 1 1 1 0, 2 1 0 0 )
       set palette defined ( 0 "#0000ff", 1 "#ffff00", 2 "#ff0000" )

 HSV 色空間でのフルカラースペクトル:
       set palette model HSV
       set palette defined ( 0 0 1 1, 1 1 1 1 )
       set palette defined ( 0 0 1 0, 1 0 1 1, 6 0.8333 1 1, 7 0.8333 0 1)

 赤以外のある色相で巻き進めた HSV フルカラースペクトル
       set palette model HSV start 0.15
       set palette defined ( 0 0 1 1, 1 1 1 1 )

 等間隔な少しの色だけのパレットを生成するには:
       set palette model RGB maxcolors 4
       set palette defined ( 0 "yellow", 1 "red" )

 '交通信号' (滑らかではなく gray = 1/3, 2/3 で跳びを持つ):
       set palette model RGB
       set palette defined (0 "dark-green", 1 "green", \
                            1 "yellow",     2 "dark-yellow", \
                            2 "red",        3 "dark-red" )

4 functions
?commands set palette functions
?set palette functions
?palette functions
      set palette functions <f1(gray)>, <f2(gray)>, <f3(gray)>
 このオプションは、`set palette rgbformulae` に似ていますが、各色成分に
 対して、定義済みの関数番号を指定する代わりに実際の関数を与えることが違
 います。各関数のダミー変数が必要なら、それは "gray" としなければいけま
 せん。関数は、[0,1] の範囲の gray の値を、[0,1] 内の値に写像しなればな
 りません。

 例:

 フルカラーパレットを生成するには:
       set palette model HSV functions gray, 1, 1

 黒から金色への良いパレット:
       set palette model RGB functions 1.1*gray**0.25, gray**0.75, 0

 ガンマ補正の白黒のパレット:
       gamma = 2.2
       map(gray) = gray**(1./gamma)
       set palette model RGB functions map(gray), map(gray), map(gray)
4 gray
?commands set palette gray
?set palette gray
?set palette grey
?palette gray
 `set palette gray` は、0.0 = 黒から 1.0 = 白への灰色階調 (グレイスケー
 ル) パレットに切り替えます。灰色階調パレットから、直前のカラーパレット
 にまた戻すには、`set palette color` とするのが簡単です。
4 cubehelix
?commands set palette cubehelix
?set palette cubehelix
?cubehelix
 オプション "cubehelix" はあるパレット族を定義しますが、これは、灰色階
 調値が 0 から 1 に増加すると正味の感覚光度が単調に増加する一方、そのパ
 レットの色相 (hue) は標準色相環を回って変化します。
       D A Green (2011) http://arxiv.org/abs/1108.5083
 `start` は、色相環に沿った開始点をラジアン単位で決定します。
 `cycles` は、パレットの範囲を渡って色相環を何回回るかを決定します。
 `saturation` (彩度) が大きいと、よりあざやかな色になります。1 より大き
 い彩度は、個々の RGB 成分をクリッピングすることになり、光度は単調では
 なくなってしまいます。`set palette gamma` もパレットに影響を与えます。
 デフォルト値は以下の通りです。
       set palette cubehelix start 0.5 cycles -1.5 saturation 1
       set palette gamma 1.5
4 viridis
?commands set palette viridis
?set palette viridis
?viridis
       set palette viridis
 パレット "viridis" は、色覚に障害のあるユーザ向けの青から黄色へのグラ
 デーションです。viridis は、Ste'fan van der Walt と Nathaniel Smith に
 より開発されました。それは、感覚的な明るさ (輝度) の近似的に線形なグラ
 デーションとなります。gnuplot が使用するカラーマップ版は、以下に基づい
 ています。
       "Viridis - Colorblind-Friendly Color Maps for R", Garnier et al (2021)
       https://CRAN.R-project.org/package=viridis
D viridis 1
4 colormap
?commands set palette colormap
?palette colormap
 `set palette colormap <name>` は、事前に colormap として保存した定義済
 みのグラデーションを読み込みます。そのカラーマップのアルファチャンネル
 (透過) 情報 は、それがあったとしても、色の値がパレット定義にコピーされ
 る際に失われます。
 以下参照: `colormap`。
4 file
?commands set palette file
?set palette file
?palette file
 `set palette file` は基本的に `set palette defined (<gradient>)` と同
 じで、この <gradient> をデータファイル、またはデータブロックから読み込
 みます。色の値は、単一の RGB 3 つ組の 24 ビット整数 (`using` 列が 1 つ
 か 2 つの場合) か、または 3 つの別々な R, G, B 成分の実数値 (`using`
 列が 3 つか 4 つの場合) のいずれかで与えられます。最初の入力列に明示的
 な灰色値が与えられない場合は、行番号をそれとして使います。これは、色軸
 に沿って等間隔なパレットを生成します。

 ファイルは通常のデータファイルとして読むので、全てのデータファイル修飾
 子が使えます。HSV 色空間が選択されている場合には、`R` は実際には `H`
 を指すことに注意してください。

 グラデーションを表示するには `show palette gradient` を使用してくださ
 い。

 例:

 RGB のパレットを [0,255] の範囲で読み込む:
       set palette file 'some-palette' using ($1/255):($2/255):($3/255)

 等間隔の虹色 (青-緑-黄-赤) パレット:
       set palette model RGB file "-" using 1:2:3
       0 0 1
       0 1 0
       1 1 0
       1 0 0
       e

 明示的な灰色値指定と RGB 値指定で同じことを:
       set palette model RGB file "-" using 1:2
       1  0x0000ff
       2  0x00ff00
       3  0xffff00
       4  0xff0000
       e

 バイナリパレットファイルも同様にサポートされています。以下参照:
 `binary general`。R,G,B の double のデータの 64 個の 3 つ組をファイル
 palette.bin に出力し、それを読み込む例:
       set palette file "palette.bin" binary record=64 using 1:2:3

4 ガンマ補正 (gamma correction)
?commands set palette gamma-correction
?set palette gamma-correction
?palette gamma-correction
?gamma-correction
 `set palette gamma <gamma>` は灰色階調写像 (`set palette gray`) と
 `cubehelix` のカラーパレット形式に対して自動的なガンマ補正を行います。
 gamma = 1 は、線形の光度グラデーションを生成します。以下参照:
 `test palette`。

 灰色階調写像に対して <gamma> のデフォルトは 1.5 で、通常は適切な値です。

 ガンマ補正は、cubehelix カラーパレット形式には適用されますが、他の色形
 式には適用されません。しかし、明示的な色関数にガンマ補正を実装するのは
 難しくありません。

 例:
       set palette model RGB
       set palette functions gray**0.64, gray**0.67, gray**0.70

 補間されたグラデーションを使ってガンマ補正を行うには、適当な色に中間の
 値を指定します。

       set palette defined ( 0 0 0 0, 1 1 1 1 )

 の代わりに例えば以下を指定してください:

       set palette defined ( 0 0 0 0, 0.5 .73 .73 .73, 1 1 1 1 )

 または、線形補間が "ガンマ補正" の補間に十分良く適合するまでより良い中
 間の点を探してください。
4 最大色数 (maxcolors)
?commands set palette maxcolors
?set palette maxcolors
?palette maxcolors
 `set palette maxcolors <N>` はパレットを、連続なパレットの等間隔な区間
 からサンプリングした N 個の離散的な色に制限します。離散的な N 個の色を
 不等間隔にしたい場合は、単一の連続パレットの代わりに
 `set palette defined` を使ってください。

 これの第一の使用目的は、離散的な色それぞれが値の範囲を代表するもので、
 それによって温度分布図を生成することです。

 2 つ目の使用目的は、限定された色数 (例えば gif や sixel では 256 色)
 しかサポートしない出力形式での処理です。gnuplot のデフォルトの線種色は
 そのうちのいくつかまでを使用するので、パレットが利用できる色数はさらに
 制限されます。よって、複数のパレットを使用する multiplot では、最初の
 パレットが利用可能な色位置を使い切ってしまって失敗します。これは、それ
 ぞれのパレットで使用できる色数を制限することで、回避できます。
4 色空間モデル (color model)
?commands set palette model
?set palette model
?palette model
?color model
?HSV
?RGB
?CMY
      set palette model { RGB | CMY | HSV {start <radians>} }
 色空間は、`model` を `RGB`, `HSV`, `CMY` とすることで変更できます。
 RGB は、標準的な赤 (Red)、緑 (Green)、青 (Blue) に、CMY は水色 (Cyan)、
 紫 (Magenta)、黄色 (Yellow) に、HSV は 色相(Hue)、彩度 (Saturation)、
 明度 (Value) に基づく色空間です。HSV 色空間では、H が 0 から 1 に変化
 するのに応じて色相環全体を一回りし、よって H=0 と H=1 は同じ色を示すこ
 とになります。デフォルトでは、その回転の開始と終了位置は赤です。オプシ
 ョンパラメータ `start` はそれをずらすので、よって
 `set palette model HSV start 0.3` の後では、H=0 と H=1 はいずれも緑に
 対応します。

 カラーモデルに関するさらなる情報については、以下を参照してください:
^ <a href="http://en.wikipedia.org/wiki/Color_space">
           http://en.wikipedia.org/wiki/Color_space
^ </a>
 (訳注: 日本語では "http://ja.wikipedia.org/wiki/色空間" があります。)

 パレットオプションに関するマニュアルは、RGB 色空間について書かれていま
 したが、例えばそれの `R` は「最初の色成分」を意味し、よって実際に使用
 している色空間によっては `H`、`C` であることに注意してください。
4 postscript
?commands set palette postscript
?set palette postscript
 このセクションの内容は、`set term postscript color` からの出力のみに関
 連しています。パレットを `set palette rgbforumulae` で定義している場合、
 gnuplot は要求した解析的な成分関数の postscript での実装を、pm3d の描
 画の直前にヘッダとして書きます。/g や /cF の定義を参照してください。通
 常は、palette が使用する 3 つの公式の定義のみを書き出せばそれでよくて、
 それがデフォルトのオプション `nops_allcF` です。オプション `ps_allcF`
 は、その代わりに 36 個の公式全ての定義を書き出します。これにより、一つ
 のグラフ内で曲面毎に違うパレットを使うために postscript ファイルを編集
 することが可能になります。

 postscript ファイルに pm3d 曲面を書き出す場合、その後で gnuplot に付属
 する awk スクリプト `pm3dCompress.awk` を実行するとそのファイルサイズ
 を小さくできるかもしれません。データが四角形の格子状になっている場合は、
 awk スクリプト `pm3dConvertToImage.awk` を使うことでより大きな圧縮率が
 得られる可能性があります。
 いずれもスクリプトも gnuplot とともに配布されています。
 使用法:
     awk -f pm3dCompress.awk thefile.ps >smallerfile.ps
     awk -f pm3dConvertToImage.awk thefile.ps >smallerfile.ps

3 媒介変数モード (parametric)
?commands set parametric
?commands unset parametric
?commands show parametric
?set parametric
?unset parametric
?show parametric
?parametric
?noparametric
 `set parametric` コマンドは `plot` および `splot` の意味を通常の関数描
 画から媒介変数表示 (parametric) 関数描画に変更します。`unset parametric`
 を使えば元の描画モードに戻ります。

 書式:
       set parametric
       unset parametric
       show parametric

 2 次元グラフにおいては、媒介変数表示関数はひとつの媒介変数に対する 2
 つの関数で定められます。例としては plot sin(t),cos(t) とすることによっ
 て円が描けます (アスペクト比が正しく設定されていれば。以下参照:
 `set size`)。`gnuplot` は、両方の関数が媒介変数による `plot` のために
 与えられていなければエラーメッセージを出します。

 3 次元グラフにおいては面は x = f(u,v), y = g(u,v), z = h(u,v) で定め
 られます。よって 3 つの関数を組で指定する必要があります。例としては、
 `cos(u)*cos(v),cos(u)*sin(v),sin(u)` とすることによって球面が描けます。
 `gnuplot` は、3 つ全部の関数が媒介変数による `splot` のために与えられ
 ていなければエラーメッセージを出します。

 これによって表現できる関数群は、単純な f(x) 型の関数群の内包することに
 なります。なぜならば、2 つ (3 つ) の関数は x, y (, z) の値を独立に計算
 する記述ができるからです。実際、t,f(t) のグラフは、一番目の関数のよう
 な恒等関数を用いて x の値が計算される場合に f(x) によって生成されるグ
 ラフと等価です。同様に、3 次元での u,v,f(u,v) の描画は、f(x,y) と等価
 です。

 媒介変数表示関数は、x の関数、y の関数 (、z の関数)の順に指定し、それ
 らは共通の媒介変数およびその変域で定義されることに留意して下さい。

 さらに、`set parametric` の指定は、新しい変数変域を使用することを暗に
 宣言します。通常の f(x) や f(x,y) が xrange、yrange (、zrange) を使用
 するのに対して、媒介変数モードではそれに加えて、trange, urange, vrange
 を使用します。これらの変域は `set trange`, `set urange`, `set vrange`
 によって直接指定することも、`plot` や `splot` で指定することもできます。
 現時点では、これらの媒介変数のデフォルトの変域は [-5:5] となっています。
 将来的にはこれらのデフォルト値をもっと有意なものに変更する予定です。
3 平行描画軸設定 (paxis)
?paxis
?commands set paxis
?set paxis
?show paxis
 書式:
       set paxis <axisno> {range <range-options> | tics <tic-options>}
       set paxis <axisno> label <label-options> { offset <radial-offset> }
       show paxis <axisno> {range | tics}
 コマンド `set paxis` は、平行座標描画 (parallel axis) とクモの巣グラフ
 (spiderplot) の p1, p2, ... 軸の一つに作用すること以外は、`set xrange`
 や `set xtics` と同じです。以下参照: `parallelaxes`, `set xrange`,
 `set xtics`。range と tics コマンドへの通常のオプションは、平行座標描
 画スタイルには意味のないものもありますが、一応すべてを受けつけます。

 `set paxis <axisno> label <label-options>` は、spiderplot 用で、その他
 では無視されます。平行座標描画の軸は、plot コマンドの `title` オプショ
 ンでラベル付けできます。これは xtic ラベルを生成するので、`set xtics`
 も必要となることに注意してください。

 軸の線種属性は、`set style parallelaxis` で制御します。
3 pixmap
?pixmap
?set pixmap
?unset pixmaps
?show pixmaps
?commands set pixmap
 書式:
       set pixmap <index> {"filename" | colormap <name>}
                  at <position>
                  {width <w> | height <h> | size <w>,<h>}
                  {front|back|behind} {center}
       show pixmaps
       unset pixmaps
       unset pixmap <index>

 コマンド `set pixmap` は、その後に続く plot で表示されるオブジェクトを
 定義するコマンド `set object` と似ています。そのピクスマップを構成する
 R/G/B/alpha の値の長方形配列が png, jpeg, gif ファイルのいずれかから読
 み込まれます。gnuplot 出力上の位置とピクスマップが占有する範囲は、任意
 の座標系 (以下参照: `coordinates`) で指定できます。`at <position>` で
 与えた座標は、キーワード `center` が指定されていない限り、ピクスマップ
 の左下角を意味します。

 `width <x-extent>` を使用して描画するピクスマップの x の範囲を 指定し
 た場合、元の画像のアスペクト比が保持され、軸のスケールや回転ではアスペ
 クト比もピクスマップの向きも変更しません。`height <y-extent>` を使用し
 て y の範囲を指定した場合も同様です。`size <x-extent> <y-extent>` を使
 用して x と y の範囲の両方を指定した場合、元のアスペクト比を変更します。
 サイズを指定しなければピクセル単位での元のサイズを使用します (よってそ
 の実際のサイズは、出力形式に依存します)。

 ピクスマップは、グラフの境界でクリッピングしません。オブジェクトやレイ
 ヤの一般的な挙動に対する例外として、`behind` レイヤに割り当てたピクス
 マップは、multiplot では最初の plot でのみ描画します。これは、一つの背
 景用のピクスマップを、multiplot のすべてのパネルで共有することを可能に
 します。

 例:
       # すべてのグラフの背景としてグラデーションを使用
       # キャンバス全体を埋めるよう x, y の両方をリサイズする
       set pixmap 1 "gradient.png"
       set pixmap 1 at screen 0, 0 size screen 1, 1 behind

       # グラフの各ページの右下にロゴをを配置
       set pixmap 2 "logo.jpg"
       set pixmap 2 at screen 0.95, 0 width screen 0.05 behind

       # ある 3 次元座標に小さい画像を配置
       # それは描画されている曲面に張り付いているように移動するが、
       # 常に前を向き直立し続ける
       set pixmap 3 "image.png" at my_x, my_y, f(my_x,my_y) width screen .05
       splot f(x,y)
4 カラーマップから作る pixmap (pixmap from colormap)
?pixmap colormap
?set pixmap colormap
 pixmap のもう一つの利用目的は、現在有効なパレットに対して自動的に作ら
 れるカラーボックスとは別に、名前付きカラーマップに対するカラーボックス
 を作ることです。

      set pixmap <index> colormap <name> at <position> size <width>, <height>
3 pm3d
?commands set pm3d
?commands show pm3d
?set pm3d
?show pm3d
?pm3d
 pm3d は `splot` の一つのスタイルで、パレットに割り付けられた 3 次元、
 4 次元データを、カラー/灰色の色地図や曲面として描画します。これは、格
 子状のデータや非格子状のデータを前処理なしに描画できます。pm3d のスタ
 イルオプションは、他の 3 次元描画要素を構築するのに使われる単色多角形
 にも影響を与えます。

 書式 (オプションは任意の順で与えることができます):
       set pm3d {
                  { at <position> }
                  { interpolate <steps/points in scan, between scans> }
                  { scansautomatic | scansforward | scansbackward
                                   | depthorder {base} }
                  { flush { begin | center | end } }
                  { ftriangles | noftriangles }
                  { clip | clip1in | clip4in }
                  { {no}clipcb }
                  { corners2color
                    { mean|geomean|harmean|rms|median|min|max|c1|c2|c3|c4 }
                  }
                  { {no}lighting
                    {primary <fraction>} {specular <fraction>}
                    {spec2 <fraction>}
                  }
                  { {no}border {retrace} {<linestyle-options>}}
                  { implicit | explicit }
                  { map }
                }
       show pm3d
       unset pm3d

 pm3d の曲面は、splot コマンドに与えた順に連続して描画することに注意し
 てください。先に描かれたグラフは、後のグラフで隠される可能性があります。
 それを避けるために、scan オプションの `depthorder` を使用することがで
 きます。

 pm3d 曲面は、表示枠の天井 (`top`) や底面 (`bottom`) に射影できます。
 以下参照: `pm3d position`。
 以下のコマンドは、異なった高さで 3 つの色付きの曲面を描きます:
       set border 4095
       set pm3d at s
       splot 10*x with pm3d at b, x*x-y*y, x*x+y*y with pm3d at t

 以下も参照: `set palette`, `set cbrange`, `set colorbox`。そしてデモフ
 ァイル `demo/pm3d.dem` も参考になるでしょう。

4 with pm3d (明示的な pm3d; pm3d explicit)
?pm3d explicit
?with pm3d
?splot with pm3d
?plotting styles pm3d
?splot with pm3d zclip
?pm3d zclip
?zclip

 書式
      splot DATA using (x):(y):(z){:(color)} with pm3d
                 {fs|fillstyle <fillstyle>} {fc|fillcolor <colorspec>}
                 {zclip [zmin:zmax]}

 すべての pm3d 曲面の描画属性は、`set pm3d` を使って制御できます。デフ
 ォルトでは、曲面全体を四辺形の格子として描画し、各格子は z 座標に割り
 当てられるパレット色で色付けします。4 番目の入力列を与えると、パレット
 の割り当ては z の値でなくその値を使用します。以下参照:
 `pm3d fillcolor`, `pm3d color_assignment`。

 `set pm3d implicit` が有効な状態で `with pm3d` 以外の描画スタイルを使
 用するのではなく、plot コマンドで明示的に `with pm3d` を使用する場合、
 描画オプションを追加することが可能です。これにより、同じグラフ上で、違
 う曲面に別々の色付けの仕組みを使うことが可能になります。

 試験段階: このバージョンの gnuplot は、オプション `zclip` を導入してい
 て、それは z の値の境界で曲面を滑らかな曲面を生成するようにクリッピン
 グします。以下の例は、2 色の 3 次元曲面の頂上の部分を徐々に消していく
 アニメーションを表示します。
      set style line 101 lc "gray"
      set style line 102 lc "blue"
      set pm3d depthorder
      do for [i=0:N] {
          splot f(x,y) with pm3d fillcolor ls 101 zclip [* : zmax-(i*delta)] 
          pause 0.2  # アニメーションフレーム間隔は 1/5 秒
      }

4 暗黙的な pm3d (pm3d implicit)
?pm3d implicit

 splot コマンドで明示的に `with pm3d` を指定した場合、またはデータや関
 数描画スタイル (`style`) が大域的に pm3d にセットされている場合、ある
 いは、pm3d モードが `set pm3d implicit` となっている場合は、pm3d のカ
 ラー曲面を描画します。後の 2 つの場合は、plot コマンドで指定したスタイ
 ルで生成する網目に pm3d 曲面を追加する形で描画します。例えば、
       splot 'fred.dat' with lines, 'lola.dat' with lines
 は、各データ集合毎に折れ線による網目と pm3d 曲面の両方を描画します。
 オプション `explicit` (明示的) が ON (または `implicit` が OFF) の場合
 は、属性 `with pm3d` を指定したグラフのみが pm3d 曲面として描画されま
 す。例えば
       splot 'fred.dat' with lines, 'lola.dat' with pm3d
 は、'freq.dat' は折れ線で (線のみで)、'lola.dat' は pm3d 曲面で描画し
 ます。

 gnuplot の起動時はそのモードは `explicit` (明示的) になっています。歴
 史的、そして互換性のために、コマンド `set pm3d;` (すなわちオプションが
 ない場合) と `set pm3d at X ...` (すなわち `at` が最初のオプションの場
 合) はモードを `implicit` (暗黙的) に変更します。コマンド `set pm3d;`
 は、その他のオプションをそれらのデフォルトの状態に設定します。

 デフォルトのデータ/関数の描画スタイルを `pm3d` にしたい場合は、例えば
       set style data pm3d
 とします。この場合、オプション `implicit` と `explicit` は効力を持ちま
 せん。
4 pm3d のアルゴリズム (algorithm)
?pm3d algorithm

 まず、地図/曲面がどのように描かれるのかについて記述します。入力データ
 は、関数を評価して得られるかまたは `splot data file` から得られます。
 曲面は、走査 (孤立線) の繰り返しで構成されます。pm3d アルゴリズムでは、
 最初の走査で検出された隣り合う 2 点と、次の走査で検出された他の 2 点の
 間の領域が、これら 4 点の z の値 (または追加された 'color' 用の列の値、
 以下参照: `using`) に従って灰色で (または カラーで) 塗られます。デフォ
 ルトでは 4 つの角の値の平均値が使われますが、それはオプション
 `corners2color` で変更できます。それなりの曲面を描くためには、隣り合う
 2 点の走査が交差してはいけなくて、近接点走査毎の点の数が違いすぎてはい
 けません。もちろん、最も良いのは走査の点の数が同じことです。他には何も
 必要ではありません (例えばデータは格子状である必要もない)。他にもこの
 pm3d アルゴリズムは、入力された (計測された、あるいは計算された) 領域
 の外には何も描かない、という長所があります。

 曲面の色づけは、以下のような入力データに関して行われます:

 1. 関数、または 1 つか 3 つのデータ列からなるデータの splot: 上に述べ
 た四角形の 4 つの角の z 座標の平均値 (または `corners2color`) から、灰
 色の範囲 [0:1] を与える `zrange` または `cbrange` の範囲
 [min_color_z,max_color_z] への対応により、灰色/カラーの値が得られます。
 この値は、直接灰色の色地図用の灰色の値として使うことができます。正規化
 された灰色の値をカラーに対応させることもできます。完全な説明は、以下
 参照: `set palette`。

 2. 2 つか 4 つのデータ列からなるデータの splot: 灰色/カラーの値は、z
 の値の代わりに最後の列の座標を使って得られますので、色と z 座標が独立
 なものになります。これは 4 次元データの描画に使うことができます。

 他の注意:

 1. 物理学者の間では、gnuplot の文書やソースに現われる 'iso_curve' (孤
 立線) という言葉よりも、上で言及した '走査 (scan)' という言葉の方が使
 われています。1 度の走査と他の走査の記録により色地図を評価する、という
 のはそういう意味です。

 2. 'gray' や 'color' の値 (scale) は、滑らかに変化するカラーパレットへ
 の、連続な変数の線形写像です。その写像の様子は描画グラフの隣に長方形で
 表示されます。この文書ではそれを "カラーボックス (colorbox)" と呼び、
 その変数をカラーボックス軸の変数と呼びます。以下参照: `set colorbox`,
 `set cbrange`。
4 光源モデル (lighting)
?lighting
?pm3d lighting
?pm3d nolighting
?set pm3d lighting
?spotlight
?pm3d spotlight
?set pm3d spotlight
 書式:
      set pm3d lighting {primary <frac>} {specular <frac>} {spec2 <frac>}
      set pm3d spotlight {rgb <color>} {rot_x <angle>} {rot_z <angle>}
                         {Phong <value>} {default}

 デフォルトでは、pm3d の色の割り当ては、向きや視方位には依存しません。
 その状態は `set pm3d nolighting` に対応します。
 一方、コマンド `set pm3d lighting` は、一点の点光源からの照明からの
 50% の光による単純な光源モデルを選択します。周囲の明るさに対するその光
 源の強度は `set pm3d lighting primary <fraction>` で調整できます。反射
 光 (specular) を含ませる度合いは、その比率 (fraction) の設定ができます:
      set pm3d lighting primary 0.50 specular 0.0   # ハイライトなし
      set pm3d lighting primary 0.50 specular 0.6   # 強いハイライト
 ベタ塗り (solid color) の pm3d 曲面は、反射光のハイライトがないととて
 も平らに見える傾向があります。

 主光源のハイライトは曲面の片側にしか影響を与えないので、他の方向から光
 る 2 番目のスポットライトの照明を追加するといい場合があります。この 2
 番目のスポットライトの強さは、"spec2 <fraction>" (比率) で設定します。
 2 番目のスポットライトは、spec2 が生の場合にのみ光源モデルに含まれます。
 その方向、色、反射モデルは、"set pm3d spotlight" で制御します。このス
 ポットライトの利用法と位置取りは、対話形式のデモ `spotlight.dem` で説
 明しています。
 hidden_compare.dem も参照してください。
^ <a href="http://www.gnuplot.info/demo/hidden_compare.html">
 (単色塗り曲面の hidden3d と pm3d の処理の比較)
^ </a>
 例:
      set pm3d lighting primary 0.8 spec 0.4 spec2 0.4
      set pm3d spot rgb "blue"
D spotlight 1
4 pm3d の位置 (position)
?pm3d position
?set pm3d position
 色の曲面は底面か天井 (この場合は灰色/カラーの平面地図) か曲面上の点の
 z 座標 (灰色/カラー曲面) に描くことができます。その選択は、オプション
 `at` に、`b`, `t`, `s` の 6 つまでの組合せの文字列をつけて指定すること
 で行えます。例えば `at b` は底面のみに描画しますし、`at st` は最初に曲
 面に描いて次に天井面に色地図を描きますし、`at bstbst` は ... 真面目な
 話、こんなものは使いません。

 塗られた四角形は、次から次へと描画されて行きます。曲面を描画する場合
 (`at s`)、後の四角形が前のものに重なり (上書きし) ます (gnuplot は塗ら
 れた多角形の網の重なりの相互作用を計算するような仮想現実ツールではあり
 ません)。 最初に走査されるデータを最初に描くか最後に描くかを切替えるス
 イッチオプション `scansforward` と `scansbackward` を試してみてくださ
 い。デフォルトは `scansautomatic` で、これは gnuplot 自身に走査の順を
 推測させます。一方で、オプション `depthorder` は四角形の順序を完全に再
 構成します。塗りつぶしは深さ順に並び変えされた後で行われ、これによりか
 なり複雑な曲面でも視覚的なものにすることができます。詳細は、以下参照:
 `pm3d depthorder`。
4 走査の順番 (scanorder)
?pm3d scanorder
?pm3d depthorder
?pm3d flush
?pm3d ftriangles
?set pm3d scanorder
?set pm3d depthorder
?set pm3d flush
?set pm3d ftriangles
?depthorder
=flush
?scansforward
?scansautomatic
?scansbackward
=ftriangles
      set pm3d {scansautomatic | scansforward | scansbackward | depthorder}

 デフォルトでは、pm3d の単色塗り曲面を構成する四角形は、それらが曲面の
 格子点に沿って出会う順番に塗り潰されます。この順番は、オプション
 `scansautomatic`|`scansforward`|`scansbackward` で制御できます。これら
 の走査 (scan) オプションは、一般には隠面処理とは両立しません。

 2 回の連続する走査で点の数が同じでなかった場合、四角形の点の取り始めを、
 両方の走査の最初から (`flush begin`) にするか、最後から (`flush end`)
 にするか、真中から (`flush center`) にするかを決定しなければいけません。
 `flush (center|end)` は `scansautomatic` とは両立せず、よって
 `flush center` または `flush end` を指定して `scansautomatic` が設定さ
 れた場合、それは無言で `scansforward` に変更されます。

 2 回の連続する走査で点の数が同じでなかった場合、個々の走査で点が足りな
 い場合に、走査の最後に色三角形を描くかどうかをオプション `ftriangles`
 は指示します。これは滑らかな色地図の境界を描くのに使われます。

 gnuplot は、曲面の単色塗りにおいては、本当の隠面処理は行いませんが、た
 いていは遠い方から近い方へ順に四角形要素を塗り潰すことで十分なできあが
 りになります。このモードは、以下のオプションを使うことで選択できます:
       set pm3d depthorder
 大域的なオプションである `set hidden3d` は、pm3d 曲面には影響しないこ
 とに注意してください。

 オプション `depthorder` は、`splot with boxes` で作った細長い長方形に
 適用すると、良くない結果を生む傾向があります。その場合、キーワード
 `base` を追加することで、z=0 の平面と箱の共通部分で深さのソートを行う
 ため少しましになります。その形式のグラフは、光源モデル (lighting) を追
 加すれば更に改善できます。
 例:
      set pm3d depthorder base
      set pm3d lighting
      set boxdepth 0.4
      splot $DATA using 1:2:3 with boxes

4 クリッピング (clipping)
?pm3d clipping
?set pm3d clipping
?clipcb
?clip1in
?clip4in
?pm3d clipcb
?noclipcb
?pm3d noclipcb
 書式:
      set pm3d {clip | clip1in | clip4in}
      set pm3d {no}clipcb

 pm3d 曲面や他の 3 次元オブジェクトを構成する四辺形は、デフォルトでは現
 在の zrange に関して滑らかにクリッピングします。これは、gnuplot 5.0 以
 前とは異なる挙動です。2 次元射影 (`set view map`) では、このモードは
 xrange と yrange に対してもクリッピングします。

 それとは別に、4 つの角全部が x, y, z の範囲内である四辺形全体
 (`set pm3d clip4in`)、または少なくとも 1 つの角が x, y, z の範囲内であ
 る四辺形全体 (`set pm3d clip1in`)を描画することにより、クリッピングす
 ることもできます。オプション `clip`, `clip1in`, `clip4in` は相互に排他
 的です。

 空間座標 x, y, z ベースのクリッピングとは別に、四辺形を描画するかどう
 かを最終的なパレットカラー値で決定することもできます。
 `clipcb`: (デフォルト) cbmin 未満のパレットカラー値は cbmin として、
 cbmax より大きいパレットカラー値は cbmax として扱います。
 `noclipcb`: cbrange 外のパレットカラー値の四辺形は何も描画しません。

4 色の割り当て
?pm3d color_assignment
 デフォルトでは、pm3d の色は、その曲面の格子の各 4 辺形毎に個別に割り当
 てられます。曲面全体に一様な色を割り当てるような他の彩色の仕組みについ
 ては、以下参照: `pm3d fillcolor`。

 各四辺形には一つの灰色/カラー値 (グラデーションではない) を割り当てま
 す。その値は、`corners2color <option>` に従って四辺形の 4 つの角の z
 座標から計算します。そして、その値を現在のパレットから色を選択するのに
 使用します。以下参照: `set palette`。
 一つの `splot` コマンド内でパレットを変更することはできません。

 4 列目にデータを与えた場合、個々の四角形の彩色は上と同様に行いますが、
 色の値は z の値とは別とみなされます。別の彩色オプションにより、4 列目
 のデータに RGB 色を与えることもできます。以下参照: `rgbcolor variable`。
 この場合、描画コマンドは以下のようにする必要があります:

       splot ... using 1:2:3:4 with pm3d lc rgb variable

 z の値の範囲と曲面の色の値の範囲は、`set zrange`, `set cbrange`,
 `set log z`, `set log cb` 等によって独立に調整し得ることに注意してくだ
 さい。
4 corners2color
?pm3d corners2color
?set pm3d corners2color
?corners2color
=mean
=geomean
=harmean
=median
=min
=max
=rms
 pm3d 曲面の各四角形の色は、その 4 つの頂点の色の値に基づいて割り当てら
 れます。<option> は 'mean' (デフォルト)、'geomean', 'harmean', 'rms',
 'median' で、曲面のカラーの平滑化に幾つかの種類を与え、'min','max' は
 それぞれ最小値、最大値を選択します。これらは鋭敏な、あるいは急激なピー
 ク値を持つようなピクセルイメージや色地図を作るときには必要ありません。
 そのような場合には、むしろオプション 'c1', 'c2', 'c3', 'c4' を使って、
 四角形の色の割当にただ一つの角の z 座標を使うようにすればいいでしょう。
 どの角が 'c1' に対応するのかを知るためには何回か実験してみる必要がある
 でしょう。その向きは描画の方向に依存しています。
 pm3d アルゴリズムは、カラー曲面を入力データ点の範囲の外には描かないの
 で、オプション 'c<j>' は、格子の 2 つのへりに沿ったピクセルが、どの四
 角形の色にも寄与しない、という結果をもたらします。例えば、pm3d アルゴ
 リズムを 4x4 のデータ点の格子に適用するスクリプト `demo/pm3d.dem` (是
 非見てください) では、(4-1)x(4-1)=9 色しかない長方形が生成されます。
4 border
?set pm3d hidden3d
?pm3d hidden3d
?set pm3d border
?pm3d border
      set pm3d border {retrace} {line-properties}
      set pm3d noborder

 このオプションは、各四角形の境界線を、四角形が描かれているように描画し
 ます。追加の線属性 (線種、色、線幅) は任意で、デフォルトでは、幅 1 の
 黒の実線で境界を書きます。

 `set pm3d border retrace` は、四辺形の塗るのと同じ色で境界を塗らせます。
 これは、結果として `noborder` と同じことになりますが、出力モードによっ
 ては、隣接した塗り潰し四辺形の間のアンチエイリアスによる副産物に苦しむ
 かもしれません。境界を再描画 (retrace) することで、出力ファイルは大き
 くなってしまいますが、これらの副産物を隠すことができます。
4 fillcolor
?pm3d fillcolor
      splot FOO with pm3d fillcolor <colorspec>

 描画スタイル `with pm3d` は、splot コマンド上で fillcolor 追加オプショ
 ンを受けつけます。その指定は、pm3d 曲面全体に適用されます。以下参照:
 `colorspec`。たいていの fillcolor 指定では単一色の単色塗りになりますが
 曲面の表裏の要素を区別するための光源モデルが存在しない場合は見た目を解
 釈するのが難しいでしょう。以下参照: `pm3d lighting`。

 2,3 特別な例を紹介します。`with pm3d fillcolor palette` は、デフォルト
 の pm3d のパレットベースの配色と全く同じ結果を生成しますので、役に立つ
 オプションではありません。
 `with pm3d fillcolor linestyle N` は多少意味があります。これは、
 gnuplot の `hidden3d` モードを使った場合の配色の仕組みと同様、pm3d 曲
 面の上側と下側に異なる色を割り当てる変種です。線種 N を上側の曲面に、
 線種 N+1 を下側の曲面に使用します。「上側」と「下側」は、走査 (scan)
 順序に依存しますので、`pm3d scansbackward` と `pm3d scansforward` では
 配色が逆になることに注意してください。この配色オプションは、
 `pm3d depthorder` とでは最適に機能しますが、それは残念ながら走査順序の
 制御を許しませんので、代わりに線種 N と N+1 で定義される色を入れ替えな
 いといけないかもしれません。
4 interpolate
?set pm3d interpolate
?pm3d interpolate
 オプション `interpolate m,n` は、より細かな網目を作るために格子点間を
 補間します。データ描画に対しては、これは色の曲面を滑らかにし、その曲面
 の尖りを補正します。関数描画に対しては、この補間はほとんど意味はありま
 せんから、関数描画の場合は普通 `samples` や `isosamples` を使って標本
 数を増加させるのがいいでしょう。

 正の m, n に対しては各四角形、または三角形は、それぞれの方向に m 回、
 n 回補間されます。負の m, n では補間の頻度は、少なくとも |m|, |n| 点が
 描画されるように選択されます。これは特別な格子関数と見なすことができま
 す。

 注意: `interpolate 0,0` は、自動的に最適な補間曲面点数を選択します。

 注意: corners2color で幾何平均 (geomean) のような非線形評価が設定され
 ていたとしても、現在の色の補間は常に線形補間で行われます。
4 非推奨なオプション
?set pm3d deprecated_options
?pm3d deprecated_options
?set pm3d map
?pm3d map
?map
 非推奨なオプション `set pm3d map` は、以下と同等です。
 `set pm3d at b; set view map; set style data pm3d; set style func pm3d;`

 非推奨なオプション `set pm3d hidden3d N` は、以下と同等です。
 `set pm3d border ls N`
3 pointinterval の箱サイズ (pointintervalbox)
?commands set pointintervalbox
?set pointintervalbox
?pointintervalbox
 線属性 `pointinterval`, `pointnumber` は、描画スタイル `linespoints`
 でのみ使われます。pointinterval や pointnumber の値を負、例えば -N と
 すると、点の記号を描く前に、各点の記号の後ろの箱 (実際には円) の部分
 を背景色で塗りつぶすことで消します。コマンド `set pointintervalbox` は
 その消す領域の大きさ (半径) を制御します。指定する値はデフォルトの半径
 (= pointsize) に対する倍率です。
3 点サイズ (pointsize)
?commands set pointsize
?commands show pointsize
?set pointsize
?show pointsize
?pointsize
 コマンド `set pointsize` は描画で使われる点の大きさを変更します。

 書式:
       set pointsize <multiplier>
       show pointsize

 デフォルトは 1.0 倍です。画像データ出力では、大きいポイントサイズの方
 が見やすいでしょう。

 一つの描画に対するポイントサイズは `plot` コマンドの上でも変更できます。
 詳細は、以下参照: `plot with`。

 ポイントサイズの設定は、必ずしも全ての出力形式でサポートされているわけ
 ではないことに注意してください。
3 極座標モード (polar)
?commands set polar
?commands unset polar
?commands show polar
?set polar
?unset polar
?show polar
?polar
?nopolar
 コマンド `set polar` はグラフの描画方法を xy 直交座標系から極座標系に
 変更します。

 書式:
       set polar
       set polar grid <grid options>
       unset polar
       show polar

 極座標モードでは、仮変数 (t) は角度θを意味します。t のデフォルトの範
 囲は [0:2*pi] ですが、単位として度が選択されていれば [0:360] となりま
 す (以下参照: `set angles`)。

 コマンド `unset polar` は描画方法をデフォルトの xy 直交座標系に戻しま
 す。

 `set polar` コマンドは 2 次元描画にのみ効力を持ちます。同様の 3 次元機
 能のコマンドについては、以下参照: `set mapping`。

 極座標モードでは t の数式の意味は r=f(t) となり、t は回転角となります。
 trange は関数の定義域 (角度) を制御し、rrange, xrange, yrange はそれぞ
 れグラフの x,y 方向の範囲を制御することになります。これらの範囲と
 rrange は自動的に設定されるか、または明示的に設定できます。詳細に関し
 ては、以下参照: `set rrange`, `set xrange`。

 例:
       set polar
       plot t*sin(t)
       set trange [-2*pi:2*pi]
       set rrange [0:3]
       plot t*sin(t)

 最初の `plot` はデフォルトの角度の範囲の 0 から 2*pi を使います。動径
 方向とグラフのサイズは自動的に伸縮されます。2 番目の `plot` は角度の定
 義域を拡張し、グラフのサイズを原点から 3 の幅に制限します。これは x,y
 のそれぞれの方向を [-3:3] に制限することになります。

 デフォルトでは極座標グラフは角度 0 (θ=0) が右向きで、増加は反時計回り
 となるように向きづけられています。その 0 の向きと増加方向の両方を明示
 的に変更可能です。以下参照: `set theta`。

 `set size square` とすると `gnuplot` はアスペクト比 (縦横の比) を 1 に
 するので円が (楕円でなく) 円に見えるようになります。同心円の周囲の目盛
 りの刻みは、`set ttics` で指定できます。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/polar.html">
 極座標のデモ (polar.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標データの描画 (poldat.dem)。
^ </a>
4 極座標格子 (polar grid)
?commands set polar grid
?set polar grid
?polar grid
 書式:
       set polar grid {<theta_segments>, <radial_segments>}
                      { qnorm {<power>} | gauss | cauchy | exp | box | hann }
                      { kdensity } { scale <scale> }
                      {theta [min:max]} {r [min:max]}

 極座標格子の設定は、描画スタイル `with surface` と組み合わせて極座標の
 点集合から温度分布図 (heat map) を生成するのに使います。面は、円を埋め
 尽くす格子からなり、それによりθと r の離散的な範囲で形作る部分で円を
 分割します。

 各部分には、個々の散在点 [x,y,z] の入力集合からフィルタ操作の適用によ
 り導かれる値を割り当てます。デフォルトのフィルタは `qnorm 1` で、これ
 は各点の、格子部分の中心からその点までの距離の逆数で重みづけされた z
 値の平均を取ることを意味します。

 他のフィルタ操作 gauss, cauchy, exp, box, hann に関しては、ほかの場所
 で詳しく説明しています。以下参照: `dgrid3d`。

 `kdensity`: このキーワードは、gnuplot に、重みつきの平均の代わりに、
 すべての点からの寄与の重み付きの和を使用することを指示します。

 `scale`: このスケール因子 (デフォルトは 1.0) は、重み計算で値を使う前
 に、すべての距離に対してスケーリングを適用します。

 マスキング: すべての入力点を、格子値を計算するのに使用します。完全に
 格子の張られた面は、常にθの範囲 [0:360] 、および自動縮尺、または前に
 実行されたコマンド `set rrange` で定義される動径範囲に渡ります。しかし
 面の実際にグラフに現れる部分は、θや r の下限、上限によって切り落した
 くさび型状に制限できます。θの範囲は度単位で与える必要があります。

Ffigure_polar_grid
 例えば、以下のコマンドは、サイズにおいて自動縮尺されたすべての入力点
 を示すグラフを生成します。すべての入力点の寄与は平均ではなく和であっ
 て (`kdensity`)、結果としての格子面のくさび部分のみを表示します。

      set rrange [0:*]
      set polar grid qnorm kdensity theta [0:190]
      plot DATA with surface, DATA with points

3 print コマンドの出力先 (print)
?commands set print
?commands show print
?set print
?show print
 コマンド `set print` は `print` コマンドの出力をリダイレクトします。

 書式:
       set print
       set print "-"
       set print "<filename>" [append]
       set print "|<shell_command>"
       set print $datablock [append]

 パラメータなしの `set print` は、出力を <STDERR> に復帰させます。"-"
 という <filename> は <STDOUT> を意味します。`append` フラグはファイル
 を追加 (append) モードで開くことを意味します。パイプをサポートするプラ
 ットホーム上では、<filename> が "|" で始まっていたら、<shell_command>
 へのパイプが開かれます。

 コマンド `print` の対象は名前付きデータブロックでも構いません。データ
 ブロック名は '$' で始まります。以下参照: `inline data`。
 データブロックへ文字列を出力する場合、改行文字が入っていると、それは
 複数のデータブロック行を生成するように展開されます。
3 PostScript 定義ファイルパス (psdir)
?commands set psdir
?commands show psdir
?set psdir
?show psdir
?psdir
 コマンド `set psdir <directory>` は、postscript 出力形式が prologue.ps
 や文字エンコード用のファイルを探すのに使用する検索パスを制御します。こ
 の仕組みは、別にローカルにカスタマイズした prolog ファイル群と切り替え
 るのに使えます。検索の順番は以下のようになっています。
       1) `set psdir` を指定した場合はそのディレクトリ
       2) 環境変数 GNUPLOT_PS_DIR で指定したディレクトリ
       3) 組み込まれたヘッダー、またはデフォルトのシステムディレクトリ
       4) `set loadpath` で指定したディレクトリ
3 極座標の動径軸 (raxis)
?commands set raxis
?raxis
?set raxis
?unset raxis
 コマンド `set raxis` と `unset raxis` は、動径軸を格子線と x 軸から分
 離して描画するかどうかを切り替えます。現在の rrange の最小値が 0 でな
 い (そして自動縮尺でない) 場合、グラフと軸が原点に達しないことを示す白
 丸が極座標グラフの中心に描かれます。軸の線は、グラフの境界と同じ線種で
 描画されます。以下参照: `polar`, `rrange`, `rtics`, `rlabel`,
 `set grid`。
3 rgbmax
?commands set rgbmax
?set rgbmax
?rgbmax
?unset rgbmax
=rgbimage
 書式:
      set rgbmax {1.0 | 255}
      unset rgbmax
 rgbimage グラフの RGB (赤、緑、青) 色成分は、デフォルトでは [0:255] の
 範囲の整数値であるとみなします。`set rgbmax 1.0` とすると、gnuplot は
 `rgbimage` や `rgbalpha` でのグラフの色成分の生成に使うデータ値を、
 [0:1] の範囲の実数値であるとみなします。`unset rgbmax` は、それをデフ
 ォルトの整数値の範囲 [0:255] に戻します。
3 rlabel
?commands set rlabel
?rlabel
?set rlabel
?unset rlabel
 このコマンドは、r 軸の上にラベルを配置します。そのラベルは、グラフが極
 座標モード (polar) であるか否かに関わらず表示されます。追加の指定キー
 ワードについては以下参照: `set xlabel`。
3 rmargin
?commands set rmargin
?set rmargin
?rmargin
 コマンド `set rmargin` は右の余白のサイズをセットします。
 詳細は、以下参照: `set margin`。
3 rrange
?commands set rrange
?commands show rrange
?set rrange
?show rrange
?rrange
 コマンド `set rrange` は極座標モードのグラフの動径方向の範囲を設定しま
 す。これは xrange と yrange の両方も設定してしまいます。両者は、
 [-(rmax-rmin) : +(rmax-rmin)] になります。しかし、これの後で xrange や
 yrange を変更しても (例えば拡大するために)、それは rrange を変更しない
 ので、データ点は rrange に関してクリッピングされたままとなります。他の
 軸とは違い、r 軸の自動縮尺では常に rmin = 0 となります。`reverse` では
 自動縮尺フラグは無視されます。
 注意: rmin を負の値を設定すると、予期せぬ結果を生む可能性があります。
3 rtics
?commands set rtics
?commands show rtics
?set rtics
?show rtics
?rtics
 コマンド `set rtics` は、動径軸に沿って目盛りを配置します。目盛りとそ
 の見出しは原点の右側に描かれます。キーワード `mirror` は、それらを原点
 の左側にも描きます。その他のキーワードに関する話については以下参照:
 `polar`, `set xtics`, `set mxtics`。
3 サンプル数 (samples)
?commands set samples
?commands show samples
?set samples
?show samples
?samples
 関数のグラフは、与えられた個数の x の値での関数値のサンプリングと、そ
 れらの値 f(x0)..f(x1)..f(x2).. を結ぶ線分を描画することで構成していま
 す。関数、またはデータの補間に関するデフォルトのサンプリング数は、コマ
 ンド `set samples` で変更できます。`plot` や `splot` コマンドの個々の
 要素のサンプリング範囲 (sampling range) を変更するには、以下参照:
 `plot sampling`。

 書式:
       set samples <samples_1> {,<samples_2>}
       show samples

 デフォルトではサンプル数は 100 点と設定されています。この値を増やすと
 より正確な描画が出来ますが遅くなります。このパラメータはデータファイル
 の描画には何の影響も与えませんが、補間/近似のオプションが使われている
 場合はその限りではありません。以下参照: `plot smooth`, `set cntrparam`,
 `set dgrid3d`。

 2 次元のグラフ描画が行なわれるときは <samples_1> の値のみが関係します。

 隠線処理なしで曲面描画が行なわれるときは、samples の値は孤立線毎に評価
 されるサンプル数の指定になります。各 v-孤立線は <samples_1> 個のサンプ
 ル点を持ち、u-孤立線は <samples_2> 個のサンプル数を持ちます。<samples_1>
 のみ指定すると、<samples_2> の値は <samples_1> と同じ値に設定されます。
 以下も参照: `set isosamples`。
3 グラフ領域サイズ (size)
?commands set size
?commands show size
?set size
?show size
?size
?aspect ratio
?set size square
?set size ratio
?ratio
?square
 書式:
       set size {{no}square | ratio <r> | noratio} {<xscale>,<yscale>}
       show size

 <xscale> と <yscale> は描画全体の拡大の倍率で、描画全体とはグラフとラ
 ベルと余白の部分を含みます。

 `歴史的な注意`: gnuplot の以前の版では、`set size` の値を、出力する描
 画領域 (キャンバス) のサイズを制御するのにも使っていた出力形式もありま
 したが、すべての出力形式がそうだったわけではありませんでした。現在は、
 `'set size'` と `'set term ... size'` の 2 つは、はっきり違う属性を設
 定します。

 `set term <terminal_type> size <x 単位>, <y 単位>` は、出力ファイルの
 サイズ、または "キャンバス" のサイズを制御します。サイズパラメータの有
 効な単位については、個々の出力形式のヘルプを参照してください。デフォル
 トでは、グラフはそのキャンバス全体に描画されます。

 `set size <xscale>, <yscale>` は、描画自体をキャンバスのサイズに対して
 相対的に伸縮させます。1.0 より小さい伸縮値を指定すると、グラフはキャン
 バス全体を埋めず、1.0 より大きい伸縮値を指定すると、グラフの一部分のみ
 がキャンバス全体に合うように描画されます。1 より大きい伸縮値を指定する
 と、ある出力形式では問題が起こるかもしれません。

 `ratio` は、指定した <xscale>, <yscale> の描画範囲内で、グラフのアスペ
 クト比 (縦横比) を <r> にします (<r> は x 方向の長さに対する y 方向の
 長さの比)。

 <r> の値を負にするとその意味は違って来ます。<r>=-1 のとき、x 軸、y 軸
 の双方の単位 (つまり 1) の目盛りの長さが同一、すなわち等長 (isotropic)
 になるよう設定します。以下も参照: `set isotropic`。
 これは、3 次元用のコマンド `set view equal xy` の 2 次元での同等物です。
 <r>=-2 のとき、y 軸の単位目盛りの長さは x 軸の単位目盛りの長さの 2 倍
 に設定されます。<r> が負の値に関して以下同様です。以下も参照:
 `set isotropic`。

 `gnuplot` が指定されたアスペクト比のグラフをちゃんと書けるかは選択され
 る出力形式に依存します。グラフの領域は出力の指定された部分にちゃんと収
 まり、アスペクト比が <r> であるような最大の長方形となります (もちろん
 適当な余白も残しますが)。
=square

 `set size square` は `set size ratio 1` と同じ意味です。

 `noratio` と `nosquare` はいずれもグラフをその出力形式 (terminal) での
 デフォルトのアスペクト比に戻しますが、<xscale> と <yscale> はそのデフ
 ォルトの値 (1.0) には戻しません。

 `ratio` と `square` は 3 次元描画では意味を持ちませんが、`set view map`
 を使用した 3 次元描画の 2 次元射影には影響を与えます。 以下も参照:
 `set view equal`。これは、3 次元の x 軸と y 軸を強制的に同じスケールに
 します。

 例:

 グラフが現在のキャンバスを埋めるような大きさに設定します:
       set size 1,1

 グラフを通常の半分の大きさで正方形にします:
       set size square 0.5,0.5

 グラフの高さを横幅の 2 倍にします:
       set size ratio 2
3 クモの巣グラフ (spiderplot)
?set spiderplot
 コマンド `set spiderplot` は、座標の解釈を極座標に切り替え、各データ点
 は、動径軸に沿った位置に割り当てられます。paxis 1 は通常鉛直向きで、2
 から N までの軸は、時計回りに等間隔に配置されます。このコマンドは、描
 画の前に発行しなければなりません。これは、グラフに以下と同様の効果も追
 加します。
      set style data spiderplot
      unset border
      unset tics
      set key noautotitle
      set size ratio 1.0
 描画語にこれらを元の状態に復帰するには、`reset` を使用してください。

3 描画スタイル設定 (style)
?set style
?show style
?unset style
 デフォルトの描画スタイルは、`set style data` と `set style function`
 で設定できます。関数やデータのデフォルトの描画スタイルを個々に変更す
 る方法については、以下参照: `plot with`。スタイルの一覧全体は、以下
 参照: `plotting styles`, `plot with`。

 書式:
       set style function <style>
       set style data <style>
       show style function
       show style data

 指定できる描画要素のデフォルトスタイルも設定できます。

 書式:
       set style arrow <n> <arrowstyle>
       set style boxplot <boxplot style options>
       set style circle radius <size> {clip|noclip}
       set style ellipse size <size> units {xy|xx|yy} {clip|noclip}
       set style fill <fillstyle>
       set style histogram <histogram style options>
       set style line <n> <linestyle>
       set style rectangle <object options> <linestyle> <fillstyle>
       set style textbox {<n>} {opaque|transparent} {{no}border} {fillcolor}
       set style watchpoint labels <label options>

4 矢印スタイル設定 (set style arrow)
?commands set style arrow
?commands unset style arrow
?commands show style arrow
?set style arrow
?unset style arrow
?show style arrow
?arrowstyle
 矢印 (arrow) のスタイルの集合は `set style arrow` を使って定義すること
 ができます。各スタイルは、それ自身の幅、点種、色などを持ち、そのためそ
 れらを後で使うときにいちいち同じ情報を繰り返して指定しなくても、それを
 番号 <index> で参照できます。

 書式:
       set style arrow <index> default
       set style arrow <index> {nohead | head | backhead | heads}
                               {size <length>,<angle>{,<backangle>} {fixed}}
                               {filled | empty | nofilled | noborder}
                               {front | back}
                               { {linestyle | ls <line_style>}
                                 | {linetype | lt <line_type>}
                                   {linewidth | lw <line_width}
                                   {linecolor | lc <colorspec>}
                                   {dashtype | dt <dashtype>} }
       unset style arrow
       show style arrow

 <index> は整数で、それで矢のスタイル (arrowstyle) を特定します。

 `default` を指定すると、全ての arrow スタイルパラメータはそのデフォル
 トの値になります。

 <index> の arrowstyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 コマンド `plot` または `splot` から呼び出した arrow スタイルには、デー
 タ毎可変な線色 (`lc variable` や `lc rgb variable`) を入れることもでき、
 それはそれに対応する `using` 指定によるデータの追加列が必要となります。
 この場合、`set arrow` で作成する個別の arrow に対しては、そのスタイル
 は多分有益なものではありません。

 `nohead` を指定することで、矢先のない矢、すなわち線分を書くこともでき
 ます。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1
 つの矢先がついています。`heads` の指定で線分の両端に矢先が描かれます。

 矢先の大きさは `size <length>,<angle>` または
 `size <length>,<angle>,<backangle>` で変更できます。`<length>` は矢先
 の各枝の長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
 `<length>` の単位は x 軸と同じですが、それは `<length>` の前に `first`,
 `second`, `graph`, `screen`, `character` をつけることで変更できます。
 詳細は、以下参照: `coordinates`。

 デフォルトでは、とても短い矢の矢先は小さくしますが、これは、`size` コ
 マンドの後ろに `fixed` を使うことで無効にできます。

 `<backangle>` は、矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方
 向、単位は度) になりますが、スタイルが `nofilled` の場合はこれを無視し
 ます。

 `filled` を指定すると、矢先の回りの線 (境界線) を描き、矢先を塗りつぶ
 します。`noborder` を指定すると、矢先は塗りつぶしますが、境界線は描き
 ません。この場合、矢先の先端がベクトルの終点ピッタリの場所に置かれ、そ
 の矢先は全体として少し小さくなります。点線で矢を描く場合は、点線の境界
 線は汚いので、常に `noborder` を使うべきです。矢先の塗りつぶしは、すべ
 ての出力形式がサポートしているとは限りません。

 線種はユーザの定義したラインスタイルのリストから選ぶこともできますし
 (以下参照: `set style line`)、用意されている `<line_type>` の値 (デフ
 ォルトのラインスタイルのリストの番号) そして `<linewidth>` (デフォルト
 の幅の倍数) を使ってここで定義することもできます。

 しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
 幅) は、単に他の `set style arrow` コマンドで適当な番号や `lt`, `lw`
 などを指定しても、変更はできないことに注意して下さい。

 `front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指
 定された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`
 を使えば、密集したデータで矢が見えなくなることを防ぐことができます。

 例:

 矢先がなく、倍の幅が矢を描くには:
       set style arrow 1 nohead lw 2
       set arrow arrowstyle 1

 その他の例については、以下参照: `set arrow`。

4 boxplot スタイル指定 (boxplot)
?commands set style boxplot
?commands unset style boxplot
?commands show style boxplot
?set style boxplot
?unset style boxplot
?show style boxplot
 コマンド `set style boxplot` により、描画スタイル `boxplot` で生成する
 描画のレイアウトを変更できます。

 書式:
       set style boxplot {range <r> | fraction <f>}
                         {{no}outliers} {pointtype <p>}
                         {candlesticks | financebars}
                         {medianlinewidth <width>}
                         {separation <x>}
                         {labels off | auto | x | x2}
                         {sorted | unsorted}

 boxplot の箱は、常にデータ点の第一四分位から第三四分位の値の範囲にかか
 っています。箱から延長される箱ひげの限界は、2 つの異なる方法で制御でき
 ます。デフォルトでは、箱ひげは、その箱のそれぞれの端から、四分位範囲の
 1.5 倍 (すなわち、その箱の厳密な垂直方向の高さ) に等しい範囲にまで延長
 されます。箱ひげそれぞれは、データ集合のある点に属する y の値で終了す
 るように、メジアンに向かって切り捨てられます。四分位範囲の丁度 1.5 倍
 の値の点がない場合もありますから、箱ひげはその名目上の範囲よりも短くな
 る場合もあります。このデフォルトは以下に対応します。
       set style boxplot range 1.5

 もう一つの方法として、箱ひげがかかる点の総数の割合 (fraction) を指定す
 ることができます。この場合、その範囲はメジアン値から、データ集合の指定
 した分を囲い込むまで、対称に延長されます。このときも、個々の箱ひげはデ
 ータ集合内の点の端までに制限されます。データ集合の 95% の点をはるには
 以下のようにします。
       set style boxplot fraction 0.95

 箱ひげの範囲の外にある任意の点は、outliers (孤立した標本値) と見なされ
 ます。デフォルトではそれらをひとつひとつ円 (pointtype 7) で描きますが、
 オプション `nooutliers` はこれを無効にします。
 描画されない outliers は、autoscaling には影響を与えません。

 デフォルトでは boxplot は candlesticks と似たスタイルで描画しますが、
 financebars と似たスタイルで描画するためのオプションもあります。

 箱の境界と同じ線種を使って、メジアンを示す横断線を描きますが、そのメジ
 アン線をより太くしたければ、以下のようにできます。
       set style boxplot medianlinewidth 2.0
 メジアン線が必要なければ、それを 0 にセットしてください。

 boxplot の using 指定が 4 列目を持つ場合、その列の値はある因子変数の離
 散的なレベル値であると見なします。この場合、その因子変数のレベルの数と
 同じだけの複数の boxplot が描かれます。それらの boxplot の隣り合うもの
 同士の距離はデフォルトでは 1.0 (x 軸の単位で) ですが、この間隔はオプシ
 ョン `separation` で変更できます。

 オプション `labels` は、これらの boxplot (それぞれデータ集合のある部分
 に対応する) のどこに、どのようにラベルをつけるかを決定します。デフォル
 トでは因子の値を水平軸 (x か x2 のいずれか plot で使われている方) の目
 盛ラベルに出力します。これはオプションの `labels auto` に対応します。
 オプション `labels x`, `labels x2` によって、強制的に x 軸、x2 軸にそ
 れぞれ出力させることもできますし、`labels off` でオフにすることもでき
 ます。

 デフォルトでは、因子変数の異なるレベルに対応する boxplot は整列化はせ
 ず、データファイルにそのレベルが現れる順番に描画します。この挙動はオプ
 ションの `unsorted` に対応しますが、オプション `sorted` を使用すると、
 まずレベルを辞書順にソートし、その順に boxplot を描画します。

 オプション `separation`, `labels`, `sorted`, `unsorted` は、plot に 4
 列目の指定を与えた場合のみ効力を持ちます。

 以下参照: `boxplot`, `candlesticks`, `financebars`。

4 データ描画スタイル指定 (set style data)
?commands set style data
?commands show style data
?set style data
?show style data
?data style
 コマンド `set style data` はデータ描画に対するデフォルトの描画スタイル
 を変更します。

 書式:
       set style data <plotting-style>
       show style data

 選択項目については、以下参照: `plotting styles`。`show style data` は
 現在のデフォルトのデータ描画スタイルを表示します。
4 塗り潰しスタイル指定 (set style fill)
?commands set style fill
?commands show style fill
?set style fill
?show style fill
?fillstyle
 コマンド `set style fill` は、boxes, histograms, candlesticks,
 filledcurves での描画における描画要素のデフォルトのスタイルの設定に使
 われます。このデフォルトは、個々の描画に塗り潰しスタイル (fillstyle)
 を指定することで上書きできます。
 `set obj` で生成する長方形 (rectangle) の塗り潰しスタイルには、別のデ
 フォルトがあることに注意してください。 以下参照: `set style rectangle`。

 書式:
       set style fill {empty
                       | {transparent} solid {<density>}
                       | {transparent} pattern {<n>}}
                      {border {lt} {lc <colorspec>} | noborder}

 デフォルトの塗りつぶしスタイル (fillstyle) は `empty` です。

 オプション `solid` は、出力形式がサポートしている場合、その色での単色
 塗りを行います。パラメータ <density> は塗りつぶし色の強さを表していて
 <density> が 0.0 なら箱は空、<density> が 1.0 なら箱はその内部は現在の
 線種と完全に同じ色で塗られます。出力形式によっては、この強さを連続的に
 変化させられるものもありますが、その他のものは、部分的な塗りつぶしの幾
 つかのレベルを実装しているに過ぎません。パラメータ <density> が与えら
 れなかった場合はデフォルトの 1 になります。

 オプション `pattern` は、出力ドライバによって与えられるパターンでの塗
 りつぶしを行います。利用できる塗りつぶしパターンの種類と数は出力ドライ
 バに依存します。塗りつぶしの boxes スタイルで複数のデータ集合を描画す
 る場合そのパターンは、複数の曲線の描画における線種の周期と同様、有効な
 パターンを、パターン <n> から始めて周期的に利用します。

 オプション `empty` は、箱を塗りつぶしませんが、これがデフォルトです。

?fillcolor
?fc
 塗り潰し色 (`fillcolor <colorspec>`) は、塗り潰しスタイル (fill style)
 から分離されています。すなわち、fillstyle は描画要素やオブジェクトで別
 々の色を持ったまま共有することができます。fillstyle を受けつける大抵の
 場所で fillcolor を指定できます。fillcolor は `fc` の省略形も使えます。
 指定しない場合は、塗り潰し色は現在の線種 (linetype) から取ります。
 例:

       plot FOO with boxes fillstyle solid 1.0 fillcolor "cyan"

5 set style fill border
?commands set style fill border
?set style fill border
?fillstyle border
=border
 キーワード `border` は、塗り潰しオブジェクトを現在の線種と色の実線で囲
 むようにします。その線の色は、linetype や linecolor を追加指定すれば変
 更できます。`noborder` は、境界の線を描かないようにします。
 例:
      # 塗り潰しは強度半分、境界は同じ色で全強度
      set style fill solid 0.5 border
      # 塗り潰しは半分透過、境界は実線の黒 (線種 -1)
      set style fill transparent solid 0.5 border -1
      # 現在の色でのパターン塗り潰し、境界は線種 5 の色で
      plot ... with boxes fillstyle pattern 2 border lt 5
      # 水色 (cyan) での領域の塗り潰し、境界は青
      plot ... with boxes fillcolor "cyan" fs solid border linecolor "blue"

 注意: fill スタイルの border (境界) 属性は、デフォルトモードの closed
 (閉曲線) の `with filledcurves` のグラフにしか影響を与えません。
5 透明化 (set style fill transparent)
?commands set style fill transparent
?set style fill transparent
?fillstyle transparent
?transparent
 いくつかの出力形式は、単色塗り領域の `transparent` (透明化) 属性をサポ
 ートしています。transparent solid の領域塗りつぶしでは、`density`
 (密度) パラメータはアルファ値として使用されます。つまり、密度 0 は完全
 な透明を、密度 1 は完全な不透明を意味します。transparent pattern の塗
 りつぶしでは、パターンの背景が完全な透明か完全な不透明のいずれかです。

 透明な塗りつぶし領域を含むグラフを見たり作ったりするのには、別な制限が
 ありうることに注意してください。例えば、png 出力形式では、"truecolor"
 オプションが指定されている場合にのみ透明化の塗り潰しが利用できます。
 PDF ファイルには透明化領域が正しく記述されていても、PDF の表示ソフトに
 よってはそれを正しく表示できないこともありえます。実際に PostScript プ
 リンタでは問題はないのに、Ghostscript/gv ではパターン塗りつぶし領域を
 正しく表示できません。
4 関数描画スタイル指定 (set style function)
?commands set style function
?commands show style function
?set style function
?show style function
 コマンド `set style function` は関数描画に対するデフォルトの描画スタイ
 ル (lines, points, filledcurves など) を変更します。以下参照:
 `plotting styles`。

 書式:
       set style function <plotting-style>
       show style function
4 ヒストグラムスタイル指定 (set style histogram)
?commands set style histogram
 以下参照: `histograms`。
4 線スタイル順指定 (set style increment)
?commands set style increment
?set style increment
 デフォルトでは、同じグラフ上の次の描画は、次の線種で行われます。
 `set style increment userstyles` はこれを変更し、代わりにユーザ定義ラ
 インスタイル番号に沿って行うようにしていました。

 非推奨: gnuplot が使用する線種の範囲を有用なものに再定義するには、これ
 の代わりに `set linetype` を使用してください。以下参照: `set linetype`。
4 線スタイル指定 (set style line)
?commands set style line
?commands unset style line
?commands show style line
?set style line
?unset style line
?show style line
?linestyle
?linewidth
=linewidth
=interval
=linespoints
=pointinterval
=pointnumber
 出力装置にはおのおのデフォルトの線種と点種の集合があり、それらはコマン
 ド `test` で見ることができます。`set style line` は線種と線幅、点種と
 点の大きさを、個々の呼び出しで、それらの情報を全部指定する代わりに、単
 なる番号で参照できるようにあらかじめ定義するものです。

 書式:
       set style line <index> default
       set style line <index> {{linetype  | lt} <line_type> | <colorspec>}
                              {{linecolor | lc} <colorspec>}
                              {{linewidth | lw} <line_width>}
                              {{pointtype | pt} <point_type>}
                              {{pointsize | ps} <point_size>}
                              {{pointinterval | pi} <interval>}
                              {{pointnumber | pn} <max_symbols>}
                              {{dashtype | dt} <dashtype>}
                              {palette}
       unset style line
       show style line

 `default` は、全てのラインスタイルパラメータをそれと同じ index を持つ
 線種 (linetype) に設定します。

 <index> の linestyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 このようにつくられるラインスタイルは、デフォルトの型 (線種, 点種) を
 別なものに置き換えることはしないので、ラインスタイル、デフォルトの型、
 どちらも使えます。ラインスタイルは一時的なもので、コマンド `reset` を
 実行すればいつでもそれらは消え去ります。線種自体を再定義したい場合は、
 以下参照: `set linetype`。

 線種と点種は、その index 値をデフォルトとします。その index 値に対する
 実際の記号の形は、出力形式によって異なり得ます。

 線幅と点の大きさは、現在の出力形式のデフォルトの幅、大きさに対する乗数
 です (しかし、ここでの <point_size> は、コマンド `set pointsize` で与
 えられる乗数には影響を受けないことに注意してください)。

 `pointinterval` は、スタイル `linespoints` でグラフ中に描かれる点の間
 隔を制御します。デフォルトは 0 です (すべての点が描画される)。例えば、
 `set style line N pi 3` は、点種が N、点の大きさと線幅は現在の出力形式
 のデフォルトで、`with linespoints` での描画では点は 3 番目毎に描画され
 るようなラインスタイルを定義します。その間隔を負の値にすると、それは間
 隔は正の値の場合と同じですが、点の記号の下になる線を書かないようにしま
 す (出力形式によっては)。

 `pointnumber` 属性は、`pointinterval` と似ていますが、N 個おきに描くよ
 うにする代わりに、全体の点の個数を N 個に限定するところが違います。

 全ての出力装置が `linewidth` や `pointsize` をサポートしているわけでは
 ありません。もしサポートされていない場合はそれらのオプションは無視され
 ます。

 出力形式に依存しない色を `linecolor <colorspec>` か `linetype <colorspec>`
 (省略形は `lc`, `lt`) のいずれかを使って割り当てることができます。この
 場合、色は RGB の 3 つ組で与えるか、gnuplot の持つパレットの色名、現在
 のパレットに対する小数指定、または cbrange への現在のパレットの対応に
 対する定数値、のいずれかで与えます。以下参照: `colors`, `colorspec`,
 `set palette`, `colornames`, `cbrange`。

 `set style line <n> linetype <lt>` は、出力形式に依存した点線/破線のパ
 ターンと色の両方をセットします。`set style line <n> linecolor <colorspec>`
 や `set style line <n> linetype <colorspec>` は、現在の点線/破線のパタ
 ーンを変更せずに新しい線色を設定します。

 3 次元モード(`splot` コマンド) では、"linetype palette z" の省略形とし
 て特別にキーワード `palette` を使うことも許されています。その色の値は、
 splot の z 座標 (高さ) に対応し、曲線、あるいは曲面に沿って滑らかに変
 化します。

 例:
 以下では、番号 1, 2, 3 に対するデフォルトの線種をそれぞれ赤、緑、青とし、
 デフォルトの点の形をそれぞれ正方形、十字、三角形であるとします。このとき
 以下のコマンド

       set style line 1 lt 2 lw 2 pt 3 ps 0.5

 は、新しいラインスタイルとして、緑でデフォルトの 2 倍の幅の線、および
 三角形で半分の幅の点を定義します。また、以下のコマンド

       set style function lines
       plot f(x) lt 3, g(x) ls 1

 は、f(x) はデフォルトの青線で、g(x) はユーザの定義した緑の線で描画しま
 す。同様に、コマンド

       set style function linespoints
       plot p(x) lt 1 pt 3, q(x) ls 1

 は、p(x) を赤い線で結ばれたデフォルトの三角形で、q(x) は緑の線で結ばれ
 た小さい三角形で描画します。

       splot sin(sqrt(x*x+y*y))/sqrt(x*x+y*y) w l pal

 は、`palette` に従って滑らかな色を使って曲面を描画します。これはそれを
 サポートした出力形式でしかちゃんとは動作しないことに注意してください。
 以下も参照: `set palette`, `set pm3d`。

       set style line 10 linetype 1 linecolor rgb "cyan"

 は、RGB カラーをサポートするすべての出力形式で、ラインスタイル 10 に実
 線の水色を割り当てます。

4 円スタイル指定 (set style circle)
?commands set style circle
?commands unset style circle
?commands show style circle
?set style circle
?unset style circle
?show style circle

 書式:
       set style circle {radius {graph|screen} <R>}
                        {{no}wedge}
                        {clip|noclip}

 このコマンドは、描画スタイル "with circles" で使われるデフォルトの半径
 を設定します。これは、データ描画で 2 列のデータ (x,y) しか与えなかった
 場合、あるいは関数描画のときに適用されます。デフォルトは、以下のように
 なっています: "set style circle radius graph 0.02"。`nowedge` は、扇形
 の円弧部分から中心に向かう 2 本の半径を描かないようにしますが、デフォ
 ルトは `wedge` です。このパラメータは完全な円に対しては何もしません。
 `clip` は円を描画境界でクリッピングしますが、`noclip` はこれを無効にし
 ます。デフォルトは `clip` です。

4 長方形スタイル指定 (set style rectangle)
?commands set style rectangle
?commands unset style rectangle
?commands show style rectangle
?set style rectangle
?unset style rectangle
?show style rectangle

 コマンド `set object` で定義された長方形には別々のスタイルを設定できま
 す。しかし、個別のスタイル指定をしなければ、そのオブジェクトはコマンド
 `set style rectangle` によるデフォルトを受け継ぎます。

 書式:
     set style rectangle {front|back} {lw|linewidth <lw>}
                         {fillcolor <colorspec>} {fs <fillstyle>}

 以下参照: `colorspec`, `fillstyle`。`fillcolor` は `fc` と省略できます。

 例:
     set style rectangle back fc rgb "white" fs solid 1.0 border lt -1
     set style rectangle fc linsestyle 3 fs pattern 2 noborder

 デフォルトの設定は、背景色での単色塗り (solid fill) で、境界は黒になっ
 ています。

4 楕円スタイル指定 (set style ellipse)
?commands set style ellipse
?commands show style ellipse
?set style ellipse
?unset style ellipse
?show style ellipse

 書式:
       set style ellipse {units xx|xy|yy}
                         {size {graph|screen} <a>, {{graph|screen} <b>}}
                         {angle <angle>}
                         {clip|noclip}

 このコマンドは、楕円の直径を同じ単位で計算するかどうかを制御します。
 デフォルトは `xy` で、これは楕円の主軸 (第 1 軸) の直径は x (または x2)
 軸と同じ単位で計算し、副軸 (第 2 軸) の直径は y (または y2) 軸の単位で
 計算します。このモードでは、楕円の両軸の比は、描画軸のアスペクト比に依
 存します。`xx` か `yy` に設定すれば、すべての楕円の両軸は同じ単位で計
 算されます。これは、描画される楕円の両軸の比は、回転しても正しいままで
 すが、水平方向か垂直方向の一方の縮尺の変更により正しくなくなることを意
 味します。

 これは、object として定義された楕円、コマンド `plot` によって描画され
 る楕円の両方に影響を与える全体的な設定ですが、`units` の値は、描画毎、
 オブジェクト毎に設定を再定義できます。

 楕円のデフォルトのサイズも、キーワード `size` で設定できます。デフォル
 トのサイズは、2 列のみのデータ、または関数の plot 命令で適用されます。
 2 つの値は、楕円の (2 つの主軸、2 つの副軸に向かい合う) 主軸直径と副軸
 直径として使用されます。

 デフォルトは、"set style ellipse size graph 0.05,0.03" です。

 最後になりますが、デフォルトの向きをキーワード `angle` で設定もできま
 す。向きは、楕円の主軸とグラフの x 軸の方向となす角で、単位は度で与え
 る必要があります。

 `clip` は楕円を描画境界でクリッピングしますが、`noclip` はこれを無効に
 します。デフォルトは `clip` です。

 楕円の object の定義に関しては以下も参照: `set object ellipse`。2 次元
 の描画スタイルに関しては以下参照: `ellipses`。
4 平行座標スタイル指定 (set style parallelaxis)
?commands set style parallelaxis
?set style parallelaxis
?show style parallelaxis

 書式:
       set style parallelaxis {front|back} {line-properties}

 これは、`with parallelaxes` グラフの垂直軸を書く際の線種とレイヤーを指
 定します。以下参照: `with parallelaxes`, `set paxis`。
4 クモの巣グラフスタイル指定 (set style spiderplot)
?commands set style spiderplot
?set style spiderplot

 書式:
         set style spiderplot
                   {fillstyle <fillstyle-properties>}
                   {<line-properties> | <point-properties>}
 このコマンドは、クモの巣グラフ (spider plot) のデフォルトの見た目を制
 御します。塗り潰し、線分、点の属性は、plot コマンドの最初の要素で変更
 できます。全体的なグラフの見た目は、`set grid spiderplot` などの他の設
 定の影響も受けます。以下も参照: `set paxis`、`spiderplot`。
 例:
      # デフォルトのクモの巣グラフを太い境界で塗り潰しなしの多角形に
      set style spiderplot fillstyle empty border lw 3
      # 以下は各軸に円 (pt 6) を追加する
      plot for [i=1:6] DATA pointtype 6 pointsize 3

4 文字列ボックススタイル指定 (set style textbox)
?commands set style textbox
?commands show style textbox
?set style textbox
?unset style textbox
?show style textbox
?textbox
?boxed

 書式:
         set style textbox {<boxstyle-index>}
                   {opaque|transparent} {fillcolor <color>}
                   {{no}border {linecolor <colorspec>}}{linewidth <lw>}
                   {margins <xmargin>,<ymargin>}

 このコマンドは、属性 `boxed` による label の表示を制御します。箱付き文
 字列をサポートしない出力形式はこのスタイルを無視します。
 注意: いくつかの出力形式 (svg, latex) での実装は不完全です。
 また、ほとんどの出力形式は、回転した文字列の箱付けが正しくできません。

 番号付きの textbox スタイルを 3 種類定義できます。boxstyle 番号 <bs>
 を指定しないと、デフォルトスタイル (番号なし) を変更します。
 例:

      # デフォルトのスタイルは、黒の境界線のみ
      set style textbox transparent border lc "black"
      # スタイル 2 (bs 2) を明るい青背景で境界なしに
      set style textbox 2 opaque fc "light-cyan" noborder
      set label 1 "I'm in a box" boxed
      set label 2 "I'm blue" boxed bs 2

4 ウォッチポイントスタイル指定 (set style watchpoint)
?commands set style watchpoint
?commands show style watchpoint
?set style watchpoint

 書式:
      set style watchpoint nolabels
      set style watchpoint labels {label-options}

 ウォッチポイントの対象 "mouse" については常にグラフ上にラベルを出力し
 ます。他のウォッチポイント対象には、スタイルが `label` か `nolabel` の
 どちらに設定されているかによってラベルを表示、または非表示とします。

 ウォッチポイントラベルの見た目は、他の gnuplot label のラベル属性にあ
 るような全機能を使ってカスタマイズできます。例えばフォント、文字色や、
 実際の x,y 座標をマークする点の点種、点サイズを設定できます。以下参照:
 `set label`。

 現在は、ラベルの文字列は、現在のグラフに対する軸の見出しに使用する書式
 を使用して、常に文字列 " x-座標 : y-座標" を自動生成します。

 例:
      set style watchpoint labels point pt 4 ps 2
      set style watchpoint labels font ":Italic,6" textcolor "blue"
      set style watchpoint labels boxed offset 1, 0.5

3 曲面描画 (surface)
?commands set surface
?commands unset surface
?commands show surface
?set surface
?unset surface
?show surface
?surface
?nosurface
 コマンド `set surface` は 3 次元描画 (`splot`) にのみ関係します。

 書式:
       set surface {implicit|explicit}
       unset surface
       show surface

 `unset surface` により `splot` は、関数やデータファイルの点に対するど
 んな点や線も描かなくなります。これは主に、等高線を作る曲面を描く代わり
 に等高線のみを描く場合に有用です。その場合でも `set contour` の設定に
 よりますが、曲面上に等高線が描かれます。他のものは通常のままで、ある一
 つの関数やデータファイルの曲面のみをオフにするには、`splot` コマンド上
 でキーワード `nosurface` を指定してください。等高線を格子の土台に表示
 したい場合は `unset surface; set contour base` という組が便利でしょう。
 以下も参照: `set contour`。

 3 次元データの組が網目 (格子線) と認識されると、gnuplot はデフォルトで
 は格子曲面を要求しているものとして、暗黙に `with lines` の描画スタイル
 を用います。以下参照: `grid_data`。コマンド `set surface explicit` は
 この機能を抑制し、入力ファイルのデータの分離されたブロックで記述される
 孤立線のみを描画します。この場合でも、splot で明示的に `with surface`
 とすれば格子曲面が描画されます。
3 テーブルデータ出力 (table)
?commands set table
?set table
?table
 `table` モードが有効な場合、`plot` と `splot` コマンドは、現在の出力形
 式に対する実際の描画を生成する代わりに
      X Y {Z} <flag>
 の値の複数列からなる表形式のテキスト出力を行ないます。フラグ文字 <frag>
 は、その点が有効な範囲内にある場合は "i"、範囲外の場合は "o"、未定義値
 (undefined) の場合は "u" です。データの書式は、軸の刻みの書式 (以下
 参照: `set format`) によって決まり、列は一つの空白で区切られます。これ
 は、等高線を生成し、それを再利用のために保存したいときに便利です。この
 方法は、補間されたデータを保存するのにも使うことができます (以下参照:
 `set samples`, `set dgrid3d`)。

 書式:
       set table {"outfile" | $datablock} {append}
                 {separator {whitespace|tab|comma|"<char>"}}
       plot <whatever>
       unset table

 この後の表形式の出力は、ファイル "outfile" を指定していればそれに書き
 出しますが、そうでなければ標準出力か、現在の `set output` が指定するも
 のに出力します。`outfile` が既に存在する場合は、`append` キーワードを
 指定すれば追加出力、指定しなければこの出力が上書きします。他に、表形式
 出力を名前付きデータブロックにリダイレクトすることもできます。データブ
 ロック名は '$' で始まります。以下も参照: `inline data`。現在の出力形式
 の標準的な描画に戻すには、`unset table` を明示的に行なう必要があります。

 `separator` 文字は、CSV ファイル (コンマ区切り) の出力に使えます。その
 モードは、描画スタイル `with table` にのみ影響を与えます。以下参照:
 `plot with table`。

4 plot with table
?plot with table
?with table
 以下の説明は、特別な描画スタイル `with table` にのみ適用されます。

 表データに変換される入力データに対する描画スタイルに依存する処理 (平滑
 化、誤差線の延長、2 軸範囲のチェック等) を避けるため、あるいは表データ
 に変換できる列の数を増やすには、通常の描画スタイルの代わりに "table"
 キーワードを使ってください。この場合、範囲内/範囲外/未定義を意味するフ
 ラグ `i`, `o`, `u` を含む追加列は、出力にはつきません。その出力先は、
 最初に `set table <where>` で指定する必要があります。例:

      set table $DATABLOCK1
      plot <file> using 1:2:3:4:($5+$6):(func($7)):8:9:10 with table

 この場合、実際の描画スタイルがない状態なので、各列には特定の軸は対応し
 ないことになり、よって xrange, yrange 等の設定は無視されます。

 文字列に対して `using` で評価した場合は、文字列も表データ化されます。
 数値データは常に %g の書式で書き出されますが、他の書式を使いたい場合は、
 そのように書式化された文字列を生成するように sprintf か gprintf を使用
 してください。

      plot <file> using ("File 1"):1:2:3 with table
      plot <file> using (sprintf("%4.2f",$1)) : (sprintf("%4.2f",$3)) with table

=csv
 CSV ファイルを生成するには、以下のようにします。
      set table "tab.csv" separator comma
      plot <foo> using 1:2:3:4 with table

 [試験段階の機能] 表データ化のためにデータ点の部分集合のみを選択するには
 入力フィルタ条件 (`if <expression>`) をコマンドの最後に指定することがで
 きます。その入力フィルタは、出力はされないデータ列も参照できることに注
 意してください。この機能は、gnuplot のリリース版が現れる前に大幅に変更
 される可能性があります。

      plot <file> using 1:2:($4+$5) with table if (strcol(3) eq "Red")
      plot <file> using 1:2:($4+$5) with table if (10. < $1 && $1 < 100.)
      plot <file> using 1:2:($4+$5) with table if (filter($6,$7) != 0)
3 出力形式 (terminal)
?commands set terminal
?commands show terminal
?set terminal
?set term
?show terminal
?show term
?set terminal push
?set term push
?terminal push
?term push
?push
?set terminal pop
?set term pop
?terminal pop
?term pop
?pop
 `gnuplot` は数多くのグラフィック形式をサポートしています。コマンド
 `set terminal` を使って `gnuplot` の出力の対象となる形式の種類を選んで
 ください。出力先をファイル、または出力装置にリダイレクトするには
 `set output` を使ってください。

 書式:
       set terminal {<terminal-type> | push | pop}
       show terminal

 <terminal-type> が省略されると `gnuplot` は利用可能な出力形式の一覧を
 表示します。<terminal-type> の指定には短縮形が使えます。

 `set terminal` と `set output` の両方を使う場合、`set terminal` を最初
 にする方が安全です。それは、OS によっては、それが必要とするフラグをセ
 ットする出力形式があるからです。

 いくつかの出力形式はたくさんの追加オプションを持ちます。
 各 `<term>` に対し、直前の `set term <term> <options>` で使用されたオ
 プションは記憶され、その後の `set term <term>` がそれをリセットするこ
 とはありません。これは例えば印刷時に有用です。幾つかの異なる出力形式を
 切替える場合、前のオプションを繰り返し唱える必要はありません。

 コマンド `set term push` は、現在の出力形式とその設定を `set term pop`
 によって復帰するまで記憶しています。これは `save term`, `load term` と
 ほぼ同等ですが、ファイルシステムへのアクセスは行わず、よって例えばこれ
 は、印刷後にプラットホームに依存しない形で出力形式を復帰する目的に使え
 ます。gnuplot の起動後、デフォルト、または `startup` ファイルに書かれ
 た出力形式が自動的に記憶 (push) されます。よって、明示的に出力形式を記
 憶させることなく、任意のプラットホーム上でデフォルトの出力形式を
 `set term pop` によって復帰させる、という動作を期待したスクリプトを可
 搬性を失わずに書くことが出来ます。

 詳細は、以下参照: `complete list of terminals`。

3 出力形式へのオプション (termoption)
?commands set termoption
?set termoption
?termoption
 コマンド `set termoption` は、現在使用している出力形式の振舞いを、新た
 な `set terminal` コマンドの発行なしに変更することを可能にします。この
 コマンド一つに対して一つのオプションのみが変更できます。そしてこの方法
 で変更できるオプションはそう多くはありません。現在使用可能なオプション
 は以下のもののみです。

      set termoption {no}enhanced
      set termoption font "<fontname>{,<fontsize>}"
      set termoption fontscale <scale>
      set termoption {linewidth <lw>}{lw <lw>} {dashlength <dl>}{dl <dl>}
      set termoption {pointscale <scale>} {ps <scale>}

3 極座標方位制御 (theta)
?commands set theta
?set theta
?unset theta
?theta
 極座標グラフは、デフォルトでは角の 0 の方向 (θ = 0) がグラフの右側を
 指すよう向きづけられ、角の増加は反時計回りに行われ、θ = 90 が真上を向
 くようになっています。`set theta` により、極座標の角の座標に関する 0
 の向きと増加方向を変更できます。
      set theta {right|top|left|bottom}
      set theta {clockwise|cw|counterclockwise|ccw}
 `unset theta` は、デフォルトの状態 "set theta right ccw" に復帰します。
3 全軸目盛り制御 (tics)
?commands set tics
?commands unset tics
?commands show tics
?set tics scale
?set tics
?unset tics
?show tics
?tics
 コマンド `set tics` は、全ての軸の目盛りの刻みとラベルを一度に制御しま
 す。

 目盛りは `unset tics` で消え、`set tics` で目盛りがつきます (デフォル
 ト)。個々の軸の目盛りは、これとは別のコマンド `set xtics`, `set ztics`
 などを使って制御できます。

 書式:
       set tics {axis | border} {{no}mirror}
                {in | out} {front | back}
                {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                {left | right | center | autojustify}
                {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                { textcolor <colorspec> }
       set tics scale {default | <major> {,<minor>}}
       unset tics
       show tics

 オプションは、個々の軸 (x, y, z, x2, y2, cb) にも適用できます。例:
       set xtics rotate by -90
       unset cbtics

 軸の刻みの線属性は、すべてグラフの境界 (以下参照: `set border`) と同じ
 ものを使って描かれます。

 tics の `back` または `front` の設定は、2D 描画 (splot は不可) にのみ
 すべての軸に 1 度適用されます。これは、目盛りと描画要素が重なった場合
 に目盛りを描画要素の前面に出すか、奥に置くかを制御します。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると境界が表示されていれば (以下参照:
 `set border`) 目盛りの見出し文字を境界の外に出してしまうでしょう。この
 場合自動的なレイアウトアルゴリズムによる余白設定は大抵よくないものとな
 ってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 `set tics scale` は、目盛りの刻みの大きさを制御します。最初の <major>
 の値には、自動的に生成され、またユーザも指定できる大目盛り (レベル 0)
 を指定し、2 つ目の <minor> の値には、自動的に生成され、またユーザも指
 定できる小目盛り (レベル 1) を指定します。<major> のデフォルトは 1.0
 で、<minor> のデフォルトは <major>/2 です。さらに値を追加すれば、レベ
 ル 2, 3, ... の目盛りの大きさになります。`set tics scale default` でデ
 フォルトの目盛りの大きさに復帰します。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸のデフォルトは
 `nomirror` です。

 <offset> は x,y かまたは x,y,z の形式ですが、それに座標系を選択して、
 その前に `first`, `second`, `graph`, `screen`, `character` のいずれか
 をつけることもできます。<offset> は、目盛りの見出し文字列のデフォルト
 の位置からのずらし位置で、そのデフォルトの単位系は `character` です。
 詳細は、以下参照: `coordinates`。`nooffset` は offset を OFF にします。

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に揃えられますが、気にいらなければ、明示的に `left`,
 `right`, `center` のキーワードにより位置揃えを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしの `set tics` は、第 1 軸に対する鏡映 (mirror) と内側向
 き目盛りの刻みをデフォルトの挙動に復帰しますが、その他の全てのオプショ
 ンは、直前の値を保持します。

 大目盛り (ラベルのつく) の他の制御に関しては、以下参照: `set xtics`。
 小目盛りの制御に関しては、以下参照: `set mxtics`。これらのコマンドは、
 各軸の独立な制御を提供します。
3 ticslevel
?commands set ticslevel
?commands show ticslevel
?set ticslevel
?show ticslevel
?ticslevel
 現在は推奨されていません。以下参照: `set xyplane`。
3 ticscale
?commands set ticscale
?commands show ticscale
?set ticscale
?show ticscale
?ticscale
 コマンド `set ticscale` は現在は推奨されていません。代わりに
 `set tics scale` を使ってください。
3 タイムスタンプ (timestamp)
?commands set timestamp
?commands unset timestamp
?commands show timestamp
?set timestamp
?unset timestamp
?show timestamp
?timestamp
?notimestamp
 コマンド `set timestamp` は現在の時刻と日付をグラフの余白に表示します。

 書式:
       set timestamp {"<format>"} {top|bottom} {{no}rotate}
                     {offset <xoff>{,<yoff>}} {font "<fontspec>"}
                     {textcolor <colorspec>}
       unset timestamp
       show timestamp

 書式文字列 (format) は、書かれる日付と時刻の書式に使用されます。デフォ
 ルトは asctime() が使用する "%a %b %d %H:%M:%S %Y" です (曜日、月名、
 日、時、分、秒、4 桁の西暦)。`top` と `bottom` を使って、日付の配置を
 左上、左下のいずれの余白にするかを選択できます (デフォルトは左下)。
 `rotate` は、日付を垂直方向に書き出します。定数 <xoff>、<yoff> はずれ
 (offset) を意味し、これによってより適切な位置決めが行えます。<font> は
 日付が書かれるフォントを指定します。

 例:
       set timestamp "%d/%m/%y %H:%M" offset 80,-2 font "Helvetica"

 日付の書式文字列に関する詳しい情報については、以下参照: `set timefmt`。
3 日時データ入力書式 (timefmt)
?commands set timefmt
?commands show timefmt
?set timefmt
?show timefmt
?timefmt
 このコマンドは、日時データの入力で使用するデフォルトの書式を設定します。
 以下参照: `set xdata time`, `timecolumn`。

 書式:
       set timefmt "<format string>"
       show timefmt

 `timefmt` と `timecolumn` の両方で有効な書式は以下の通りです:

@start table - まずは対話型テキスト形式
       書式         説明
       %d           何日, 1--31
       %m           何月, 1--12
       %y           何年, 0--99
       %Y           何年, 4-digit
       %j           1 年の何日目, 1--365
       %H           何時, 0--24
       %M           何分, 0--60
       %s           Unix epoch (1970-01-01, 00:00 UTC) からの秒数
       %S           何秒 (出力では 0--60 の整数、入力では実数)
       %b           月名 (英語) の 3 文字省略形
       %B           月名 (英語)
       %p           2 文字の am AM pm PM のいずれか
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{時系列データ書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%d@ & 何日, 1--31 \\
#\verb@%m@ & 何月, 1--12 \\
#\verb@%y@ & 何年, 0--99 \\
#\verb@%Y@ & 何年, 4 桁 \\
#\verb@%j@ & 1 年の何日目, 1--365 \\
#\verb@%H@ & 何時, 0--24 \\
#\verb@%M@ & 何分, 0--60 \\
#\verb@%s@ & Unix epoch (1970-01-01, 00:00 UTC) からの秒数\\
#\verb@%S@ & 何秒 (出力では 0--60 の整数、入力では実数)\\
#\verb@%b@ & 月名 (英語) の 3 文字省略形 \\
#\verb@%B@ & 月名 (英語) \\
#\verb@%p@ & 2 文字の am AM pm PM のいずれか \\
%c l .
%書式@説明
%_
%%d@何日, 1--31
%%m@何月, 1--12
%%y@何年, 0--99
%%Y@何年, 4 桁
%%j@1 年の何日目, 1--365
%%H@何時, 0--24
%%M@何分, 0--60
%%s@Unix epoch (1970-01-01, 00:00 UTC) からの秒数
%%S@何秒 (出力では 0--60 の整数、入力では実数)
%%b@月名 (英語) の 3 文字省略形
%%B@月名 (英語)
%%p@2 文字の am AM pm PM のいずれか
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%d</tt></td>    <td>何日, 1&ndash;31</td></tr>
^<tr>    <td><tt>%m</tt></td>    <td>何月, 1&ndash;12</td></tr>
^<tr>    <td><tt>%y</tt></td>    <td>何年, 0&ndash;99</td></tr>
^<tr>    <td><tt>%Y</tt></td>    <td>何年, 4-digit</td></tr>
^<tr>    <td><tt>%j</tt></td>    <td>1 年の何日目, 1&ndash;365</td></tr>
^<tr>    <td><tt>%H</tt></td>    <td>何時, 0&ndash;24</td></tr>
^<tr>    <td><tt>%M</tt></td>    <td>何分, 0&ndash;60</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>Unix epoch (1970-01-01 00:00 UTC) からの秒数</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>何秒 (出力では 0&ndash;60 の整数、入力では実数)</td></tr>
^<tr>    <td><tt>%b</tt></td>    <td>月名 (英語) の 3 文字省略形</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>月名 (英語)</td></tr>
^<tr>    <td><tt>%p</tt></td>    <td>2 文字の am AM pm PM のいずれか</td></tr>
^</tbody>
^</table>

 任意の文字を文字列中で使用できますが、規則に従っている必要があります。
 \t (タブ) は認識されます。バックスラッシュ + 8 進数列 (\nnn) はそれが
 示す文字に変換されます。日時要素の中に分離文字がない場合、%d, %m, %y,
 %H, %M, %S はそれぞれ 2 桁の数字を読み込みます。%S での読み込みで小数
 点がそのフィールドについている場合は、その小数点つきの数を小数の秒指定
 だと解釈します。%Y は 4 桁、%j は 3 桁の数字を読み込みます。%b は 3 文
 字を、%B は必要な分だけの文字を要求します。

 空白 (スペース) の扱いはやや違います。書式文字列中の 1 つの空白は、フ
 ァイル中の 0 個、あるいは 1 つ以上の空白文字列を表します。すなわち、
 "%H %M" は "1220" や "12     20" を "12 20" と同じように読みます。

 データ中の非空白文字の集まりそれぞれは、`using n:n` 指定の一つ一つの列
 とカウントされます。よって `11:11  25/12/76  21.0` は 3 列のデータと認
 識されます。混乱を避けるために、日時データが含まれる場合 `gnuplot` は、
 あなたの `using` 指定が完璧なものであると仮定します。

 日付データが曜日、月の名前を含んでいる場合、書式文字列でそれを排除しな
 ければいけませんが、"%a", "%A", "%b", "%B" でそれらを表示することはで
 きます。`gnuplot` は数値から月や曜日を正しく求めます。これら、及び日時
 データの出力の他のオプションの詳細に関しては、以下参照: `set format`。

 2 桁の西暦を %y で読む場合、69-99 は 2000 年未満、00-68 は 2000 年以後
 と見なします。注意: これは、UNIX98 の仕様に合わせたものですが、この慣
 例はあちこちで違いがあるので、2 桁の西暦値は本質的にあいまいです。

 書式 %p が "am" か "AM" を返す場合、12 時は 0 時と解釈します。
 書式 %p が "pm" か "PM" を返す場合、12 未満の時刻には 12 追加します。

 他の情報については、以下も参照: `set xdata`, `time/date`,
 `time_specifiers`。

 例:
       set timefmt "%d/%m/%Y\t%H:%M"
 は、`gnuplot` に日付と時間がタブで分離していることを教えます (ただし、
 あなたのデータをよーく見てください。タブだったものがどこかで複数のスペ
 ースに変換されていませんか ? 書式文字列はファイル中に実際にある物と一
 致していなければなりません)。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/timedat.html">
 時系列データ (time data) デモ。
^ </a>
3 グラフタイトル (title)
?commands set title
?commands show title
?set title
?show title
?title
 コマンド `set title` は、描画の上の真中に書かれる描画タイトルを生成し
 ます。`set title` は `set label` の特殊なもの、とみなせます。

 書式:
       set title {"<title-text>"} {offset <offset>} {font "<font>{,<size>}"}
                 {{textcolor | tc} {<colorspec> | default}} {{no}enhanced}
       show title

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、タイトルは与え
 られた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set title offset 0,-1`" はタイトルの y 方向
 の位置のみ変更し、大ざっぱに言って 1 文字分の高さだけタイトルを下に下
 げます。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> はタイトルが書かれるフォントを指定するのに使われます。<size> の
 単位は、どの出力形式 (terminal) を使っているかによって変わります。

 `textcolor <colorspec>` は、文字の色を変更します。<colorspec> は、線
 種、rgb 色、またはパレットへの割当のいずれかが指定できます。以下参照:
 `colorspec`, `palette`。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、タイトルを拡張文字列処理させないようにします。

 `set title` をパラメータなしで使うとタイトルを消去します。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いについては、以下参照: `syntax`。
3 tmargin
?commands set tmargin
?set tmargin
?tmargin
 コマンド `set tmargin` は上の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 trange
?commands set trange
?commands show trange
?set trange
?show trange
?trange
 書式:    set trange [tmin:tmax]
 媒介変数 t の範囲は、以下の 3 つの状況で有効です。
#start
#b 媒介変数モードでは、これがコマンド `plot` の両方の生成関数の標本範囲
## を制限します。以下参照: `set parametric`, `set samples`。
#b 極座標モードでは、これがコマンド `plot` の偏角変数θの入力中の許容可
## 能な範囲を制限、または定義します。この範囲外のθを持つデータ点は、そ
## れが描画境界の内側に入っていたとしても、グラフからは除外されます。
## 以下参照: `polar`。
#b `plot` または `splot` コマンドでは、疑似ファイル "+" による 1 次元デ
## ータの標本化に使用します。
## 以下参照: `sampling 1D`, `special-filenames`。
#end
3 ttics
?commands set ttics
?commands show ttics
?set ttics
?show ttics
?ttics
 コマンド `set ttics` は、極座標グラフの周囲に目盛り刻みをつけます。そ
 れは、`set border polar` とした場合は境界になりますが、そうでなければ
 極座標格子の、r 軸に沿って最も右端の刻みの場所に書かれる最も外側の円周
 になります。以下参照: `set grid`, `set rtics`。角の位置は、常に度の単
 位でラベル付けされます。現在の角の範囲の設定 (trange) に関係なく、同心
 円全体に刻みラベルをつけることができます。刻みラベルが必要な範囲の設定
 は、下に示す例のようにしてください。刻みに関する追加属性を設定すること
 もできます。以下参照: `xtics`。

      set ttics -180, 30, 180
      set ttics add ("Theta = 0" 0)
      set ttics font ":Italic" rotate
D ttics 3
3 urange
?commands set urange
?commands show urange
?set urange
?show urange
?urange
 書式:     set urange [umin:umax]
 媒介変数 u と v の範囲は、以下の 2 つの状況で有効です。
 1) 媒介変数モードの `splot`。以下参照: `set parametric`,
    `set isosamples`。
 2) `plot` または `splot` コマンドでは、疑似ファイル "++" による 2 次元
    標本化データの生成に使用します。以下参照: `sampling 2D`。
3 version
?show version
?show version long
 コマンド `show version` は現在起動している gnuplot のバージョン、最終
 修正日、著作権者と、FAQ や info-gnuplot メーリングリスト、バグレポート
 先のメールアドレスを表示します。対話的にプログラムが呼ばれているときは
 スクリーン上にその情報を表示します。

 書式:
       show version {long}

 show version `long` では、その `gnuplot` がコンパイルされたときに使わ
 れたオペレーティングシステム、設定、コンパイルオプションなども表示しま
 す。
3 vgrid
?commands set vgrid
?set vgrid
?unset vgrid
?show vgrid
?vgrid
 書式:
      set vgrid $gridname {size N}
      unset vgrid $gridname
      show vgrid

 指定した名前付き格子 $gridname が既に存在していれば、こえはそれを有効
 にし、これに続く `vfill` と `voxel` の操作で使えるようにします。サイズ
 を新たに指定した場合、存在するデータを 0 で埋めた N x N x N 格子に置き
 換えます。その名前の格子がまだない場合は、N x N x N 格子 (デフォルトは
 N=100) の領域をメモリに割り当て、その中身を 0 にし、有効にします。格子
 名は、'$' から始めなければいけないことに注意してください。

 `show vgrid` は、現在定義済みのボクセル格子すべての一覧を表示します。
 出力例:
       $vgrid1: (active)
                size 100 X 100 X 100
                vxrange [-4:4]  vyrange[-4:4]  vzrange[-4:4]
                non-zero voxel values:  min 0.061237 max 94.5604
                number of zero voxels:  992070   (99.21%)

 `unset vgrid $gridname` は、そのボクセル格子に関係するすべてのデータ領
 域をメモリから開放します。そのデータ領域は、`reset session` でも開放さ
 れます。
 関数 `voxel(x,y,z)` は、その座標に一番近い有効な格子点の値を返します。
 以下も参照: `splot voxel-grids`。

3 視線方向 (view)
?commands set view
?commands show view
?set view
?set view map
?show view
?view
 コマンド `set view` は `splot` の視線の角度を設定します。これは、グラ
 フ描画の 3 次元座標をどのように 2 次元の画面 (screen) に投影するかを制
 御します。これは、描画されたデータの回転と縮尺の制御を与えてくれますが
 正射影しかサポートしていません。3 次元射影、および 2 次元描画的地図上
 への 2 次元直交射影がサポートされています。

 書式:
       set view <rot_x>{,{<rot_z>}{,{<scale>}{,<scale_z>}}}
       set view map {scale <scale>}
       set view projection {xy|xz|yz}
       set view {no}equal {xy|xyz}
       set view azimuth <angle>
       show view

 ここで <rot_x> と <rot_z> は、画面に投影される仮想的な 3 次元座標系の
 回転角 (単位は度) の制御で、最初は (すなわち回転が行なわれる前は)
 画面内の水平軸は x, 画面内の垂直軸は y, 画面自身に垂直な軸が z となっ
 ています。最初は x 軸の周りに <rot_x> だけ回転されます。次に、新しい
 z 軸の周りに <rot_z> だけ回転されます。

 コマンド `set view map` は、グラフを地図のように表示するのに使います。
 これは等高線 (`contour`) のグラフや、pm3d モードによる 2 次元温度分布
 (heatmap) などで `with image` よりもむしろ有用です。後者では、入力デー
 タ点のフィルタ用の `zrange` の設定、および色の範囲の縮尺に関する
 `cbrange` の設定を適切に行うことに注意してください。

 <rot_x> は [0:180] の範囲に制限されていて、デフォルトでは 60 度です。
 <rot_z> は [0:360] の範囲に制限されていて、デフォルトでは 30 度です。
 <scale> は `splot` 全体の伸縮率を制御し、<scale_z> は z 軸の伸縮のみを
 行ないます。伸縮率のデフォルトはどちらも 1.0 です。

 例:
       set view 60, 30, 1, 1
       set view ,,0.5

 最初の例は 4 つの全てをデフォルトの値にしています。2 つめの例は縮小率
 のみを 0.5 に変更しています。
4 azimuth
?set view azimuth
?view azimuth
?azimuth
       set view azimuth <angle-in-degrees>
 azimuth の設定は、3 次元グラフ (splot) の z 軸の向きに影響します。デフ
 ォルトは azimuth = 0 で、グラフの z 軸はスクリーンの水平方向に対して垂
 直な平面に含まる、すなわち、z 軸の 2 次元射影がスクリーンの鉛直方向に
 なります。0 でない azimuth は視界を原点に関して回転し、z 軸の射影は鉛
 直方向ではなくなります。azimuth = 90 では z 軸は鉛直方向ではなく、水平
 方向になります。
 対話型の表示の際、ホットキー `z` は azimuth を 0 にリセットします。
4 equal_axes
?set view equal_axes
?set view equal xyz
?set view equal
?view equal_axes
?view equal xyz
?equal_axes
?equal xyz
 コマンド `set view equal xy` は x 軸と y 軸の単位の長さが強制的に等し
 くなるように縮尺を合わせ、グラフがページに丁度合うようにその縮尺を選択
 します。コマンド `set view equal xyz` は、さらに z 軸も x と y 軸に合
 うようにしますが、z 軸の範囲が、描画境界の範囲に合う保証はありません。
 以下も参照: `set isotropic`。デフォルトでは、3 つの軸は独立に有効な領
 域を埋めるように伸縮します。

 以下も参照: `set xyplane`。
4 projection
?set view projection
?view projection
?projection
 書式:
      set view projection {xy|xz|yz}
 3 次元グラフの視角を回転し、主平面 xy, xz, yz のいずれかがグラフの平面
 に乗るようにします。軸の目盛りとラベルの配置はそれに従って調整され、そ
 れに垂直な第 3 軸の目盛りとラベルは無効になります。そのグラフは、'plot'
 が同じ軸の範囲で生成するものとほぼ一致するサイズにスケール変換します。
 `set view projection xy` は、`set view map` と同じです。

 オブジェクトやラベル、矢、その他の描画要素を指定する x, y の座標の両方
 が "graph" 座標の場合、それは射影面では "x/y" ではなく、"水平/鉛直" 値
 として解釈します。

     set key top right at graph 0.95, graph 0.95     # 任意の射影で動作

3 vrange
?commands set vrange
?commands show vrange
?set vrange
?show vrange
?vrange
 書式:     set vrange [vmin:vmax]
 媒介変数 u と v の範囲は、以下の 2 つの状況で有効です。
 1) 媒介変数モードの `splot`。以下参照: `set parametric`,
    `set isosamples`。
 2) `plot` または `splot` コマンドでは、疑似ファイル "++" による 2 次元
    標本化データの生成に使用します。以下参照: `sampling 2D`。
3 vxrange
?commands set vxrange
?set vxrange
?vxrange
 書式:      set vxrange [vxmin:vxmax]

 これは、現在有効なボクセル格子が占める x 座標の範囲を設定します。ボク
 セル格子の他の 2 つの方向用に、これと同様のコマンド `set vyrange`,
 `set vzrange` があります。最初の `vclear`, `vfill`, `voxel(x,y,z) = `
 のコマンドの前に明示的な範囲が設定されていなかった場合、vmin と vmax
 は現在の `xrange` の範囲をコピーします。
3 vyrange
?commands set vyrange
?set vyrange
?vyrange
 以下参照: `set vxrange`。
3 vzrange
?commands set vzrange
?set vzrange
?vzrange
 以下参照: `set vxrange`。
3 walls
?commands set walls
?commands show walls
?set walls
?show walls
?unset walls
?walls
 書式:
      set walls
      set wall {x0|y0|z0|x1|y1} {<fillstyle>} {fc <fillcolor>}

Ffigure_walls
 `splot` が描く 3 次元曲面は、x, y, z 軸の範囲とは無関係に正規化された
 単位立方体の中に置きます。そしてこの立方体の境界壁は、グラフ座標の
 x == 0 や x == 1 等の平面となります。コマンド `set walls` は、これらの
 壁を x0, y0, z0 を、単色塗りの曲面として描画します。デフォルトではこれ
 らの壁は、半透明 (fillstyle transparent solid 0.5) とします。このコマ
 ンドでどの壁を描画するか、そして個別の色や個別の塗り潰しスタイル
 (fillstyle) をカスタマイズできます。壁の描画を有効にする場合は、
 `set xyplane 0` も設定するといいでしょう。
 例:
      set wall x0; set wall y1; set wall z0 fillstyle solid 1.0 fillcolor "gray"
      splot f(x,y) with pm3d fc "goldenrod"

3 watchpoints
?commands show watchpoints
?show watchpoints

 コマンド plot の各描画要素毎に、一つ以上のウォッチポイントを設定できま
 す。コマンド `show watchpoints` で、すべてのウォッチポイント対象と直前
 の plot コマンドでヒットした点の要約を見ることができます。

 例:
      plot DATA using 1:2 smooth cnormal watch y=0.25 watch y=0.5 \
           watch y=0.75
      show watchpoints

          Plot title:     "DATA using 1:2 smooth cnormal"
            Watch 1 target y = 0.25         (1 hits)
                    hit 1   x 50.6  y 0.25
            Watch 2 target y = 0.5          (1 hits)
                    hit 1   x 63.6  y 0.5
            Watch 3 target y = 0.75         (1 hits)
                    hit 1   x 68.3  y 0.75

 最初のウォッチポイント (y=0.25) を満たすすべての点の座標を配列 WATCH_1
 に保存します。y=0.5 を満たす点は配列 WATCH_2 に保存し、以下同様です。

 各ヒット点は、x 座標を実数部分、y 座標を虚数部分とする複素数として保存
 し、よってウォッチポイント 2 の最初のヒット点は、x = real(WATCH_2[1]),
 y = imag(WATCH_2[1]) となります。この例では、ヒット点の x 座標のみが関
 心事で、y 座標は常に対象となる y の値に一致します。しかし、ウォッチポ
 イント対象が関数 f(x,y) の z 値である場合、x, y 座標はどちらも事前には
 わかりません。

3 x2data
?commands set x2data
?commands show x2data
?set x2data
?show x2data
?x2data
 コマンド `set x2data` は x2 (上) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 x2dtics
?commands set x2dtics
?commands unset x2dtics
?commands show x2dtics
?set x2dtics
?unset x2dtics
?show x2dtics
?x2dtics
?nox2dtics
 コマンド `set x2dtics` は x2 (上) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 x2label
?commands set x2label
?commands show x2label
?set x2label
?show x2label
?x2label
 コマンド `set x2label` は x2 (上) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 x2mtics
?commands set x2mtics
?commands unset x2mtics
?commands show x2mtics
?set x2mtics
?unset x2mtics
?show x2mtics
?x2mtics
?nox2mtics
 コマンド `set x2mtics` は、x2 (上) 軸を 1 年の各月に設定します。詳細は、
 以下参照: `set xmtics`。
3 x2range
?commands set x2range
?commands show x2range
?set x2range
?show x2range
?x2range
 コマンド `set x2range` は x2 (上) 軸の表示される水平範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。以
 下も参照: `set link`。
3 x2tics
?commands set x2tics
?commands unset x2tics
?commands show x2tics
?set x2tics
?unset x2tics
?show x2tics
?x2tics
?nox2tics
 コマンド `set x2tics` は x2 (上) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 x2zeroaxis
?commands set x2zeroaxis
?commands unset x2zeroaxis
?commands show x2zeroaxis
?set x2zeroaxis
?unset x2zeroaxis
?show x2zeroaxis
?x2zeroaxis
?nox2zeroaxis
 コマンド `set x2zeroaxis` は、原点を通る x2 (上) 軸 (y2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 軸毎のデータ種類指定 (xdata)
?commands set xdata
?commands show xdata
?set xdata
?show xdata
?xdata
 このコマンドは x 軸のデータ形式の解釈を制御します。他の軸それぞれにも
 同様のコマンドが機能します。

 書式:
       set xdata {time}
       show xdata

 `ydata`, `zdata`, `x2data`, `y2data`, `cbdata` にも同じ書式が当てはま
 ります。

 `time` オプションはデータが秒単位の日時データであることを伝えます。
 gnuplot バージョン 6 は時刻をミリ秒の精度保存します。

 キーワード `time` なしの `set xdata` は、データの解釈方法を通常の形式
 に戻します。
4 日時データ (time)
?commands set xdata time
?set xdata time
 `set xdata time` は、x 座標がミリ秒精度の日時データであることを意味し
 ます。`set ydata time` という同様のコマンドもあります。

 日時データの入力と出力の解釈には、別々の書式機構があります。ファイルか
 らの入力データは、全体に通用する `timefmt` を使うか、または plot コマ
 ンド内で timecolumn() 関数を使って読み込みます。この入力機構は、軸の範
 囲 (range) を設定するときに時間の値を使用する際にも適用されます。以下
 参照: `set timefmt`, `timecolumn`。

 例:

      set xdata time
      set timefmt "%d-%b-%Y"
      set xrange ["01-Jan-2013" : "31-Dec-2014"]
      plot DATA using 1:2
 または
      plot DATA using (timecolumn(1,"%d-%b-%Y")):2

 出力、すなわち軸に沿った目盛りのラベルや、マウス操作での座標出力につい
 ては、デフォルトでは、秒での内部時刻から日時を表現する文字列への変換に
 は、関数 'strftime' (unix でそれを調べるには "man strftime" とタイプし
 てください) を使います。`gnuplot` はこれを適当に意味のある書式で表示し
 ようとしますが、`set format x` か `set xtics format` のいずれかを使っ
 てカスタマイズすることもできます。
 特別な時間書式指定子に関しては、以下参照: `time_specifiers`。他の情報
 については、以下も参照: `time/date`。
3 曜日軸目盛り (xdtics)
?commands set xdtics
?commands unset xdtics
?commands show xdtics
?set xdtics
?unset xdtics
?show xdtics
?xdtics
?noxdtics
 コマンド `set xdtics` は x 軸の目盛りの刻みを曜日に変換します (0=Sun,
 6=Sat)。6 を越える場合は 7 による余りが使われます。`unset xdtics` は
 その見出しをデフォルトの形式に戻します。他の軸にも同じことを行なう同
 様のコマンドが用意されています。

 書式:
       set xdtics
       unset xdtics
       show xdtics

 `ydtics`, `zdtics`, `x2dtics`, `y2dtics`, `cbdtics` にも同じ書式が当て
 はまります。

 以下も参照: `set format`。
3 軸ラベル (xlabel)
?commands set xlabel
?commands show xlabel
?set xlabel
?show xlabel
?xlabel
 コマンド `set xlabel` は x 軸の見出しを設定します。他の軸にも見出しを
 設定する同様のコマンドがあります。

 書式:
       set xlabel {"<label>"} {offset <offset>} {font "<font>{,<size>}"}
                  {textcolor <colorspec>} {{no}enhanced}
                  {rotate by <degrees> | rotate parallel | norotate}
       show xlabel

 同じ書式が `x2label`, `ylabel`, `y2label`, `zlabel`, `cblabel` にも適
 用されます。

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、見出しは与えら
 れた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set xlabel offset -1,0`" は見出しの x 方向の
 位置のみ変更し、大ざっぱに言って 1 文字分の幅だけ見出しを左にずらしま
 す。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> は見出しが書かれるフォントを指定するのに使われます。フォントの
 <size> (大きさ) の単位は、どんな出力形式を使うかに依存します。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、ラベル文字列を拡張文字列処理させないようにします。

 見出しを消去するには、オプションをつけずに実行します。例: "`set y2label`"

 軸の見出しのデフォルトの位置は以下の通りです:

 xlabel: x 軸の見出しはグラフの下の真中

 ylabel: y 軸の見出しはグラフの左の真中で、水平方向に書かれるか垂直方向
 になるかは出力形式依存。
 グラフの左側に回転させない ylabel 文字列を置くには、十分なスペースがな
 い場合もありえます。その場合は、`set lmargin` で揃えられます。

 zlabel: z 軸の見出しは軸の表示範囲より上で、見出しの真中が z 軸の真上

 cblabel: 色見本 (color box) の軸の見出しは箱に沿って中央揃えされ、箱の
 向きが水平なら下に、垂直なら右に

 y2label: y2 軸の見出しは y2 軸の右。その位置は、出力形式依存で y 軸と
 同様の規則で決定。

 x2label: x2 軸の見出しはグラフの上で、タイトルよりは下。これは、 改行
 文字を使えば、それによる複数の行からなる描画タイトルで x2 軸の見出しを
 生成することも可能。例:

       set title "This is the title\n\nThis is the x2label"

 これは二重引用符を使うべきであることに注意してください。この場合、もち
 ろん 2 つの行で同じフォントが使われます。

 2 次元描画の場合の x, x2, y, y2 軸のラベルの方向 (回転角) は、
 `rotate by <角度>` を指定することで変更できます。3 次元描画の x, y 軸
 のラベルの方向はデフォルトでは水平方向になっていますが、
 `rotate parallel` を指定することで軸に平行にすることができます。

 もし軸の位置のデフォルトの位置が気に入らないならば、代わりに `set label`
 を使ってください。このコマンドは文字列をどこに配置するかをもっと自由に
 制御できます。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いに関するより詳しい情報については、以下参照: `syntax`。
3 月軸目盛り (xmtics)
?commands set xmtics
?commands unset xmtics
?commands show xmtics
?set xmtics
?unset xmtics
?show xmtics
?xmtics
?noxmtics
 コマンド `set xmtics` は x 軸の目盛りの見出しを月に変換します。1=Jan
 (1 月)、12=Dec (12 月) となります。12 を越えた数字は、12 で割ったあまりの
 月に変換されます。`unset xmtics` で目盛りはデフォルトの見出しに戻ります。
 他の軸に対しても同じ役割をする同様のコマンドが用意されています。

 書式:
       set xmtics
       unset xmtics
       show xmtics

 `x2mtics`, `ymtics`, `y2mtics`, `zmtics`, `cbmtics` にも同じ書式が適用
 されます。

 以下も参照: `set format`。
3 軸範囲指定 (xrange)
?commands set xrange
?commands show xrange
?set xrange
?show xrange
?set range
?writeback
?restore
?xrange
 コマンド `set xrange` は表示される水平方向の範囲を指定します。他の軸
 にも同様のコマンドが存在しますし、極座標での動径 r, 媒介変数 t, u, v
 にも存在します。

 書式:
       set xrange [{{<min>}:{<max>}}] {{no}reverse} {{no}writeback} {{no}extend}
                  | restore
       show xrange

 ここで <min> と <max> は定数、数式、または '*' で、'*' は自動縮尺機能
 を意味します。日時データの場合、範囲は `set timefmt` の書式に従った文
 字列を引用符で囲む必要があります。<min> や <max> を省略した場合は、現
 在の値を変更しません。自動縮尺機能に関する詳細は下に述べます。以下も
 参照: `noextend`。

 `yrange`, `zrange`, `x2range`, `y2range`, `cbrange`, `rrange`, `trange`,
 `urange`, `vrange` は同じ書式を使用します。

 x と x2 軸、あるいは y と y2 軸の範囲をリンクするオプションについては
 以下参照: `set link`。

 オプション `reverse` は、自動縮尺の軸の方向を逆にします。例えば、デー
 タ値の範囲が 10 から 100 であるとき、これは、set xrange [100:10] とし
 たのと同じように自動縮尺します。`reverse` は、自動縮尺ではない軸に対し
 ては機能しません。

 自動縮尺機能: <min> (同様のことが <max> にも適用されます) がアスタリス
 ク "*" の場合は自動縮尺機能がオンになります。その場合のその値に、下限
 <lb>、または上限 <ub>、またはその両方の制限を与えられます。書式は以下
 の通りです。
       { <lb> < } * { < <ub> }
 例えば
       0 < * < 200
 は <lb> = 0, <ub> = 200 となります。そのような設定では、<min> は自動縮
 尺されますが、その最終的な値は 0 から 200 の間になります (記号は '<'
 ですが両端の値も含みます)。下限か上限を指定しない場合は、その '<' も省
 略できます。<ub> が <lb> より小さい場合は、制限はオフになり、完全な自
 動縮尺になります。
 この機能は、自動縮尺だけれども範囲に制限がある測定データの描画や、外れ
 値のクリッピング、またはデータがそれほどの範囲を必要としていなくても最
 小の描画範囲を保証するのに有用でしょう。

 オプション `writeback` は、`set xrange` で占められているバッファの中に
 自動縮尺機能により作られた範囲を保存します。これは、いくつかの関数を同
 時に表示し、しかしその範囲はそのうちのいくつかのものから決定させたい場
 合に便利です。`writeback` の作用は、`plot` の実行中に機能するので、その
 コマンドの前に指定する必要があります。最後に保存した水平方向の範囲は
 `set xrange restore` で復元できます。例を上げます。

       set xrange [-10:10]
       set yrange [] writeback
       plot sin(x)
       set yrange restore
       replot x/2

 この場合、y の範囲 (yrange) は sin(x) の値域として作られた [-1:1] の方
 になり、x/2 の値域 [-5:5] は無視されます。上記のそれぞれのコマンドの後
 に `show yrange` を実行すれば、上で何が行なわれているかを理解する助け
 になるでしょう。

 2 次元描画において、`xrange` と `yrange` は軸の範囲を決定し、`trange`
 は、媒介変数モードの媒介変数の範囲、あるいは極座標モードの角度の範囲を
 決定します。同様に 3 次元媒介変数モードでは、`xrange`, `yrange`, `zrange`
 が軸の範囲を管理し、`urange` と `yrange` が媒介変数の範囲を管理します。

 極座標モードでは、`rrange` は描画される動径の範囲を決定します。<rmin>
 は動径への追加の定数として作用し、一方 <rmax> は動径を切り捨てる (clip)
 ように作用し、<rmax> を越えた動径に対する点は描画されません。`xrange`
 と `yrange` は影響されます。これらの範囲は、グラフが r(t)-rmin のグラ
 フで、目盛りの見出しにはそれぞれ rmin を加えたようなものであるかのよう
 にセットされます。

 全ての範囲は部分的に、または全体的に自動縮尺されますが、データの描画で
 なければ、パラメータ変数の自動縮尺機能は意味がないでしょう。

 範囲は `plot` のコマンドライン上でも指定できます。コマンドライン上で与
 えられた範囲は単にその `plot` コマンドでだけ使われ、`set` コマンドで設
 定された範囲はその後の描画で、コマンドラインで範囲を指定していないもの
 全てで使われます。これは `splot` も同じです。
4 例 (examples)
?commands set xrange examples
?set xrange examples
?set range examples
?xrange examples
 例:

 x の範囲をデフォルトの値にします:
       set xrange [-10:10]

 y の範囲が下方へ増加するようにします:
       set yrange [10:-10]

 z の最小値には影響を与えずに (自動縮尺されたまま)、最大値のみ 10 に設
 定します:
       set zrange [:10]

 x の最小値は自動縮尺とし、最大値は変更しません:
       set xrange [*:]

 x の最小値を自動縮尺としますが、その最小値は 0 以上にします。
       set xrange [0<*:]

 x の範囲を自動縮尺としますが、小さくても 10 から 50 の範囲を保持します
 (実際はそれより大きくなるでしょう):
       set xrange [*<10:50<*]

 自動縮尺で最大範囲を -1000 から 1000、すなわち [-1000:1000] 内で自動縮
 尺します:
       set xrange [-1000<*:*<1000]

 x の最小値を -200 から 100 の間のどこかにします:
       set xrange [-200<*<100:]
4 extend
?commands set xrange noextend
?set xrange noextend
?set range noextend
?xrange noextend
?set xrange extend
?set range extend
?xrange extend
 `set xrange noextend` は、`set autoscale x noextend` と全く同じです。
 以下参照: `noextend`。
3 軸主目盛り指定 (xtics)
?commands set xtics
?commands unset xtics
?commands show xtics
?set xtics
?unset xtics
?show xtics
?xtics
?noxtics
 x 軸の (見出しのつく) 大目盛りは コマンド `set xtics` で制御できます。
 目盛りは `unset xtics` で消え、`set xtics` で (デフォルトの状態の) 目
 盛りがつきます。y,z,x2,y2 軸の大目盛りの制御を行なう同様のコマンドがあ
 ります。

 書式:
       set xtics {axis | border} {{no}mirror}
                 {in | out} {scale {default | <major> {,<minor>}}}
                 {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                 {left | right | center | autojustify}
                 {add}
                 {  autofreq
                  | <incr>
                  | <start>, <incr> {,<end>}
                  | ({"<label>"} <pos> {<level>} {,{"<label>"}...) }
                 {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                 { numeric | timedate | geographic }
                 {{no}logscale}
                 { rangelimited }
                 { textcolor <colorspec> }
       unset xtics
       show xtics

 同じ書式が `ytics`, `ztics`, `x2tics`, `y2tics`, `cbtics` にも適用され
 ます。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると目盛りの見出し文字を境界の外に出して
 しまうでしょう。この場合自動的なレイアウトアルゴリズムによる余白設定は
 大抵よくないものとなってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 目盛りの刻みのサイズは `scale` で調整できます。<minor> の指定が省略さ
 れた場合は、それは 0.5*<major> になります。デフォルトのサイズは、大目
 盛りが 1.0 で小目盛りが 0.5 で、これは `scale default` で呼びだせます。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸には、
 `{axis | border}` オプションは無効で、デフォルトは `nomirror` です。z
 軸の目盛りをミラー化したいなら、多分 `set border` でそのための空間をあ
 ける必要があるでしょう。

 <offset> は x,y かまたは x,y,z の形式で指定しますが、それに座標系を選
 択して、その前に `first`, `second`, `graph`, `screen`, `character` の
 いずれかをつけることもできます。<offset> は刻み文字のデフォルトの位置
 からのずれを表し、デフォルトの座標系は `character` です。詳細は、以下
 参照: `coordinates`。`nooffset` はずらしを無効にします。

 例:

 xtics をより描画に近づける:
       set xtics offset 0,graph 0.05

 軸の目盛りとグラフ自身の描画の相対的な順番を変更するには、コマンド
 `set grid` に 'front', 'back', 'layerdefault' 等のオプションを使用して
 ください。ただし、異なる軸の目盛りや格子線に異なるレイヤーを割り当てる
 オプションはありません。

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に揃えられますが、気にいらなければ、明示的に `left`,
 `right`, `center` のキーワードにより位置揃えを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしで `set xtics` を実行すると、目盛りが表示される状態であ
 れば、それはデフォルトの境界、または軸を復元し、そうでなければ何もしま
 せん。その前に指定した目盛りの間隔、位置 (と見出し) は保持されます。

 目盛りの位置は、デフォルト、またはオプション `autofreq` が指定されてい
 れば自動的に計算されます。

 目盛りの位置の列は、目盛りの間隔のみ、または開始位置と間隔と終りの位置、
 のいずれかを指定することができます (以下参照: `xtics series`)。

 明示的な位置のリストを与えることで、個々の目盛りの位置を個別に指定する
 こともできます。各位置には、それに対する見出しラベルを指定することもで
 きます。以下参照: `xtics list`。

 しかし指定しても、表示されるのはあくまで描画範囲のものだけです。

 目盛りの見出しの書式 (または省略) は `set format` で制御されます。ただ
 しそれは `set xtics (`<label>`)` の形式の明示的な見出し文字列が含まれ
 ていない場合だけです。

 (見出し付けされない) 小目盛りは、`set mxtics` コマンドで自動的に追加す
 るか、または位置を手動で `set xtics ("" <pos> 1, ...)` の形式で与える
 こともできます。

 刻みの見た目 (線種、幅等) は、それを軸の上に描く場合であっても、境界線
 によって決定されます (以下参照: `set border`)。
4 xtics series
?set xtics series
?xtics series
 書式:
      set xtics <incr>
      set xtics <start>, <incr>, <end>
 暗示的な <start>, <incr>, <end> 形式は、目盛りの列を <start> から <end>
 の間を <incr> の間隔で表示します。<end> を指定しなければ、それは無限大
 とみなされます。<incr> は負の値も可能です。<start> と <end> の両方が指
 定されていない場合、<start> は -∞、<end> は +∞とみなされ、目盛りは
 <incr> の整数倍の位置に表示されます。軸が対数軸の場合、目盛りの間隔
 (増分) は、倍数として使用されます。

 負の <start> や <incr> を、数値の後ろに指定すると (例えば
 `rotate by <angle>` とか `offset <offset>` の後ろ)、gnuplot の構文解析
 器は、その値からその負の <start> や <incr> の値の引き算を行おうとする
 間違いを犯します。これを回避するには、そのような場合は、`0-<start>` や
 `0-<incr>` のように指定してください。

 例:
       set xtics border offset 0,0.5 -5,1,5
 最後の ',' のところで失敗します。
 代わりに
       set xtics border offset 0,0.5 0-5,1,5
 か
       set xtics offset 0,0.5 border -5,1,5
 のようにしてください。これらは、ちゃんと指示通りに、目盛りを境界に、目
 盛り見出し文字列を 0,0.5 文字分だけずらして、start, increment, end を
 それぞれ -5,1,5 に設定します。

 例:

 目盛りを 0, 0.5, 1, 1.5, ..., 9.5, 10 の位置に生成
       set xtics 0,.5,10

 目盛りを ..., -10, -5, 0, 5, 10, ... に生成
       set xtics 5

 目盛りを 1, 100, 1e4, 1e6, 1e8 に生成
       set logscale x; set xtics 1,100,1e8

4 xtics list
?set xtics list
?set xtics add
?xtics list
?xtics add
 書式:
      set xtics {add} ("label1" <pos1> <level1>, "label2" <pos2> <level2>, ...)

 明示的な ("label" <pos> <level>, ...) の形式は、任意の目盛りの位置、あ
 るいは数字でない見出しの生成も可能にします。この形式では、目盛りは位置
 の数字の順に与える必要はありません。各目盛りは位置 (pos) と見出し
 (label) を持ちますが、見出しは必須ではありません。

 見出しは引用符で囲んだ文字列か、または文字列値の数式です。それには、
 "%3f clients" のようにその位置を数字に変換する書式文字列を入れても構い
 ませんし、空文字列 "" でも構いません。より詳しい情報については、以下
 参照: `set format`。もし、文字列を指定しなければ、デフォルトの数字の見
 出しを使用します。

 明示的な形式では 3 つ目のパラメータとしてレベルを指定できます。デフォ
 ルトのレベルは 0 で、これは大目盛りを意味し、レベル 1 の場合は小目盛り
 を生成します。ラベルは、小目盛りには決して付きません。大目盛りと小目盛
 りは gnuplot が自動的に生成しますが、ユーザが明示的に指定もできます。
 レベルが 2 以上の目盛りは、ユーザが明示的に指定しなければならず、自動
 生成の目盛りよりも高い優先度を持ちます。各レベルの目盛りの刻みの大きさ
 は、`set tics scale` で制御します。

 例:
       set xtics ("low" 0, "medium" 50, "high" 100)
       set xtics (1,2,4,8,16,32,64,128,256,512,1024)
       set ytics ("bottom" 0, "" 10, "top" 20)
       set ytics ("bottom" 0, "" 10 1, "top" 20)

 2 番目の例では、全ての目盛りが見出し付けされます。3 番目の例では、端の
 ものだけが見出し付けされます。4 番目の例の、見出しのない目盛りは小目盛
 りになります。

 通常明示的な (手動の) 目盛り位置が与えられた場合、自動的に生成される目
 盛りは使われません。逆に、`set xtics auto` のようなものが指定された場
 合は、以前に手動で設定した目盛りは消されてしまします。この手動の目盛り
 と自動的な目盛りを共存させるにはキーワード `add` を使用してください。
 これは追加する目盛りのスタイルの前に書かなければいけません。

 例:
       set xtics 0,.5,10
       set xtics add ("Pi" 3.14159)

 これは自動的に目盛りの刻みを x 軸に 0.5 間隔でつけますが、πのところに
 明示的な見出しも追加します。
4 xtics timedata
?set xtics timedata
?xtics timedata tics
?set xtics time
?xtics time
?timedata tics
 時間と日付は内部では秒数として保持されています。

 入力: 非数値の日時値は、入力時に `timefmt` で指定した書式を用いて秒数
 に変換します。軸の範囲、目盛りの配置、グラフの座標も `timefmt` で解釈
 される日時で、引用符で囲んで与えることができます。

 出力: 軸の目盛りラベルは、`set format` か `set xtics format` のいずれ
 かで指定された、別の書式を使って生成します。デフォルトでは、それは通常
 の数値書式指定であると認識しますが (`set xtics numeric`)、他に、地理座
 標 (`set xtics geographic`) や、日時データ (`set xtics time`) のオプシ
 ョンがあります。

 注意: 以前の版の gnuplot との互換性のため、コマンド `set xdata time`
 も暗黙に `set xtics time` を実行しますし、`set xdata` や `unset xdata`
 は暗黙に `set xtics numeric` へリセットします。しかし、これはその後に
 `set xtics` を呼び出すことで変更できます。

 例:
       set xdata time           # 入力データの解釈の制御
       set timefmt "%d/%m"      # 入力データの読み込みの書式
       set xtics timedate       # 出力書式の解釈の制御
       set xtics format "%b %d" # 目盛りラベルで使う書式
       set xrange ["01/12":"06/12"]
       set xtics "01/12", 172800, "05/12"

       set xdata time
       set timefmt "%d/%m"
       set xtics format "%b %d" time
       set xrange ["01/12":"06/12"]
       set xtics ("01/12", "" "03/12", "05/12")
 これらは両方とも "Dec 1", "Dec 3", "Dec 5", の目盛りを生成しますが、2
 番目の例 "Dec 3" の目盛りは見出し付けされません。

 <start>, <incr>, <end> 形式を使う場合、<incr> はデフォルトでは秒単位で
 すが、`minutes`, `hours`, `days`, `weeks`, `months`, `years` の明示的
 な時間の単位を後ろに追加することもできます。これは、間隔 <incr> のみを
 指定する場合も同じです。

 例
      set xtics time 5 years     # 5 年間隔で目盛りラベルを配置
      set xtics "01-Jan-2000", 1 month, "01-Jan-2001"

 小目盛用の特別な時刻モードもあります。以下参照: `set mxtics time`。
4 地理座標 (geographic)
?commands set xtics geographic
?set xtics geographic
?geographic
 `set xtics geographic` は、x 軸の値が度の単位の地理座標であることを意
 味します。その軸の刻みの見出しの表現の指定には、`set xtics format` か
 `set format x` を使います。地理座標データに関する書式指定子は以下の通
 り:
        %D                   = 度の整数表示
        %<width.precision>d  = 度の浮動小数表示
        %M                   = 分の整数表示
        %<width.precision>m  = 分の浮動小数表示
        %S                   = 秒の整数表示
        %<width.precision>s  = 秒の浮動小数表示
        %E                   = +/- でなく E/W のラベル
        %N                   = +/- でなく N/S のラベル
 例えば、コマンド `set format x "%Ddeg %5.2mmin %E"` は、x 座標の -1.51
 という値を `" 1deg 30.60min W"` のように表示します。
C shige: 日本語ロケールの場合を訳注として書くべきか。
C 度の記号は set encoding locale で出るようになると。

 xtics がデフォルトの状態のまま (`set xtics numeric`) の場合は、座標は
 10 進数の度で表示し、`format` も上の特別な記号ではなく、通常の数値書式
 が使われているとみなされます。

 マップ上にラベルを置くなど、軸の目盛りとは異なる場所で度/分/秒の出力を
 するには、strptime に相対的時間書式指定 %tH %tM %tS を使用できます。以
 下参照: `time_specifiers`, `strptime`。
4 xtics logscale
?set xtics logscale
?xtics logscale
=logscale
 対数軸に沿う刻みに対して `logscale` 属性を設定すると、刻みの間隔は公差
 ではなく、公比と解釈されます。例:
      # y=20 y=200 y=2000 y=20000 に刻み列を作成
      set log y
      set ytics 20, 10, 50000 logscale
 y=50000 は 2*10^x の数列には含まれないので、そこには刻みはつかないこと
 に注意してください。logscale 属性が無効の場合、軸の増分は、たとえ対数
 軸であっても公差として扱われます。例:
      # y=20 y=40 y=60 ... y=200 に刻みを作成
      set log y
      set yrange [20:200]
      set ytics 20 nologscale
 `logscale` 属性は、コマンド `set log` で自動的に設定されるので、2 つ目
 の例のような軸の刻み間隔に強制的にしたい場合でなければ、通常はこのキー
 ワードは必要ありません。
4 xtics rangelimited
?set xtics rangelimited
?xtics rangelimited
?rangelimited
?range-frame
 このオプションは、自動的に生成される軸の目盛りの見出しと、描画されたデ
 ータで実際に与えられる範囲に対応する描画境界の両方を制限します。これは
 描画に対する現在の範囲制限とは無関係であることに注意してください。例え
 ばデータ "file.dat" のデータがすべて 2 < y < 4 の範囲にあるとすると、
 以下のコマンドは、左側の描画境界 (y 軸) は y の範囲全体 ([0:10]) のこ
 の部分 ([2:4]) のみが描画され、この範囲 ([2:4]) の軸の目盛りのみが作ら
 れる描画を生成します。つまり、描画は y の範囲全体 ([0:10]) に拡大され
 ますが、左の境界は 0 から 2 の間、4 から 10 の間は空白領域となります。
 このスタイルは、`範囲枠` グラフ (range-frame) とも呼ばれます。
       set border 3
       set yrange [0:10]
       set ytics nomirror rangelimited
       plot "file.dat"
3 xy 平面位置 (xyplane)
?commands set xyplane
?commands show xyplane
?set xyplane
?show xyplane
?xyplane
 `set xyplane` コマンドは 3D 描画で描かれる xy 平面の位置を調整するのに
 使われます。後方互換性のために、"set ticslevel" も同じ意味のコマンドと
 して使うことができます。

 書式:
       set xyplane at <zvalue>
       set xyplane relative <frac>
       set ticslevel <frac>        # set xyplane relative と同等
       show xyplane

 `set xyplane relative <frac>` は、xy 平面を Z 軸の範囲のどこに置くかを
 決定します。<frac> には、xy 平面と z の一番下の位置との差の、z 軸の範
 囲全体に対する割合を与えます。デフォルトの値は 0.5 です。負の値も許さ
 れていますが、そうすると 3 つの軸の目盛りの見出しが重なる可能性があり
 ます。

 もう一つの形式である `set xyplane at <zvalue>` は、現在の z の範囲を気
 にすることなく、指定した z の値の位置に xy 平面を固定します。よって、
 x,y,z 軸を共通の原点を通るようにするには、`set xyplane at 0` とすれば
 いいことになります。

 以下も参照: `set view`, `set zeroaxis`。
3 xzeroaxis
?commands set xzeroaxis
?commands unset xzeroaxis
?commands show xzeroaxis
?set xzeroaxis
?unset xzeroaxis
?show xzeroaxis
?xzeroaxis
?noxzeroaxis
 コマンド `set xzeroaxis` は y = 0 の直線を描きます。詳細に関しては、以
 下参照: `set zeroaxis`。
3 y2data
?commands set y2data
?commands show y2data
?set y2data
?show y2data
?y2data
 コマンド `set y2data` は y2 (右) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 y2dtics
?commands set y2dtics
?commands unset y2dtics
?set y2dtics
?unset y2dtics
?show y2dtics
?y2dtics
?noy2dtics
 コマンド `set y2dtics` は y2 (右) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 y2label
?commands set y2label
?commands show y2label
?set y2label
?show y2label
?y2label
 コマンド `set y2label` は y2 (右) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 y2mtics
?commands set y2mtics
?commands unset y2mtics
?commands show y2mtics
?set y2mtics
?unset y2mtics
?show y2mtics
?y2mtics
?noy2mtics
 コマンド `set y2mtics` は y2 (右) 軸の目盛りを 1 年の各月に変更します。
 詳細は、以下参照: `set xmtics`。
3 y2range
?commands set y2range
?commands show y2range
?set y2range
?show y2range
?y2range
 コマンド `set y2range` は y2 (右) 軸の表示される垂直範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。以
 下も参照: `set link`。
3 y2tics
?commands set y2tics
?commands unset y2tics
?commands show y2tics
?set y2tics
?unset y2tics
?show y2tics
?y2tics
?noy2tics
 コマンド `set y2tics` は y2 (右) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 y2zeroaxis
?commands set y2zeroaxis
?commands unset y2zeroaxis
?commands show y2zeroaxis
?set y2zeroaxis
?unset y2zeroaxis
?show y2zeroaxis
?y2zeroaxis
?noy2zeroaxis
 コマンド `set y2zeroaxis` は、原点を通る y2 (右) 軸 (x2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 ydata
?commands set ydata
?commands show ydata
?set ydata
?show ydata
?ydata
 コマンド `set ydata` は y 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 ydtics
?commands set ydtics
?commands unset ydtics
?commands show ydtics
?set ydtics
?unset ydtics
?show ydtics
?ydtics
?noydtics
 コマンド `set ydtics` は y 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 ylabel
?commands set ylabel
?commands show ylabel
?set ylabel
?show ylabel
?ylabel
 このコマンドは y 軸の見出しを設定します。以下参照: `set xlabel`。
3 ymtics
?commands set ymtics
?commands unset ymtics
?commands show ymtics
?set ymtics
?unset ymtics
?show ymtics
?ymtics
?noymtics
 コマンド `set ymtics` は、y 軸の目盛りを月に変更します。詳細は、以下
 参照: `set xmtics`。
3 yrange
?commands set yrange
?commands show yrange
?set yrange
?show yrange
?yrange
 コマンド `set yrange` は、y 方向の垂直範囲を設定します。詳細は、以下
 参照: `set xrange`。
3 ytics
?commands set ytics
?commands unset ytics
?commands show ytics
?set ytics
?unset ytics
?show ytics
?ytics
?noytics
 コマンド `set ytics` は y 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 yzeroaxis
?commands set yzeroaxis
?commands unset yzeroaxis
?commands show yzeroaxis
?set yzeroaxis
?unset yzeroaxis
?show yzeroaxis
?yzeroaxis
?noyzeroaxis
 コマンド `set yzeroaxis` は x = 0 の直線 (y 軸) を書きます。詳細は、以
 下参照: `set zeroaxis`。
3 zdata
?commands set zdata
?commands show zdata
?set zdata
?show zdata
?zdata
 コマンド `set zdata` は z 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 zdtics
?commands set zdtics
?commands unset zdtics
?commands show zdtics
?set zdtics
?unset zdtics
?show zdtics
?zdtics
?nozdtics
 コマンド `set zdtics` は z 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 zzeroaxis
?commands set zzeroaxis
?commands unset zzeroaxis
?commands show zzeroaxis
?set zzeroaxis
?unset zzeroaxis
?show zzeroaxis
?zzeroaxis
?nozzeroaxis
 コマンド `set zzeroaxis` は (x=0,y=0) を通る直線を描きます。これは、2D
 描画、および `set view map` での splot では効力を持ちません。詳細は、
 以下参照: `set zeroaxis`, `set xyplane`。
3 cbdata
?commands set cbdata
?commands show cbdata
?set cbdata
?show cbdata
?cbdata
 このコマンドはカラーボックス軸のデータを時系列 (日時) 形式に式に設定し
 ます。以下参照: `set xdata`。
3 cbdtics
?commands set cbdtics
?commands unset cbdtics
?commands show cbdtics
?set cbdtics
?unset cbdtics
?show cbdtics
?cbdtics
?nocbdtics
 コマンド `cbdtics` はカラーボックス軸の目盛りの刻みを曜日に変換します。
 詳細は、以下参照: `set xdtics`。
3 ゼロ閾値 (zero)
?commands set zero
?commands show zero
?set zero
?show zero
?zero
 `zero` の値は、0.0 に近いデフォルトの閾値を表します。

 書式:
       set zero <expression>
       show zero

 `gnuplot` は、(複素数値を持つ点の描画においては) その値の虚数部分の絶
 対値が `zero` 閾値より大きい場合 (つまり実数でない値を持つ点) は、その
 点を描画しません。この閾値は `gnuplot` の他の様々な部分においてその
 (大まかな) 数値誤差の閾値としても使われています。デフォルトの `zero` の
 値は 1e-8 です。1e-3 (= 典型的なビットマップディスプレイの解像度の逆数)
 より大きい `zero` の値は設定すべきではないでしょうが、`zero` を 0.0 と
 設定するのは意味のないことではありません。
3 ゼロ軸 (zeroaxis)
?commands set zeroaxis
?commands unset zeroaxis
?commands show zeroaxis
?set zeroaxis
?unset zeroaxis
?show zeroaxis
?zeroaxis
 x 軸は `set xzeroaxis` によって描かれ、`unset xzeroaxis` によって削除
 されます。同様の y, x2, y2, z 軸用のコマンドが同様の働きをします。
 `set zeroaxis ...` (前置詞なし) は、x, y, z 軸すべてに機能します。

 書式:
       set {x|x2|y|y2|z}zeroaxis { {linestyle | ls <line_style>}
                                  | {linetype | lt <line_type>}
                                    {linewidth | lw <line_width>}
                                    {linecolor | lc <colorspec>}
                                    {dashtype | dt <dashtype>} }
       unset {x|x2|y|y2|z}zeroaxis
       show {x|y|z}zeroaxis


 デフォルトでは、これらのオプションはオフになっています。選択された 0
 の軸は <line_type> の線の型、<line_width> の線の幅、<colorspec> の色、
 <dashtype> の点線/破線パターンで (いずれも現在使用している出力形式が
 サポートしていれば)、あるいはあらかじめ定義された <line_style> のスタ
 イルで描かれます。以下参照: `set style line`。

 線の型を指定しなければ、軸は通常の軸の線の型 (型 0) で描かれます。

 例:

 y=0 の軸を見えるように簡単に書く場合:

        set xzeroaxis

 太い線にして、違った色、または点線パターンにしたい場合:

        set xzeroaxis linetype 3 linewidth 2.5
3 zlabel
?commands set zlabel
?commands show zlabel
?set zlabel
?show zlabel
?zlabel
 このコマンドは z 軸の見出しを設定します。以下参照: `set xlabel`。
3 zmtics
?commands set zmtics
?commands unset zmtics
?commands show zmtics
?set zmtics
?unset zmtics
?show zmtics
?zmtics
?nozmtics
 コマンド `set zmtics` は z 軸の目盛りを月に変更します。詳細は、以下
 参照: `set xmtics`。
3 zrange
?commands set zrange
?commands show zrange
?set zrange
?show zrange
?zrange
 コマンド `set zrange` は z 軸方向に表示される範囲を設定します。このコ
 マンドは `splot` にのみ有効で、`plot` では無視されます。詳細は、以下
 参照: `set xrange`。
3 ztics
?commands set ztics
?commands unset ztics
?commands show ztics
?set ztics
?unset ztics
?show ztics
?ztics
?noztics
 コマンド `set ztics` は z 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 cblabel
?commands set cblabel
?commands show cblabel
?set cblabel
?show cblabel
?cblabel
 このコマンドはカラーボックス軸の見出しを設定します。以下参照:
 `set xlabel`。
3 cbmtics
?commands set cbmtics
?commands unset cbmtics
?commands show cbmtics
?set cbmtics
?unset cbmtics
?show cbmtics
?cbmtics
?nocbmtics
 コマンド `set cbmtics` はカラーボックス軸の目盛りの見出しを月に変換し
 ます。詳細は、以下参照: `set xmtics`。
3 cbrange
?commands set cbrange
?commands show cbrange
?set cbrange
?show cbrange
?cbrange
 コマンド `set cbrange` は、スタイル `with pm3d`, `with image` や
 `with palette` などによって現在のパレット (`palette`) を使って色付けさ
 れる値の範囲を設定します。その範囲外の値に対しては、最も近い限界の値の
 色が使用されます。

 カラーボックス軸 (cb-軸) が `splot` で自動縮尺されている場合は、その
 カラーボックスの範囲は `zrange` が使われます。`splot ... pm3d|palette`
 で描画される点は、異なる `zrange` と `cbrange` を使うことでフィルタリ
 ングできます。

 `set cbrange` の書式に関する詳細は、以下参照: `set xrange`。以下も参照:
 `set palette`, `set colorbox`。
3 cbtics
?commands set cbtics
?commands unset cbtics
?commands show cbtics
?set cbtics
?unset cbtics
?show cbtics
?cbtics
?nocbtics
 コマンド `set cbtics` はカラーボックス軸の (見出し付けされる) 大目盛り
 を制御します。詳細は、以下参照: `set xtics`。
2 シェルコマンド (shell)
?commands shell
?shell
 `shell` コマンドは対話的なシェルを起動します。`gnuplot` に戻るには、
 Unix ならば `exit` もしくは END-OF-FILE 文字を、MS-DOS か OS/2 ならば
 `exit` を入力して下さい。

 コマンド `shell` は、それ以外の gnuplot コマンドライン上のものをすべて
 無視します。そうでなく、シェルに直ちにコマンド文字列を渡したい場合は、
 関数 `system` か、ショートカット `!` を使用してください。以下参照:
 `system`。

 例:

       shell
       system "print previous_plot.ps"
       ! print previous_plot.ps
       current_time = system("date")

2 show
 ほとんどの `set` コマンドには、それに対応する、特別なオプションを持た
 ない show コマンドがあります。例:
      show linetype 3
 は、以下のように、前のコマンドから現在有効な属性を報告します:
      set linetype 3 linewidth 2 dashpattern '.-'
 この形式とは離れる 2, 3 の `show` コマンドについては別に説明します。
3 show colornames
?commands show colornames
?show colornames
?show palette colornames
 gnuplot は 100 程度の色名を持っています (以下参照: `colornames`)。コマ
 ンド `show colornames` を使えば、その出力形式に対する色名の一覧を出力
 できます。
 新しい色名を設定する方法は今はありません。
3 show functions
?commands show functions
?show functions
 `show functions` コマンドはユーザーが定義した関数とその定義内容を表示
 します。

 書式:
       show functions

 gnuplot における関数の定義とその使い方については、以下参照:
 `expressions`。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/spline.html">
 ユーザ定義関数でのスプライン (spline.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 関数と複素変数を翼に使用 (airfoil.dem)。
^ </a>
3 show palette
?commands show palette
?show palette
=palette
 書式:
       show palette
       show palette palette {<ncolors>} {{float | int | hex}}
       show palette gradient
       show palette rgbformulae
       test palette

 コマンド `test palette` は、現在のパレットの R,G,B 成分の対応状態
 (profile) を描画し、その値をデータブロック $PALETTE に残させます。

4 show palette gradient
?commands show palette gradient
?show palette gradient
 `show palette gradient` は、コマンド `set palette defined` で前に定義
 した部分的なグラデーションを表示します。現在のパレットが、rgbformulae
 に基づくか、または前に定義した値の集合に基づく場合は、このコマンドは何
 もしません。

4 show palette palette
?commands show palette palette
?show palette palette
       show palette palette {<ncolors>} {{float | int | hex}}

 `show palette palette <n>` は、現在のパレットの各エントリの色成分の表
 を、画面、または `set print` で指定されたファイルに書き出します。デフ
 ォルトでは、連続なパレットを 128 区切りに標本化します。<ncolors> を指
 定すると、パレットを (128 でなく) その数の区切りに均等に標本化します。
 デフォルトは、以下の長形式での一覧表示です:
      0. gray=0.0000, (r,g,b)=(0.0000,0.0000,0.0000), #000000 =   0   0   0
      1. gray=0.1111, (r,g,b)=(0.3333,0.0014,0.6428), #5500a4 =  85   0 164
      2. gray=0.2222, (r,g,b)=(0.4714,0.0110,0.9848), #7803fb = 120   3 251
      ...
 後にオプションキーワード `float`, `int`, `hex` をつけると、代わりに各
 エントリに一つの色成分表現のみを表示します。
         int:        85       0     164
       float:    0.3333  0.0014  0.6428
         hex:  0x5500a4

 `set print` を使ってこの出力をファイルに書き出すことで、gnuplot の現在
 のカラーパレットを Octave のような他の画像処理アプリケーションに取り込
 むことができます。

 `set print` を使ってこの出力をデータブロックに書き出すことで、現在のパ
 レットを保存できますが、それにより有効なパレットを再定義した後でも、後
 の plot コマンドで保存したパレットを使えるようになります。これは、カラ
 ーボックスがただ現在有効なパレットだけを表現する一方で、複数のパレット
 で描画するグラフを作成することを可能にします。

4 show palette rgbformulae
?commands show palette rgbformulae
?show palette rgbformulae
 `show palette rgbformulae` は、定義済で利用できる、灰色階調値からカラ
 ーへの変換公式を表示します。これは、現在のパレットの状態を表示「しては
 いません。」

3 show plot
?commands show plot
?show plot
 コマンド `show plot` は直前の描画コマンド、すなわち `replot` コマンド
 で再現される、直前に行われた `plot` や `splot` コマンドを表示します。

 さらにコマンド`show plot add2history` は、この現在の描画コマンドを
 `history` に書き出します。これは、`replot` を使って直前の描画コマンド
 に曲線を追加した場合、そしてコマンド行全体をすぐに編集したい場合に便利
 です。
3 show variables
?commands show variables
?show variables all
?show variables
 `show variables` コマンドはユーザ定義変数と内部変数の現在の値の一覧を
 表示します。gnuplot は、GPVAL_, MOUSE_, FIT_, TERM_ で始まる名前を持つ
 変数を内部で定義しています。

 書式:
       show variables      # GPVAL_ で始まるもの以外の変数を表示
       show variables all  # GPVAL_ で始まるものも含め全ての変数を表示
       show variables NAME # NAME で始まる変数のみを表示

2 splot
?commands splot
?splot
 `splot` は 3 次元描画のためのコマンドです (もちろんご存知でしょうが、
 実際にはその 2 次元への射影)。それは、`plot` コマンドの 3 次元版です。
 `splot` は、それぞれ単一の x, y, z 軸を提供するだけで、`plot` で用意さ
 れている第 2 軸 x2, y2 のようなものはありません。

 2 次元と 3 次元描画の両方で使える多くのオプションについては、以下参照:
 `plot`。

 書式:
       splot {<ranges>}
             {<iteration>}
             <function> | {{<file name> | <datablock name>}
                           {datafile-modifiers}}
                        | <voxelgridname>
                        | keyentry
             {<title-spec>} {with <style>}
             {, {definitions{,}} <function> ...}

 コマンド `splot` は、関数から生成されたデータ、またはデータファイルか
 ら読み込んだデータ、または事前に保存された名前付きデータブロックのデー
 タを処理します。データファイル名は、通常引用符で囲んだ文字列として与え
 ます。関数は 1 本の数式ですが、媒介変数モード (parametric) では 3 つの
 数式の組として与えます。

 バージョン 5.4 以降、`splot` はボクセルデータの操作ができます。以下
 参照: `voxel-grids`, `set vgrid`, `vxrange`。有効なボクセル格子データ
 は、スタイル `with dots`, `with points`, `with isosurface` のいずれか
 を使って描画できます。ボクセル格子データ値は、これら以外の描画スタイル
 でも `using` 指定を使えば参照でき、例えば色を割り当てるなどに利用でき
 ます。

 デフォルトでは、`splot` は描画されるデータの下に完全な xy 面を描きます。
 z の一番下の目盛りと xy 平面の位置関係は `set xyplane` で変更できます。
 `splot` の射影の向きは `set view` で制御できます。詳細は、以下参照:
 `set view`, `set xyplane`。

 `splot` コマンドの範囲の指定の書式は `plot` の場合と同じです。媒介変数
 モード (parametric) でなければ、範囲指定は以下の順で、
       splot [<xrange>][<yrange>][<zrange>] ...
 媒介変数モード (parametric) では、範囲指定は以下の順で与えなければいけ
 ません:
       splot [<urange>][<vrange>][<xrange>][<yrange>][<zrange>] ...

 `title` オプションも `plot` と同じです。`with` も `plot` とほぼ同じで
 すが、2 次元の描画スタイル全部が使えるわけではありません。

 `datafile` オプションにはさらに違いがあります。

 媒介変数モード (parametric) や関数を利用して曲面を描く別の方法に、疑似
 ファイル '++' を利用して xy 平面の格子の上に標本点を生成するやり方があ
 ります。

 以下も参照: `show plot`, `set view map`, `sampling`。
3 データファイル (datafile)
?commands splot datafile
?splot datafile
 `plot` と同じように、`splot` でファイルからグラフを生成できます。

 書式:
       splot '<file_name>' {binary <binary list>}
                           {{nonuniform|sparse} matrix}
                           {index <index list>}
                           {every <every list>}
                           {using <using list>}

 `""` や `"-"` といった特別なファイル名も `plot` と同様に許されます。以
 下参照: `special-filenames`。

 キーワード `binary` や `matrix` はそのデータが特別な形であることを、
 `index` は多重データ集合ファイルからどのデータ集合を選んで描画するかを、
 `every` は各データ集合からどの部分行を選んで描画するかを、
 `using` は各データ行からどのように列を選ぶかを指定します。

 `index` と `every` オプションは `plot` の場合と同じように振舞います。
 `using` も、`using` のリストが 2 つでなく 3 つ必要であるということを
 除いては同様です。

 `plot` のオプションである `smooth` は `splot` では利用できません。しか
 し、`cntrparam` や `dgrid3d` が、制限されてはいますが平滑化のために用
 意されています。

 データファイルの形式は、各点が (x,y,z) の 3 つ組である以外は、本質的に
 `plot` と同じです。もし一つの値だけが与えられれば、それは z として使わ
 れ、ブロック番号が y として、そして x はそのブロック内での番号が使われ
 ます。もし 2 つ、あるいは 4 つの値が与えられれば、`gnuplot` はその最後
 の値を pm3d plot での色の計算に使います。3 つの値は (x,y,z) の組と見な
 されます。他に値があれば、それは一般に誤差と見なされます。それは `fit`
 で使うことが可能です。

 `splot` のデータファイルでは、1 行の空行はデータのブロック分離子です。
 `splot` は個々のブロックを、関数の y-孤立線と同じものとして扱います。
 1 行の空行で分離されている点同士は線分で結ばれることはありません。全て
 のブロックが全く同じ点の数を持つ場合、`gnuplot` はブロックを横断し、各
 ブロックの対応する点同士を結ぶ孤立線を描きます。これは "grid data" と
 呼ばれ、曲面の描画、等高線の描画 (`set contour`)、隠線処理
 (`set hidden3d`) では、この形のデータであることが必要となります。以下
 も参照: `splot grid_data`。

4 matrix
?commands plot datafile matrix
?commands splot datafile matrix
?plot datafile matrix
?splot datafile matrix
?binary matrix
?matrix
 テキストファイルやバイナリファイルから、matrix データを色々な形式
 (`uniform`, `nonuniform`, `sparse`) で入力することができます。

 1 つ目の形式は、x, y の座標が一様 (uniform) であると仮定して、その値を
 この一様な格子の matrix のそれぞれの要素 M[i,j] に割り当てる方法です。
 割り当てられる x 座標は [0:NCOLS-1] の範囲の整数です。
 割り当てられる y 座標は [0:NROWS-1] の範囲の整数です。
 これは、テキストデータに対してはデフォルトですが、バイナリデータに対し
 てはそうではありません。
 例や追加キーワードについては以下参照: `matrix uniform`。

 2 つ目の形式は、x, y 座標が明示された非一様 (nonuniform) な格子で、入
 力データの最初の行を y 座標、最初の列を x 座標とみなします。
 バイナリ入力データでは、1 行目の最初の要素は、列数でなければいけません。
 `binary matrix` 入力ではこれがデフォルトですが、テキスト入力データに対
 しては追加キーワード `nonuniform` が必要になります。
 例に関しては以下参照: `nonuniform`。

 `sparse matrix` の形式は一様な格子を定義しますが、その格子内の任意の個
 数のそれぞれの点の値を、入力ファイルから、任意の順の一行に一つのデータ
 として、読み取ります。これは、主に不完全なデータから温度分布図
 (heatmap) を生成する目的のものです。
 例に関しては以下参照: `sparse`。

5 uniform matrix
?commands plot datafile matrix uniform
?commands splot datafile matrix uniform
?datafile matrix uniform
?matrix uniform
?binary matrix uniform
?uniform
 一様 (uniform) な matrix データを描画するコマンドの例:
      splot 'file' matrix using 1:2:3          # テキストデータ
      splot 'file' binary general using 1:2:3  # バイナリデータ

 一様な格子の matrix データでは、各ブロックの z の値は一行で一度に読ま
 れます。すなわち、
     z11 z12 z13 z14 ...
     z21 z22 z23 z24 ...
     z31 z32 z33 z34 ...
 等。

 テキストデータに対しては、1 行目がデータでなく列ラベルを持つ場合、追加
 キーワード `columnheaders` を使ってください。同様に、各行の最初の要素
 がデータでなくラベルである場合は、追加キーワード `rowheaders` を使用し
 てください。以下は、その両方を使用する例です:
     $DATA << EOD
     xxx A   B   C   D
     aa  z11 z12 z13 z14
     bb  z21 z22 z23 z24
     cc  z31 z32 z33 z34
     EOD
     plot $DATA matrix columnheaders rowheaders with image

 テキストデータでは、空行やコメント行は配列データを終了させ、新たなデー
 タブロックを開始します。いつものことですが、`splot` コマンドの `index`
 オプションを使ってファイル内のデータブロックを自由に選択できます。オプ
 ション columnheaders がある場合は、それは最初のデータブロックにのみ適
 用します。
5 nonuniform matrix
?commands plot datafile matrix nonuniform
?commands splot datafile matrix nonuniform
?datafile matrix nonuniform
?matrix nonuniform
?binary matrix nonuniform
?nonuniform
 入力データの最初の行は y 座標を持ちます。
 入力データの最初の列は x 座標を持ちます。
 バイナリ入力データでは、1 行目の最初の要素は列数でなければいけません
 (テキストデータではその番号は無視されます)。

 非一様 (nonuniform) な matrix データを描画するコマンドの例:
      splot 'file' nonuniform matrix using 1:2:3  # テキストデータ
      splot 'file' binary matrix using 1:2:3      # バイナリデータ

 よって、非一様な matrix データの構造は以下のようになります:

       <N+1>  <x0>   <x1>   <x2>  ...  <xN>
        <y0> <z0,0> <z0,1> <z0,2> ... <z0,N>
        <y1> <z1,0> <z1,1> <z1,2> ... <z1,N>
         :      :      :      :   ...    :

 これらは以下のような 3 つの数字の組に変換されます:
       <x0> <y0> <z0,0>
       <x0> <y1> <z0,1>
       <x0> <y2> <z0,2>
        :    :     :
       <x0> <yN> <z0,N>

       <x1> <y0> <z1,0>
       <x1> <y1> <z1,1>
        :    :     :

 そして、これらの 3 つの数字の組は `gnuplot` の孤立線に変換され、その後
 `gnuplot` が通常の方法で描画の残りを行います。
5 sparse matrix
?datafile sparse matrix
?sparse
 書式:
       sparse matrix=(cols,rows) origin=(x0,y0) dx=<delx> dy=<dely>
#TeX \\
 `sparse` な matrix 形式は、`plot` や `splot` のコマンドラインの一部分
 として、一様な格子を定義します。最初は格子は空です。
 その後で入力ファイルから個々の点の値を任意個、一行から一つずつ読み込み、
 それをそれに最も近い格子点に割り当てて行きます。すなわち、データ行の
       x y value
 が、
       i = (x - x0) / delx
       j = (y - y0) / dely
       matrix[i,j] = value
 のように評価されます。
 matrix のサイズは必須です。
 `origin` (オプション) のデフォルトは origin=(0,0) です。
 `dx` (オプション) のデフォルトは dx=1 です。
 `dy` (オプション) のデフォルトは dy=dx です。

 この形式は、順序がバラバラで、不完全であってもよいデータから `image`,
 `rgbimage`, `rgbalpha` 描画スタイルなどを用いて温度分布図 (heatmap) を
 生成するのが本来の使用目的です。以下の例は、与えらえた上三角成分のみか
 ら 4x4 の温度分布図の形式の離散 matrix を生成します。
Ffigure_sparsematrix
       $DATA << EOD
       1 1 10
       1 2 20
       1 3 30
       1 4 40
       2 2 10
       2 3 50
       2 4 60
       3 3 10
       3 4 20
       4 4 10
       EOD
       plot $DATA sparse matrix=(4,4) origin=(1,1) with image

5 every
?datafile matrix every
?matrix every
 キーワード `every` は、matrix データに対して使用すると特別な意味を持ち
 ます。データの点やブロックに適用するのでなく、データの行、列に適用しま
 す。matrix データの行と列の番号は、0 から始まり、よって番号 N の列は、
 (N+1) 番目であることに注意してください。
 書式:
       plot 'file' every {<column_incr>}
                           {:{<row_incr>}
                             {:{<start_column>}
                               {:{<start_row>}
                                 {:{<end_column>}
                                   {:<end_row>}}}}}
 例:
       plot 'file' matrix every :::N::N   # N 番の行のすべての値を描画
       plot 'file' matrix every ::3::7    # すべての行の 3-7 列を描画
       plot 'file' matrix every ::3:0:7:4 # [3,0], [7,4] 枠の部分行列
5 examples
?commands plot datafile matrix examples
?commands splot datafile matrix examples
?datafile matrix examples
?matrix examples
?binary matrix examples
 行列やベクトルの操作のサブルーチン (C による) が `binary.c` に用意され
 ています。バイナリデータを書くルーチンは

       int fwrite_matrix(file,m,nrl,nrl,ncl,nch,row_title,column_title)

 です。これらのサブルーチンを使う例が `bf_test.c` として用意されていて、
 これはデモファイル `demo/binary.dem` 用に複数のバイナリファイルを生成
 します。

 `plot` での使用法:
     plot 'a.dat' matrix
     plot 'a.dat' matrix using 1:3
     plot 'a.gpbin' {matrix} binary using 1:3
 これらは配列の行を描画し、using 2:3 とすれば配列の列を描画、using 1:2
 は、点の座標を描画します (多分無意味です)。オプション `every` を適用す
 ることで明示的に行や列を指定できます。

 例 -- テキストデータファイルの配列の軸の拡大:
     splot `a.dat` matrix using (1+$1):(1+$2*10):3

 例 -- テキストデータファイルの配列の第 3 行の描画:
     plot 'a.dat' matrix using 1:3 every 1:999:1:2
 (行は 0 から数えられるので、3 ではなくて 2 を指定します)。

 Gnuplot は、`array`, `record`, `format`, `filetype` などの general バ
 イナリ形式を特定するようなキーワードをつけずにオプション `binary` を使
 うことで、matrix バイナリファイルを読み込むことができます。その他の変換
 用の general バイナリキーワードは、matrix バイナリファイルにも適用でき
 るでしょう。(詳細は、以下参照: `binary general`)
4 データファイルの例
?commands splot datafile example
?splot datafile example
?splot example
 以下は3 次元データファイルの描画の単純な一つの例です。

       splot 'datafile.dat'

 ここで、"datafile.dat" は以下を含むとします:

       # The valley of the Gnu.
          0 0 10
          0 1 10
          0 2 10

          1 0 10
          1 1 5
          1 2 10

          2 0 10
          2 1 1
          2 2 10

          3 0 10
          3 1 0
          3 2 10

 この "datafile.dat" は 4*3 の格子 (それぞれ 3 点からなるブロックの
 4 つの行) を定義することに注意して下さい。行 (ブロック) は 1 行の空行
 で区切られます。

 x の値はそれぞれのブロックの中で定数になっていることに注意して下さい。
 もし y を定数の値とし、隠線処理が有効な状態で描画すると、その曲面は裏
 返しで書かれることになります。

 格子状データ (grid data) に対して、個々のブロック内で x の値を定数とし
 ておく必要はありませんし、同じ場所の y の値を同じ値に揃えておく必要も
 ありません。`gnuplot` は個々のブロック内の点の数が等しいということを必
 要としているだけです。しかし、等高線を導くのに用いられる曲面の網目は、
 対応する点を列的に選んで結ぶため、不揃いの格子データに対する曲面の描画
 への影響は予想できません。それはケースバイケースの原理でテストすべきで
 しょう。
3 格子状データ (grid data)
?commands splot grid_data
?splot grid_data
?grid_data
 3 次元描画のためのルーチンは、個々の網目の格子においては一つの標本点と
 一つのデータ点がある、という形の格子状データ用に設計されています。各デ
 ータ点は、関数の値を評価すること (以下参照: `set isosamples`)、または
 データファイルを読み込むこと (以下参照: `splot datafile`) によって生成
 されます。"孤立線" という言葉は関数に対しても、データに対してもその網
 目の線を表すものとして用いられます。網目は、必ずしも x, y に関する長方
 形でなくてもよく、u,v で媒介変数表示されても構わないことに注意して下さ
 い。以下参照: `set isosamples`。

 しかし、`gnuplot` はそのような形式を必ずしも必要とはしません。例えば関
 数の場合は、`samples` は `isosamples` と違っていても構いません。すなわ
 ち、x-孤立線のうち、1 本の y-孤立線と交わないものがいくつかあることが
 あります。データファイルの場合は、個々のブロックのばらついた点の個数が
 全て同じであれば、"孤立線は" はブロックの点を結び、"横断孤立線" は各ブ
 ロックの対応する点同士を結び、"曲面" を作ろうとします。どちらの場合で
 も、等高線、および隠線処理モードは点が意図したフォーマットであった場合
 とは違った描画を与えることになります。

 ばらつきのあるデータは、描画前に格子に合わせることが可能です。以下参照:
 `set dgrid3d`。

 等高線に関するコードは、y-孤立線の点と、それに対応する隣の y-孤立線上
 の点の間の線分に沿っての z の張力を計測します。よって、x-孤立線に、
 y-孤立線との交点とはならないような標本点があるような曲面に対しては、
 `splot` の等高線はそのような標本点を無視することになります。以下を試して
 みて下さい:
        set xrange [-pi/2:pi/2]; set yrange [-pi/2:pi/2]
        set style function lp
        set contour
        set isosamples 10,10; set samples 10,10;
        splot cos(x)*cos(y)
        set samples 4,10; replot
        set samples 10,4; replot

3 splot の曲面 (splot surfaces)
?commands splot surfaces
?splot surfaces
 `splot` は点の集まりとして、あるいは、それらの点を結ぶことによって曲面
 を表示することができます。`plot` と同様に、点はデータファイルから読む
 こともできますし、指定された区間で関数の値を評価して得ることもできます。
 以下参照: `set isosamples`。曲面は、各点を線分で結ぶことで近似的に作ら
 れます。以下参照: `set surface`。そしてその場合曲面は、`set hidden3d`
 で不透明にもできます。3 次元曲面を眺める向きは、`set view` で変更でき
 ます。

 さらに、格子状のデータ点に対しては、`splot` は同じ高さを持つ点を補間す
 ることができ (以下参照: `set contour`)、そしてそれらを結んで等高線を描
 くことができます。さらに、その結び方には真直な線分や滑らかな線を使うこ
 とができます (以下参照: `set cntrparam`)。関数は、常に `set isosamples`
 と `set samples` で決定される格子状データとして評価されます。一方、フ
 ァイルのデータは、`data-file` に書かれているような格子状データフォーマ
 ットにするか、あるいは格子データを生成する (以下参照: `set dgrid3d`)
 ということをしなければそうはなりません。

 等高線は曲面の上に表示することもできますし、底面に射影することもできま
 す。底面への射影は、ファイルに書き出すこともでき、そしてそれを `plot`
 で再び読み込んで `plot` のより強い整形能力を生かすこともできます。
3 ボクセル格子データ (voxel-grid)
?commands splot voxel-grid
?splot voxel-grids
?voxel-grids
 書式:
      splot $voxelgridname with {dots|points} {above <threshold>} ...
      splot $voxelgridname with isosurface {level <threshold>} ...

 ボクセルデータは、指定した閾値 (threshold; デフォルトは 0) よりも大き
 い値の個々のボクセルに印を付けるように、with dots か with points で描
 画できます。色、点種、線幅の属性は、通常と同様に追加指定できます。

 多くの視方向に対して、ボクセル格子点は、ディスプレイ上で互いを隠したり
 モアレを生成したりします。それらの副作用は、jitter を導入してドットや
 点を実際のボクセル格子座標からランダムにずらすことで避けることが可能で
 す。以下参照: `set jitter`。

 密なボクセル格子は、`pointinterval` 属性 (省略形 `pi`) を使うことで、
 点の数を減らすよう標本化レベルを下げることが可能です。
      splot $vgrid with points pointtype 6 pointinterval 2

 `with isosurface` は、指定された閾値より大きいボクセル全体を包む、3 次
 元モザイク型曲面を生成します。この曲面は、閾値それ自体を通過するよう、
 線形補間により調整されて配置されます。

 以下参照: `set vgrid`, `vfill`。
 以下のデモも参照してください: `vplot.dem`, `isosurface.dem`。

2 stats (簡単な統計情報)
?commands stats
?stats
?statistics
=filter
 書式:
      stats {<ranges>} 'filename' {matrix | using N{:M}} {name 'prefix'}
            {{no}output}
      stats $voxelgridname {name 'prefix'}

 このコマンドは、ファイルの 1 列、または 2 列のデータの簡単な統計情報を
 提供します。using 指定子は、plot コマンドと同じ形で解釈されますが、
 `index`, `every`, `using` 指定に関する詳細については以下参照: `plot`。
 データ点は、その解析の前に xrange, yrange に従ってフィルタにかけられま
 す。以下参照: `set xrange`。その情報はデフォルトではスクリーンに出力さ
 れますが、コマンド `set print` を先に使うことで出力をファイルにリダイ
 レクトしたり、オプション `nooutput` を使うことで出力しないようにするこ
 ともできます。

 ファイルが見つからない、あるいはファイルから読み込めない場合は、致命的
 ではない警告を発行します。これは、プログラムエラーを伴わないファイルの
 存在確認に利用できます。以下参照: `stats test`。

 画面出力に加え、gnuplot は個々の統計情報を 3 つの変数グループに保存し
 ます。
 1 番目の変数グループは、どんなデータが並んでいるかを示しますが、先頭行
 の配列は、`set datafile columnheaders` が有効な場合にのみ作成されます:
@start table
      STATS_records           # 範囲内のデータ行の総数 N
      STATS_outofrange        # 範囲外として除かれた行数
      STATS_invalid           # 無効/不完全/欠損データ行の総数
      STATS_blank             # 空行の総数
      STATS_blocks            # ファイル内のデータの index ブロック数
      STATS_columns           # データ先頭行の列数
      STATS_column_header     # 先頭行に見つかった文字列を保持する配列
#\begin{tabular}{|lcl|} \hline
#\verb@STATS_records@      & $~~N~~$  &  範囲内のデータ行の総数 $N$ \\
#\verb@STATS_outofrange@   & $~~~~~$  &  範囲外として除かれた行数 \\
#\verb@STATS_invalid@      & $~~~~~$  &  無効/不完全/欠損データ行の総数 \\
#\verb@STATS_blank@        & $~~~~~$  &  空行の総数 \\
#\verb@STATS_blocks@       & $~~~~~$  &  ファイル内のデータの index ブロック数 \\
#\verb@STATS_columns@      & $~~~~~$  &  データ先頭行の列数 \\
#\verb@STATS_column_header@& $~~~~~$  &  先頭行に見つかった文字列を保持する配列 \\
%l l .
%変数@説明
%_
%STATS_records@範囲内のデータ行の総数 N
%STATS_outofrange@範囲外として除かれた行数
%STATS_invalid@無効/不完全/欠損データ行の総数
%STATS_blank@空行の総数
%STATS_blocks@ファイル内のデータの index ブロック数
%STATS_columns@データ先頭行の列数
%STATS_column_header@先頭行に見つかった文字列を保持する配列
@end table

 2 番目の変数グループは、1 つの列の、範囲内のデータの性質を示します。こ
 の列は y の値として扱われます。y 軸が自動縮尺の場合は、対象とする範囲
 に限界はありませんが、そうでなければ範囲 [ymin:ymax] 内の値のみを対象
 とします。

 2 つの列を同時に 1 回の `stats` コマンドで解析する場合は、各変数名に
 "_x", "_y" という接尾辞を追加します。例えば STATS_min_x は、1 つ目の列
 のデータの最小値で、STATS_min_y は 2 つ目の列のデータの最小値を意味し
 ます。この場合、点は xrange と yrange の両方で検査することでふるいにか
 けます。

@start table
      STATS_min               # 範囲内のデータ点の最小値
      STATS_max               # 範囲内のデータ点の最大値
      STATS_index_min         # data[i] == STATS_min となる添字 i
      STATS_index_max         # data[i] == STATS_max となる添字 i
      STATS_lo_quartile       # 第一 (下の) 四分位境界値
      STATS_median            # メジアン値 (第二四分位境界値)
      STATS_up_quartile       # 第三 (上の) 四分位境界値
      STATS_mean              # 範囲内のデータ点の平均値
      STATS_ssd               # 範囲内のデータ点の不偏標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / (N-1) )
      STATS_stddev            # 範囲内のデータ点の標本標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / N )
      STATS_sum               # 和
      STATS_sumsq             # 平方和
      STATS_skewness          # 範囲内のデータ点の歪度
      STATS_kurtosis          # 範囲内のデータ点の尖度
      STATS_adev              # 範囲内のデータ点の平均絶対偏差
      STATS_mean_err          # 平均値の標準誤差
      STATS_stddev_err        # 標準偏差の標準誤差
      STATS_skewness_err      # 歪度の標準誤差
      STATS_kurtosis_err      # 尖度の標準誤差
#\begin{tabular}{|lrll|} \hline
#\verb@STATS_min@ && $\min(y)$ &  範囲内のデータ点の最小値 \\
#\verb@STATS_max@ && $\max(y)$ &  範囲内のデータ点の最大値 \\
#\verb@STATS_index_min@ && $i \mid y_i = \min(y)$ &  data[i] == STATS\_min となる添字 i \\
#\verb@STATS_index_max@ && $i \mid y_i = \max(y)$ &  data[i] == STATS\_max となる添字 i \\
#\verb@STATS_mean@ & $\bar{y}=$ & $\frac{1}{N}\sum{y}$ &  範囲内のデータ点の平均値 \\
#\verb@STATS_stddev@ & $\sigma_y=$ & $\sqrt{\frac{1}{N}{\sum{{(y-\bar{y})}^2}}}$ &  範囲内のデータ点の標本標準偏差 \\
#\verb@STATS_ssd@ & $s_y=$ & $\sqrt{\frac{1}{N-1}{\sum{{(y-\bar{y})}^2}}}$ &  範囲内のデータ点の不偏標準偏差 \\
#\verb@STATS_lo_quartile@ && ~ &  第一 (下の) 四分位境界値 \\
#\verb@STATS_median@ && ~ &  メジアン値 (第二四分位境界値) \\
#\verb@STATS_up_quartile@ && ~ &  第三 (上の) 四分位境界値 \\
#\verb@STATS_sum@ && $\sum{y}$ &  和 \\
#\verb@STATS_sumsq@ && $\sum{y^2}$ &  平方和 \\
#\verb@STATS_skewness@ && $\frac{1}{N\sigma^3}\sum{(y-\bar{y})^3}$ &  範囲内のデータ点の歪度 \\
#\verb@STATS_kurtosis@ && $\frac{1}{N\sigma^4}\sum{(y-\bar{y})^4}$ &  範囲内のデータ点の尖度 \\
#\verb@STATS_adev@ && $\frac{1}{N}\sum{|{y}-\bar{y}|}$ &  範囲内のデータ点の平均絶対偏差 \\
#\verb@STATS_mean_err@ && $\sigma_y / \sqrt{N}$ &  平均値の標準誤差 \\
#\verb@STATS_stddev_err@ && $\sigma_y / \sqrt{2N}$ &  標準偏差の標準誤差 \\
#\verb@STATS_skewness_err@ && $\sqrt{6/N}$ &  歪度の標準誤差 \\
#\verb@STATS_kurtosis_err@ && $\sqrt{24/N}$ &  尖度の標準誤差 \\
%l c l .
%変数@ @説明
%_
%STATS_min@$min ( y )$@範囲内のデータ点の最小値
%STATS_max@$max ( y )$@範囲内のデータ点の最大値
%STATS_index_min@$i~|~y sub i = min ( y )$@data[i] == STATS_min となる添字 i
%STATS_index_max@$i~|~y sub i = max ( y )$@data[i] == STATS_max となる添字 i
%STATS_lo_quartile@ @第一 (下の) 四分位境界値
%STATS_median@ @メジアン値 (第二四分位境界値)
%STATS_up_quartile@ @第三 (上の) 四分位境界値
%STATS_mean@$y bar = 1 over N sum y$@範囲内のデータ点の平均値
%STATS_ssd@$sigma sub y = sqrt { 1 over { N - 1 } sum { ( y - y bar ) sup 2  } }$範囲内のデータ点の不偏標準偏差
%STATS_stddev@$s sub y = sqrt { 1 over N sum { ( y - y bar ) sup 2 } }$@範囲内のデータ点の標本標準偏差
%STATS_sum@$sum y$@和
%STATS_sumsq@$sum y sup 2$@平方和
%STATS_skewness@$1 over { N  sigma sup 3} sum { left ( y - y bar right ) sup 3}$@範囲内のデータ点の歪度
%STATS_kurtosis@$1 over { N  sigma sup 4} sum { left ( y - y bar right ) sup 4}$@範囲内のデータ点の尖度
%STATS_adev@$1 over N sum | y - y bar |$@範囲内のデータ点の平均絶対偏差
%STATS_mean_err@$sigma sub y / sqrt N$@平均値の標準誤差
%STATS_stddev_err@$sigma sub y / sqrt { 2 N }$ @標準偏差の標準誤差
%STATS_skewness_err@$sqrt { 6 / N }$@歪度の標準誤差
%STATS_kurtosis_err@$sqrt { 24 / N }$@尖度の標準誤差
@end table

 3 番目の変数グループは、2 つの列のデータの解析専用です。
@start table
      STATS_correlation       # x と y の不偏相関係数
      STATS_slope             # 回帰直線 y = Ax + B の係数 A
      STATS_slope_err         # A の不確かさ
      STATS_intercept         # 回帰直線 y = Ax + B の係数 B
      STATS_intercept_err     # B の不確かさ
      STATS_sumxy             # 積和 (x*y の和)
      STATS_pos_min_y         # y の最小値を与える x 座標
      STATS_pos_max_y         # y の最大値を与える x 座標
#\begin{tabular}{|lll|} \hline
#\verb@STATS_correlation@ &   &  x と y の不偏相関係数 \\
#\verb@STATS_slope@       &   &  回帰直線 y = Ax + B の係数 A \\
#\verb@STATS_slope_err@   &   &  A の不確かさ \\
#\verb@STATS_intercept@   &   &  回帰直線 y = Ax + B の係数 B \\
#\verb@STATS_intercept_err@ &   &  B の不確かさ \\
#\verb@STATS_sumxy@       &   &  積和 (x*y の和) \\
#\verb@STATS_pos_min_y@   &   &  y の最小値を与える x 座標 \\
#\verb@STATS_pos_max_y@   &   &  y の最大値を与える x 座標 \\
%l l .
%変数@説明
%_
%STATS_correlation@x と y の不偏相関係数
%STATS_slope@回帰直線 $y = A x + B$ の係数 A
%STATS_slope_err@A の不確かさ
%STATS_intercept@回帰直線 $y = A x + B$ の係数 B
%STATS_intercept_err@B の不確かさ
%STATS_sumxy@積和 ($x times y$ の和),  $sum x~y$
%STATS_pos_min_y@y の最小値を与える x 座標
%STATS_pos_max_y@y の最大値を与える x 座標
@end table

 キーワード `matrix` は、入力が行列形式であることを指示します (以下参照:
 `matrix`)。通常の統計情報は、すべての行列要素を考慮して生成します。行
 列のサイズは、変数 STATS_size_x, STATS_size_y に保存します。
@start table
      STATS_size_x            # 行列の列数
      STATS_size_y            # 行列の行数
#\begin{tabular}{|lll|} \hline
#\verb@STATS_size_x@ &   &  行列の列数 \\
#\verb@STATS_size_y@ &   &  行列の列数 \\
%l l .
%Variable@Description
%STATS_size_x@行列の列数
%STATS_size_y@行列の行数
@end table

 STATS_index_xxx で示される添字の値は、plot コマンドの第 0 疑似列 ($0)
 の値に対応し、最初の点は添字は 0、最後の点の添字は N-1 となります。

 メジアンと四分位境界値を探す際はデータの値をソートし、点の総数 N が奇
 数の場合は、その (N+1)/2 番目の値をメジアン値とし、N が偶数の場合は、
 N/2 番目と (N+2)/2 番目の値の平均値をメジアン値とします。四分位境界値
 も同様に処理します。

 その後の描画に注釈をつけるためにコマンド `stats` を利用した例について
 は、以下を参照してください。
^ <a href="http://www.gnuplot.info/demo/stats.html">
 stats.dem。
^ </a>

 現在のバージョンの gnuplot の `stats` コマンドでは、日時フィールド
 (`set xdata time` や `set ydata time`) でなければ対数軸のデータも処理
 できます。この制限は、将来のバージョンで緩和されるでしょう。
3 接頭辞名 (name)
?stats name
?statistics name
 2 つ以上のファイルやデータ列からの統計情報を並列に扱うことができれば便
 利ですので、変数のデフォルトの接頭辞である "STATS" を、オプション
 `name` でユーザが指定する文字列に置き換えることができるようになってい
 ます。例えば、異なる 2 つのファイルのそれぞれの 2 列目のデータの平均値
 は以下のようにして比較できます:
      stats "file1.dat" using 2 name "A"
      stats "file2.dat" using 2 name "B"
      if (A_mean < B_mean) {...}

=columnheader
 name として文字列定数を用意する代わりに、キーワード `columnheader` や
 関数 `columnheader(N)` により、データファイルの 1 行目から取得した任意
 の文字列から接頭辞を生成することもできます:
      do for [COL=5:8] { stats 'datafile' using COL name columnheader }
3 ファイルの存在確認 (test for existence of a file)
?stats test
?statistics test
 存在しない、あるいは読み込めないファイルを描画しようとすると、それはエ
 ラーとなり、スクリプトや繰り返しの先を停止してしまいます。それを避ける
 には、以下の例のように stats コマンドが利用できます。
      do for [i=first:last] {
          filename = sprintf("file%02d.dat", i)
          stats filename nooutput
          if (GPVAL_ERRNO) {
              print GPVAL_ERRMSG
              continue
          }
          plot filename title filename
      }
3 voxelgrid
?stats voxelgrid
?statistics voxelgrid
      stats $vgridname {name "prefix"}
 コマンド stats は、ボクセル格子の内容を問い合わせるのにも使えます。こ
 れは、`show vgrid` と同じ情報を生成しますが、これはそれをスクリプトで
 利用できる変数に保存できます。

@start table
      STATS_min               # 格子のすべてのボクセルの 0 でない最小値
      STATS_max               # 格子のすべてのボクセルの最大値
      STATS_mean              # 格子の 0 でないボクセルの平均値
      STATS_stderr            # 0 でないボクセル値の標準偏差
      STATS_sum               # 格子のすべてのボクセルの和
      STATS_nonzero           # 0 でないボクセル数
#\begin{tabular}{|lll|} \hline
#\verb@STATS_min@ &   &  格子のすべてのボクセルの 0 でない最小値 \\
#\verb@STATS_max@       &   &  格子のすべてのボクセルの最大値 \\
#\verb@STATS_mean@   &   &  格子の 0 でないボクセルの平均値 \\
#\verb@STATS_stddev@   &   &  0 でないボクセル値の標準偏差 \\
#\verb@STATS_ssum@   &   &  格子のすべてのボクセルの和 \\
#\verb@STATS_nonzero@ &   &  0 でないボクセル数 \\
%l l .
%Variable@Description
%_
%STATS_min@格子のすべてのボクセルの 0 でない最小値
%STATS_max@格子のすべてのボクセルの最大値
%STATS_mean@格子の 0 でないボクセルの平均値
%STATS_stddev@0 でないボクセル値の標準偏差
%STATS_sum@格子のすべてのボクセルの和
%STATS_nonzero@0 でないボクセル数
@end table

2 system
?commands system
?system
 書式:
       system "command string"
       ! command string
       output = system("command string")
       show variable GPVAL_SYSTEM

 `system "command"` は、オペレーティングシステムのデフォルトシェルを呼
 び出し、そのサブプロセスとして "command" を実行します。関数として
 `system("command")` を呼び出した場合は、そのサブプロセスの標準出力から
 の文字ストリームを文字列として返します。最後に改行がついている場合は、
 それは結果文字列からは除去されます。以下も参照: `backquotes`。

 そのサブプロセスの終了コードは、変数 GPVAL_SYSTEM_ERRNO と
 GPVAL_SYSTEM_ERRMSG に保存されます。しかし、もしコマンド文字列が 2 つ
 以上のプログラムを呼び出している場合は、そのうちの一つのプログラムがエ
 ラーを出しても、"成功" を返す可能性があることに注意してください。例え
 ば、file = system("ls -1 *.plt | tail -1") は、*.plt ファイルが一つも
 ない場合でも "成功" が返ります。それは、`ls` が失敗しても `tail` は成
 功するからです。

2 test
?commands test
?test palette
?test
 このコマンドは、出力形式やパレットでどのような出力が行なえるかを画像で
 テストし表示します。

 書式:
       test {terminal | palette}

 `test` または `test terminal` は、現在使用中の出力形式 (`terminal`) で
 使える線の種類、点の種類、または利用可能なその他の描画を生成します。

 `test palette` は、R(z),G(z),B(z) (0<=z<=1) の状態を描画します。これら
 は、`set palatte` で定義した現在のカラーパレットの RGB 成分を示します。
 また、RGB を灰色階調に写像する NTSC 係数を用いて計算された視光度も描画
 します。さらにこのコマンドはこの対応関係を $PALETTE という名前のデータ
 ブロックに取り込みます。
D viridis 1
2 toggle
?commands toggle
?toggle
 書式:
       toggle {<plotno> | "plottitle" | all}

 このコマンドは、対話型出力形式 (qt, wxt, x11) で表示されているグラフの
 key エントリ上で左クリックしたのと同じ効果を与えます。すなわち、そのグ
 ラフが表示されていればそれを消し、グラフが消えていれば再び表示します。
 `toggle all` は、ホットキー "i" と同様、有効なグラフすべてに作用します。
 `toggle "title"` の形式は、グラフのタイトルと完全に一致するタイトルを
 指定する必要がありますが、`toggle "ti*"` の場合は、グラフのタイトルと
 '*' の前の部分が一致する最初のグラフに作用します。現在の出力形式が対話
 型でない場合は、コマンド toggle は何もしません。
2 undefine
?commands undefine
?undefine
 1 つ、または複数の定義済みのユーザ変数を削除します。これは、初期化テス
 トを含むようなスクリプトの状態をリセットするのに便利でしょう。

 変数名には、最後の文字としてワイルドカード文字 `*` を使うことができま
 す。ワイルドカード文字が見つかると、それより前の部分で始まるすべての変
 数を削除します。これは、共通の接頭語を使っている複数の変数を削除するの
 に便利でしょう。ただし、ワイルドカード文字は変数名の最後にしか使えない
 ことに注意してください。`undefine` にワイルドカード文字のみを引数とし
 て与えた場合は何もしません。

 例:

       undefine foo foo1 foo2
       if (!exists("foo")) load "initialize.gp"

       bar = 1; bar1 = 2; bar2 = 3
       undefine bar*                 # 3 つの変数を全部削除

2 unset
?commands unset
?unset
=iteration
 コマンド `set` で設定したオプションは、それに対応した `unset` コマンド
 によってそのデフォルトの値に戻すことが可能です。`unset` コマンドには繰
 り返し節も利用できます。以下参照: `plot for`。

 例:
       set xtics mirror rotate by -45 0,10,100
       ...
       unset xtics

       # 番号 100 から 200 までのラベルを unset
       unset for [i=100:200] label i
3 linetype
?unset linetype
 書式:
       unset linetype N
 以前に単一の線種に割り当てたすべての特性を削除します。この後にこの線種
 を使用した場合、特性、色は現在の出力形式にデフォルトで設定されているも
 のを使用します (すなわち gnuplot 4.6 より前のバージョンで有効だった、
 いわゆるデフォルトの線種)。
3 monochrome
?unset monochrome
 現在有効な白黒の線種をカラーの線種に切り替えます。`set color` と同等で
 す。
3 output
?unset output
 複数のグラフを一つの出力ファイルに書き出すことができる出力形式もあるの
 で、描画の後で出力ファイルを自動的には閉じません。よってそのファイルを
 安全に印刷等をするためには、まず明示的に `unset out` や `set output`
 とすることで前のファイルを閉じた上で新しいファイルを開いてください。
3 terminal
?unset terminal
 プログラムの最初に有効になるデフォルトの出力形式は、個々のシステム環境、
 gnuplot のコンパイルオプション、および環境変数 GNUTERM に依存します。
 そのデフォルトが何であっても、gnuplot はそれを内部変数 GNUTERM に保存
 しています。コマンド `unset terminal` は、その初期初期出力形式に復帰し、
 これは、`set terminal GNUTERM` とすることと同じです。しかし、GNUTERM
 が出力形式名の後に terminal オプションも含んでいる場合は、その代わりに
 `set terminal @GNUTERM` とする必要があります。
3 warnings
?unset warnings
?set warnings
 警告メッセージ (致命的なエラーではない) は、通常はその警告を引き起こす
 コマンドラインをエコーした後で stderr に出力されます。この警告は、コマ
 ンド `unset warnings` で抑制でき、明示的に `set warnings` で有効にされ
 るまで抑制され続けます。
2 update
?commands update
?update
 注意: このコマンドは「非推奨」です。代わりに `save fit` を使用してくだ
 さい。
2 vclear
?commands vclear
?vclear
 書式:
      vclear {$gridname}
 これは、存在するボクセル格子内のすべてのボクセル値を 0 にリセットしま
 す。格子名を指定しない場合、現在有効な格子をクリアします。
2 vfill
?commands vfill
?vfill
?vgfill
=VoxelDistance
?VoxelDistance
=GridDistance
?GridDistance
 書式:
      vfill  FILE using x:y:z:radius:(<expression>)
      vgfill FILE using x:y:z:radius:(<expression>)

 コマンド `vfill` は、それがグラフを生成する代わりに現在有効なボクセル
 格子データを変更する以外は、コマンド `plot` と同様に作用します。入力フ
 ァイルから読み込んだ各点に対して、その点を含むボクセル、及び中心が
 (x,y,z) で指定半径 (radius) の球に含まれるその他すべてのボクセルが以下
 のように増やされます:
#start
#b (x,y,z) からそのボクセルのユーザ座標での原点 (vx,vy,vz) までの距離を
## ユーザ変数 VoxelDistance にセットします。
#b (x,y,z) からそのボクセルの格子座標での原点までの距離をユーザ変数
## GridDistance にセットします。
#b `using` 指定の 5 番目に指定した数式を評価します。この数式は、新しい
## VoxelDistance や GridDistance の値を使用できます。
#b voxel(vx,vy,vz) += その数式 <expression> の評価結果
#end
 例:
      vfill "file.dat" using 1:2:3:(3.0):(1.0)
 このコマンドは、file.dat 内の各点の半径 3.0 の球の中にあるすべてのボク
 セル値を 1 増やします。この球と重なるボクセルの個数は、ユーザ座標での
 格子の間隔に依存します。

      vgfill "file.dat" using 1:2:3:(2):(1.0)
 このコマンドは、現在の点を中心とするボクセルの 5x5x5 の立方体内のボク
 セルの値を 1 増やします。半径の "2" は、x の両方向、y の両方向、z の両
 方向に丁度 2 ボクセルずつ広げることと解釈し、これはそれらの軸に関する
 ユーザ座標の相対的なスケールとは無関係です。

 例:
      vfill "file.dat" using 1:2:3:4:(VoxelDistance < 1 ? 1 : 1/VoxelDistance)
 このコマンドは、各点の 4 列目で決まる半径の円内のすべてのボクセル値を
 変更します。各ボクセルに追加される増分値は、データ点からの距離に従って
 減少します。

 `vfill` と `vgfill` は、現在のボクセル格子の存在する値を常に増加させる
 ことに注意してください。
 ボクセル一つを 0 にリセットするには、`voxel(x,y,z) = 0` を使用し、
 すべての格子を 0 にリセットするには、`vclear` を使用してください。
2 While
?while
?commands while
 書式:
       while (<expr>) {
           <commands>
       }
 これは、コマンドのブロックを、<expr> が 0 でない値と評価される間、繰り
 返し実行します。このコマンドは、古い形式 (かっこなし) の if/else 構文
 と一緒に使うことはできません。以下も参照: `do`, `continue`, `break`。
1 出力形式 (Terminal)
^ <h2> Terminal Types </h2>
2 出力形式の一覧
?complete list of terminals
?terminal
?term
 gnuplot はとても多くの出力形式をサポートしています。これらは、適切な
 出力形式を、必要なら機能を変更する追加オプションをつけて選択すること
 により設定されます。以下参照: `set terminal`。

 この文書は、あなたのシステム上で初期設定およびインストールがなされなか
 ったために利用できない出力形式についても記述されているかも知れません。
 `legacy` (古い) と印のついた出力形式は、最近のバージョンの gnuplot で
 はデフォルトではビルドされず、実際には使用できないかもしれません。
 個々の gnuplot 対話形式実行時に、どの出力形式が有効なのかの一覧を見る
 には、オプションを何もつけずに 'set terminal' と打ってください。

 (訳注: この日本語訳に含まれる terminal のマニュアルは、その一覧にはな
 い出力形式のものも含まれているかもしれませんし、逆にその一覧内の出力形
 式でマニュアルがないものもあるかもしれません。)

 TeX/LaTeX 文書システムでの使用のために設計された出力形式がいくつかあり
 ます。TeX 用の出力形式に関する要約が以下にあります:
^ <a href="http://www.gnuplot.info/docs/latex_demo.pdf">
           http://www.gnuplot.info/docs/latex_demo.pdf
^ </a>

<3 -- 全ての出力ドライバの項目は、.trm ファイルから引っ張って来られます。
