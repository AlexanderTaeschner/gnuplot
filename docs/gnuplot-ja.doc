C RCS $Id: gnuplot-ja.doc,v 1.290 2009-05-19 17:16:15+09 shige Exp $
C corresponding original gnuplot.doc revision: 1.568
C
C Copyright (C) 1986 - 1993, 1998, 1999, 2000, 2001, 2004   Thomas Williams, Colin Kelley et al.
C
C Japanese translation: Hiroharu Tamaru (2.0, 3.2), MASUTANI Yasuhiro (3.5),
C Shigeharu Takeno et al (3.7, 4.X)
^ <h2> An Interactive Plotting Program </h2><p>
^ <h2>  Thomas Williams & Colin Kelley</h2><p>
^ <h2>  Version 4.2 organized by Hans-Bernhard Broeker and others</h2><p>
^ <h2>Major contributors (alphabetic order):</h2>
^<ul><h3>
^<li>  Hans-Bernhard Broeker
^<li>  John Campbell
^<li>  Robert Cunningham
^<li>  David Denholm
^<li>  Gershon Elber
^<li>  Roger Fearick
^<li>  Carsten Grammes
^<li>  Lucas Hart
^<li>  Lars Hecking
^<li>  Thomas Koenig
^<li>  David Kotz
^<li>  Ed Kubaitis
^<li>  Russell Lang
^<li>  Alexander Lehmann
^<li>  Alexander Mai
^<li>  Ethan A Merritt
^<li>  Petr Mikulik
^<li>  Carsten Steger
^<li>  Tom Tkacik
^<li>  Jos Van der Woude
^<li>  Alex Woo
^<li>  James R. Van Zandt
^<li>  Johannes Zellner
^</h3></ul> <p>
^<h2>  Copyright (C) 1986 - 1993, 1998 - 2004   Thomas Williams, Colin Kelley<p>
^   Mailing list for comments: gnuplot-info@lists.sourceforge.net <p>
^   Mailing list for bug reports: gnuplot-bugs@lists.sourceforge.net <p>
^</h2><p>
^<h3> This manual was originally prepared by Dick Crawford</h3><p>
^<h3> Last revised: March 2009</h3><p>
^<hr>
1 gnuplot
2 著作権 (Copyright)
?copyright
?license
     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 Permission to use, copy, and distribute this software and its
 documentation for any purpose with or without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.

 Permission to modify the software is granted, but not the right to
 distribute the complete modified source code.  Modifications are to
 be distributed as patches to the released version.  Permission to
 distribute binaries produced by compiling modified sources is granted,
 provided you
   1. distribute the corresponding source modifications from the
    released version in the form of a patch file along with the binaries,
   2. add special version identification to distinguish your version
    in addition to the base release version number,
   3. provide your name and address as the primary contact for the
    support of your modified version, and
   4. retain our contact information in regard to use of the base
    software.
 Permission to distribute the released version of the source code along
 with corresponding source modifications in the form of a patch file is
 granted with same provisions 2 through 4 for binary distributions.

 This software is provided "as is" without express or implied warranty
 to the extent permitted by applicable law.


       AUTHORS

       Original Software:
          Thomas Williams,  Colin Kelley.

       Gnuplot 2.0 additions:
          Russell Lang, Dave Kotz, John Campbell.

       Gnuplot 3.0 additions:
          Gershon Elber and many others.


       Gnuplot 4.0 additions:
          See list of contributors at head of this document.

 (以下おおまかな訳; 訳は正しくないかも知れませんので詳しくは上記の原文
 を当たってください。訳者は責任を持ちません。)

       Copyright (C) 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley

 このソフトウェアとその付属文書の使用、複製、配布の許可は、上記の著作権
 (copyright) 表示が、全ての複製物に書かれていること、および著作権表示と
 この許諾文の両方がその支援文書に書かれていることを条件とした上で、この
 文書により保証されます。

 このソフトウェアの修正も認められています。しかし、修正を含む全ソースコ
 ードの配布の権利は認められません。修正はリリース版に対するパッチの形で
 配布しなければなりません。修正されたソースをコンパイルして作られたバイ
 ナリの配布は、以下の条件の元で認められます:
   1. リリース版からのソースの修正部分を、パッチの形でバイナリと共に配
      布すること
   2. ベースとなるリリース版と区別するために、そのバージョン番号に特別
      なバージョン指定子を付加すること
   3. その修正版のサポート用に、あなたの名前とアクセス可能なアドレスと
      を提供すること
   4. ベースとなるソフトウェアの使用に関しては、我々の連絡情報を保持し
      続けること
 リリース版のソースコードを、パッチの形でのソースの修正と一緒に配布する
 ことは、バイナリ配布に関する条項 2 から 4 までの条件の元で許されます。

 このソフトウェアは "あるがまま" 提供され、適用可能な法律で許められる範
 囲の保証を表明あるいは暗示していはいません。


       著者

       オリジナルソフトウェア:
          Thomas Williams,  Colin Kelley.

       Gnuplot 2.0 追加:
          Russell Lang, Dave Kotz, John Campbell.

       Gnuplot 3.0 追加:
          Gershon Elber とその他の人々。

       Gnuplot 4.0 追加:
          この文書の最初にある寄与者 (contributors) のリスト参照。
2 はじめに (Introduction)
?introduction
?
 `gnuplot` は、コマンド入力方式の対話的な関数描画プログラムです。
 書式:
       gnuplot {X11OPTIONS} {OPTIONS} file1 file2 ...

 一般的な X11 オプションは、もしあるならそれを最初に置きます (あなたの
 X11 の説明書を参照; X11 を使わないならここは無視してください)。gnuplot
 に与えるオプションは、そのコマンド行のどこに置くこともできます。ファイ
 ルは指定した順に実行され、同様に -e オプションで任意のコマンドも与える
 ことができます。

 例:
       gnuplot   file1.in   -e "reset"   file2.in

 特別なファイル名 "-" は、標準入力から読ませるのに使います。`gnuplot`
 は最後のファイルを処理し終わると終了します。読み込ませるファイルを一つ
 つも指定しない場合は、`gnuplot` は標準入力からの対話入力を取ります。詳
 細は、以下参照: `batch/interactive`。gnuplot 用のオプションについては、
 以下のようにして一覧を見ることができます:

       gnuplot --help

 `gnuplot` は、コマンドや関数名は大文字小文字を区別します。いずれのコマ
 ンドも、あいまいさの無い限りにおいて省略することができます。1 行中には
 セミコロン (;) で区切って複数のコマンドを書くことができます。文字列は単
 一引用符、あるいは二重引用符のどちらかで書き始めますが、両者には微妙な
 違いがあります (詳細は、以下参照: `syntax`)。例:

       load "filename"
       cd 'dir'

 `gnuplot` のコマンドの多くは複数のオプションを持っています。Version 4
 は以前の版に比べて、それらのオプションの順序に関しては許容的になってい
 ますが、しかし順序に依存するものも残ってはいます。オプションが認識され
 ないといったエラーメッセージが現われたら、正確にドキュメントに書かれて
 いる通りの順番で指定して試してみてください。

 コマンドは、複数行にまたがることができます。その場合は、最終行以外の
 全ての行の行末にバックスラッシュ (\) を書く必要があります。バックス
 ラッシュは必ず各行 *最後* の文字でなくてはなりません。その結果として
 バックスラッシュと、それに続く改行文字が存在しなかったかのように扱わ
 れます。つまり、改行文字がスペースの役をすることもありませんし、改行
 によってコメントが終了することもありません。ですから複数行にまたがる
 行の先頭をコメントアウトすると、そのコマンド全体がコメントアウトされ
 ることになります (以下参照: `comments`)。なお注意しますが、もし、複数
 行のコマンドのどこかでエラーが起きたとき、パーサはその場所を正確には
 指示することができませんし、また、正しい行に指示する必要もないでしょ
 う。

 このドキュメントにおいて、中括弧 ({}) は省略可能な引数を表すものとし、
 縦棒 (|) は、互いに排他的な引数を区切るものとします。`gnuplot` のキー
 ワードや `help` における項目名は、バッククオート (｀) または可能な場合
 には `boldface` (太字) で表します。角括弧 (<>) は、それに対応するもの
 に置き換えられるべきものを表します。多くの場合、オプションの引数には、
 それが省略されるとデフォルトの値が使用されます。しかし、これらの場合、
 必ずしも角括弧が中括弧で囲まれて書かれているわけではありません。

 ある項目についてのヘルプが必要なときには、`help` に続けてその項目名を
 入力して下さい。または単に `help ?` でもヘルプの項目のメニューが現われ
 ます。

 初めて `gnuplot` を使う方は、`plotting` に関する説明から読みはじめると
 良いでしょう (対話型で使用中ならば `help plotting` と入力して下さい)。

 simple.dem デモを参照してください。あるいは以下の Web ページにも他のデ
 モと一緒にあります。
^ <a href="http://www.gnuplot.info/demo/">
           http://www.gnuplot.info/demo/
^ </a>
2 探し出す手助け (Seeking-assistance)
?help-desk
?seeking-assistance
^ <a name="Seeking-assistance"></a>
 `gnuplot` ユーザのためのメーリングリストがあります。しかし、ニュースグ
 ループ
       comp.graphics.apps.gnuplot
 は、そのメーリングリストと同等であることに注意してください (どちらにも
 同じメッセージが流れます)。私達はメーリングリストに参加するより、むし
 ろニュースグループのメッセージを読むことを勧めます。メーリングリストに
 参加する方法に関しては、SouceForge にある gnuplot の開発 Web サイト
^ <a href="http://sourceforge.net/projects/gnuplot">
           http://sourceforge.net/projects/gnuplot
^ </a>
 を参照してください。

 メーリングリストメンバーへのメールアドレス:
       gnuplot-info@lists.sourceforge.net

 バグリポート、ソースの改良等は以下の trackers に upload してください:
       http://sourceforge.net/projects/gnuplot

 βテスト版に関するメーリングリスト:
       gnuplot-beta@lists.sourceforge.net

 公式の (そしてたまに更新が遅れることもある) WWW ページもあります。

^ <a href="http://www.gnuplot.info">
           http://www.gnuplot.info
^ </a>

 助けを求める前に、次をチェックしてください:

^ <a href="http://www.gnuplot.info/faq/">
           FAQ (度々聞かれる質問; Frequently Asked Questions) の一覧
^ </a>

 何か質問を投稿するときは、あなたが使用している `gnuplot` のバージョン、
 実行マシン、オペレーティングシステム、といった全ての情報を含むようにし
 てください。その問題を引き起こす _小さい_ スクリプトがあればなお良いで
 す。その場合、データファイルのプロットよりも関数のプロットの方がより良
 いです。もし、gnuplot-info へメールをするなら、そのメーリングリストの
 購読をしているかどうかを述べてください。そうすれば、ニュースを見たユー
 ザはあなたへの返事をメールで出せば良いことが分かるでしょうから。そのよ
 うな記事のポストの form が WWW サイトにあります。

2 バージョン 4.3 で導入された新しい機能 (New features)
?new-features
 gnuplot version 4.3 は、直前の公式バージョン 4.2 以降に追加されたたく
 さんの機能を提供します。この節では、主な追加機能の一覧と、変更や細かい
 新機能の一部を紹介します。より網羅的な一覧は、ファイル NEWS を参照して
 ください。

3 国際化 (Internationalization)
 gnuplot 4.3 には、ロカールの設定と UTF-8 文字エンコードのサポートに関
 する意味深い改良が含まれています。以下参照: `set locale`,
 `set encoding`, `set decimalsign`。

3 透明化 (Transparency)
 現在の gnuplot は、いくつかの方法で透明なオブジェクトをサポートしてい
 ます。塗り潰しスタイルを使用する任意のオブジェクト、描画要素には「完全
 な不透明」から「完全な透明」までの値を割り当てることができます。画像や
 matrix データは、新しい描画スタイル `with rgbalpha` を使用することで、
 アルファチャネル指定付きで描画できます。以下参照: `fillstyle`,
 `rgbalpha`。

3 揮発性データ (Volatile Data)
 新しいコマンド `refresh` はほぼ `replot` と同じですが、入力データファ
 イルの再読み込みをせず、前に保存した入力データを使うところが違います。
 入力データが `volatile` と指定されていれば、マウス操作 (ズーム、回転)
 `replot` ではなく自動的に `refresh` を使用します。パイプ入力、インラン
 データも自動的に `volatile` と扱われます。以下参照: `refresh`,
 `plot datafile volatile`。

3 キャンバスサイズ (Canvas size)
?canvas size
?canvas
?set term size

 gnuplot の以前の版では、`set size` の値を、出力する描画領域 (キャンバ
 ス) のサイズを制御するのにも使っていた出力形式もありましたが、すべての
 出力形式がそうだったわけではありませんでした。この目的のために
 `set size` を使用することは version 4.2 で非推奨となり、version 4.3 で
 は、ほとんどの出力形式が以下のルールに従うようになりました:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。サイズパラメータの有効な値に
 ついては、個々の出力形式のヘルプを参照してください。デフォルトでは、グ
 ラフはそのキャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
 形式では問題が起こるかもしれないことに注意してください。

 このルールに沿わない主な例外は PostScript ドライバで、デフォルトでは以
 前の版のと同じ振舞いをします。gnuplot の次の版では、PostScript ドライ
 バも同様にデフォルトの振舞いを変更することになるでしょう。

 例:

       set size 0.5, 0.5
       set term png size 600, 400
       set output "figure.png"
       plot "data" with lines

 このコマンドは、幅 600 ピクセル、高さ 400 ピクセルの出力ファイル
 "figure.png" を生成します。グラフはキャンバスの中の左下に置かれます。
 これは、multiplot モードが常に行ってきた方法とは矛盾していませんが、し
 かし単一のグラフに対する version 4.0 の png ドライバの挙動とは異ってい
 ます。

3 新しい描画要素
=circles
=ellipse
=polygon
 コマンド `set object` は、現在は固定された長方形だけでなく、円、楕円、
 多角形も定義でき、そして、それに対応する新しい描画スタイル
 `plot with circles` もあります。以下参照: `circle` `ellipse` `polygon`。

3 新しい/修正された出力形式
 cairo, pango ライブラリによる 2 つの新しいドライバ `pngcairo`,
 `pdfcairo` が含まれています。これらは、古い libgd ベースの png ドライ
 バ、古い PDFLib ベースの pdf ドライバの代替品です。このマニュアルの
 pdf 版の図は、pdfcairo 出力ドライバで作成されたものです (訳注: PDF 版
 マニュアルにこの図を入れるのには pdflatex が必要なため、日本語 PDF 版
 マニュアルには今のところこの図は含まれていないでしょう)。

3 新しい平滑化アルゴリズム
=kdensity
=cumulative
 2 次元、3 次元描画の両方に、新しい平滑化アルゴリズムが追加されていて、
 滑らかなヒストグラムや累積分布関数の `plot` による描画に、それぞれ
 `smooth kdensity` や `smooth cumul` が使えます。`splot` での使用に対し
 ては、`dgrid3d` にいくつかの新しい平滑化重み付け関数 (kernel) が追加さ
 れています。以下参照: `smooth`, `dgrid3d`。

2 後方互換性 (Backwards compatibility)
?backwards compatibility
?compatibility
 以前の版で使われていたいくつかの書式は gnuplot 4.0 で非推奨となりまし
 たが、それは今でも認識はされ続けています。これは現在コンパイル時に制御
 され、以下のようにして無効にできます:

       ./configure --disable-backwards-compatibility

 注意: 非推奨の書式は、未来の gnuplot のある版からは、完全に無効になっ
 てしまうかもしれません。

 一つの主な違いは、複雑なコマンド (特に文字列変数を含むコマンド) のあい
 まいさを避けるようなキーワードの導入です。特に注意すべき点は、オフセッ
 ト、線種、点種に対する生の数の使用でした。
 具体例:

 非推奨:
       set title "Old" 0,-1
       set data linespoints
       plot 1 2 4               # horizontal line at y=1
 新:
       TITLE = "New"
       set title TITLE offset char 0, char -1
       set style data linespoints
       plot 1 linetype 2 pointtype 4

2 バッチ/対話型操作 (Batch/Interactive)
?batch/interactive
 `gnuplot` は多くのシステム上で、バッチ処理形式、あるいは対話型のどちら
 の形式でも実行でき、それらを組み合わせることも可能です。

 コマンドライン引数は、プログラムへのオプション (文字 - で始まる) か、
 `gnuplot` コマンドを含むファイルの名前であると解釈されます。
 -e "command" の形式のオプションは、gnuplot コマンドを強制的に実行させ、
 各ファイルとこのコマンド文字列は、指定された順に実行されます。特別なフ
 ァイル名 "-" は、コマンドを標準入力から読み込むことを意味します。最後
 のファイルを実行した後に `gnuplot` は終了します。読み込ませるファイル、
 およびコマンド文字列を指定しなかった場合は、`gnuplot` は標準入力からの
 対話型の入力を受け付けます。

 `exit` と `quit` はどちらも現在のコマンドファイルを終了し、まだ全ての
 ファイルが終っていなければ、次のファイルを `load` するのに使われます。

 例:

 対話を開始する:
       gnuplot

 2 つのコマンドファイル "input1", "input2" を使ってバッチ処理を行なう:
       gnuplot input1 input2

 初期化ファイル "header" の後、対話型モードを起動し、その後別のコマンド
 ファイル "tailer" を実行する:
       gnuplot header - trailer

 コマンドラインから `gnuplot` コマンドを直接与え、終了後にスクリーン上
 にグラフが残るようにオプション "-persist" を使う:
        gnuplot -persist -e "set title 'Sine curve'; plot sin(x)"

 ファイルのコマンドを実行する前に、ユーザ定義変数 a と s をセットする:
       gnuplot -e "a=2; s='file.png'" input.gpl


2 コマンドライン編集 (Command-line-editing)
?line-editing
?editing
?command-line-editing
 コマンドラインでの編集機能とコマンドヒストリの機能は、外部の GNU
 readline ライブラリか外部の BSD libedit ライブラリ、または組み込まれて
 いる同等のもののいずれかを使ってサポートしています。この選択は、
 gnuplot のコンパイル時の configure のオプションで行います。

 組み込みの readline 版の場合の編集コマンドは以下の通りです。GNU
 readline ライブラリと BSD libedit ライブラリに関しては、それ自身のドキ
 ュメントを参照してください。

@start table - まずは対話型テキスト形式
       `行編集`:

       ^B    1 文字前へ戻す
       ^F    1 文字先へ進める
       ^A    行の先頭に移動
       ^E    行の最後に移動
       ^H,DEL  直前の文字を削除
       ^D    現在位置の文字を削除
       ^K    現在位置から行末まで削除
       ^L,^R 壊れた表示の行を再表示
       ^U    行全体の削除
       ^W    カーソル手前の単語から行末まで削除

       `履歴`:

       ^P    前の履歴へ移動
       ^N    次の履歴へ移動
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{コマンド行編集コマンド} \\ \hline \hline
#文字 & 機能 \\ \hline
# & \multicolumn{1}{|c|}{行編集}\\ \cline{2-2}
#\verb~^B~ & 1 文字前へ戻す\\
#\verb~^F~ & 1 文字先へ進める\\
#\verb~^A~ & 行の先頭へ移動\\
#\verb~^E~ & 行の最後へ移動\\
#\verb~^H, DEL~ & 直前の文字を削除\\
#\verb~^D~ & 現在位置の文字を削除\\
#\verb~^K~ & 現在位置から行末まで削除\\
#\verb~^L, ^R~ & 壊れた表示の行を再表示\\
#\verb~^U~ & 行全体の削除\\
#\verb~^W~ & カーソル手前の単語から行末まで削除\\ \hline
# & \multicolumn{1}{|c|}{履歴} \\ \cline{2-2}
#\verb~^P~ & 前の履歴へ移動\\
#\verb~^N~ & 次の履歴へ移動\\
%c l .
%文字@機能
%_
%@行編集
%^B@1 文字前へ戻す
%^F@1 文字先へ進める
%^A@行の先頭に移動
%^E@行の最後に移動
%^H, DEL@直前の文字を削除
%^D@現在位置の文字を削除
%^K@現在位置から行末まで削除
%^L, ^R@壊れた表示の行を再表示
%^U@行全体の削除
%^W@カーソル手前の単語から行末まで削除
%_
%@履歴
%^P@前の履歴へ移動
%^N@次の履歴へ移動
@end table
2 コメント (Comments)
?comments
 コメントは次のように実装されています: 文字 '#' は、行中のたいていの場
 所に書くことができます。このとき `gnuplot` はその行の残りの部分を無視し
 ます。ただし、引用符の中、数 (複素数を含む) の中、コマンド置換 (command
 substitution) の中などではこの効果がありません。簡単に言うと、意味
 のあるような使い方をしさえすれば、正しく動作すると言うことです。

 データファイル中のコメント文字の指定については、以下参照:
 `set datafile commentschars`。コメント行が '\' で終わっている場合、次
 の行もコメントとして扱われることに注意してください。
2 座標系 (Coordinates)
?coordinates
=axes
 コマンド `set arrow`, `set key`, `set label`, `set object` はグラフ上
 の任意の位置が指定できます。その位置は以下の書式で指定します:

       {<system>} <x>, {<system>} <y> {,{<system>} <z>}

 各座標系指定 <system> には、`first`, `second`, `graph`, `screen`,
 `character` のいずれかが入ります。

 `first` は左と下の軸で定義される x,y (3D の場合は z も) の座標系を使用
 します。`second` は第 2 軸 (上と右の軸) を使用します。`graph` はグラフ
 描画領域内の相対的位置を指定し、左下が 0,0 で 右上が 1,1 (splot の場合
 はグラフ描画領域内の左下が 0,0,0 で、土台の位置は負の z の値を使用しま
 す。以下参照: `set ticslevel`) となります。`screen` は表示範囲内 (範囲
 全体であり、`set size` で選択される一部分ではありません) を指定し、左
 下が 0,0 で 右上が 1,1 となります。`character` は、画面領域の左下
 (screen 0,0) からの、文字の幅、文字の高さでの位置を与えます。よって、
 `character` 座標は、選択されたフォントのサイズに依存します。

 x の座標系が指定されていない場合は `first` が使われます。y の座標系が
 指定されていない場合は x に対する座標系が使用されます。

 与える座標が絶対的な位置ではなくて相対的な値である場合もあります (例え
 ば `set arrow` ... `rto` の 2 番目の数値)。そのほとんどが、与えられた
 数値を最初の位置に対する差として使います。与えられた座標が対数軸内にあ
 る場合は、その相対的な値は積因子として解釈されます。例えば

       set logscale x
       set arrow 100,5 rto 10,2

 は、x 軸が対数軸で y 軸が線形の軸なので、100,5 の位置から 1000,7 の位
 置への矢印を書くことになります。

 一つ (あるいはそれ以上) の軸が時間軸である場合、`timefmt` の書式文字列
 に従って、引用符で囲まれた時間文字列で適切な座標を指定する必要がありま
 す。以下参照: `set xdata`, `set timefmt`。また、`gnuplot` は整数表記も
 認めていて、その場合その整数は 2000 年 1 月 1 日からの秒数と解釈されま
 す。
2 文字列データ (Datastrings)
?datastrings
 データファイルには、ホワイトスペース (空白やタブ) を含まない任意の印字
 可能な文字列、あるいは 2 重引用符で囲まれた任意の文字列 (ホワイトスペ
 ースが含まれても良い)、のいずれかの形からなる文字列データを持たせるこ
 とも可能です。データファイルに次の例のような行が含まれている場合、それ
 は 4 つの列を含み、3 列目がテキスト部分であると見なされます:

   1.000 2.000 "Third column is all of this text" 4.00

 テキスト部分は 2 次元や 3 次元描画内で例えば以下のように使用されます:

   plot 'datafile' using 1:2:4 with labels
   splot 'datafile using 1:2:3:4 with labels

 テキスト部分の列データは 1 つ、または複数の描画軸の目盛りのラベルとし
 て使用できます。次の例は、入力データの 3 列目と 4 列目を (X,Y) 座標と
 して取り出し、それらの点の列を結ぶ線分を描画します。しかしこの場合
 gnuplot は、x 軸に沿って標準的に間の空いた数字ラベルのついた目盛り刻み
 をつけるのではなく、入力データファイルの 1 行目の X 座標の位置に、目盛
 り刻みと文字列を x 軸に沿ってつけて行きます。

   set xtics
   plot 'datafile' using 3:4:xticlabels(1) with linespoints

=columnheader
 入力データの列の最初のエントリ (すなわち列の見出し) をテキスト部分と解
 釈するもう一つのオプションがあり、それはテキスト部分を、その描画した列
 のデータの説明 (key) のタイトル部分として使用します。次の例は、先頭の
 行の 2 列目の部分を説明ボックス内のタイトルを生成するのに使用し、その
 後の列の 2,4 列目は要求された曲線を描画するのに処理されます:

   plot 'datafile' using 1:(f($2)/$4) with lines title columnhead(2)

 以下参照: `set style labels`, `using xticlabels`, `plot title`,
 `using`。
2 拡張文字列処理モード (Enhanced text mode)
?enhanced text
?enhanced
 多くの出力形式が、拡張文字列処理モード (enhanced text mode) をサポート
 しています。これは、文字列に追加の書式情報を埋めこみます。例えば "x^2"
 は x の自乗を、通常我々が見る上付きの 2 がついた形で書き出します。この
 モードは、例えば、"set term png enhanced" のように普通は出力形式を設定
 するときに選択しますが、後で "set termoption enhanced" を使ってその機
 能を有効/無効にもできますし、"set label 'x_2' noenhanced" のように個々
 の文字列に適用することもできます。

@start table - まずは対話型テキスト形式
  制御記号     例              説明
   ^           a^x             上付き文字
   _           a_x             下付き文字
   @           @x or a@^b_{cd} 空ボックス (幅がない)
   &           &{space}        指定した長さのスペースを挿入
   ~           ~a{.8-}         'a' の上に '-' を、現在のフォントサ
                               イズの .8 倍持ち上げた位置に重ね書き
#\begin{tabular}{|cccl|} \hline
#\multicolumn{4}{|c|}{拡張文字列制御記号} \\ \hline
#制御記号 & 例 & 結果 & 説明 \\ \hline
#\verb~^~ & \verb~a^x~ & $a^x$ & 上付き文字\\
#\verb~_~ & \verb~a_x~ & $a_x$ & 下付き文字\\
#\verb~@~ & \verb~a@^b_{cd}~ & $a^b_{cd}$ & 空ボックス (幅がない)\\
#\verb~&~ & \verb~d&{space}b~ & d\verb*+     +b & 指定した長さのスペースを挿入\\
#\verb|~| & \verb|~a{.8-}| & $\tilde{a}$ & 'a' の上に '-' を、現在のフォントサ\\
#\verb~ ~ & \verb~ ~ & ~ ~ & イズの .8 倍持ち上げた位置に重ね書き\\
%c c l .
%.TE", /* ugly - doc2ms uses @ for column separator, but here we */
%.TS", /* need @ in table, so end and restart the table ! */
%center box tab ($) ;
%c c l .
%制御記号$例$説明
%_
%^$a^x$上付き文字
%\&_$a\&_x$下付き文字
% @ $ @x or a\&@^b\&_{cd}$空ボックス (幅がない)
% & $ &{space}$指定した長さのスペースを挿入
% ~ $ ~a{.8-}$'a' の上に '-' を、現在のフォントサ
%   $   $イズの .8 倍持ち上げた位置に重ね書き
@end table

 中カッコは一文字が期待される箇所に複数の文字を書く場合に使われます (例
 えば 2^{10})。フォント、およびそのサイズを変更するには、以下の形式を使
 ってください: {/[fontname][=fontsize | *fontscale] text} よって、例え
 ば {/Symbol=20 G} は 20 ポイントのΓ (ガンマ)に、{/*0.75 K} は現在の有
 効なフォントサイズの 3/4 の大きさの K になります (文字 '/' は、'{' の
 直後の文字でなくてはなりません)。

 空ボックス (phantom box) は a@^b_c の上付き文字と下付き文字を揃えると
 きに有用ですが、文字にアクセント記号を重ねる場合にはうまく働きません。
 後者の目的のためには、色々なアクセントやその他のダイアクリティカルマ
 ークのある多くの文字を持つエンコード (例えば iso_8859_1 や utf8) を使
 用する方がいいでしょう。以下参照: `set encoding`。そのボックスはスペー
 シングが行なわれないので、ボックス内 (つまり @ の後ろ) の上付き文字や
 下付き文字を短く出力するのに適しています。

 ある文字列と同じ長さのスペースを文字 '&' を使うことで入れることができ
 ます。すなわち、
         'abc&{def}ghi'
 は以下を生成します (abc と ghi の間は 3 文字分の空白):
         'abc   ghi'

 文字 '~' は、次の文字、またはカッコで囲まれた文字列に、それに続く文字
 またはカッコで囲まれた文字列を重ね書きします。2 番目の文字は最初の文字
 にあわせて水平方向にセンタリングされます。よって '~a/' は 'a' を貫くよ
 うなスラッシュが得られます。2 番目の文字は、その前に数字を置くことで垂
 直方向に移動させることができます。その数字は現在のフォントサイズに対す
 る割合を意味し、それに従って文字が上がったり下がったりします。この場合
 数字と文字列は 1 文字より長くなるのでカッコで囲む必要があります。重ね
 書きされる文字列が数字から始まっている場合は、垂直にずらす値と文字列と
 の間にスペースを入れてください ('~{abc}{.5 000}')。それ以外はスペース
 は不要です ('~{abc}{.5---}')。一方、あるいは両方のフォントを変更するこ
 ともできます ('~a{.5 /*.2 o}'; 'a' その 1/5 の大きさの 'o'、この場合数
 字とスラッシュの間のスペースは必要です) が、その文字列が始まった後で変
 更することはできません。それぞれの文字列内で、他の特殊な書式を使うこと
 もできません。もちろん、'~a{\^}' のように特殊な文字をエスケープするこ
 と (下記参照) は可能です。

 \文字コード (8 進数) を指定することで特殊な記号を指定することができま
 す。例えば、{/Symbol \245} は無限大の記号になります。しかし、これは、
 UTF-8 のようなマルチバイトエンコードの場合にはうまくいきません。UTF-8
 環境では、タイプ入力するかまたは別のやり方であなたが望む文字を選択する
 ことでマルチバイト列を入力できるようにすべきです。

 制御文字は、 \\ や \{ などのように \ を使ってエスケープできます。

 しかし、二重引用符内の文字列は単一引用符内の文字列とは異なって解釈され
 ることを知っておいてください。主な違いは、二重引用符内の文字列ではバッ
 クスラッシュは 2 つ重ねる必要があることです。

 例 (これらは言葉で説明するのは難しいのでとりあえずやってみてください):
       set xlabel 'Time (10^6 {/Symbol m}s)'
       set title '{/Symbol=18 \\362@_{/=9.6 0}^{/=12 x}} \\
                  {/Helvetica e^{-{/Symbol m}^2/2} d}{/Symbol m}'

 gnuplot ソース配布物内の /docs/psdoc サブディレクトリにあるファイル
 "ps_guide.ps" に、拡張された書式に関する例が更に載っています。
2 環境変数 (Environment)
?environment
 `gnuplot` は多くのシェル環境変数を認識します。必須のものはありませんが、
 使えば便利になるかも知れません。

 GNUTERM が定義されている場合、それは使用される出力形式 (terminal) の名
 前として使われます。これは `gnuplot` が起動時に見つけた出力形式に優先
 して使用されますが、.gnuplot (またはそれに相当する) スタートアップファ
 イル (以下参照: `start-up`) による指定や、当り前のことですが、その後に
 明示的に指定した物の方が優先されます。

 GNUHELP にヘルプファイル (gnuplot.gih) のパス名を定義しておくことがで
 きます。

 VMS では、論理名 GNUPLOT$HELP を `gnuplot` のヘルプライブラリの名前と
 して定義します。`gnuplot` のヘルプは任意のシステムのヘルプライブラリに
 入れることができ、`gnuplot` の内部からでも外部からでも参照して構いませ
 ん。

 Unix においては、カレントディレクトリに .gnuplot というファイルがない
 場合には、HOME に定義されたディレクトリを探します。AmigaOS, MS-DOS,
 Windows, OS/2 では GNUPLOT がその役割に使われます。Windows では、NT 専
 用の変数 USERPROFILE も参照されます。VMS では SYS$LOGIN です。
 `help start-up` と打ってみてください。

 Unix においては、PAGER がヘルプメッセージの出力用のフィルタとして使わ
 れます。

 Unix, AmigaOS では、SHELL が `shell` コマンドの際に使われます。MS-DOS,
 OS/2 では COMSPEC が `shell` コマンドの際に使われます。

 FIT_SCRIPT は、当てはめ (fit) が中断されたときに実行する `gnuplot` コ
 マンドの指定に使われます。以下参照: `fit`。FIT_LOG は当てはめによるロ
 グファイルのデフォルトのファイル名の指定に使われます。

 GNUPLOT_LIB は、データやコマンドファイルの検索ディレクトリを追加定義す
 るのに使われます。その変数は、一つのディレクトリ名かまたは複数のディレ
 クトリ名を書くことができますが、ディレクトリの区切りはプラットホーム毎
 に違います。例えば Unix では ':' で、DOS,Windows,OS/2,Amiga では ';'
 です。GNUPLOT_LIB の値は変数 `loadpath` に追加されますが、それは
 `save` や `save set` コマンドでは保存されません。

 出力ドライバの中には gd ライブラリ経由で TrueType フォントを扱えるもの
 もいくつかあります。これらのドライバのフォント検索パスは、環境変数
 GDFONTPATH で制御できます。さらに、それらのドライバでのデフォルトのフ
 ォントは環境変数 GNUPLOT_DEFAULT_GDFONT で制御できます。

 postscript 出力ドライバは自分で持っているフォント検索パスを使いますが、
 それは環境変数 GNUPLOT_FONTPATH で制御できます。書式は GNUPLOT_LIB と
 同じです。GNUPLOT_FONTPATH の値は変数 `fontpath` に追加されますが、そ
 れは `save` や `save set` コマンドでは保存されません。

 PostScript ドライバは、外部 (組み込まれていない) 定義ファイルを使うた
 めに環境変数 GNUPLOT_PS_DIR を利用します。インストール時の作業により、
 gnuplot にはそれらのファイルのコピーが組み込まれているか、または単にそ
 れらのファイルのあるデフォルトのパスが埋め込まれるかが変わります。カス
 タマイズした定義ファイルで PostScript 出力をテストする場合はこの環境変
 数を使ってください。以下参照: `postscript prologue`。
2 式 (Expressions)
?expressions
 基本的には C, FORTRAN, Pascal, BASIC において利用可能な数学表現を使用
 できます。 演算子の優先順位は C 言語の仕様に従います。数式中の空白文字
 とタブ文字は無視されます。

 複素数の定数は {<real>,<imag>} と表現します。ここで <real> と <imag>
 (実部、虚部) は数値定数である必要があります。例えば {3,2} は 3 + 2i を
 あらわし、{0,1} は 'i' 自身を表します。これらには明示的に中カッコを使
 う必要があります。

=division
 gnuplot は "実数" と "整数" 演算を FORTRAN や C のように扱うということ
 に注意してください。"1", "-10" などは整数と見なされ、"1.0", "-10.0",
 "1e1", 3.5e-1 などは実数と見なされます。 これら 2 つのもっとも重要な違
 いは割算です。整数の割算は切り捨てられます: 5/2 = 2。実数はそうではあ
 りません: 5.0/2.0 = 2.5。それらが混在した式の場合、計算の前に整数は実
 数に "拡張" されます: 5/2e0 = 2.5。負の整数を正の整数で割る場合、その
 値はコンパイラによって変わります。"print -5/2" として、あなたのシステ
 ムが -2 と -3 のどちらを答えとするかを確認してください。

 数式 "1/0" は "未定義値 (undefined)" フラグを生成し、それによりその点
 は無視されます。`ternary` 演算子 (三項演算子) の項にその例があります。
 または、あらかじめ定義されている値 NaN を使っても同じことになります。
=NaN

 複素数表現の実数部分、虚数部分は、どんな形で入力されても常に実数です:
 {3,2} の "3" と "2" は実数であり、整数ではありません。

 gnuplot は文字列に対する単純な演算、および文字列変数も利用できます。例
 えば式 ("A" . "B" eq "AB") は真と評価されますが、これは文字列の結合演
 算子と文字列の等号演算子を意味しています。

 数としての値を含む文字列は、それが数式で利用された場合は、対応する整数
 や実数に変換されます。よって、("3" + "4" == 7) や (6.78 == "6.78") は
 どちらも真になります。整数は、それが文字列結合演算子で使われた場合は文
 字列に変換されますが、実数や複素数はダメです。典型的な例は、ファイル名
 や他の文字列内に整数を使う場合でしょう: 例えば ("file" . 4 eq "file4")
 は真です。

 後置指定する範囲記述子 [beg:end] によって、部分文字列を指定することが
 できます。例えば、"ABCDEF"[3:4] == "CD" で、"ABCDEF"[4:*] == "DEF" で
 す。書式 "string"[beg:end] は、文字列値の組み込み関数
 substr("strings",beg,end) を呼ぶこととほぼ同じですが、関数呼び出しでは
 beg, end は省略することはできません。
3 関数 (Functions)
?expressions functions
?functions
 `gnuplot` の関数は、Unix 数学ライブラリの関数とほぼ同じですが、特に注
 意がなければ全ての関数が整数、実数、複素数の引数を取ることができます。

 度、あるいはラジアンのどちらかで角度を引数としたり戻り値としたりする関
 数 (sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(x), arg(z))
 に対しては、その単位は `set angles` で選択でき、デフォルトはラジアンで
 す。

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{数学ライブラリ関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
%c c l .
%関数@引数@戻り値
%_
4 abs
?expressions functions abs
?functions abs
?abs
#abs(x) & 任意  &  $x$ の絶対値, $|x|$; 同じ型\\
#abs(x) & 複素数 &  $x$ の長さ, $\sqrt{{\mbox{real}(x)^{2} +
#\mbox{imag}(x)^{2}}}$ \\
%abs(x)@任意@$x$ の絶対値, $|x|$; 同じ型
%abs(x)@複素数@$x$ の長さ, $sqrt{roman real (x) sup 2 + roman imag (x) sup 2}$
 関数 `abs(x)` 引数の絶対値を返します。返り値の型は引数と同じです。

 複素数の引数に対しては, abs(x) は複素平面における x の長さと定義されて
 います [すなわち sqrt(real(x)**2 + imag(x)**2) ]。
4 acos
?expressions functions acos
?functions acos
?acos
#acos(x) & 任意 & $\cos^{-1} x$ (アークコサイン) \\
%acos(x)@任意@$cos sup -1 x$ (アークコサイン)
 関数 `acos(x)` は引数のアークコサイン (逆余弦) を返します。`acos` の
 返す値がラジアン単位かまたは度であるかは `set angles` で選択されます。
4 acosh
?expressions functions acosh
?functions acosh
?acosh
#acosh(x) & 任意 & ラジアンでの $\cosh^{-1} x$ (逆双曲余弦)\\
%acosh(x)@任意@$ラジアンでの cosh sup -1 x$ (逆双曲余弦)
 関数 `acosh(x)` は逆ハイパボリックコサイン (逆双曲余弦) の値をラジアンで
 返します。
4 arg
?expressions functions arg
?functions arg
?arg
#arg(x) & 複素数 & $x$ の偏角 \\
%arg(x)@複素数@$x$ の偏角
 関数 `arg(x)` は複素数の偏角を、`set angles` の設定にしたがってラジアン、
 または度で返します。
4 asin
?expressions functions asin
?functions asin
?asin
#asin(x) & 任意  & $\sin^{-1} x$ (アークサイン) \\
%asin(x)@任意@$sin sup -1 x$ (アークサイン)
 関数 `asin(x)` は引数のアークサイン (逆正弦) を返します。`asin` の
 返す値は `set angles` の設定によってラジアン単位かまたは度になります。
4 asinh
?expressions functions asinh
?functions asinh
?asinh
#asinh(x) & 任意  & ラジアンでの $\sinh^{-1} x$ (逆双曲正弦)\\
%asinh(x)@任意@$ラジアンでの sinh sup -1 x$ (逆双曲正弦)
 関数 `asinh(x)` は逆ハイパボリックサイン (逆双曲正弦) の値をラジアンで
 返します。
4 atan
?expressions functions atan
?functions atan
?atan
#atan(x) & 任意  & $\tan^{-1} x$ (アークタンジェント) \\
%atan(x)@任意@$tan sup -1 x$ (アークタンジェント)
 関数 `atan(x)` は引数のアークタンジェント (逆正接) の値を返します。
 `atan` の返す値は `set angles` の設定によってラジアン単位かまたは度に
 なります。
4 atan2
?expressions functions atan2
?functions atan2
?atan2
#atan2(y,x) & 整数または実数 & $\tan^{-1} (y/x)$ (アークタンジェント) \\
%atan2(y,x)@整数または実数@$tan sup -1 (y/x)$ (アークタンジェント)
 関数 `atan2(y,x)` は引数の実数部分の比のアークタンジェント (逆正接) の
 値を返します。`atan2` は `set angles` の設定によってラジアン単位か度に
 なる、適切な四分円における値を返します。
4 atanh
?expressions functions atanh
?functions atanh
?atanh
#atanh(x) & 任意  & ラジアンでの $\tanh^{-1} x$ (逆双曲正接)\\
%atanh(x)@任意@ラジアンでの $tanh sup -1 x$ (逆双曲正接)
 関数 `atanh(x)` は逆ハイパボリックタンジェント (逆双曲正接) の値をラジ
 アンで返します。
4 EllipticK
#EllipticK(k) & 実数 k $\in$ (-1:1) & $K(k)$ 第 1 種完全楕円積分\\
%EllipticK(k)@実数 k in (-1:1)@$K k$ 第 1 種完全楕円積分
 以下参照: `elliptic integrals`。
4 EllipticE
#EllipticE(k) & 実数 k $\in$ [-1:1] & $E(k)$ 第 2 種完全楕円積分\\
%EllipticE(k)@実数 k in [-1:1]@ $E k$ 第 2 種完全楕円積分
 以下参照: `elliptic integrals`。
4 EllipticPi
#EllipticPi(n,k) & 実数 n$<$1, 実数 k $\in$ (-1:1) & $\Pi(n,k)$ 第 3 種完全楕円積分\\
%EllipticPi(n,k)@ 実数 n<1, 実数 k in (-1:1)@ $Pi n,k$ 第 3 種完全楕円積分
 以下参照: `elliptic integrals`。
4 besj0
?expressions functions besj0
?functions besj0
?besj0
#besj0(x) & 整数または実数 & $x$ の $j_{0}$ ベッセル関数\\
%besj0(x)@整数または実数@$x$ の $j sub 0$ ベッセル関数
 関数 `besj0(x)` は引数の j0 ベッセル関数 (0 次の第 1 種円柱関数 J0、0
 次ベッセル関数) の値を返します。`besj0` には引数はラジアンで与えます。
4 besj1
?expressions functions besj1
?functions besj1
?besj1
#besj1(x) & 整数または実数 & $x$ の $j_{1}$ ベッセル関数\\
%besj1(x)@整数または実数@ $x$ の $j sub 1$ ベッセル関数
 関数 `besj1(x)` は引数の j1 ベッセル関数 (1 次の第 1 種円柱関数 J1、1
 次ベッセル関数) の値を返します。`besj1` には引数はラジアンで与えます。
4 besy0
?expressions functions besy0
?functions besy0
?besy0
#besy0(x) & 整数または実数 & $x$ の $y_{0}$ ベッセル関数\\
%besy0(x)@整数または実数@$x$ の $y sub 0$ ベッセル関数
 関数 `besy0(x)` は引数の y0 ベッセル関数 (0 次の第 2 種円柱関数 Y0、0
 次ノイマン関数) の値を返します。`besy0` には引数はラジアンで与えます。
4 besy1
?expressions functions besy1
?functions besy1
?besy1
#besy1(x) & 整数または実数 & $x$ の $y_{1}$ ベッセル関数\\
%besy1(x)@整数または実数@$x$ の $y sub 1$ ベッセル関数
 関数 `besy1(x)` は引数の y1 ベッセル関数 (1 次の第 2 種円柱関数 Y1、1
 次ノイマン関数) の値を返します。`besy1` には引数はラジアンで与えます。
4 ceil
?expressions functions ceil
?functions ceil
?ceil
#ceil(x) & 任意 & $\lceil x \rceil$, $x$ 以上の最小の整数
#(real part) \\
%ceil(x)@任意@$left ceiling x right ceiling$, $x$ (の実数部分) 以上の最小の整数
 関数 `ceil(x)` は引数以上の最小の整数を返します。複素数引数に対しては
 その実数部分以上の最小の整数を返します。
4 cos
?expressions functions cos
?functions cos
?cos
#cos(x) & 任意 & $x$ のコサイン $\cos x$\\
%cos(x)@ラジアン@$x$ のコサイン $cos~x$
 関数 `cos(x)` は引数のコサイン (余弦) の値を返します。`cos` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 cosh
?expressions functions cosh
?functions cosh
?cosh
#cosh(x) & 任意 & $\cosh x$, $x$ のハイパボリックコサイン \\
%cosh(x)@任意@$cosh~x$, $x$ のハイパボリックコサイン
 関数 `cosh(x)` は引数のハイパボリックコサインの値を返します。`cosh` の
 引数はラジアンで与えます。
4 erf
?expressions functions erf
?functions erf
?erf
#erf(x) & 任意 & $\mbox{erf}(\mbox{real}(x))$,  $x$ の 実部の誤差関数\\
%erf(x)@任意@$erf ( roman real (x))$, $x$ の実部の誤差関数
 関数 `erf(x)` は引数の実部の誤差関数の値を返します。引数が複素数の場合は
 虚部は無視されます。以下参照: `erfc`, `inverf`, `norm`。
4 erfc
?expressions functions erfc
?functions erfc
?erfc
#erfc(x) & 任意 & $\mbox{erfc}(\mbox{real}(x))$,  1.0 - ($x$ の実部の誤差関数) \\
%erfc(x)@任意@$erfc ( roman real (x))$, 1.0 - ($x$ の実部の誤差関数)
 関数 `erfc(x)` は 1.0 から、引数の実部の誤差関数の値を引いたものを返し
 ます。引数が複素数の場合は虚部は無視されます。以下参照: `erf`,
 `inverf`, `norm`。
4 exp
?expressions functions exp
?functions exp
?exp
#exp(x) & 任意 & $e^{x}$, $x$ の指数関数\\
%exp(x)@任意@$e sup x$, $x$ の指数関数
 関数 `exp(x)` 引数の指数関数の値 (`e` の引数乗) を返します。環境によっては
 (特に sun) 大きい x の値に対する exp(-x) は未定義値を返す場合があります。
 このような場合、safe(x) = x<-100 ? 0 : exp(x) のようなユーザ定義関数が役に
 立つでしょう。
4 floor
?expressions functions floor
?functions floor
?floor
#floor(x) & 任意 & $\lfloor x \rfloor$, $x$ (の実部) 以下の最大の整数\\
%floor(x)@任意@$left floor x right floor$, $x$ (の実部) 以下の最大の整数
 関数 `floor(x)` はその引数以下の最大の整数を返します。複素数引数に対しては
 `floor` はその引数の実部以下の最大の整数を返します。
4 gamma
?expressions functions gamma
?functions gamma
?gamma
#gamma(x) & 任意 & $\mbox{gamma}(\mbox{real}(x))$, $x$ の実部のガンマ関数\\
%gamma(x)@任意@$GAMMA ( roman real (x))$, $x$ の実部のガンマ関数
 関数 `gamma(x)` は引数の実部のガンマ関数の値を返します。整数 n に対しては
 gamma(n+1) = n! です。引数が複素数の場合、虚数部分は無視されます。
4 ibeta
?expressions functions ibeta
?functions ibeta
?ibeta
#ibeta(p,q,x) & 任意 & $\mbox{ibeta}(\mbox{real}(p,q,x))$, $p$,$q$,$x$ の実部の不完全ベータ関数 \\
%ibeta(p,q,x)@任意@$ibeta ( roman real (p,q,x))$, $p$,$q$,$x$ の実部の不完全ベータ関数
 関数 `ibeta(p,q,x)` は引数の実部の不完全ベータ関数の値を返します。p, q > 0
 で x は [0:1] 内の値です。引数が複素数の場合は虚部は無視されます。
4 inverf
?expressions functions inverf
?functions inverf
?inverf
#inverf(x) & 任意 & $x$ の実部の逆誤差関数 \\
%inverf(x)@任意@$x$ の実部の逆誤差関数
 関数 `inverf(x)` は引数の実部の逆誤差関数の値を返します。以下参照:
 `erf`, `invnorm`。
4 igamma
?expressions functions igamma
?functions igamma
?igamma
#igamma(a,x) & 任意 & $\mbox{igamma}(\mbox{real}(a,x))$, $a$,$x$ の実部の不完全ガンマ関数 \\
%igamma(a,x)@任意@$igamma ( roman real (a,x))$, $a$,$x$ の実部の不完全ガンマ関数
 関数 `igamma(a,x)` は引数の実部の、正規化された不完全ガンマ関数の値を
 返します。ここで、a > 0, x >= 0 です。標準的な記法では P(a,x) (例えば
 Abramowitz and Stegun (6.5.1)) で、x が無限大に発散する場合の極限値は
 1 です。引数が複素数の場合は虚部は無視されます。
4 imag
?expressions functions imag
?functions imag
?imag
#imag(x) & 複素数 & $x$ の虚数部分 (実数) \\
%imag(x)@複素数@$x$ の虚数部分 (実数)
 関数 `imag(x)` は引数の虚数部分を実数として返します。
4 invnorm
?expressions functions invnorm
?functions invnorm
?invnorm
#invnorm(x) & 任意 & $x$ の実部の逆正規分布関数 \\
%invnorm(x)@任意@$x$ の実部の逆正規分布関数
 関数 `invnorm(x)` は引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の逆関数の値を返します。以下参照: `norm`。
4 int
?expressions functions int
?functions int
?int
#int(x) & 実数 &  $x$ の実数部分 (0 に向かって丸め) \\
%int(x)@実数@$x$ の実数部分 (0 に向かって丸め)
 関数 `int(x)` は、引数の整数部分 (0 に向かって丸めた) を返します。
4 lambertw
?expressions functions lambertw
?functions lambertw
?lambertw
#lambertw(x) & 実数 & Lambert W 関数 \\
%lambertw(x)@実数@Lambert W 関数
 lambertw 関数は Lambert の W 関数の主値を返します。これは、
 (W(z)*exp(W(z))=z で定義されます。z は z >= -exp(-1) を満たす実数でな
 ければいけません。
4 lgamma
?expressions functions lgamma
?functions lgamma
?lgamma
#lgamma(x) & 任意 & $\mbox{lgamma}(\mbox{real}(x))$, $x$ の実部のガンマ対数関数\\
%lgamma(x)@任意@$lgamma ( roman real (x))$, $x$ の実部のガンマ対数関数
 関数 `lgamma(x)` は引数の実部のガンマ関数値の自然対数の値を返します。
 引数が複素数の場合、虚部は無視されます。
4 log
?expressions functions log
?functions log
?log
#log(x) & 任意 & $\log_{e} x$,  $x$ の自然対数 (底 $e$) \\
%log(x)@任意@$ln~x$, $x$ の自然対数 (底 $e$)
 関数 `log(x)` は引数の自然対数 (底 `e`) の値を返します。以下参照:
 `log10`。
4 log10
?expressions functions log10
?functions log10
?log10
#log10(x) & 任意 & $\log_{10} x$, $x$ の対数 (底 $10$) \\
%log10(x)@任意@${log sub 10}~x$, $x$ の対数 (底 $10$)
 関数 `log10(x)` は引数の対数 (底 10) を返します。
4 norm
?expressions functions norm
?functions norm
?norm
#norm(x) & 任意 & $x$ の実部の正規分布 (ガウス分布) 関数 \\
%norm(x)@任意@$norm(x)$, $x$ の実部の正規分布 (ガウス分布) 関数
 関数 `norm(x)` は、引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の値を返します。以下参照: `invnorm`, `erf`, `erfc`。
4 rand
?expressions functions rand
?functions rand
?rand
#rand(x) & 任意 & $\mbox{rand}(\mbox{real}(x))$, 疑似乱数生成器\\
%rand(x)@任意@$rand (x)$, 疑似乱数生成器
 `rand(0)`  内部に持つ 2 つの 32bit の種 (seed) の現在の値から生成され
            る [0:1] 区間内の疑似乱数値を返す
 `rand(-1)` 2 つの種の値を標準値に戻す
 `rand(x)`  x>0 ならば両方の種に x の値に基づく値を設定する
 `rand({x,y})` x>0 ならば seed1 を x に、seed2 を y に設定する
4 real
?expressions functions real
?functions real
?real
#real(x) & 任意 &  $x$ の実部 \\
%real(x)@任意@$x$ の実部
 関数 `real(x)` は引数の実部を返します。
4 sgn
?expressions functions sgn
?functions sgn
?sgn
#sgn(x) & 任意 & $x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0. $x$ の虚部は無視 \\
%sgn(x)@任意@$x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0. $x$ の虚部は無視
 関数 `sgn(x)` は引数が正なら 1 を、負なら -1 を、0 ならば 0 を返します。
 引数が複素数の場合虚部は無視されます。
4 sin
?expressions functions sin
?functions sin
?sin
#sin(x) & 任意 & $\sin x$, $x$ のサイン\\
%sin(x)@任意@$sin~x$, $x$ のサイン
 関数 `sin(x)` は引数のサイン (正弦) の値を返します。`sin` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 sinh
?expressions functions sinh
?functions sinh
?sinh
#sinh(x) & 任意 & $\sinh x$, $x$ のハイパボリックサイン \\
%sinh(x)@任意@$sinh~x$, $x$ のハイパボリックサイン
 関数 `sinh(x)` は引数のハイパボリックサインの値を返します。`sinh` の
 引数はラジアンで与えます。
4 sqrt
?expressions functions sqrt
?functions sqrt
?sqrt
#sqrt(x) & 任意 & $\sqrt{x}$,  $x$ の平方根\\
%sqrt(x)@任意@$sqrt x $, $x$ の平方根
 関数 `sqrt(x)` は引数の平方根の値を返します。
4 tan
?expressions functions tan
?functions tan
?tan
#tan(x) & 任意 & $\tan x$,  $x$ のタンジェント \\
%tan(x)@任意@$tan~x$, $x$ のタンジェント
 関数 `tan(x)` は引数のタンジェント (正接) の値を返します。`tan` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 tanh
?expressions functions tanh
?functions tanh
?tanh
#tanh(x) & 任意 & $\tanh x$, $x$ のハイパボリックタンジェント\\
%tanh(x)@任意@$tanh~x$, $x$ のハイパボリックタンジェント
 関数 `tanh(x)` は引数のハイパボリックタンジェントの値を返します。`tanh` の
 引数はラジアンで与えます。
@end table

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{文字列関数} \\ \hline \hline
#関数 & 引数 & 返り値 \\ \hline
%c c l .
%関数@引数@返り値
%_
4 gprintf
?expressions functions gprintf
?functions gprintf
#gprintf("format",x) & 任意 & gnuplot の書式解析器を適用した結果の文字列 \\
%gprintf("format",x)@任意@gnuplot の書式解析器を適用した結果の文字列 \\
 `gprintf("format",x)` は、gnuplot 独自の書式指定子に一つの変数 x を適
 用し、その結果の文字列を返します。標準的な C 言語書式指定子を使いたい
 場合は、代わりに `sprintf("format",x)` を使う必要があります。
 以下参照: `format specifiers`。
4 sprintf
?expressions functions sprintf
?functions sprintf
?sprintf
#sprintf("format",x,...) & 複数個 & C 言語の sprintf の返す文字列 \\
%sprintf("format",x,...)@複数個@C 言語の sprintf の返す文字列 \\
 `sprintf("format",var1,var2,...)` は標準的な C 言語の書式指定子を複数
 個の引数に適用し、その結果の文字列を返します。gnuplot 独自の書式指定子
 を使いたい場合は、代わりに `gprintf()` を使用する必要があります。
 sprintf の書式指定子に関するより詳しい情報については、標準的な C 言語
 の本か、unix の sprintf の man ページを参照してください。
4 strlen
?expressions functions strlen
?functions strlen
?strlen
#strlen("string") & 文字列 & 文字列の長さ (整数) \\
%strlen("string")@文字列@文字列の長さ (整数)
 `strlen("string")` は文字列の中の文字数を返します。
4 strstrt
?expressions functions strstrt
?functions strstrt
?strstrt
#strstrt("string","key") & 文字列 & 部分文字列 "key" が現れる先頭位置\\
%strstrt("string","key")@文字列@部分文字列 "key" が現れる先頭位置
 `strstrt("string","key")` は、文字列 "key" を "string" の中で探し、そ
 れが現れる先頭位置を返します。"key" が見つからなかった場合は 0 を返し
 ます。C ライブラリの strstr 関数に似ていますが、文字列へのポインタを返
 す strstr とは違い、これは整数での位置を返します。例えば、
 strstrt("hayneedlestack","needle") = 4 となります。
4 substr
?expressions functions substr
?functions substr
?substr
=substring
#substr("string",beg,end) & 複数個 & 文字列 "string"[beg:end] \\
%substr("string",beg,end)@複数個@文字列 "string"[beg:end]
 `substr("string",beg,end)` は、元の文字列の beg から end 番目までの文
 字からなる文字列を返します。これは、"string"[beg:end] という式とほぼ同
 じですが、こちらはオプション beg, end を省略できません。
4 strftime
?expressions functions strftime
?functions strftime
?strftime
#strftime("timeformat",t) & 任意 & gnuplot による時刻解析結果の文字列 \\
%strftime("timeformat",t)@任意@gnuplot による時刻解析結果の文字列
 `strftime("timeformat",t)` は、2000 年からの秒数による時刻 t に、時刻
 書式指定 timeformat を適用します。
 以下参照: `time_specifiers`, `strptime`。
4 strptime
?expressions functions strptime
?functions strptime
?strptime
#strptime("timeformat",s) & 文字列 & 文字列を変換した 2000 年からの秒数 \\
%strptime("timeformat",s)@文字列@文字列を変換した 2000 年からの秒数
 `strptime("timeformat",s)` 書式指定 timeformat を使って文字列 s から時
 刻を読み込んで、それを 2000 年からの秒数に変換します。
 以下参照: `time_specifiers`, `strftime`。
4 system
?expressions functions system
?functions system
=system
#system("command") & 文字列 & 出力を持つシェルコマンド文字列\\
%system("command")@文字列@出力を持つシェルコマンド文字列
 `system("command")` は、標準的なシェルを用いて "command" を実行し、そ
 の標準出力への文字列を文字列変数として返します。一番最後の改行一つは無
 視されます。

 これは、'f(x) = real(system(sprintf("somecommand %f", x)))' のようにし
 て、外部関数の出力を gnuplot スクリプト内に取り込むのに利用できます。
4 word
?expressions functions word
?functions word
?word
=word
#word("string",n) & 文字列, 整数 & 文字列 "string" の n 番目の文字列 \\
%word("string",n)@文字列, 整数@文字列 "string" の n 番目の文字列
 `word("string",n)` は文字列 string の n 番目の文字列を返します。例えば
 `word("one two three",2)` は文字列 "two" を返します。
4 words
?expressions functions words
?functions words
?words
=words
#words("string") & 文字列 & 文字列 "string" 中の単語数 \\
%words("string")@文字列@文字列 "string" 中の単語数
 `words("string")` は文字列 string 中の単語数を返します。例えば
 `words(" a b c d")` は 4 を返します。
@end table

@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{他の {\bf gnuplot} の関数} \\ \hline \hline
#関数 & 引数 & 返り値 \\ \hline
%c c l .
%関数@引数@返り値
%_
4 column
?expressions functions column
?functions column
?column
#column(x) & 整数 & データファイル操作での $x$ 列目 \\
%column(x)@整数@ データファイル操作での $x$ 列目
 `column(x)` は fit あるいはデータファイルプロットでの `using` の操作の
 数式の一部としてのみ使われます。これは $x$ 列目の内容を数値として評価
 します。以下参照: `plot datafile using`。
4 defined
?expressions functions defined
?functions defined
?defined
#defined(X) & 変数名 & [非推奨] X が定義されていれば 1 そうでなければ 0 を返す\\
%defined(X)@変数名@ [非推奨] X が定義されていれば 1 そうでなければ 0 を返す
 `defined(X)` [非推奨] は、X が定義されていれば 1 そうでなければ 0 を返します。
4 exists
?expressions functions exists
?functions exists
?exists
#exists("X") & "変数名" & 変数名 X が定義されていれば 1 そうでなければ 0 を返す\\
%exists("X")@"変数名"@ 変数名 X が定義されていれば 1 そうでなければ 0 を返す
 exists() の引数は文字列定数、または文字列変数です。その文字列が、定義
 されている変数名を持っていれば 1 を、そうでなければ 0 を返します。
4 stringcolumn
?expressions functions stringcolumn
?functions stringcolumn
?stringcolumn
?expressions functions strcol
?functions strcol
?strcol
#stringcolumn(x) & 整数 & 文字列としての $x$ 列目の内容 \\
%stringcolumn(x)@整数@ 文字列としての $x$ 列目の内容
 `stringcolumn(x)` は fit あるいはデータファイルプロットでの `using` の
 操作の数式の一部としてのみ使われます。これは $x$ 列目の内容を文字列変
 数として返します。以下参照: `plot datafile using`。
4 timecolumn
?expressions functions timecolumn
?functions timecolumn
?timecolumn
#timecolumn(x) & 整数 & データファイル処理中の日時データ列 $x$ \\
%timecolumn(x)@整数@ データファイル処理中の日時データ列 $x$
 `timecolumn(x)` は fit あるいはデータファイルプロットでの `using` の操
 作の数式の一部としてのみ使われます。以下参照: `plot datafile using`。

 これは、その指定した列から始まるデータを日時データ値として読み、その値
 を gnuplot の内部時間表現である "2000 年からの秒数" で返します。

 処理のために正しい `timefmt` 文字列を見つけるため、`timecolumn` はその
 引数と同じ列番号を `using` 指定の中で探します。もしそれが見つかったら、
 その指定の対象となる軸の `timefmt` 文字列が使用されます。見つからなか
 ったら、`timecolumn` はデフォルトでは x 軸の `timefmt` 文字列を選択し
 ます。
4 tm_hour
?expressions tm_hour
?functions tm_hour
?tm_hour
#tm\_hour(x) & 整数 & 時\\
%tm_hour(x)@整数@時
 関数 `tm_hour` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何時 (0--23 の範囲の整数) であるかを、実数として返します。
4 tm_mday
?expressions tm_mday
?functions tm_mday
?tm_mday
#tm\_mday(x) & 整数 & 日 \\
%tm_mday(x)@整数@日
 関数 `tm_mday` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 その月の何日 (1--31 の範囲の整数) であるかを、実数として返します。
4 tm_min
?expressions tm_min
?functions tm_min
?tm_min
#tm\_min(x) & 整数 & 分 \\
%tm_min(x)@整数@分
 関数 `tm_min` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何分 (0--59 の範囲の整数) であるかを、実数として返します。
4 tm_mon
?expressions tm_mon
?functions tm_mon
?tm_mon
#tm\_mon(x) & 整数 & 月 \\
%tm_mon(x)@整数@月
 関数 `tm_mon` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 何月 (0--11 の範囲の整数) であるかを、実数として返します。
4 tm_sec
?expressions tm_sec
?functions tm_sec
?tm_sec
#tm\_sec(x) & 整数 & 秒 \\
%tm_sec(x)@整数@秒
 関数 `tm_sec` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何秒 (0--59 の範囲の整数) であるかを、実数として返します。
4 tm_wday
?expressions tm_wday
?functions tm_wday
?tm_wday
#tm\_wday(x) & 整数 & その週の何日目 \\
%tm_wday(x)@整数@その週の何日目
 関数 `tm_wday` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 その週の何日目 (0--6 の範囲の整数) であるかを、実数として返します。
4 tm_yday
?expressions tm_yday
?functions tm_yday
?tm_yday
#tm\_yday(x) & 整数 & その年の何日目 \\
%tm_yday(x)@整数@その年の何日目
 関数 `tm_yday` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 その年の何日目 (1--366 の範囲の整数) であるかを、実数として返します。
4 tm_year
?expressions tm_year
?functions tm_year
?tm_year
#tm\_year(x) & 整数 & 西暦 \\
%tm_year(x)@整数@西暦
 関数 `tm_year` は引数を 2000 年 1 月 1 日からの秒数と解釈し、それが
 西暦何年 (整数) であるかを、実数として返します。
4 valid
?expressions functions valid
?functions valid
?valid
#valid(x) & 整数 & データ中の $\mbox{column}(x)$ の正当性\\
%valid(x)@整数@ データ中の column($x$) の正当性
 `valid(x)` は、データ描画か fit における `using` の式の中でしか使われ
 ません。以下参照: `plot datafile using`。
@end table

4 種々の楕円積分 (elliptic integrals)
?expressions functions elliptic integrals
?functions elliptic integrals
?elliptic integrals
=elliptic integrals
 関数 `EllipticK(k)` は、第 1 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を返
 します。`k` の定義域は -1 から 1 です (両端は含まない)。

 関数 `EllipticE(k)` は、第 2 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**0.5` の 0 からπ/2 までの範囲の広義積分の値を返し
 ます。`k` の定義域は -1 から 1 です (両端も含む)。

 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分、すなわち関数
 `(1-(k*sin(p))**2)**(-0.5)/(1-n*sin(p)**2)` の 0 からπ/2 までの範囲の
 広義積分の値を返します。パラメータ `n` は 1 より小さく、`k` は -1 と 1
 の間 (両端は含まない) でなければいけません。定義より、すべての正の `k`
 に対し EllipticPi(0,k) == EllipticK(k) であることに注意してください。
4 乱数の生成 (random)
?expressions random
?functions random
?random
 古い版の gnuplot では、疑似乱数列を生成するのに rand(x>0) を使っていた
 こともありますが、現在の挙動は以下の通りです:
  `rand(0)`  内部に持つ 2 つの 32bit の種 (seed) の現在の値から生成され
             る [0:1] 区間内の疑似乱数値を返す
  `rand(-1)` 2 つの種の値を標準値に戻す
  `rand(x)`  x>0 ならば両方の種に x の値に基づく値を設定する
  `rand({x,y})` x>0 ならば seed1 を x に、seed2 を y に設定する

3 演算子 (Operators)
?expressions operators
?operators
 `gnuplot` の演算子は、C 言語の演算子とほぼ同じですが、特に注意がなけれ
 ば全ての演算子が整数、実数、複素数の引数を取ることができます。また、
 FORTRAN で使える ** (累乗) 演算子もサポートされています。

 演算の評価の順序を変更するにはかっこを使います。
4 単項演算子 (Unary)
?expressions operators unary
?operators unary
?unary
 以下は、単項演算子とその使用法の一覧です:

@start table - まずは対話型テキスト形式
     記号          例        説明
       -           -a          マイナス符号
       +           +a          プラス符号 (何もしない)
       ~           ~a        * 1 の補数 (ビット反転)
       !           !a        * 論理的否定
       !           a!        * 階乗
       $           $3        * `using` 内での引数/列指定
=factorial
=negation
=one's complement
=operator precedence
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{単項演算子}\\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb@-@ & \verb@-a@ & マイナス符号 \\
#\verb@+@ & \verb@+a@ & プラス符号 (何もしない) \\
#\verb@~@ & \verb@~a@ & * 1 の補数 (ビット反転) \\
#\verb@!@ & \verb@!a@ & * 論理的否定 \\
#\verb@!@ & \verb@a!@ & * 階乗 \\
#\verb@$@ & \verb@$3@ & * `using` 内での引数/列指定 \\
C ugly hack: doc2ms uses $ as delimiter for eqn's so it doesn't seem to
C be able to print them. So we have to typeset this table without using
C eqn (at least that's the only solution I found, without any real docs
C on *roff and eqn
C First, terminate the table doc2ms.c already started:
%.TE
C ... then turn off eqn delimiters:
%.EQ
%delim off
%.EN
C ... and restart the table:
%.TS
%center box tab (@) ;
%c c l .
%記号@例@説明
%_
%-@-a@マイナス符号
%+@+a@プラス符号 (何もしない)
%~@~a@* 1 の補数 (ビット反転)
%!@!a@* 論理的否定
%!@a!@* 階乗
%$@$3@* `using` 内での引数/列指定
%_
@end table
 説明に星印 (*) のついた演算子の引数は整数でなければなりません。

 演算子の優先順位は Fortran や C と同じです。それらの言語同様、演算の評
 価される順序を変えるためにかっこが使われます。よって -2**2 = -4 で、
 (-2)**2 = 4 です。

 階乗演算子は、大きな値を返せるように実数を返します。
4 二項演算子 (Binary)
?expressions operators binary
?operators binary
 以下は、二項演算子とその使用法の一覧です:

@start table - まずは対話型テキスト形式
     記号          例          説明
       **          a**b          累乗
       *           a*b           積
       /           a/b           商
       %           a%b         * 余り
       +           a+b           和
       -           a-b           差
       ==          a==b          等しい
       !=          a!=b          等しくない
       <           a<b           より小さい
       <=          a<=b          以下
       >           a>b           より大きい
       >=          a>=b          以上
       &           a&b         * ビット積 (AND)
       ^           a^b         * ビット排他論理和 (XOR)
       |           a|b         * ビット和 (OR)
       &&          a&&b        * 論理的 AND
       ||          a||b        * 論理的 OR
       =           a = b         代入
       ,           (a,b)         累次評価
       .           A.B           文字列の連結
       eq          A eq B        文字列が等しいかどうか
       ne          A ne B        文字列が等しくないかどうか
=bitwise operators
=string operators
=modulo
=exponentiation
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{二項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~**~ & \verb~a**b~ & 累乗\\
#\verb~*~ & \verb~a*b~ & 積\\
#\verb~/~ & \verb~a/b~ & 商\\
#\verb~%~ & \verb~a%b~ & * 余り\\
#\verb~+~ & \verb~a+b~ & 和\\
#\verb~-~ & \verb~a-b~ & 差\\
#\verb~==~ & \verb~a==b~ & 等しい\\
#\verb~!=~ & \verb~a!=b~ & 等しくない\\
#\verb~<~ & \verb~a<b~ & より小さい\\
#\verb~<=~ & \verb~a<=b~ & 以下\\
#\verb~>~ & \verb~a>b~ & より大きい\\
#\verb~>=~ & \verb~a>=b~ & 以上\\
#\verb~&~ & \verb~a&b~ & * ビット積 (AND)\\
#\verb~^~ & \verb~a^b~ & * ビット排他的論理和 (XOR)\\
#\verb~|~ & \verb~a|b~ & * ビット和 (OR)\\
#\verb~&&~ & \verb~a&&b~ & * 論理的 AND\\
#\verb~||~ & \verb~a||b~ & * 論理的 OR\\
#\verb~=~ & \verb~a = b~ & 代入\\
#\verb~,~ & \verb~(a,b)~ & 累次評価\\
#\verb~.~ & \verb~A.B~ & 文字列の連結\\
#\verb~eq~ & \verb~A eq B~ & 文字列が等しいかどうか\\
#\verb~ne~ & \verb~A ne B~ & 文字列が等しくないかどうか\\
%c c l .
%記号@例@説明
%_
%**@a**b@累乗
%*@a*b@積
%/@a/b@商
%%@a%b@* 余り
%+@a+b@和
%-@a-b@差
%==@a==b@等しい
%!=@a!=b@等しくない
%<@a<b@より小さい
%<=@a<=b@以下
%>@a>b@より大きい
%>=@a>=b@以上
%&@a&b@* ビット積 (AND)
%^@a^b@* ビット排他的論理和 (XOR)
%|@a|b@* ビット和 (OR)
%&&@a&&b@* 論理的 AND
%||@a||b@* 論理的 OR
%=@a = b@代入
%,@(a,b)@累次評価
%.@a.b@文字列の連結
%eq@A eq B@文字列が等しいかどうか
%ne@A ne B@文字列が等しくないかどうか

@end table
 説明に星印 (*) のついた演算子の引数は整数でなければなりません。
 大文字の A,B は演算子が文字列引数を要求することを意味します。

 論理演算子の AND (&&) と OR (||) は C 言語同様に必要最小限の評価しかし
 ません。すなわち、`&&` の第 2 引数は、第 1 引数が偽ならば評価されませ
 んし、`||` の第 2 引数は、第 1 引数が真ならば評価されません。

 累次評価 (,) は、カッコの中でのみ評価され、左から右へ順に実行すること
 が保証され、最も右の式の値が返されます。
4 三項演算子 (Ternary)
?expressions operators ternary
?operators ternary
?ternary
 一つだけ三項演算子があります:

@start table - まずは対話型テキスト形式
      記号          例       説明
       ?:          a?b:c     三項演算子
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{三項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~?:~ & \verb~a?b:c~ & 三項演算子\\
%c c l .
%記号@例@説明
%_
%?:@a?b:c@* 三項演算子

@end table
 三項演算子は C のものと同じ働きをします。最初の引数 (a) は整数でなけれ
 ばいけません。この値が評価され、それが真 (ゼロでない) ならば 2 番目の
 引数 (b) が評価されその値が返され、そうでなければ 3 番目の引数 (c) が
 評価され、その値が返されます。

 三項演算子は、区分的に定義された関数や、ある条件が満たされた場合にのみ
 点を描画する、といったことを行なう場合に有用です。

 例:

 0 <= x < 1 では sin(x) に、1 <= x < 2 では 1/x に等しくて、それ以外の
 x では定義されない関数を描画:
       f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
       plot f(x)
^ <img align=bottom src="http://www.gnuplot.info/doc/ternary.gif" alt="[ternary.gif]" width=640 height=480>
 `gnuplot` は未定義値に対しては何も表示せずにただ無視するので、最後の場
 合の関数 (1/0) は点を何も出力しないことに注意してください。また、この
 関数描画の描画スタイルが lines (線描画) の場合、不連続点 (x=1) の所も
 連続関数として線が結ばれてしまうことにも注意してください。その点を不連
 続になるようにするには、関数を 2 つの部分それぞれに分けてください (こ
 のような場合、媒介変数関数を使うのが便利です)。

 ファイル 'file' のデータで、4 列目のデータが負でないときだけ、1 列目の
 データに関する 2 列目と 3 列目のデータの平均値を描画:

       plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )

 `using` の書式の説明に関しては、以下参照: `plot datafile using`。

3 定義済み変数 (Gnuplot-defined variables)
?gnuplot-defined variables
 gnuplot は、プログラムの現在の内部状態と直前の描画を反映するような読み
 出し専用の変数をいくつか持っています。これらの変数の名前は、例えば
 GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN のように "GPVAL_" で
 始まります。これらすべての一覧とその値を見るには、`show variables all`
 と入力してください。ただし、軸のパラメータに関連する値 (範囲、対数軸で
 あるか等) は、現在 `set` したものではなく、最後に描画されたものが使用
 されます。

=errors
=error state
 読み出し専用変数 GPVAL_ERRNO は、任意の gnuplot コマンドがあるエラーの
 ために早く終わってしまった場合に 0 でない値にセットされ、直前のエラー
 メッセージは文字列変数 GPVAL_ERRMSG に保存されます。GPVAL_ERRNO と
 GPVAL_ERRMSG は、コマンド `reset errors` を使ってクリアできます。

 `mouse` 機能が使える対話型入出力形式は、"MOUSE_" で始まる読み出し専用
 変数をいくつか持っています。詳細は、以下参照: `mouse variables`。

 `fit` 機能は、"FIT_" で始まるいくつかの変数を使用しますので、そのよう
 な名前を使うのは避けるべきでしょう。しかし、`fit` の使用に際しては、例
 えば "FIT_LIMIT" のように再定義をする必要があるような変数はあります。
 `set fit errorvariables` とすると各当てはめ変数のエラーは、そのパラメ
 ータ名に "_err" を追加した変数に保存されます。詳細は、以下参照: `fit`。

 以下も参照: `user-defined variables`, `reset errors`,
 `mouse variables`, `fit`。

3 ユーザ定義の変数と関数 (User-defined)
?expressions user-defined
?user-defined variables
?user-defined
?variables
 新たなユーザ定義変数と 1 個から 12 個までの引数を持つユーザ定義関数を、
 任意の場所で定義したり使ったりすることができます。それは `plot` コマン
 ド上でも可能です。

 ユーザ定義関数書式:
       <func-name>( <dummy1> {,<dummy2>} ... {,<dummy12>} ) = <expression>

 ここで <expression> は仮変数 <dummy1> から <dummy12> で表される数式です。

 ユーザ定義変数書式:
       <variable-name> = <constant-expression>

 例:
       w = 2
       q = floor(tan(pi/2 - 0.1))
       f(x) = sin(w*x)
       sinc(x) = sin(pi*x)/(pi*x)
       delta(t) = (t == 0)
       ramp(t) = (t > 0) ? t : 0
       min(a,b) = (a < b) ? a : b
       comb(n,k) = n!/(k!*(n-k)!)
       len3d(x,y,z) = sqrt(x*x+y*y+z*z)
       plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)

       file = "mydata.inp"
       file(n) = sprintf("run_%d.dat",n)

^ <img align=bottom src="http://www.gnuplot.info/doc/userdefined.gif" alt="[userdefined.gif]" width=640 height=480>
 最後の 2 行の例は、ユーザ定義文字列変数と、ユーザ定義文字列関数を意味
 しています。

=NaN
=pi
 変数 `pi` (3.14159...) と `NaN` (IEEE 非数 ("Not a Number")) はあらか
 じめ定義されています。これらが必要なければ、他のものに再定義することも
 可能ですし、以下のようにして元の値に復帰することもできます:

       NaN = GPVAL_NaN
       pi  = GPVAL_pi

 他にもいくつかの変数が、例えば対話型入出力形式でのマウス操作や当てはめ
 (fit) などの gnuplot の動作状態に応じて定義されます。詳細は
 以下参照: `gnuplot-defined variables`。

 ある変数 V が既に定義されているかどうかは、式 exists("V") でチェックで
 きます。例:
       a = 10
       if (exists("a")) print "a is defined"
       if (!exists("b")) print "b is not defined"

 変数名や関数名の命名規則は、大抵のプログラミング言語と同じで、先頭はア
 ルファベットで、その後の文字はアルファベット、数字、"$", "_" が使えま
 す。

 各関数の定義式は、'GPFUN_' という接頭辞を持つ特別な文字列値変数として
 利用できます。

 例:
       set label GPFUN_sinc at graph .05,.95

 以下参照: `show functions`, `functions`, `gnuplot-defined variables`,
 `macros`。
2 フォント
?fonts
 gnuplot それ自身にはどんなフォントも含まれてはおらず、外部フォント処理
 に頼っているだけで、その細部は悲しいことに出力形式毎に異なります。ここ
 では、複数の出力形式に適用されるフォント機構について説明します。ここに
 上げたもの以外の出力形式でのフォントの使用に関しては、その出力形式のド
 キュメントを参照してください。
3 cairo (pdfcairo, pngcairo, wxt 出力形式)
?fonts cairo
=fonts
=pdf
=png
=wxt
 すみません。このセクションはまだできていません。
3 gd (png, gif, jpeg terminals)
?gd
?fonts gd
=fonts
=png
=jpeg
=gif
 png, gif, jpeg 出力形式のフォント処理は、外部ライブラリ libgd によって
 行われます。libgd は、次の 5 種類の基本フォントを直接提供しています:
 `tiny` (5x8 ピクセル), `small` (6x12 ピクセル), `medium`, (7x13 Bold),
 `large` (8x16), `giant` (9x15 ピクセル)。これらのフォントは大きさを変
 更したり回転したりすることはできません。使用する際は、`font` キーワー
 ドの代わりに上のキーワードを指定します。例:
      set term png tiny

 多くのシステムで、libgd は Adobe Type 1 フォント (*.pfa) と TrueType
 フォントへのアクセスも提供します。その場合フォント自身の名前ではなく、
 フォントファイルの名前を、"<face> {,<pointsize>}" の形式で与えます。
 ここで、<face> はフォントファイルのフルパス名か、または環境変数
 GDFONTPATH で指示されるディレクトリの一つの中のファイル名の先頭部分、
 のいずれかです。よって、'set term png font "Face"' は、
 <あるディレクトリ>/Face.ttf か <あるディレクトリ>/Face.pfa というファ
 イル名のフォントを探そうとします。例えば、GDFONTPATH に
 `/usr/local/fonts/ttf:/usr/local/fonts/pfa` が含まれている場合は、以下
 のコマンドの 2 つずつはいずれも同じことになります:
      set term png font "arial"
      set term png font "/usr/local/fonts/ttf/arial.ttf"
      set term png font "Helvetica"
      set term png font "/usr/local/fonts/pfa/Helvetica.pfa"
 デフォルトのフォントサイズも同時に指定するには:
      set term png font "arial,11"

 TrueType と Adobe Type 1 フォントは、完全に大きさの変更や回転が可能で
 す。"set term" コマンドでフォントを指定しなかった場合、gnuplot は別の
 デフォルトフォントの設定があるかどうかを調べるために環境変数
 GNUPLOT_DEFAULT_GDFONT を参照します。
3 postscript (カプセル化 postscript *.eps も)
?fonts postscript
=fonts
=postscript
=eps
 PostScript フォント処理は、プリンタか表示ソフトが行います。もし、あな
 たのコンピュータにフォントが一切なくても、gnuplot は正しい PostScript
 ファイル、またはカプセル化 PostScript (*.eps) ファイルを生成できます。
 gnuplot は単に出力ファイル中にフォントを名前として入れるだけで、プリン
 タや表示ソフトがその名前からフォントを見つけるか近似することを仮定して
 います。

 PostScript プリンタや表示ソフトはすべて、標準的な Adobe フォントセット
 `Times-Roman`, `Helvetica`, `Courier`, `Symbol` は知っているはずです。
 多分その他にも多くのフォントが使えるようになっていると思いますが、それ
 ら特定のフォントセットはあなたのシステムやプリンタの設定に依存します。
 gnuplot は、それは知りませんし気にもしません。gnuplot が作成した *.ps
 や *.eps 出力は、あなたの要求したフォント名を単に持っているだけです。

 よって、
      set term postscript eps font "Times-Roman,12"
 は、すべてのプリンタや表示ソフトに適切な出力を作成します。

 一方、
      set term postscript eps font "Garamond-Premier-Pro-Italic"
 は、正しい PostScript を含む出力ファイルを作成しますが、それは特殊なフ
 ォントを参照しますので、一部のプリンタや表示ソフトしか、要求したその特
 定のフォントは表示できないでしょう。大抵の場合は別なフォントで代用され
 ます。

 しかし、指定したフォントを出力ファイル中に埋め込んで、どんなプリンタで
 もそれを使うようにすることも可能です。これには、あなたのシステムに適切
 なフォント記述ファイルがあることが必要となります。この方法でフォントを
 埋め込む場合、特定のライセンスが必要となるフォントファイルもあることに
 注意してください。より詳細な説明や例については、以下参照:
 `postscript fontfile`。
2 ヘルプの用語解説 (Glossary)
?glossary
 このドキュメント全体に渡って、用語に関する一貫性の維持が考えられていま
 す。しかしこの試みは完全には成功していません。それは `gnuplot` が時間
 をかけて進化してきたように、コマンドやキーワードの名前もそのような完全
 性を排除するかのように採用されて来ているからです。この節では、これらの
 キーワードのいくつかがどのように使われているかを説明します。

 "ページ (page)"、"表示画面 (screen)"、"キャンバス (canvas)" は、
 `gnuplot` がアクセス可能な領域全体を指します。デスクトップではそれはウ
 ィンドウ全体を指し、プロッタでは、一枚の紙全体、svga モードでは、モニ
 タスクリーン全体を指します。

 表示画面は、一つ、またはそれ以上の "グラフ描画 (plot)" を含みます。グ
 ラフ描画は一つの横座標と一つの縦座標で定義されますが、余白 (margin) や
 その中に書かれる文字列 (text) 同様、それらは実際にその上に表示されてい
 る必要はありません。

 グラフ描画は一つの "グラフ" を含みます。グラフは一つの横座標と一つの縦
 座標で定義されますが、これらは実際にその上に表示されている必要はありま
 せん。

 グラフは一つまたはそれ以上の "曲線 (line)" を含みます。曲線は一つの関
 数、またはデータ集合です。用語 "line" は描画スタイルとしても使われます。
 さらにこの用語は "文字列の一行 (a line of text)" のように使われること
 もあります。多分文脈からそれらは区別できるでしょう。

 一つのグラフ上の複数の曲線はそれぞれ名前を持ちます。その名前は、その曲
 線の表現に使われる描画スタイルのサンプルとともに "(説明) key" 内に一覧
 表示されます。説明は、時には "(表題) legend" とも呼ばれます。

 用語 "タイトル (title)" は `gnuplot` では複数の意味で使われます。この
 ドキュメントではそれらを区別するために、形容詞として "描画の (plot)"、
 "曲線の (line)"、"説明の (key)" を頭につけたりもします。
 2 次元のグラフは 4 つまでの見出し付けされる軸を持つことができます。こ
 れら 4 つの軸の名前はそれぞれ、グラフ描画の下の境界に沿う軸である "x"、
 左の境界に沿う軸 "y"、上の境界に沿う軸 "x2"、右の境界に沿う軸 "y2" と
 なっています。以下参照: `axes`。

 3 次元のグラフは  3 つまでの見出し付けされる軸 (`axes`) "x","y","z" を
 持つことができます。どの特定の軸に関してもそれがグラフ上でどこに書かれ
 るかを述べることはできません。それは、`set view` でグラフを見る方向を
 変更できるからです。

 データファイルに関する議論では、用語 "行 (record)" を復活し、ファイル
 の一行の文字列、すなわち、改行文字や行末文字同士の間の文字列、を指し示
 すのに使います。"点 (point)" は行から取り出した一つのデータです。"デー
 タブロック (datablock)" は、空行で区切られた連続した複数の行からなる点
 の集合です。データファイルの議論の中で "line" が参照される場合は、これ
 はデータブロックの部分集合を指します。

 (訳注: この日本語訳の中ではここに書かれているような用語の統一は考慮さ
 れてはおらず、よって混乱を引き起こす可能性があります。厳密には原文を参
 照すべきでしょう。)
2 線種、色、スタイル (linetype)
?linetype
?colors
 gnuplot の各出力形式は "線種 (linetype)" をある程度用意しています。そ
 れらは色、太さ、点線/破線のパターン、または色と点線/破線の組合せで違い
 を表現しています。特定の出力形式のデフォルトの線種は、その出力形式を設
 定した (`set terminal`) 後で `test` コマンドを発行することで確認できま
 す。定義されている色、点線/破線のパターンはすべての出力形式で同じもの
 であるという保証は何もありませんが、線種 -1 は特別に全ての出力形式で、
 最も普通の表示色 (通常は黒) の実線を意味しています。デフォルトでは、一
 つの描画コマンド内での関数やデータファイルの並びには、順番に線種が割り
 当てられます。そのデフォルトは、関数、データファイル、またはその他の描
 画要素に個別に線種を指定することで上書きできます。

 例:

      plot "foo", "bar"                 # 線種 1, 2 で 2 ファイルを描画
      plot sin(x) linetype 4            # 出力形式に依存する線種色 4
      plot sin(x) lt -1                 # 黒

=colors
 多くの出力形式で、ユーザ定義色を定義できるようになっています。色の定義
 は明示的な rgb (赤、緑、青) を指定するか、色名か、現在の PM3D パレット
 を参照する色の値のいずれかで行ないます。

 例:

      plot sin(x) lt rgb "violet"       # gnuplot の持つ色名の一つ
      plot sin(x) lt rgb "#FF00FF"      # 明示的な 16 進 RGB 3 つ組
      plot sin(x) lt palette cb -45     # 現在のパレットの cbrange の
                                        # -45 に対応する色
      plot sin(x) lt palette frac 0.3   # パレットに対応する小数値

 以下参照: `show colornames`, `set palette`, `cbrange`。

 点線/破線のパターンをサポートする出力形式では、デフォルトの線種は点線/
 破線のパターンと色の両方が定義されています。しかし、デフォルトの色は、
 キーワード `linecolor` (省略形は `lc`) を使うことで上書きできます。例
 えば、postscript 出力形式のデフォルトの線種 3 は青の破線です。以下の描
 画コマンドは同じ破線パターンで 3 つの描画を行ないますが、一つは青 (デ
 フォルト)、一つは赤 (線種 1 のデフォルト色)、もう一つは金色になります。

 例:

      set term postscript dashed color
      plot 'foo' lt 3, 'baz' lt 3 linecolor 1, 'bar' lt 3 lc rgb 'gold'

 線は、線幅のような他の属性も持つことができます。点 (point) の記号に対
 する同様の属性とともに、これらの属性をコマンド `set style line` を使っ
 てユーザ定義 "ラインスタイル (linestyle)" として結びつけることができま
 す。一度定義された linestyle は、plot コマンド中で、一つまたは多くの描
 画要素に対してその表示を制御するのに使うことができます。

 例:

      # 新しいラインスタイルを、出力形式に依存しない色 cyan、線幅が 3、
      # 点種 6 (丸の中に点) と定義
      set style line 5 lt rgb "cyan" lw 3 pt 6
      plot sin(x) with linespoints ls 5          # 定義スタイル 5 で

 以下参照: `linestyle`, `set style line`。
3 色指定 (colorspec)
?colorspec
?rgbcolor
=colors
?lc
?linecolor
?tc
?textcolor
 多くのコマンドで、明示的な色の指定をともなった線種を指定することができ
 ます。出力形式に依存する色の選択は、使用している出力形式が RGB カラー
 か pm3d パレットをサボートしている場合にのみ利用可能です。

 書式:

       ... {linecolor | lc} <colorspec>
       ... {textcolor | tc} <colorspec>

 <colorspec> は以下の形式のいずれかです:

       rgbcolor "colorname"
       rgbcolor "#RRGGBB"
       rgbcolor variable       # 色は入力ファイルから読み込む
       palette frac <val>      # <val> は 0 から 1 の値
       palette cb <value>      # <val> は cbrange の範囲の値
       palette z
       variable                # 入力ファイルから色番号を読み込む

 "colorname" は gnuplot が内部に持っている色の名前のうちの一つを指定し
 ます。有効な名前の一覧に関しては、以下参照: `show colornames`。

 "#RRGGBB" は "#" 記号の後に 16 進定数を並べます。RRGGBB は、赤、緑、青
 の色の成分を意味し、それぞれは 0 - 255 の範囲の数です。例えば、マゼン
 タ (紫) = 最も明るい赤 + 最も明るい青、なので、#FF00FF と表され、これ
 は 16 進数で、(255 << 16) + (0 << 8) + (255) を意味しています。

 カラーパレットとは、色の線型な勾配で、単一の数値を特定の色に滑らかに対
 応づけます。常にそのような 2 つの対応付けが効力を持ちます。
 `palette frac` は 0 から 1 までの小数値を、カラーパレットの全範囲に対
 応付けるもので、`palette cb` は、色軸の範囲を同じカラーパレットへ割り
 当てるものです。以下参照: `set cbrange`, `set colorbox`。これらの対応
 付けのどちらかを使って、現在のパレットから定数色を選び出すことができま
 す。

 "palette z" は、各描画線分や描画要素の z の値を、パレットへ対応づけら
 れている cbrange の範囲に対応づけます。これにより、3 次元の曲線や曲面
 に沿って色を滑らかに変化させることができます。これは、2 次元描画で、パ
 レット値を追加の列データから読み込ませて色付けするのにも使えます (すべ
 ての 2 次元描画スタイルがこの追加列を認識するわけではありません)。
4 rgbcolor variable
?rgbcolor variable
?lc rgbcolor variable
?tc rgbcolor variable
 大抵の場合描画コマンドは、各描画要素に一つの色 (線種) を割り当て、一つ
 のグラフに複数の描画を行う場合、デフォルトの色 (線種) が順番に使われて
 いきます。これとは別に、入力データファイルの追加情報に基づいて、各デー
 タ点、各線分、または各ラベルにそれぞれ異なる色を割り当てることも可能で、
 これは、色指定のキーワード `variable` を使うことで行えます。

 `lc rgbcolor variable` は、データファイルの別の列から 24-bit RGB 色を
 取得して使用するようプログラムに指示します。よってこれは、`using` 指定
 子へ対応する列の指定の追加を必要とし、その列は 24-bit 形式の RGB の 3
 つ組であるとみなされます。これは、最も簡単な形式の 16 進値として指定し
 ます (以下参照: `rgbcolor`)。文字の色も同様に、`tc rgbcolor variable`
 で指定できます。

 例:

       # 3 次元描画で、各 x,y,z 座標に対応した赤、緑、青の成分を持つ色
       # のついた点を配置
       rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
       splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable

4 linecolor variable
?linecolor variable
?lc variable
?textcolor variable
?tc variable
 大抵の場合描画コマンドは、各描画要素に一つの色 (線種) を割り当て、一つ
 のグラフに複数の描画を行う場合、デフォルトの色 (線種) が順番に使われて
 いきます。これとは別に、入力データファイルの追加情報に基づいて、各デー
 タ点、各線分、または各ラベルにそれぞれ異なる色を割り当てることも可能で、
 これは、色指定のキーワード `variable` を使うことで行えます。

 `lc variable` は、入力データの一つの列から読んだ値をラインスタイルの番
 号として使い、そのラインスタイルに属する色を使うようプログラムに指示し
 ます。よってこれは、`using` 指定子へ対応する列の指定の追加を必要としま
 す。文字の色も同様に、`tc variable` で指定できます。

 一つのデータファイルには、複数のデータ集合を入れることが可能で、それら
 は 2 行の空行で分離されています。これらの個々のデータ集合には、index
 値が割り当てられていて (以下参照: `index`)、using 指定の column(-2) で
 取得できます。以下参照: `pseudocolumns`。デフォルトでは、ファイル内の
 すべてのデータが同じ色、線種、点種の属性で描画されますが、コマンド
 `lc variable` を使えば、疑似列 -2 による index 値を用いて、そのファイ
 ル内の個々のデータ集合に異なる色を割り当てることが可能です。

 例:
       # データの 3 列目を、個々の点に色を割り当てるのに使用
       plot 'data' using 1:2:3 with points lc variable

       # ラインスタイルの色を選択するのにデータ集合の index を使用
       plot 'data' using 1:2:(column(-2)) with lines lc variable

2 マウス入力 (mouse input)
?mouse input
 出力形式 `x11`, `pm`, `windows`, `ggi`, `wxt` では、現在の描画にマウス
 を使って作用をすることが可能になっています。これらはホットキーの定義も
 サポートしていて、マウスカーソルが有効な描画ウィンドウにあるときに、あ
 るキーを押すことであらかじめ定義した関数を実行させることができます。マ
 ウス入力を `batch` コマンドスクリプトと組み合わせることも可能で、例え
 ば `pause mouse` として、その後にマウスクリックによってパラメータとし
 て返って来るマウス変数をその後のスクリプト動作に反映させることができま
 す。以下参照: `bind`, `mouse variables`。また以下も参照: `set mouse`。
3 bind
?commands bind
?bind
 書式:
       bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
       bind <key-sequence> ""
       reset bind

 `bind` は、ホットキーの定義、再定義に使用します。ホットキーとは、入力
 カーソルがドライバのウィンドウ内にあるときに、あるキー、または複数のキ
 ーを押すことで、gnuplot のコマンド列を実行させる機能のことを言います。
 `bind` は、gnuplot が `mouse` をサポートするようにコンパイルされていて
 かつマウスが有効な出力形式上で使われてる場合にのみ有効であることに注意
 してください。ユーザ指定のキー割当 (binding) は、組み込み (builtin) キ
 ー割当を置き換えますが、<space> と 'q' は通常は再定義はできません。そ
 の唯一の例外については、以下参照: `bind space`。

 マウスボタンは再定義はできません。

 ホットキーの一覧を得るには `show bind`, または `bind` とタイプするか、
 グラフウィンドウ上でホットキー 'h' を入力してください。

 キー定義は、`reset bind` でデフォルトの状態に復帰できます。

 修飾キーを含む複数のキーの定義は引用符で囲む必要があることに注意してく
 ださい。

 標準ではホットキーは現在の描画ウィンドウ上に入力カーソルがある場合のみ
 認識されます。`bind allwindows <key> ...` (`bind all <key> ...` と省略
 可) は、<key> の割当を、それが現在の有効なものか否かに関わらず、すべて
 の gnuplot の描画ウィンドウ上で可能にします。この場合、gnuplot 変数
 MOUSE_KEY_WINDOW にそれが行なわれたウィンドウの ID が保存されるのでそ
 れをキーに割り当てたコマンドで使用することができます。

 例:

 - キー割当の設定:

     bind a "replot"
     bind "ctrl-a" "plot x*x"
     bind "ctrl-alt-a" 'print "great"'
     bind Home "set view 60,30; replot"
     bind all Home 'print "This is window ",MOUSE_KEY_WINDOW'

 - キー割当を表示:
     bind "ctrl-a"          # ctrl-a に対するキー割当を表示
     bind                   # 全てのキー定義を表示
     show bind              # 全てのキー定義を表示

 - キー割当を削除:
     bind "ctrl-alt-a" ""   # ctrl-alt-a のキー割当を削除
                              (組み込みキー定義は削除されません)
     reset bind             # デフォルト (組み込み) のキー定義を導入
     bind!                  # "reset bind" の別の形式 (非推奨)

 - トグルスイッチ形式にキー割当:
   v=0
   bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term x11 raise"

 修飾キー (ctrl / alt) は大文字小文字の区別はありませんが、キーはそうで
 はありません:
     ctrl-alt-a == CtRl-alT-a
     ctrl-alt-a != ctrl-alt-A

 修飾キー (alt == meta) の一覧:
     ctrl, alt

 サポートされている特殊キーの一覧:

    "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
    "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
    "PageUp", "PageDown", "End", "Begin",

    "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
    "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
    "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
    "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
    "KP_Divide",

    "KP_1" - "KP_9", "F1" - "F12"

 以下は、実際のキーではなく、ウィンドウに関するイベントです:

    "Close"

 以下も参照: `mouse`, `if`。
4 bind space
?commands bind space
?bind space
 gnuplot が、configure 時にオプション --enable-rase-console をつけてイ
 ンストールされた場合は、描画ウィンドウ内で <space> をタイプすると
 gnuplot のコマンドウィンドウが前面に出ます。このホットキーは、
 'gnuplot -ctrlq' のようにして gnuplot を起動するか、または X リソース
 の 'gnuplot*ctrlq' を設定することで ctrl-space に変更できます。
 以下参照: `x11 command-line-options`。
3 マウス用の変数 (Mouse variables)
?mouse variables
 マウス機能が有効な場合、現在のウィンドウ上でのマウスクリックによって
 gnuplot のコマンドライン上で使うことができる色々なユーザ変数が設定され
 ます。クリック時のマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2,
 MOUSE_Y2 に代入されます。クリックされたボタンや、そのときのメタキーの
 状態は MOUSE_BUTTON, MOUSE_SHIFT, MOUSE_ALT, MOUSE_CTRL に代入されます。
 これらの変数は任意の描画の開始時には未定義で、有効な描画ウィンドウ中で
 のマウスクリックイベントによって初めて定義されます。有効な描画ウィンド
 ウ中でマウスが既にクリックされたかどうかをスクリプトから調べるには、こ
 れらの変数のうちのどれか一つが定義されているかどうかをチェックすれば十
 分です。

       plot 'something'
       pause mouse
       if (defined(MOUSE_BUTTON)) call 'something_else'; \
       else print "No mouse click."

 描画ウィンドウ上での一連のキー入力を追跡することも、マウスコードを使う
 ことで可能となります。

       plot 'something'
       pause mouse keypress
       print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y

 `pause mouse keypress` が、キー入力で終了した場合は MOUSE_KEY には押さ
 れたキーの ascii コードが保存されます。MOUSE_CHAR にはその文字自身が文
 字列値として保存されます。pause コマンドが (例えば ctrl-C や描画ウィン
 ドウが外部から閉じられるなどして) 異常終了した場合は MOUSE_KEY は -1
 になります。

 マウスによる拡大の後の新しい描画範囲は、GPVAL_X_MIN, GPVAL_X_MAX,
 GPVAL_Y_MIN, GPVAL_Y_MAX で参照できることに注意してください。
 以下参照: `gnuplot-defined variables`。


2 描画 (Plotting)
?plotting
 `gnuplot` には描画を生成する 3 つのコマンド、`plot`, `splot`, `replot`
 があります。`plot` は 2 次元描画を生成し、`splot` は 3 次元描画 (もち
 ろん実際には 2 次元面への射影) を生成します。`replot` は与えられた引数
 を、直前の `plot` または `splot` コマンドに追加し、それを実行します。

 描画に関する一般的な情報の大半は、`plot` に関する項で見つかります。3
 次元描画に固有の情報は `splot` の項にあります。

 `plot` は xy 直交座標系と極座標系が使えます。極座標系の詳細に関しては
 以下参照: `set polar`。`splot` は xyz 直交座標系のみしか扱えませんが、
 コマンド `set mapping` で他の 2, 3 の座標系を使用することが出来ます。
 さらに、オプション `using` を使えば、`plot` でも `splot` でもほとんど
 どんな座標系でもそれを定義して使うことが出来ます。

=axes
 `plot` では、4 つの境界 x (下), x2 (上), y (左), y2 (右) をそれぞれ独
 立な軸として扱うこともできます。オプション `axes` で、与えられた関数や
 データ集合をどの軸のペアで表示させるかを選べます。また、各軸の縮尺や見
 出しづけを完全に制御するために十分な補佐となる `set` コマンド群が存在
 します。いくつかのコマンドは、`set xlabel` のように軸の名前をその中に
 持っていますし、それ以外のものは `set logscale xy` のように、1 つ、ま
 たは複数の軸の名前をオプションとしてとります。z 軸を制御するオプション
 やコマンドは 2 次元グラフには効力を持ちません。

 `splot` は、曲面の描画と、点や線を加えて等高線を書くことも出来ます。3
 次元の関数の格子定義に関する情報については、以下参照: `splot`,
 `set isosamples`。3 次元データのファイルに必要な形態に関しては、以下も
 参照: `splot datafile`。等高線に関する情報については、以下も参照:
 `set contour`, `set cntrparam`。

 `splot` での縮尺や見出し付けの制御は、x2 軸と y2 軸を制御するコマンド
 やオプションは効果がなく、z 軸を制御するものにはもちろん効果がある、と
 いうことを除けば `plot` と全く同じです。
2 起動 (Startup)
?startup
?start
?.gnuplot
^ <a name="start-up"></a>
 `gnuplot` が起動されるとき、初期設定ファイルを読み込もうとします。この
 ファイルは Unix と AmigaOS では、`.gnuplot` であり、その他の処理系で
 は `GNUPLOT.INI` となっています。このファイルがカレントディレクトリに
 無い場合、`gnuplot` はホームディレクトリを検索します (AmigaOS, MS-DOS,
 Windows, OS/2 では、環境変数 `GNUPLOT` にホームディレクトリに対応する
 ディレクトリを指定します; Windows NT では、GNUPLOT が定義されていなけ
 れば `USERPROFILE` が使われます)。注意: インストールの時に NOCWDRC を
 定義した場合には、`gnuplot` はカレントディレクトリからは読みません。

 初期設定ファイルが見つかると、`gnuplot` はこのファイルに書かれているコ
 マンドを実行します。ここには任意の正しい `gnuplot` コマンドを書くこと
 が可能ですが、一般的には、出力装置の指定や、よく使う関数や変数の定義を
 設定する程度に抑えておきます。
2 文字列定数と文字列変数 (Strings)
?strings
?string variables
 文字列定数に加えて、ほとんどの gnuplot コマンドは文字列変数、文字列式
 または文字列を返す関数も受け付けます。例えば、以下の 4 つの plot のや
 り方は結果として全て同じ描画タイトルを生成します:

       four = "4"
       graph4 = "Title for plot #4"
       graph(n) = sprintf("Title for plot #%d",n)

       plot 'data.4' title "Title for plot #4"
       plot 'data.4' title graph4
       plot 'data.4' title "Title for plot #".four
       plot 'data.4' title graph(4)

 整数は、それが文字列結合演算子によって作用された場合は、文字列に変換さ
 れますので、以下の例も上と同様に動作します:

       N = 4
       plot 'data.'.N title "Title for plot #".N

 一般に、コマンドラインの各要素は、それらが標準的な gnuplot への命令文
 法の一部分と認識されるもの以外は、有効な文字列変数としての評価のみが行
 なわれます。よって、以下のコマンド列は、恐らくは混乱を引き起こさないよ
 うに避けられるべきですが、文法的には間違ってはいません:

       plot = "my_datafile.dat"
       title = "My Title"
       plot plot title title

 文字列に対する 3 つの二項演算子が用意されています: 文字列の結合演算子
 ".", 文字列の等号演算子 "eq", および文字列の不等号演算子 "ne" です。以
 下の例では TRUE が表示されます。

      if ("A"."B" eq "AB") print "TRUE"

 以下も参照: 2 つの文字列書式関数 `gprintf`, `sprintf`。

=substring
 任意の文字列、文字列変数、文字列値関数に、範囲指定子をつけることにより
 部分文字列を指定できます。範囲指定子は [begin:end] の形で、begin は部
 分文字列の先頭位置、end は最後の位置です。位置指定は、最初の文字を 1
 番目と見ます。先頭の位置、最後の位置は空、あるいは '*' でも構いません。
 その場合、それは元の文字列自体の先頭、あるいは最後を意味します。例えば、
 str[:] や str[*:*] はどちらも str の文字列全体を意味します。
2 置換とコマンドラインマクロ (Substitution)
?substitution
 gnuplot への命令文字列が最初に読み込まれた時点、すなわちまだそれが解釈
 され、もしくは実行される前の段階で、2 つの形式の単語の置換が実行されま
 す。それらはバッククォート (ASCII 番号 96) で囲まれているか、または @
 (ASCII 番号 64) が頭についた文字列に対して行なわれます。
3 バッククォートによるシステムコマンドの置換 (Substitution backquotes)
?substitution backquotes
?backquotes
?shell commands
 シェルコマンドをバッククォートで囲むことによってコマンド置換を行うこ
 とができます。このコマンドは子プロセスで実行され、その出力結果でコマ
 ンドラインのバッククォートで囲まれたコマンドを置き換えます。処理系に
 よってはパイプがサポートされている場合もあります。以下参照:
 `plot datafile special-filenames`。

 コマンド置換は、単一引用符内の文字列以外は、`gnuplot` のコマンドライ
 ン中、どこででも使用可能です。

 例:

 以下の例は、`leastsq` というプログラムを実行し、その出力結果で、
 `leastsq` を (まわりの引用符こみで) 置き換えます:
       f(x) = `leastsq`

 ただし VMS では、
       f(x) = `run leastsq`

 以下は現在の日付とユーザー名のラベルを生成します:
       set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
       set timestamp "generated on %Y-%m-%d by `whoami`"
3 文字列変数のマクロ置換 (Substitution macros)
?substitution macros
?macros
=exists
 コマンドラインのマクロ置換はデフォルトでは無効になっていますが、
 `set macros` で有効にできます。マクロ置換が有効である場合、文字 @ は、
 コマンドライン上でその文字列変数の値への置換を行なうのに使われます。文
 字列変数の値としての文は、複数の単語からなることも可能です。これにより
 文字列変数をコマンドラインマクロとして使うことが可能になります。この機
 能により展開できるのは文字列定数のみで、文字列を値に取る数式を使うこと
 はできません。
 例:

       set macros
       style1 = "lines lt 4 lw 2"
       style2 = "points lt 3 pt 5 ps 2"
       range1 = "using 1:3"
       range2 = "using 1:5"
       plot "foo" @range1 with @style1, "bar" @range2 with @style2

 この @ 記号を含む行は、その入力時に展開され、それが実際に実行されると
 きには次のように全部打ち込んだ場合と同じことになります。

       plot "foo" using 1:3 with lines lt 4 lw 2, \
            "bar" using 1:5 with points lt 3 pt 5 ps 2

 関数 exists() はマクロの評価に関して有用でしょう。以下の例は、C が安全
 にユーザ定義変数の名前に展開できるかどうかをチェックします。

       C = "pi"
       if (exists(C)) print C," = ", @C

 マクロの展開は、単一引用符内、または二重引用符内では行なわれませんが、
 バッククォート内ではマクロ展開されます。

 コマンドを完成させて実行するには、コマンド `evaluate` も有用でしょう。
3 文字列変数、マクロ、コマンドライン置換 (mixing_macros_backquotes)
?mixing_macros_backquotes
?substitution mixing_macros_backquotes
 文字列変数やバッククォートによる置換、マクロによる置換の相互関係は少し
 ややこしいです。バッククォートはマクロ置換を妨げないので、

       filename = "mydata.inp"
       lines = ` wc --lines @filename | sed "s/ .*//" `

 は、mydata.ipn の行数を整数変数 lines に保存することになります。また、
 二重引用符はバッククォートの置換を妨げないので、

       mycomputer = "`uname -n`"

 は、システムコマンド `uname -n` の返す文字列を文字列変数 mycomputer に
 保存することになります。

 しかし、マクロ置換は二重引用符内では機能しないので、システムコマンドを
 マクロとして定義してそれをマクロとして利用しかつバッククォート置換を行
 なうことはでできません。

        machine_id = "uname -n"
        mycomputer = "`@machine_id`"  # うまくいかない !

 この失敗は、二重引用符が @machine_id をマクロとして解釈することを妨げ
 ているからです。システムコマンドをマクロとして保存し、その後それを実行
 するには、バッククォート自体もマクロ内に含める必要があります。これは以
 下のようにマクロを定義することで実現できます。sprintf の書式には 3 種
 類の引用符全てが入れ子になっていることに注意してください。

       machine_id = sprintf('"`uname -n`"')
       mycomputer = @machine_id
2 区切りやカッコの使い方 (Syntax)
?syntax
?specify
?punctuation
 gnuplot Version 4 では、以前の範囲比べてキーワードやオプションに関する
 順序はだいぶ許容的になりました。しかし、もしあなたが正しく動くべきだと
 思うオプション指定がエラーメッセージを出したなら、正確にドキュメントに
 書かれている通りの順序で指定して試してみてください。

 リストや座標がコンマ (,) 区切りであるのに対し、オプションやそれに伴う
 パラメータはスペース ( ) 区切りです。範囲はコロン (:) で区切ってかぎか
 っこ ([]) でくくりますし、文字列やファイル名は引用符でくくり、他にいく
 つかカッコ (()) でくくるものがあります。中カッコ ({}) は特別な目的で使
 われます。

 コンマは以下の区切りで使用されます。`set` コマンドの `arrow`, `key`,
 `label` の座標; 当てはめ (fit) られる変数のリスト (コマンド `fit` のキ
 ーワード `via` に続くリスト); コマンド `set cntrparam` で指定されると
 びとびの等高線の値やそのループパラメータのリスト; `set` コマンドの
 `dgrid3d` `dummy`, `isosamples`, `offsets`, `origin`, `samples`,
 `size`, `time`, `view` の引数; 目盛りの位置やそのループパラメータのリ
 スト; タイトルや軸の見出しの位置; `plot`, `replot`, `splot` コマンドの
 x,y,z 座標の計算に使われる媒介変数関数のリスト; `plot`, `replot`,
 `splot` コマンドの複数の描画 (データ、または関数) のそれぞれの一連のキ
 ーワードのリスト。

 (丸) カッコは、目盛りの見出しを (ループパラメータではなく) 明示的に集
 合与える場合の区切りとして、または `fit`, `plot`, `replot`, `splot` コ
 マンドの `using` フィルタでの計算を指示するために使われます。

 (カッコやコンマは通常の関数の表記でも使われます。)

 かぎかっこは、`set`, `plot`, `splot` コマンドでは範囲を区切るのに使わ
 れます。

 コロンは `range` (範囲) 指定 (`set`, `plot`, `splot` コマンドで使われ
 る) の両端の値を区切るのに、または `plot`, `replot`, `splot`, `fit` コ
 マンドの `using` フィルタの各エントリを区切るのに使われます。

 セミコロン (;) は、一行のコマンド行内で与えられる複数のコマンドを区切
 るのに使われます。

 中カッコは、`postscript` のようないくつかの出力形式で特別に処理される
 文字列内で使用されます。または複素数を記述するのにも使われます: {3,2}
 = 3 + 2i となります。

 PostScript 出力形式で `enhanced text` モード (拡張文字列処理モード) を
 使う場合、現在は、{} の内部に \n を入れてはいけません。

 EEPIC, Imagen, Uniplex, LaTeX, TPIC の各出力形式では、単一引用符内の
 \\ または二重引用符内の \\\\ で改行を示すことが可能です。
3 引用符 (Quotes)
?quotes
?syntax quotes
 gnuplot は、文字列を区切るのに、二重引用符 (ASCII コード 34 番)、単一
 引用符 (ASCII コード 39 番)、およびバッククォート (ASCII コード 96 番)
 の 3 種類の引用符を使います。

 ファイル名は単一引用符、あるいは二重引用符内で囲みます。このマニュアル
 では一般にコマンドの例示では、わかりやすくするためにファイル名は単一引
 用符でくくり、他の文字列は二重引用符でくくります。

 見出し (label)、タイトル (title)、またはその他の描画要素で使用される文
 字列定数や複数行文字列は単一引用符、あるいは二重引用符内で囲みます。引
 用符で囲まれた文字列のさらなる処理の結果は、どの引用符記号を選ぶかによ
 って変わります。

 \n (改行) や \345 (8 進表記の文字コード) のようなバックスラッシュ (\)
 による特殊文字表現は、2 重引用符内の文字列では効力を持ちます。単一引用
 符内では、バックスラッシュ自体が通常の文字と見なされます。単一引用符
 内の文字列で単一引用符自体 (ASCII コード 39 番) を使うには、それを重ね
 て書く必要があります。つまり、文字列 "d\" s' b\\" と、'd" s'' b\' は完
 全に同じものとなります。

 1 つの複数行文字列に関する位置合わせは各行に同等に働きます。よって、中
 央に位置合わせされた文字列
       "This is the first line of text.\nThis is the second line."
 は次のように表示されます:
                        This is the first line of text.
                           This is the second line.
 しかし
       'This is the first line of text.\nThis is the second line.'
 だと次のようになります。
           This is the first line of text.\nThis is the second line.

 拡張文字列処理 (enhanced text processing) は二重引用符に対しても単一引
 用符に対しても機能します。しかし、そのモードをサポートしている出力形式
 でのみ働きます。以下参照: `enhanced text`。

 バッククォート (｀｀) はコマンドライン中の置換のためにシステムコマンド
 を囲むのに使います。以下参照: `substitution`。
2 時間/日付データ (Time/Date)
?time/date
^ <a name="Time/Date data"></a>
^ <a name="Time/date"></a>
 `gnuplot` は入力データとして時間/日付情報の使用をサポートしています。
 この機能は `set xdata time`, `set ydata time` などのコマンドによって有
 効になります。

 内部では全ての時間/日付は 2000 年からの秒数に変換されます。コマンド
 `set timefmt` は全ての入力書式を定義します。データファイル、範囲、軸の
 目盛りの見出し、ラベルの位置。手短に言えば、データの値を受けとる全ての
 ものがこの書式にしたがって受けとらなければいけません。一時には一つの入
 力書式のみが有効なので、同じときに入力される全ての時間/日付のデータは
 同じ書式である必要があります。よって、ファイル内の x と y の両方が時間
 /日付データである場合は、それらは同じ書式でなければいけません。

 秒数へ (秒数から) の変換は国際標準時 (UT; グリニッジ標準時 (GMT) と同
 じ) が使われます。各国標準時や夏時間への変換の機能は何も持ち合わせてい
 ません。もしデータがすべて同じ標準時間帯に従っているなら (そして全てが
 夏時間か、そうでないかのどちらか一方にのみ従うなら) これに関して何も心
 配することはありません。しかし、あなたが使用するアプリケーションで絶対
 的な時刻を厳密に考察しなければいけない場合は、あなた自身が UT に変換す
 べきでしょう。

 `show xrange` のようなコマンドは、その整数値を `timefmt` に従って解釈
 し直します。`timefmt` を変更してもう一度 `show` でその値を表示させると
 それは新しい `timefmt` に従って表示されます。このため、もし機能を停止
 させるコマンド (`set xdata` のような) を与えると、その値は整数値として
 表示されることになります。

 コマンド `set format` または `set tics format` は、指定された軸が時間/
 日付であるなしに関わらず目盛りの見出しに使われる書式を定義します。

 時間/日付情報がファイルから描画される場合、`plot`, `splot` コマンドで
 は `using` オプションを「必ず」使う必要があります。`plot`, `splot` で
 は各行のデータ列の分離にスペースを使いますが、時間/日付データはその中
 にスペースを含み得るからです。もしタブ区切りを使用しているのなら、あな
 たのシステムがそれをどう扱うか確かめるために何度もテストする必要がある
 でしょう。

 次の例は時間/日付データの描画の例です。

 ファイル "data" は以下のような行からなるとします:

       03/21/95 10:00  6.02e23

 このファイルは以下のようにして表示されます:

       set xdata time
       set timefmt "%m/%d/%y"
       set xrange ["03/21/95":"03/22/95"]
       set format x "%m/%d"
       set timefmt "%m/%d/%y %H:%M"
       plot "data" using 1:3

 ここで、x 軸の目盛りの見出しは "03/21" のように表示されます。

 各コマンドの詳細はそれぞれの項の記述を参照してください。
1 描画スタイル (plotting styles)
?plotting styles

 gnuplot では、たくさんの描画スタイルが利用できます。
 それらは、アルファベット順に以下に紹介されています。
 コマンド `set style data` と `set style function` は、それ以降の
 `plot` や `splot` コマンドに対してデフォルトの描画スタイルを変更
 します。

 描画スタイルは、コマンド `plot` や `splot` の一部分として、明示的にオ
 プション指定することもできます。一つの描画の中で、複数の描画スタイルを
 組み合わせたい場合は、各要素に対して描画スタイルを指定する必要がありま
 す。

 例:

      plot 'data' with boxes, sin(x) with lines

 各描画スタイルは、それ自体がデータファイルからのいくつかのデータの組
 を期待します。例えば、デフォルトでは `lines` スタイルは、y の値だけの
 1 列のデータ (x の値は暗黙に順番に取られる)、または最初が x, 次が y の
 2 つの列を期待しています。ファイルの何列のデータを描画データと解釈させ
 るうまい方法に関する情報については、以下参照: `using`。

2 boxerrorbars
?commands set style boxerrorbars
?set style boxerrorbars
?plotting styles boxerrorbars
?style boxerrorbars
?boxerrorbars
 描画スタイル `boxerrorbars` は 2 次元のデータ描画でのみ利用可能です。
 これは `boxes` と `yerrorbars` スタイルの組合せです。これは、3 列、ま
 たは 4 列、または 5 列のデータを使用します:

      3 列:  x  y  ydelta
      4 列:  x  y  ydelta xdelta        # 箱の幅 != -2
      4 列:  x  y  ylow  yhigh          # 箱の幅 == -2
      5 列:  x  y  ylow  yhigh  xdelta

Ffigure_boxerrorbars
 y の誤差が "ydelta" の形式で与えられて、箱の横幅があらかじめ -2.0 に設
 定されて (`set boxwidth -2.0`) いなければ、箱の横幅は 4 列目の値で与え
 られます。y の誤差が "ylow yhigh" の形式で与えられる場合は箱の横幅は 5
 列目の値で与えられます。特別な場合として、"ylow yhigh" の誤差形式の 4
 列のデータに対する `boxwidth = -2.0` という設定があります。この場合箱
 の横幅は、隣接する箱にくっつくように自動的に計算されます。3 列のデータ
 の場合も、横幅は自動的に計算されます。

 箱の高さは、`yerrorbars` スタイル同様に y の誤差の値から決定されます。
 y-ydelta から y+ydelta まで、あるいは ylow から yhigh まで、これらは何
 列のデータが与えられているかによって決まります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar デモ。
^ </a>
2 boxes
?commands set style boxes
?set style boxes
?plotting styles boxes
?style boxes
?boxes
Ffigure_boxes
 `boxes` スタイルは 2 次元描画でのみ利用可能です。これは与えられた x 座
 標を中心とし、x 軸から (グラフの境界から、ではありません) 与えられた y
 座標までの箱を書きます。これは基本的に、2 列、または 3 列のデータを使
 用します。余分な入力列は、variable 行や塗り潰し色の情報が提供されたも
 のとして使用されます (以下参照: `rgbcolor variable`)。

      2 列:  x  y
      3 列:  x  y  x_width

 箱の幅は 3 つのうち一つの方法で決定されます。入力データが 3 列目のデー
 タを持っている場合は、それが箱の幅にセットされます。そうでなくて
 `set boxwidth` コマンドで箱の幅がセットされていた場合は、それが使われ
 ます。そのどちらでもない場合、箱の幅は、隣接する箱がくっつくように自動
 的に計算されます。

 箱の中身は現在の塗りつぶしスタイル (fillstyle) に従って塗りつぶされま
 す。詳細は、以下参照: `set style fill`。新しい塗りつぶしスタイルを
 plot コマンド上で指定することもできます。

 塗りつぶしスタイルが `empty` の場合は、箱は塗りつぶされません。

 塗りつぶしスタイルが `solid` の場合は、箱は現在の描画色でベタ塗りされ
 ます。これには追加オプション <density> があり、それは塗りつぶし密度を
 意味し、0 は背景色、1 は描画色そのものになります。

 塗りつぶしスタイルが `pattern` の場合は、箱は現在の描画色であるパター
 ンで塗りつぶされますが、出力ドライバがサポートしている必要があります。

 例:

 データファイルを塗りつぶした箱で描画し、箱同士を少し垂直方向にスペース
 を空ける (棒グラフ):

       set boxwidth 0.9 relative
       set style fill solid 1.0
       plot 'file.dat' with boxes

 パターンでの塗りつぶしスタイルの箱で sin と cos のグラフを描画:

       set style fill pattern
       plot sin(x) with boxes, cos(x) with boxes

 sin はパターン 0 で、cos はパターン 1 で描画されます。追加される描画は
 出力ドライバがサポートするパターンを循環的に使用します。

 それぞれのデータ集合で明示的に塗りつぶしスタイルを指定:

      plot 'file1' with boxes fs solid 0.25, \
           'file2' with boxes fs solid 0.50, \
           'file3' with boxes fs solid 0.75, \
           'file4' with boxes fill pattern 1, \
           'file5' with boxes fill empty

2 boxxyerrorbars
?commands set style boxxyerrorbars
?set style boxxyerrorbars
?plotting styles boxxyerrorbars
?style boxxyerrorbars
?boxxyerrorbars
Ffigure_boxxyerrorbars
 `boxxyerrorbars` スタイルは 2 次元のデータ描画でのみ利用可能です。これ
 は、`xyerrorbars` スタイルが単に線分の交差で表現するところを長方形で表
 現することを除けば、ほぼ同じです。これは、入力データの 4 列、または 6
 列を使用します。余分な入力列は、variable 行や塗り潰し色の情報が提供さ
 れたものとして使用されます (以下参照: `rgbcolor variable`)。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 箱の幅と高さは `xyerrorbars` スタイル同様 x, y の誤差から決定されます
 つまり、xlow から xhigh までと ylow から yhigh まで、または x-xdelta
 から x+xdelta までと y-ydelta から y+ydelta まで。これらは何列のデータ
 が与えられているかによって決まります。

 箱の内部は現在の塗りつぶしスタイル (fillstyle) に従って塗られます。詳
 細は、以下参照: `set style fill`, `boxes`。plot コマンド上で新しい塗り
 つぶしスタイルを指定することもできます。
2 candlesticks
?commands set style candlesticks
?set style candlesticks
?plotting styles candlesticks
?style candlesticks
?candlesticks
Ffigure_candlesticks
 `candlesticks` スタイルは、金融データの 2 次元のデータ描画、および統計
 データのひげ付きの棒グラフを生成するのに使えます。
 記号は、水平方向には x を中心とし、垂直方向には開始値 (open) と終値
 (close) を境界とする長方形が使われます。そして、その x 座標のところに
 長方形のてっぺんから最高値 (high) までと、長方形の底から最安値 (low)
 までの垂直線が引かれますが、この垂直線は最高値と最安値が入れ替わっても
 変更されません。

 基本的に 5 列のデータが必要です:

       金融データ:   date  open  low  high  close
       箱ひげ描画:   x  box_min  whisker_min  whisker_high  box_high

 長方形の幅はコマンド `set boxwidth` で制御できますが、以前の gnuplot
 への後方互換性として、boxwidth パラメータが設定されていない場合は
 `set bars <width>` で制御されるようになっています。

 デフォルトでは、鉛直線分のてっぺんと底には垂直に交わる水平線は引かれま
 せん。それを引きたい場合、例えば典型的な例は箱ひげ図 (box-and-whisker
 plot) での使用ですが、描画コマンドにキーワード `whiskerbars` を追加し
 てください。デフォルトでは、水平線は箱 (candlestick) の水平幅一杯に引
 かれますが、それは全体の幅に対する割合を指定することで変更できます。

 金融データの通常の慣習では、(開始値) < (終値) の場合は長方形は空で、
 (終値) < (開始値) の場合は塗り潰されます。現在の fillstyle に "empty"
 をセットしている場合は、実際にこうなります。以下参照: `fillstyle`。
 fillstyle に塗り潰し、またはパターンをセットしている場合は、開始値、終
 値に関係なく、すべての箱にそれが使われます。以下参照: `set bars`,
 `financebars`。また、以下も参照してください。
^ <a href="http://gnuplot.sourceforge.net/demo/candlesticks.html">
 candlestick
^ </a>
 と
^ <a href="http://gnuplot.sourceforge.net/demo/finance.html">
 finance
^ </a>
 のデモ。

 注意: 中央値を表すための記号などを追加したい場合、以下の例のように、ひ
 げ付きの棒グラフに他の描画コマンドを追加する必要があります:

   # データ列:  X '最小値' '1/4 位の値' '中央値' '3/4 位の値' '最大値'
   set bars 4.0
   set style fill empty
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
        ''         using 1:4:4:4:4 with candlesticks lt -1 notitle

   # ひげの上に水平線を伴う描画で、水平線の幅を全体幅の 50% にする
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5

 以下参照: `set boxwidth`, `set bars`, `set style fill`。
2 circles
?commands set style circles
?set style circles
?plotting styles circles
?style circles
?circles
Ffigure_circles
 スタイル `circles` は、各データ点に明示された半径の円を描画します。こ
 れは、x, y, 半径、の 3 列のデータが必要です。4 列目のデータを追加して
 色の情報の指定とすることもできます。半径は、常に描画の水平軸 (x または
 x2) の単位で解釈されます。y 方向の縮尺と描画のアスペクト比は、いずれも
 無視されます。

 例 (面積が 3 列目の値に比例するような円を描画):

     set style fill transparent solid 0.2 noborder
     plot 'data' using 1:2:(sqrt($3)) with circles, \
          'data' using 1:2 with linespoints

 これは、pointstyle 6 で点のサイズを variable とした `points` による描
 画と似ていますが、circles は x 軸の範囲で縮尺される点が異なります。以
 下も参照: `set object circle`, `fillstyle`。
2 dots
?commands set style dots
?set style dots
?plotting styles dots
?style dots
?dots
Ffigure_dots
 `dots` スタイルは各点に小さなドットを描画します。これはたくさんの点か
 らなる散布図の描画に便利でしょう。2 次元描画では 1 列、または 2 列の入
 力データが、3 次元描画では 3 列のデータが必要です。

 出力形式によっては (post, pdf など)、ドットの大きさは linewidth を変更
 することで制御できることもあります。

      1 列:  y         # x は行番号
      2 列:  x  y
      3 列:  x  y  z   # 3D のみ (splot)

2 filledcurves
?commands set style filledcurves
?set style filledcurves
?plotting styles filledcurves
?style filledcurves
?filledcurves
Ffigure_filledcurves
 スタイル `filledcurves` は 2 次元描画でのみ利用可能です。これは 3 種類
 の異なる指定が可能です。最初の 2 種類は関数描画、あるいは 2 列の入力デ
 ータ用のもので、後で紹介するようにオプションで更なる指定ができます。

 書式:

     plot ... with filledcurves [option]

 ここで、オプションは以下のうちのいずれかです:

     [closed | {above | below}
     {x1 | x2 | y1 | y2}[=<a>] | xy=<x>,<y>]

 最初のものは `closed` で、これは曲線それ自身を閉多角形と見なします。入
 力データが 2 列の場合にはこれがデフォルトです。

 2 種類目は指定された軸、あるいは水平線、垂直線、与えられた点などと、曲
 線との間に作られる領域を塗りつぶします。

     filledcurves closed   ... 丁度閉曲線で囲まれる領域
     filledcurves x1       ... x1 軸
     filledcurves x2       ... x2 軸 (y1, y2 軸も同様)
     filledcurves y1=0     ... (y1 軸での) 直線 y=0 i.e. x1 軸と平行
     filledcurves y2=42    ... (y2 軸での) 直線 y=42 i.e. x2 軸と平行
     filledcurves xy=10,20 ... x1,y1 軸での点 10,20 (扇型のような形状)

 3 種類目は 3 列の入力データを必要とし、それらは x 座標と、それに対する
 2 つの y 座標からなり、それらは同じ x 座標の集合に対する 2 つの曲線の
 y 座標に対応します。そしてその 2 つの曲線の間の領域が塗りつぶされます。
 入力データが 3 列以上の場合にはこれがデフォルトです。

      3 列:  x  y1  y2

 入力された 2 つの曲線の間の領域の塗りつぶしの例:
^ <a href="http://www.gnuplot.info/demo/fillbetween.html">
 曲線間の塗りつぶしデモ。
^ </a>

     plot 'data' using 1:2:3 with filledcurves

 `above` と `below` オプションは
     ... filledcurves above {x1|x2|y1|y2}=<val>
 および
     ... using 1:2:3 with filledcurves below
 の形のコマンドに適用可能です。どちらの場合でも、これらのオプションは
 塗りつぶし領域を、境界線、または境界曲線の片側に制限します。

 注意: この描画モードは全ての出力形式でサポートされるとは限りません。

 データファイルから描かれた曲線の塗りつぶしを拡大すると、何もなくなった
 り正しくない領域になることがありますが、それは gnuplot が、領域ではな
 く点や線をクリッピングしているからです。

 <a>, <x>, <y> が描画領域の外にある場合、それらはグラフの境界へ移動され
 ます。よって、オプション xy=<x>,<y> を指定した場合の実際の塗りつぶし領
 域は、xrange や yrange に依存します。
2 financebars
?commands set style financebars
?set style financebars
?plotting styles financebars
?style financebars
?financebars
 `financebars` スタイルは金融データの 2 次元のデータ描画でのみ利用可能
 です。これは、x 座標 1 つ (通常日付) と、4 つの y 座標 (金額) を必要と
 します。

      5 列:   date  open  low  high  close

Ffigure_financebars
 記号は、水平方向にはその x 座標に置かれ、垂直方向には最高値 (high) と
 最安値 (low) を端とする線分が使われます。そして、その線分に水平左側の
 刻みが開始値 (open) の所に、水平右側の刻みが終り値 (close) の所につき
 ます。その刻みの長さは `set bars` で変更できます。記号は最高値と最安値
 が入れ替わっても変わりません。以下参照: `set bars`, `candlesticks`。以
 下も参照してください。
^ <a href="http://www.gnuplot.info/demo/finance.html">
 金融データデモ。
^ </a>
2 fsteps
?commands set style fsteps
?set style fsteps
?plotting styles fsteps
?style fsteps
?fsteps
Ffigure_fsteps
 `fsteps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で
 隣り合う点をつなぎます: 1 本目は (x1,y1) から (x1,y2) まで、2 本目は
 (x1,y2) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>
2 histeps
?commands set style histeps
?set style histeps
?plotting styles histeps
?style histeps
?histeps
Ffigure_histeps
 `histeps` スタイルは 2 次元描画でのみ利用可能です。これはヒストグラム
 の描画での利用を意図しています。y の値は、x の値を中心に置くと考え、
 x1 での点は ((x0+x1)/2,y1) から ((x1+x2)/2,y1) までの水平線として表現
 されます。端の点では、その線はその x 座標が中心になるように延長されま
 す。隣り合う点同士の水平線の端は、その両者の平均値のところでの鉛直線、
 すなわち ((x1+x2)/2,y1) から ((x1+x2)/2,y2) の線分で結ばれます。
 入力列の条件は、`lines` や `points` に対するものと同じです。

 `autoscale` が有効である場合、x の範囲は、その延長された水平線の範囲で
 はなく、データ点の範囲が選択されます。よって、端の点に関してはその水平
 線は半分しか描かれないことになります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

 `histeps` は単なる描画スタイルにすぎず、`gnuplot` には、ヒストグラムの
 箱を生成する能力や、データ集合から母集団を決定する能力などはありません。
2 histograms
?commands set style histogram
?set style histogram
?style histograms
?plotting styles histograms
?histograms
 スタイル `histograms` は 2 次元描画でのみ有効です。これは、データの各
 列の並びから平行な棒グラフを作ります。`plot` コマンドの各要素は、それ
 に関する目盛りの値や説明のタイトルが付属するかも知れませんが、単一の
 入力データを指定する必要があります (例えば入力ファイルの 1 つの列)。現
 在は、4 種類のヒストグラム形式のスタイルがサポートされています。

       set style histogram clustered {gap <gapsize>}
       set style histogram errorbars {gap <gapsize>} {<linewidth>}
       set style histogram rowstacked
       set style histogram columnstacked

 デフォルトのスタイルは `set style histogram clustered gap 2` に対応し
 ています。このスタイルでは、並列に指定されたデータの値の集合は、選択さ
 れたデータ列のそのそれぞれの序列 (行番号) に対応する x 座標の場所に、
 各々箱のグループとして固められて置かれます。よって、<n> 個のデータ列を
 並列に指定した場合、最初の固まりは x=1 を中心とする <n> 個の箱の固まり
 からなり、その各々の高さは、その <n> データ列各々の最初 (1 行目) の値
 が取られます。その後に少し空白 (gap) が空けられ、次に各データ列の次 (2
 行目) の値に対応する箱の固まりが x=2 を中心として置かれます。以下同様
 です。デフォルトの空白 (gap) 幅の 2 は、箱の固まり同士の間の空白が、箱
 2 つの幅に等しいことを意味します。同じ列に対する箱は全て同じ色または同
 じパターンで与えられます (以下参照: `set style fill`)。

 箱の固まりそれぞれは、データファイルの 1 つの行から得られます。そのよ
 うな入力ファイルの各行の最初の項目が見出し (ラベル) でることは良くある
 ことです。その列にある見出し (ラベル) は、`using` に `xticlabels` オプ
 ションをつけることで、それに対応する箱の固まりの真下の x 軸に沿ったと
 ころに置くことができます。

 `errorbars` スタイル は、各エントリに対して追加の入力列を必要とする以
 外は `clustered` スタイルにとても良く似ています。最初の列は、
 `clustered` スタイルの場合と全く同様に箱の高さ (y の値) として保持され
 ます。
      2 列:       y yerr          # 線は y-yerr から y+err へ伸びる
      3 列:       y ymin yman     # 線は ymin から ymax へ伸びる
 誤差線の見た目は、現在の `set bars` の値と <linewidth> オプション指定
 で制御できます。

 積み上げ型のヒストグラムも 2 つの形式がサポートされています。それらは
 コマンド `set style histogram {rowstacked|columnstacked}` で選択できま
 す。これらのスタイルにおいて、選択された列のデータの値は積み上げられた
 箱として集められます。正の値は、y=0 から上の方へ積み上げられ、負の値は
 下へ向かって積み上げられます。正の値と負の値が混じってい場合は、上向き
 と下向きの両方の積み上げが生成されます。デフォルトの積み上げモードは
 `rowstacked` です。

 スタイル `rowstacked` は、まず最初に選択された列の各行の値を x 軸のそ
 れぞれの位置に配置します: 1 行目の値は x=1 の箱、2 行目のは x=2、以下
 同様となります。2 番目以降に選択された列に対応する箱は、それらの上に積
 み重ねられて行きます。そして結果として、x=1 にできる箱の積み重ねは、各
 列の最初の値 (1 行目の値) からなり、x=2 の箱の積み重ねは各列の 2 行目
 の値、などのようになります。同じ列に対する箱は全て同じ色または同じパタ
 ーンで与えられます (以下参照: `set style fill`)。

 スタイル `columnstacked` も同様ですが、こちらは各箱の積み上げは (各行
 のデータからではなく) 各列のデータからなります。最初に指定された列の各
 行のデータが x=1 の箱の積み上げを生成し、2 番目に指定した列の各行のデ
 ータが x=2 の箱の積み上げ、などのようになります。このスタイルでは、各
 箱の色は、各データ項目の (列番号ではなく) 行番号から決定されます。

 箱の幅はコマンド `set boxwidth` で変更できます。
 箱の塗りつぶしスタイルはコマンド `set style fill` で設定できます。

 histograms は x 軸は常に x1 軸を使いますが、y 軸に関しては y1 軸か y2
 軸かを選択できます。plot 命令が、histograms と他のスタイルの描画の両方
 を含む場合、histogram でない方は、x1 軸を使うか x2 軸を使うかを選択で
 きます。

 例:
Ffigure_histclust
 入力ファイルは、2, 4, 6, ... の列にデータ値を持ち、3, 5, 7, ...  の列
 に誤差評価を持つとします。以下の例は、2 列目、4 列目の値を箱の固まり型
 (clustered; デフォルトスタイル) のヒストグラムとして描画します。ここで
 は、plot コマンドで繰り返し (iteration) を使用していますので、任意の個
 数のデータ列を一つのコマンドで処理できます。以下参照: `iteration`。

       set boxwidth 0.9 relative
       set style data histograms
       set style histogram cluster
       set style fill solid 1.0 border lt -1
       plot for [COL=2:4:2] 'file.dat' using COL

 これは、x 軸上の各整数値を中心とするそれぞれ 2 つの箱 (鉛直な棒) 毎の
 固まりによる描画を生成します。入力ファイルの最初の列にラベルが含まれて
 いるならそれを、以下の少し変更したコマンドで x 軸に沿って配置できます。

       plot for [COL=2:4:2] 'file.dat' using COL:xticlabels(1)

 ファイルが、各データの測定値と範囲の情報の両方を含んでいる場合、描画に
 誤差線を追加することができます。以下のコマンドは誤差線を (y-<error>)
 から (y+<error>) に引き、その頭に箱と同じ幅の水平線をつけます。誤差線
 と誤差線の端の線は、黒で線幅 2 で描画されます。

       set bars fullwidth
       set style fill solid 1 border lt -1
       set style histogram errorbars gap 2 lw 2
       plot for [COL=2:4:2] 'file.dat' using COL:COL+1

 同じデータを行毎の積み上げ型 (rowstacked) のヒストグラムで描画する場合、
 これまでとは違い、以下の例では繰り返しを使うのでなく、明示的に別々の列
 を指定します。

       set style histogram rowstacked
       plot 'file.dat' using 2, '' using 4:xtic(1)

Ffigure_histrows
 これは、一つ一つの鉛直な棒が、データの一つの列に対応する描画を生成しま
 す。各棒は、2 つの部分の積み上げの形であり、それぞれの部分の高さが、デ
 ータファイルの 2 列目と 4 列目の値に対応します。

 最後に以下のコマンド

       set style histogram columnstacked
       plot 'file.dat' using 2, '' using 4

Ffigure_histcols
 は、一つ一つがそれぞれデータ列に対応する、2 つの鉛直な積み重ねの棒を生
 成します。x=1 にある棒は、データファイルの 2 列目の各行の値に対応する
 箱からなります。x=2 にある棒は、データファイルの 4 列目の各行の値に対
 応する箱からなります。これは、gnuplot の通常の入力の縦、横の解釈を入れ
 換えることになりますので、key タイトルや x 軸の目盛りの見出しの指定も
 変更する必要があります。以下のコメント部分を参照してください。

       set style histogram columnstacked
       plot '' u 5:key(1)            # 1 列目を key タイトルに使用
       plot '' u 5 title columnhead  #

 この 2 つの例は、全く同じデータ値を与えているのですが、異なる書式であ
 ることに注意してください。
3 newhistogram
?newhistogram
?histograms newhistogram
?plotting style histograms newhistogram
 一回の描画に 2 つ以上のヒストグラムの組を作ることもできます。この場合
 `newhistogram {"<title>"} {<first-linetype} {at <x-coord>}` の描画コマ
 ンドを使うことで、それらを強制的に分離し、またそれぞれのラベルを分離す
 ることができます。
 例:

       set style histogram  cluster
       plot newhistogram "Set A", 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B", 'b' using 1, '' using 2, '' using 3

 ラベル "Set A" と "Set B" は、それぞれのヒストグラムの組の下、x 軸の全
 てのラベルの下の位置に現われます。

 コマンド newhistogram は、ヒストグラムの色付けを強制的に指定した色
 (linetype) で始めるのにも使えます。デフォルトでは、色の番号はヒストグ
 ラムの境界をまたいでさえも連続的に増加し続けます。次の例は、複数のヒス
 トグラムに同じ色付けを施します。
       plot newhistogram "Set A" lt 4, 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B" lt 4, 'b' using 1, '' using 2, '' using 3

 オプション `at <x-coord>` は列データの積み上げ型 (`columnstacked`) の
 ヒストグラムのみに適用されます。
3 複数の列に渡る自動的な繰り返し (automated)
?automated
?histograms automated
?styles histograms automated
?plotting styles histograms automated
 一つのデータファイルのたくさんの列から、一つのヒストグラムを生成したい
 場合、plot の繰り返し (iteration) 機能を使うと便利でしょう。以下参照:
 `iteration`。例えば、3 列目から 8 列目までのデータを積み上げた形のヒス
 トグラムを生成する例:

       set style histogram columnstacked
       plot for [i=3:8] "datafile" using i title columnhead
2 image
?commands set style image
?set style image
?plotting styles image
?style image
?image
?rgbimage
?rgbalpha
 描画スタイル `image`, `rgbimage`, `rgbalpha` は、いずれも一様に標本点
 を取った格子状データ値を、2 次元、または 3 次元中のある平面上に射影し
 ます。入力データは、既にあるビッマップ画像ファイル (PNG のような標準的
 なフォーマットから変換したものでよい) か、単純な数値配列です。

=heatmap
Ffigure_heatmap
 この図は、スカラー値の配列から温度分布を生成した例です。現在のパレット
 を、各スカラー値から対応するピクセルの色への割り当てに使用します。
       plot '-' matrix with image
       5 4 3 1 0
       2 2 0 0 1
       0 0 0 1 0
       0 1 2 4 3
       e
       e

Ffigure_rgb3D
 入力 2 次元画像の各ピクセル (データ点) は、描画グラフ中では長方形、ま
 たは平行六面体となります。画像の各データ点の座標は、平行六面体の中心を
 決定します。すなわち、M x N 個のデータ集合は M x N ピクセルの画像を生
 成します。これは、M x N 個のデータ集合が (M-1) x (N-1) 要素を作成する
 pm3d の構造とは異なります。バイナリ画像データの格子の走査方向は、追加
 キーワードでさらに制御可能です。以下参照:
 `binary general keywords flipx`, `center`, `rotate`。

 スタイル `image` は、グレイスケール (灰色階調)、またはカラーパレット値
 を含んでいるピクセルの入力を処理します。よって 2 次元描画 (`plot` コマ
 ンド) では 3 列のデータ (x,y,value) を、3 次元描画 (`splot` コマンド)
 では 4 列のデータ (x,y,z,value) が必要になります。

 スタイル `rgbimage` は、赤、緑、青の 3 つの色成分 (RGB) で記述されたピ
 クセルの入力を処理します。よって `plot` では 5 次元データ (x,y,r,g,b)
 が、`splot` では 6 次元データ (x,y,z,r,g,b) が必要になります。赤、緑、
 青の各成分は [0:255] の範囲内にあると仮定されます。

 スタイル `rgbalpha` は、赤、緑、青の RGB 成分に加えて、アルファチャネ
 ル (透過パラメータ) の情報も含んだピクセルの入力を処理します。よって、
 `plot` では 6 次元データ (x,y,r,g,b,a) が、`splot` では 7 次元データ
 (x,y,z,r,g,b,a) が必要になります。赤、緑、青、およびアルファの各成分は
 [0:255] の範囲内にあると仮定されます。
3 透明化 (transparency)
?image transparency
?transparency
?alpha channel
 描画スタイル `rgbalpha` は、入力データの各ピクセルが [0:255] の範囲内
 のアルファ値を持っている必要があります。alpha = 0 のピクセルは完全な透
 明で、その下 (奥) の描画要素を全く変えません。alpha = 255 のピクセルは
 完全な不透明です。すべての出力形式は、これら 2 つの両極端な値をサポー
 トします。0 < alpha < 255 のピクセルは半透明で、これは 2,3 の出力形式
 しか完全には対応しておらず、他の出力形式ではこれを 0 か 255 として扱う
 ことによる近似しか行いません。
3 image failsafe
?commands set style image failsafe
?set style image failsafe
?plotting styles image failsafe
?style image failsafe
?image failsafe
?failsafe
 出力形式のドライバによっては、2 次元の長方形領域内での画像データのレン
 ダリングを最適化するルーチンを提供している場合があります。しかし、その
 ルーチンは不完全であることが知られています。この最適化ルーチンは、キー
 ワード `failsafe` を使うことで無効化できます。例:

       plot 'data' with image failsafe
2 impulses
?commands set style impulses
?set style impulses
?plotting styles impulses
?style impulses
?impulses
Ffigure_impulses
 `impulses` スタイルは、2 次元描画では x 軸から各点の y の値への、3 次
 元描画では xy 平面から各点の z の値への、垂直な線分を表示します。y や
 z の値は負の値でもよいことに注意してください。他のほとんどの描画スタイ
 ルと同様、データの追加列を各垂直線分の色の制御に利用できます。このスタ
 イルを 3 次元描画で使用する場合、太い線 (linewidth > 1) を利用するとよ
 り効果的でしょう。それは 3 次元の棒グラフに似たものになります。


      1 列:  y        # 行番号による暗黙の x 座標 (2D)
      2 列:  x  y     # [x,0] から [x,y] への線 (2D)
      3 列:  x  y  z  # [x,y,0] から [x,y,z] への線 (3D)

2 labels
?commands set style labels
?set style labels
?plotting styles labels
?style labels
?labels
Ffigure_labels
 スタイル `labels` は、データファイルから座標と文字列を読み込み、その文
 字列をその 2 次元、または 3 次元座標に置きます。これは基本的に 3 列、
 または 4 列の入力を必要とします。余分な入力列は、フォントサイズか文字
 色の変数値のような情報が提供されたものとして使用されます (以下参照:
 `rgbcolor variable`)。

      3 列:  x  y  string    # 2 次元版
      4 列:  x  y  z  string # 3 次元版

 フォント、色、回転角やその他の描画テキストの属性は追加オプションとして
 指定可能です (以下参照: `set label`)。次の例は、入力ファイルの 1 列目
 から取った市の名前から作られる文字列を、4, 5 列目から取った地図座標に
 描画します。フォントサイズは、3 列目の値から計算していて、この場合はそ
 れは人口を意味しています。

   CityName(String,Size) = sprintf("{/=%d %s}", Scale(Size), String)
   plot 'cities.dat' using 5:4:(CityName(stringcolumn(1),$3)) with labels

 フォントサイズを、個々の市の名前に対して異なるサイズに合わせなくていい
 ならば、コマンドはもっと簡単です:

   plot 'cities.dat' using 5:4:1 with labels font "Times,8"

 スタイル `labels` は 3 次元描画でも使用できます。この場合 X,Y,Z と文字
 列、の 4 つの入力列指定が必要です。

   splot 'datafile' using 1:2:3:4 with labels

 以下も参照: `datastrings`, `set style data`。
2 lines
?commands set style lines
?set style lines
?plotting styles lines
?style lines
?lines
Ffigure_lines
 `lines` スタイルは隣接する点を真直な線分で結びます。
 これは、2 次元描画でも、3 次元描画でも使用でき、基本的には、1 列か 2
 列か 3 列かの入力データを必要とします。
 余分な入力列は、線の色の変更などの情報が提供されたものとして使用されま
 す (以下参照: `rgbcolor variable`)。

 2 次元の場合
      1 列:  y       # 行番号による暗黙の x
      2 列:  x  y
 3 次元の場合
      1 列:  z       # x は暗黙の行番号、y は index から
      3 列:  x  y  z

 以下も参照: `linetype`, `linewidth`, `linestyle`。
2 linespoints
?commands set style linespoints
?commands set style lp
?set style linespoints
?plotting styles linespoints
?set style lp
?style linespoints
?style lp
?linespoints
?lp
Ffigure_linespoints
 `linespoints` スタイルは `lines` と `points` の両方を行ないます。すな
 わち、各点に小さな記号をつけ、そして隣接する点を真直な線分で結びます。
 コマンド `set pointsize` を使って点 (point) の記号の大きさを変更できま
 す。その使い方については、以下参照 `set pointsize`。基本的に 2 次元描
 画では 1 列、または 2 列の入力データが必要で、3 次元描画では 1 列、ま
 たは 3 列のデータが必要です。以下参照: `style lines`。余分な入力列は、
 点のサイズや線の色の変更などの情報が提供されたものとして使用されます。

 `linespoints` は `lp` と略すことが出来ます。
2 points
?commands set style points
?set style points
?plotting styles points
?style points
?points
Ffigure_points
 `points` スタイルは各点に小さな記号を表示します。その記号のデフォルト
 の大きさを変更するにはコマンド `set pointsize` が使えます。
 基本的に 2 次元描画では 1 列、または 2 列の入力データが必要で、3 次元
 描画では 1 列、または 3 列のデータが必要です。以下参照: `style lines`。
 余分な入力列は、点のサイズや線色の変更などの情報が提供されたものとして
 使用されます。
2 steps
?commands set style steps
?set style steps
?plotting styles steps
?style steps
?steps
Ffigure_steps
 `steps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で
 隣り合う点をつなぎます: 1 本目は (x1,y1) から (x2,y1) まで、2 本目は
 (x2,y1) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

2 rgbalpha
?commands set style rgbalpha
?set style rgbalpha
?plotting styles rgbalpha
?style rgbalpha
 以下参照: `image`。
2 rgbimage
?commands set style rgbimage
?set style rgbimage
?plotting styles rgbimage
?style rgbimage
 以下参照: `image`。
2 vectors
?commands set style vectors
?set style vectors
?plotting styles vectors
?style vectors
?vectors
 2 次元の `vectors` スタイルは (x,y) から (x+xdelta,y+ydelta) までのベ
 クトルを書きます。3 次元の `vectors` スタイルも同様ですが、データは基
 本的に 6 列必要です。各ベクトルの先端には小さな矢先も書かれます。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  z  xdelta  ydelta  zdelta

 vectors スタイルを使っての splot は `set mapping cartesian` のみでサポ
 ートされています。キーワード "with vectors" は arrow スタイルの指定子
 を後ろに伴うことができます。詳細は、以下参照: `arrowstyle`。

 例:
       plot 'file.dat' using 1:2:3:4 with vectors head filled lt 2
       splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2

 `set clip one` と `set clip two` は 2 次元のベクトルの描画に影響を与え
 ます。詳細は、以下参照: `set clip`, `arrowstyle`。
2 xerrorbars
?commands set style xerrorbars
?set style xerrorbars
?plotting styles xerrorbars
?style xerrorbars
?xerrorbars
Ffigure_xerrorbars
 `xerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorbars` は、水平の誤差指示線 (error bar) が表示される以外は
 `dots` と同じです。各点 (x,y) において (xlow,y) から (xhigh,y) まで、
 または (x-xdelta,y) から (x+xdelta,y) までの線分が引かれますが、これら
 はいくつのデータ列が与えられるかによって変わります。誤差指示線の端には
 刻みの印が付けられます (`set bars` が使われていなければ。詳細に関して
 は、以下参照: `set bars`)。このスタイルは基本的に、3 列か 4 列のデータ
 が必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

2 xyerrorbars
?commands set style xyerrorbars
?set style xyerrorbars
?plotting styles xyerrorbars
?style xyerrorbars
?xyerrorbars
Ffigure_xyerrorbars
 `xyerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorbars` は、水平、垂直の誤差指示線 (error bar) も表示される以外
 は `dots` と同じです。各点 (x,y) において (x,y-ydelta) から (x,y+ydelta)
 までと (x-xdelta,y) から (x+xdelta,y) まで、または (x,ylow) から
 (x,yhigh) までと (xlow,y) から (xhigh,y) までの線分が引かれますが、こ
 れらはいくつのデータ列が与えられるかによって変わります。誤差指示線の端
 には刻みの印が付けられます (`set bars` が使われていなければ。詳細に関
 しては、以下参照: `set bars`)。これは 4 列か、6 列のデータが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars
2 yerrorbars
?commands set style yerrorbars
?commands set style errorbars
?plotting styles yerrorbars
?plotting styles errorbars
?set style yerrorbars
?set style errorbars
?style yerrorbars
?style errorbars
?yerrorbars
Ffigure_yerrorbars
 `yerrorbars` (または `errorbars`) スタイルは 2 次元のデータ描画のみで
 利用可能です。`yerrorbars` は、垂直の誤差指示線 (error bar) が表示され
 る以外は `points` に似ています。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) まで、または (x,ylow) から (x,yhigh) までの線分が引かれま
 すが、これらはいくつのデータ列が与えられるかによって変わります。誤差指
 示線の端には刻みの印が付けられます (`set bars` が使われていなければ。
 詳細に関しては、以下参照: `set bars`)。これは、3 列か 4 列のデータが必
 要です。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar デモ。
^ </a>
2 xerrorlines
?commands set style xerrorlines
?set style xerrorlines
?plotting styles xerrorlines
?style xerrorlines
?xerrorlines
Ffigure_xerrorlines
 `xerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorlines` は `linespoints` に似ていますが、水平の誤差線が描かれる
 ことが違います。各点 (x,y) で、データ列の個数に応じて (xlow,y) から
 (xhigh,y) まで、または (x-xdelta,y) から (x+xdelta,y) までの線分が描か
 れ、そして刻の印が誤差線の端に置かれます (`set bars` が使われていない
 場合。詳細は、以下参照: `set bars`)。基本的には、3 列か 4 列のデータが
 必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

2 xyerrorlines
?commands set style xyerrorlines
?set style xyerrorlines
?plotting styles xyerrorlines
?style xyerrorlines
?xyerrorlines
Ffigure_xyerrorlines
 `xyerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorlines` は `linespoints` に似ていますが、水平と垂直の誤差線も描
 かれることが違います。各点 (x,y) で、データ列の個数に応じて、
 (x,y-ydelta) から (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y)
 まで、あるいは (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y)
 までの線分が描かれ、そして刻の印が誤差線の端に置かれます (`set bars`
 が使われていない場合。詳細は、以下参照: `set bars`)。これは、4 列か 6
 列の入力データが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines
2 yerrorlines
?commands set style yerrorlines
?commands set style errorlines
?plotting styles yerrorlines
?plotting styles errorlines
?set style yerrorlines
?set style errorlines
?style yerrorlines
?style errorlines
?yerrorlines
Ffigure_yerrorlines
 `yerrorlines` (または `errorlines`) スタイルは 2 次元のデータ描画のみ
 で利用可能です。`yerrorlines` は `linespoints` に似ていますが、垂直の
 誤差線が描かれることが違います。各点 (x,y) で、データ列の個数に応じて
 (x,y-ydelta) から (x,y+ydelta) まで、または (x,ylow) から (x,yhigh)
 までの線分が描かれ、そして刻の印が誤差線の端に置かれます (詳細は、以下
 参照: `set bars`)。
 これは、3 列か 4 列の入力が必要です。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 以下も参照。
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 エラーバーのデモ
^ </a>
2 3 次元 (曲面) 描画 (3D (surface) plots)
?3D (surface) plots
?plotting styles 3d (surface) plots
Ffigure_surface
 曲面描画は、コマンド `plot` ではなくコマンド `splot` を使って生成しま
 す。スタイル `with lines` を使えば、曲面を格子線で生成できます。曲面の
 塗り潰しは、スタイル `with pm3d` で行うことができます。曲面は通常、そ
 れが 3 次元の曲面であるとはっきりわかるような視方向から表示されます。
 その場合、X, Y, Z 軸はすべて描画内に表示されます。3 次元的な錯覚は、隠
 線処理や、曲面要素の深さ整列により、より増幅されます。以下参照:
 `hidden3d`, および `set pm3d` のオプションである `depthorder`。
Ffigure_surface+contours
 コマンド `splot` は、定数の Z 値に対する等高線を計算し描画することもで
 きます。これらの等高線は、曲面それ自体の上に書くこともできますし、XY
 平面へ射影することもできます。以下参照: `set contour`。






Ffigure_mapcontours
 コマンド `splot` の特別な場合として、描画の Z 方向の射影による、Z 座標
 の 2 次元曲面への地図作成 (map) があります。以下参照: `set view map`。
 この描画モードは、等高線の描画や温度分布を生成するのに利用できます。


1 コマンド (Commands)
?commands
 このセクションでは `gnuplot` が受け付けるコマンドをアルファベット順に
 並べています。このドキュメントを紙に印刷したものは全てのコマンドを含ん
 でいますが、対話型で参照できるドキュメントの方は完全ではない可能性があ
 ります。実際、この見出しの下に何のコマンドも表示されないシステムがあり
 ます。

 ほとんどの場合、コマンド名とそのオプションは、紛らわしくない範囲で省略
 することが可能です。すなわち、"`plot f(x) with lines`" の代わりに
 "`p f(x) w li`" とすることができます。

 書式の記述において、中カッコ ({}) は追加指定できる引数を意味し、
 縦棒 (|) は互いに排他的な引数を区切るものとします。
2 cd
?commands cd
?cd
 `cd` コマンドはカレントディレクトリを変更します。

 書式:
         cd '<ディレクトリ名>'

 ディレクトリ名は引用符に囲まれていなければなりません。

 例:
         cd 'subdir'
         cd '..'

 バックスラッシュ (\) は二重引用符内 (") では特別な意味を持ってしまうた
 めにエスケープする必要がありますので、Windows ユーザには単一引用符を使
 うことを勧めます。例えば、
         cd "c:\newdata"
 では失敗しますが、
         cd 'c:\newdata'
         cd "c:\\newdata"
 なら期待通りに動くでしょう。
2 call
?commands call
?call
 `call` コマンドは、1 つの機能以外は `load` コマンドと等価です。
 その機能は、10 個までのパラメータをコマンドに追加できることです
 (パラメータは標準的な構文規則によって区切られます)。これらのパラメータ
 は、ファイルから読まれる行に代入することができます。`call` した入力
 ファイルから各行が読まれる時に、`$` (ドル記号) に続く数字 (0--9) の並
 びを走査します。もし見つかれば、その並びは `call` のコマンド行の対応す
 るパラメータで置き換えられます。`call` の行でそのパラメータが文字列と
 して指定されているならば、取り囲んでいる引用符が省かれて代入されます。
 文字列 `$#` はパラメータの個数に置き換えられます。文字が後に続く `$`
 はその文字になります。例えば、一つの `$` を得るには `$$` を使います。
 `call` のコマンド行に 10 個より多いパラメータを与えるとエラーが起こり
 ます。与えられなかったパラメータは、何も無しとして扱われます。`call`
 中のファイルの中にさらに `load` または `call` コマンドがあっても構いま
 せん。

 書式:
         call "<入力ファイル>" <パラメータ 0> <パ 1> ... <パ 9>

 入力ファイル名は引用符で囲まなければなりません。そして、パラメータも
 引用符で囲むことを推奨します (gnuplot の将来のバージョンでは引用符で
 囲んである部分と囲んでない部分に対しては違う取り扱いをする予定です)。

 例:

 ファイル 'calltest.gp' は以下の行を含んでいるとすると:
     print "argc=$# p0=$0 p1=$1 p2=$2 p3=$3 p4=$4 p5=$5 p6=$6 p7=x$7x"

 次の行を入力すると:
     call 'calltest.gp' "abcd" 1.2 + "'quoted'" -- "$2"

 以下のように表示されるでしょう:
     argc=7 p0=abcd p1=1.2 p2=+ p3='quoted' p4=- p5=- p6=$2 p7=xx

 注意: `using` を使用しているデータファイルでは文法的に重なってしまいま
 す。その場合、`call` されたデータファイルからプロットするときは、デー
 タの n カラム目の指示には `$$n` または `column(n)` を使用してください。
2 clear
?commands clear
?clear
 `clear` コマンドは、`set output` で選択された画面または出力装置をクリ
 アします。通常、ハードコピー装置に対しては改ページを行います。出力装置
 を選択するには `set terminal` を使用して下さい。

 いくつかの出力装置は `clear` コマンドでは `set size` で定義された描画
 領域のみを消去します。そのため、`set multiplot` とともに使用することで
 挿入図を一つ作ることができます。

 例:
       set multiplot
       plot sin(x)
       set origin 0.5,0.5
       set size 0.4,0.4
       clear
       plot cos(x)
       unset multiplot

 これらのコマンドの詳細については、以下参照: `set multiplot`,
 `set size`, `set origin`。
2 evaluate
?commands evaluate
?evaluate
 コマンド `evaluate` は、引数文字列として与えられたコマンドを実行します。
 その文字列中に改行文字を入れてはいけません。

 書式:
       eval <string expression>

 これは、特に同様のコマンドの繰り返しに有用です。

 例:
       set_label(x, y, text) \
         = sprintf("set label '%s' at %f, %f point pt 5", text, x, y)
       eval set_label(1., 1., 'one/one')
       eval set_label(2., 1., 'two/one')
       eval set_label(1., 2., 'one/two')

 文字列からコマンドを実行する別の方法に関しては、以下参照:
 `substitution macros`。
2 exit
?commands exit
?exit
 `exit` と `quit` の両コマンドは END-OF-FILE 文字 (通常 Ctrl-D) 同様、
 現在の入力ストリーム、すなわち端末の対話やパイプ入力、ファイル入力 (パ
 イプ) からの入力を終了させます。

 入力ストリームが入れ子 (階層的な `load` のスクリプトで) になっている場
 合、読み込みは親のストリームで継続されます。トップレベルのストリームが
 閉じられると、プログラムはそれ自身終了します。

 コマンド `exit gnuplot` は、直ちに、無条件に、そして例え入力ストリーム
 が多段階にネストされていても、gnuplot を終了させます。その場合、開かれ
 ていた全ての出力ファイルはきれいに完全な形では閉じられない可能性があり
 ます。使用例:

       bind "ctrl-x" "unset output; exit gnuplot"

 詳細は、以下参照: `batch/interactive`。
2 fit
?commands fit
?fit
?least-squares
?Marquardt
 `fit` コマンドはユーザの与えた式を (x,y) または (x,y,z) の形式のデータ
 点の集合への当てはめを可能にします。それには Marquardt-Levenberg 法に
 よる非線形最小自乗法 (NLLS) の実装が用いられます。式の内部に現われるユ
 ーザ定義変数はいずれも当てはめのパラメータとして使うことができます。た
 だ、その式の返り値は実数である必要があります。

 書式:
       fit {<ranges>} <expression>
           '<datafile>' {datafile-modifiers}
           via '<parameter file>' | <var1>{,<var2>,...}

 範囲 (xrange,yrange) は、当てはめられるデータ点を一時的に制限するのに
 使うことができ、その範囲を超えたデータは全て無視されます。その書式は
 `plot` コマンド同様
       [{dummy_variable=}{<min>}{:<max>}],
 です。以下参照: `plot ranges`。

 <expression> は通常はあらかじめユーザ定義された f(x) または f(x,y) の
 形の関数ですが、`gnuplot` で有効な任意の数式を指定できます。

 <datafile> は `plot` コマンドと同様に扱われます。`plot datafile` の修
 飾子 (`using`, `every`,...) は、`smooth` とあまり勧められない `thru`
 を除いて、全て `fit` に使うことができます。以下参照:`plot datafile`。

 当てはめる 1 変数関数 z=f(x) へのデフォルトのデータの書式は z か x:z
 です。つまり、データが 1 列しかなければそれは従属変数値 (関数値) と見
 なされ、行番号が独立変数値 (変数値) となり、2 列のデータがあれば、1 列
 目が独立変数値、2 列目が従属変数値となります。

 これらの形式はデータファイルへの `using` 指定子で変更でき、例えば z の
 値を他の列から取ったり、あるいは複数の列から計算した値とすることができ
 ます。3 番目の `using` 指定 (列番号、または数式) が与えられた場合は、
 それは対応する z の値の標準偏差として解釈され、それはそのデータへの重
 み (=1/s**2) を計算するのに使われます。そうでなければ、全てのデータは
 同じ重み (1) で計算されます。`using` オプションを全く指定しなかった場
 合、3 列目のデータがあった場合でもデータから z の偏差は読まれませんの
 で、その場合は重み 1 になります。

 2 変数関数 z=f(x,y) を当てはめる場合、データの書式は `using` による 4
 つの項目 x:y:z:s が要求されます。これは完全に全てが与えられなければな
 らず、不足する項目に対してはどの列もデフォルトは仮定されていません。各
 データ点の重みは上と同様に 's' から計算されます。もし誤差評価を持って
 いなければ、定数値を定数式として指定すればいいでしょう (以下参照:
 `plot datafile using`)。例えば `using 1:2:3:(1)` のように。

 当てはめ関数には、独立変数を 5 つまで持たせられますが、1 変数以外の場
 合は、その独立変数の個数よりも 2 つ多い `using` 指定をしなければいけま
 せん。許される書式、そしてデフォルトのダミー変数名は以下の通りです:

       z
       x:z
       x:z:s
       x:y:z:s
       x:y:t:z:s
       x:y:t:u:z:s
       x:y:t:u:v:z:s

 ダミー変数名は、下にあげるように範囲指定によって変更できます。最初の範
 囲は `using` 指定の最初のものに対応し、以下同様です。z (従属変数) の範
 囲も指定できますが、その名前は変更できません。

 複数のデータ集合も複数の 1 変数関数に同時に当てはめることも、y を '仮
 変数' とすれば可能です。例えばデータ行番号を使い、2 変数関数への当ては
 め、とすればいいでしょう。以下参照: `fit multi-branch`。

 `via` 指定子は、パラメータの調節を直接か、またはパラメータファイルを参
 照することによって行うかを指定します。

 例:
       f(x) = a*x**2 + b*x + c
       g(x,y) = a*x**2 + b*y**2 + c*x*y
       FIT_LIMIT = 1e-6
       fit f(x) 'measured.dat' via 'start.par'
       fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
       fit f(x) './data/trash.dat' using 1:2:3 via a, b, c
       fit g(x,y) 'surface.dat' using 1:2:3:(1) via a, b, c
       fit a0 + a1*x/(1 + a2*x/(1 + a3*x)) 'measured.dat' via a0,a1,a2,a3
       fit a*x + b*y 'surface.dat' using 1:2:3:(1) via a,b
       fit [*:*][yaks=*:*] a*x+b*yaks 'surface.dat' u 1:2:3:(1) via a,b
       fit a*x + b*y + c*t 'foo.dat' using 1:2:3:4:(1) via a,b,c
       h(x,y,t,u,v) = a*x + b*y + c*t + d*u + e*v
       fit h(x,y,t,u,v) 'foo.dat' using 1:2:3:4:5:6:(1) via a,b,c,d,e

 反復の個々のステップの後で、当てはめの現在の状態についての詳細な情報が
 画面に表示されます。そし最初と最後の状態に関する同じ情報が "fit.log"
 というログファイルにも書き出されます。このファイルは前の当てはめの履歴
 を消さないように常に追加されていきます。これは望むなら削除、あるいは別
 な名前にできます。コマンド `set fit logfile` を使ってログファイルの名
 前を変更することもできます。

 gnuplot が、`set fit errorvariables` を使えるようにインストールされて
 いて、そのコマンドを使用した場合、各当てはめパラメータの誤差は、そのパ
 ラメータと似た名前 ("_err" が追加された名前) の変数に保存されます。よ
 ってその誤差を更なる計算の入力として使用することができます。

 当てはめの反復は Ctrl-C を押すことで中断できます。現在の反復が正常に終
 了した後、
 (1) 当てはめを止めて現在のパラメータの値を採用する
 (2) 当てはめを続行する
 (3) 環境変数 FIT_SCRIPT で指定した `gnuplot` コマンドを実行する
 のいずれかを選ぶことができます。FIT_SCRIPT のデフォルトは `replot` で
 あり、よってもしデータと当てはめ関数を一つのグラフにあらかじめ描画して
 あれば、現在の当てはめの状態を表示することができます。

 `fit` が終了した後は、最後のパラメータの値を保存するのに `update` コマ
 ンドを使います。その値は再びパラメータの値として使うことができます。
 詳細は、以下参照: `update`。
3 パラメータの調整 (adjustable parameters)
?commands fit parameters
?fit parameters
?commands fit adjustable_parameters
?fit adjustable_parameters
?fit_parameters
 `via` はパラメータを調節するための 2 つの方法を指定できます。一つは
 コマンドラインから直接指示するもので、もう一つはパラメータファイルを
 参照して間接的に行うものです。この 2 つは初期値の設定で違った方法を取
 ります。

 調整するパラメータは、`via` キーワードの後ろにコンマで区切られた変数名
 のリストを書くことで指定できます。定義されていない変数は初期値 1.0 と
 して作られます。しかし当てはめは、変数の初期値があらかじめ適切な値に設
 定されている方が多分速く収束するでしょう。

 パラメータファイルは個々のパラメータを、個別に 1 行に一つずつ、初期値を
 次のような形で指定して書きます。
       変数名 = 初期値

 '#' で始まるコメント行や空行も許されます。特別な形式として
       変数名 = 初期値       # FIXED

 は、この変数が固定されたパラメータであることを意味し、それはこのファイ
 ルで初期化されますが、調節はされません。これは、`fit` でレポートされる
 変数の中で、どれが固定された変数であるかを明示するのに有用でしょう。な
 お、`# FIXED` と言うキーワードは厳密にこの形でなくてはなりません。

3 fit の概略 (fit beginners_guide)
?commands fit beginners_guide
?fit beginners_guide
?fit guide
?fitting
 `fit` は、与えられたデータ点を与えられたユーザ定義関数にもっとも良く
 当てはめるようなパラメータを見つけるのに使われます。その当てはめは、
 同じ場所での入力データ点と関数値との自乗誤差、あるいは残差 (SSR:Sum
 of the Squared Residuals) の和を基に判定されます。この量は通常χ(カイ)
 自乗と呼ばれます。このアルゴリズムは SSR を 最小化することをしようと
 します。もう少し詳しく言うと、データ誤差 (または 1.0) の重みつき残差の
 自乗和 (WSSR) の最小化を行っています。詳細は、以下参照:
 `fit error_estimates`。

 これが、(非線形) 最小自乗当てはめ法と呼ばれるゆえんです。`非線形` が
 何を意味しているのかを見るための例を紹介しますが、その前にいくつかの
 仮定について述べておきます。ここでは簡単のため、1 変数のユーザー定義
 関数は z=f(x), 2 変数の関数は z=f(x,y) のようにし、いずれも従属変数と
 して z を用いることにします。パラメータとは `fit` が調整して適切な値を
 決定するユーザ定義変数で、関数の定義式中の未知数です。ここで言う、線形
 性/非線形性とは、従属変数 z と `fit` が調整するパラメータとの関係に対
 するものであり、z と独立変数 x (または x と y) との関係のことではあり
 ません (数学的に述べると、線形最小自乗問題では、当てはめ関数のパラメー
 タによる 2 階 (そして更に高階の) 導関数は 0、ということになります)。

 線形最小自乗法 (LLS) では、ユーザ定義関数は単純な関数の和であり、それ
 ぞれは一つのパラメータの定数倍で他のパラメータを含まない項になります。
 非線形最小自乗法 (NLLS) ではより複雑な関数を扱い、パラメータは色んな
 使われ方をされます。フーリエ級数は線形と非線形の最小自乗法の違いを表す
 一つの例です。フーリエ級数では一つの項は
      z=a*sin(c*x) + b*cos(c*x).
 のように表されます。もし、a と b が未知なパラメータで c は定数だとすれば
 パラメータの評価は線形最小自乗問題になります。しかし、c が未知なパラメー
 タならばそれは非線形問題になります。

 線形の場合、パラメータの値は比較的簡単な線形代数の直接法によって決定で
 きます。しかしそのような LLS は特殊な場合であり、'gnuplot' が使用する
 反復法は、もちろんそれも含めて、より一般的な NLLS 問題を解くことができ
 ます。`fit` は検索を行うことで最小値を探そうとします。反復の各ステップ
 は、パラメータの新しい値の組に対して WSSR を計算します。Marquardt-
 Levenberg のアルゴリズムは次のステップのパラメータの値を選択します。そ
 してそれはあらかじめ与えた基準、すなわち、(1) 当てはめが "収束した"
 (WSSR の相対誤差が FIT_LIMIT より小さくなった場合)、または (2) あらか
 じめ設定された反復数の限界 FIT_MAXITER (以下参照:
 `fit control variables`) に達した場合、のいずれかを満たすまで続けられ
 ます。キーボードからその当てはめの反復は中断できますし、それに続いて中
 止することもできます (以下参照: `fit`)。ユーザ変数 FIT_CONVERGED は、
 直前の fit コマンドが収束により終了した場合は 1 を含み、それ以外の理由
 で中断した場合は 0 を含みます。

 当てはめに使われる関数はしばしばあるモデル (またはある理論) を元にして
 いて、それはデータの振舞を記述したり、あるいは予測しようとします。よっ
 て `fit` は、データがそのモデルにどれくらいうまく当てはまっているのかを
 決定するため、そして個々のパラメータの誤差の範囲を評価するために、モデ
 ルの自由なパラメータの値を求めるのに使われます。以下参照:
 `fit error_estimates`。

 そうでなければ、曲線による当てはめにおける関数は、モデルとは無関係に選
 ばれています (それは十分な表現力と最も少ない数のパラメータを持ち、デー
 タの傾向を記述しそうな関数として経験に基づいて選ばれるでしょう)。

 しかし、もしあなたが全てのデータ点を通るような滑らかな曲線を欲しいなら
 `fit` ではなく、むしろ `plot` の `smooth` オプションでそれを行うべきで
 しょう。
3 誤差評価 (error estimates)
?commands fit error_estimates
?fit error_estimates
?fit errors
 `fit` において "誤差" という用語は 2 つの異なった文脈で用いられます。
 一つはデータ誤差、もう一つはパラメータ誤差です。

 データ誤差は、平方残差の重み付きの和 WSSR、すなわちχ自乗を決定する際
 個々のデータ点の相対的な重みを計算するのに用いられます。それらはパラメ
 ータの評価に影響を与えます。それは、それらが、当てはめられた関数からの
 個々のデータ点の偏差が最終的な値に与える影響の大きさを決定することによ
 ります。正確なデータ誤差評価が与えられている場合には、パラメータの誤差
 評価等の `fit` が出力する情報はより役に立つでしょう。

 'statistical overview' では `fit` の出力のいくつかを説明し、
 'practical guidelines' に対する背景を述べています。
4 統計的な概要 (statistical overview)
?commands fit error statistical_overview
?fit error statistical_overview
?statistical_overview
 非線形最小自乗法 (Non-Linear Least-Squares; NLLS) の理論は、誤差の正規
 分布の点から一般的に記述されています。すなわち、入力データは与えられた
 平均とその平均に対する与えられた標準偏差を持つガウス (正規) 分布に従う
 母集団からの標本と仮定されます。十分大きい標本、そして母集団の標準偏差
 を知ることに対しては、χ自乗分布統計を用いて、通常「χ自乗」と呼ばれる
 値を調べることにより「当てはめの良さ」を述べることができます。減らされ
 た自由度のχ自乗 (χ自乗の自由度は、データ点の数から当てはめられるパラ
 メータの個数だけ引いた数) が 1.0 である場合は、データ点と当てはめられた
 関数との偏差の重みつき自乗和が、現在のパラメータ値に対する関数と与えら
 れた標準偏差によって特徴付けられた母集団の、ランダムなサンプルに対する
 自乗和とが全く同じであることを意味します。

 分散 = 総計である数え上げ統計学同様、母集団の標準偏差が定数でない場合、
 各点は観測される偏差の和と期待される偏差の和を比較するときに個別に重み
 づけされるべきです。

 最終段階で `fit` は 'stdfit'、すなわち残差の RMS (自乗平均平方根) で求
 められる当てはめの標準偏差と、データ点が重みづけられている場合に '減ら
 されたχ自乗' とも呼ばれる残差の分散をレポートします。自由度 (データ点
 の数から当てはめパラメータの数を引いたもの) はこれらの評価で使用されま
 す。なぜなら、データ点の残差の計算で使われるパラメータは同じデータから
 得られるものだからです。これらの値は以下の変数に代入されます:
       FIT_NDF = 自由度の数
       FIT_WSSR = 重みつき残差の自乗和
       FIT_STDFIT = sqrt(WSSR/NDF)

 パラメータに関する信頼レベルを評価することで、当てはめから得られる最小
 のχ自乗と、要求する信頼レベルのχ自乗の値を決定するためのχ自乗の統計
 を用いることが出来ます。しかし、そのような値を生成するパラメータの組を
 決定するには、相当のさらなる計算が必要となるでしょう。

 `fit` は信頼区間の決定よりむしろ、最後の反復後の分散-共分散行列から直
 ちに得られるパラメータの誤差評価を報告します。これらの評価は、標準偏差
 として計算される量の指定に関する統計上の条件が、一般には非線形最小自乗
 問題では保証されないのですが、線形最小自乗問題での標準誤差 (各パラメー
 タの標準偏差) と同じ方法で計算されます。そしてそのため慣例により、これ
 らは "標準誤差" とか "漸近標準誤差" と呼ばれています。漸近標準誤差は一
 般に楽観過ぎ、信頼レベルの決定には使うべきではありませんが、定性的な指
 標としては役に立つでしょう。

 最終的な解は相関行列も生成します。それは解の範囲におけるパラメータの相
 関の表示を与えてくれます:もし一つのパラメータが変更されると、χ自乗の
 増加が、他の補正の変更を行なう ? 主対角成分、すなわち自己相関はすべて
 1 で、もし全てのパラメータが独立ならば他の成分はすべて 0 に近い値にな
 ります。完全に他を補いあう 2 つ変数は、大きさが 1 で、関係が正の相関か
 負の相関かによって正か負になる符号を持つ非対角成分を持ちます。非対角要
 素の大きさが小さいほど、各パラメータの標準偏差の評価は、漸近標準誤差に
 近くなります。
4 実用的なガイドライン (practical guidelines)
?commands fit error practical_guidelines
?fit error practical_guidelines
?practical_guidelines
?guidelines
 個々のデータ点への重みづけの割り当ての基礎を知っているなら、それが測定
 結果に対するより詳しい情報を使用させようとするでしょう。例えば、幾つか
 の点は他の点より当てになるということを考慮に入れることが可能です。そし
 て、それらは最終的なパラメータの値に影響します。

 データの重み付けは、最後の反復後の `fit` の追加出力に対する解釈の基礎
 を与えます。各点に同等に重み付けを行なうにしても、重み 1 を使うことよ
 りもむしろ平均標準偏差を評価することが、χ自乗が定義によりそうであるよ
 うに、WSSR を 無次元変数とすることになります。

 当てはめ反復の各段階で、当てはめの進行の評価に使うことが出来る情報が表
 示されます ('*' はより小さい WSSR を見つけられなかったこと、そして再試
 行していることを意味します)。'sum of squares of residuals' (残差の自乗
 和) は、'chisquare' (χ自乗) とも呼ばれますが、これはデータと当てはめ
 関数との間の WSSR を意味していて、`fit` はこれを最小化しようとします。
 この段階で、重み付けされたデータによって、χ自乗の値は自由度 (= データ
 点の数 - パラメータの数) に近付くことが期待されます。WSSR は補正された
 χ自乗値 (WSSR/ndf; ndf = 自由度)、または当てはめ標準偏差 (stdfit =
 sqrt(WSSR/ndf)) を計算するのに使われます。それらは最終的な WSSR に対し
 てレポートされます。

 データが重み付けされていなければ、stdfit は、ユーザの単位での、データ
 と当てはめ関数の偏差の RMS (自乗平均平方根) になります。

 もし妥当なデータ誤差を与え、データ点が十分多く、モデルが正しければ、
 補正χ自乗値はほぼ 1 になります (詳細は、適当な統計学の本の 'χ自乗分
 布' の項を参照してください)。この場合、この概要に書かれていること以外
 に、モデルがデータにどれくらい良く当てはっているかを決定するための追加
 の試験方法がいくつかあります。

 補正χ自乗が 1 よりはるかに大きくなったら、それは不正なデータ誤差評価、
 正規分布しないデータ誤差、システム上の測定誤差、孤立した標本値
 (outliers)、または良くないモデル関数などのためでしょう。例えば
 `plot 'datafile' using 1:($2-f($1))` などとして残差を描画することは、
 それらのシステム的な傾向を知るための手がかりとなります。データ点と関数
 の両者を描画することは、他のモデルを考えための手がかりとなるでしょう。

 同様に、1.0 より小さい補正χ自乗は、WSSR が、正規分布する誤差を持つラ
 ンダムなサンプルと関数に対して期待されるものよりも小さいことを意味しま
 す。データ誤差評価が大きすぎるのか、統計的な仮定が正しくないのか、また
 はモデル関数が一般的すぎて、内在的傾向に加えて特殊なサンプルによる変動
 の当てはめになっているのでしょう。最後の場合は、よりシンプルな関数にす
 ればうまく行くでしょう。

 標準的なエラーを、パラメータの不確定性に関する、あるより現実的な評価に
 関係付けること、および相関行列の重要性を評価することができるようになる
 前に、あなたは `fit` と、それを適用しようとするある種の問題に慣れてお
 く必要があるでしょう。

 `fit` は、大抵の非線形最小自乗法の実装では共通して、距離の自乗
 (y-f(x))**2 の重み付きの和を最小化しようとすることに注意してください。
 それは、x の値の "誤差" を計算に関してはどんな方法も与えてはおらず、単
 に y に関する評価のみです。また、"孤立点" (正規分布のモデルのから外れ
 ているデータ点) は常に解を悪化させる可能性があります。
3 制御 (control)
?commands fit control
?fit control
 `fit` に影響を与えるために定義できるたくさんの `gnuplot` の変数があり
 ます。それらは `gnuplot` の動作中に一度定義できますが、それは
 `control_variable` で紹介し、`gnuplot` が立 ち上がる前に設定する変数は
 `environment_variables` で紹介します。
4 制御変数 (control variables)
?commands fit control variables
?fit control variables
 デフォルトのもっとも小さい数字の限界 (1e-5) は、変数
       FIT_LIMIT
 で変更できます。残差の平方自乗和が 2 つの反復ステップ間で、この数値よ
 り小さい数しか変化しなかった場合、当てはめルーチンは、これを '収束した'
 と見なします。

 反復数の最大値は変数
       FIT_MAXITER
 で制限されます。0 (または定義しない場合) は制限無しを意味します。

 更にそのアルゴリズムを制御したい場合で、かつ Marquardt-Levenberg アル
 ゴリズムを良く知っている場合は、さらにそれに影響を与える変数があります。
 `lambda` (λ) の最初の値は、通常 ML 行列から自動的に計算されますが、も
 しそれをあらかじめ用意した値にセットしたければ
       FIT_START_LAMBDA
 にセットしてください。FIT_START_LAMBDA を 0 以下にセットすると、自動的
 に計算されるようになります。変数
       FIT_LAMBDA_FACTOR
 は、χ自乗化された関数が増加、あるいは減少するにつれて `lambda` が増加
 あるいは減少する因数を与えます。FIT_LAMBDA_FACTOR を 0 とすると、それは
 デフォルトの因数 10.0 が使用されます。

 `fit` には FIT_ から始まる変数が他にもありますから、ユーザ定義変数とし
 てはそのような名前で始まる変数は使わないようにするのが安全でしょう。

 変数 FIT_SKIP と FIT_INDEX は、以前の版の `gnuplot` の、`gnufit` と呼
 ばれていた `fit` パッチで使われていたもので、現在は使用されていません。
 FIT_SKIP の機能はデータファイルに対する `every` 指定子で用意されていま
 す。FIT_INDEX は複数当てはめ法 (multi-branch fitting) で使われていたも
 のですが、1 変数の複数当てはめ法は、今では 疑似 3 次元当てはめとして行
 なわれていて、そこでは枝の指定には 2 変数と `using` が使われています。
 以下参照: `fit multi-branch`。
4 環境変数 (control environment)
?commands fit control environment
?fit control environment
 環境変数は `gnuplot` が立ち上がる前に定義しなければなりません。その設
 定方法はオペレーティングシステムに依存します。

       FIT_LOG
 は、当てはめのログが書かれるファイル名 (およびパス) を変更します。デフ
 ォルトでは、作業ディレクトリ上の "fit.log" となっています。そのデフォ
 ルトの値はコマンド `set fit logfile` を使って上書きできます。

       FIT_SCRIPT
 は、ユーザが中断した後に実行するコマンドを指定します。デフォルトでは
 `replot` ですが、`plot` や `load` コマンドとすれば、当てはめの進行状
 況の表示をカスタマイズするのに便利でしょう。
3 複数の当てはめ (multi-branch)
?commands fit multi-branch
?fit multi-branch
?multi-branch
?branch
 複数当てはめ法 (multi-branch fitting) では、複数のデータ集合を、共通の
 パラメータを持つ複数の 1 変数の関数に、WSSR の総和を最小化することによ
 って同時に当てはめることが出来ます。各データ集合に対する関数とパラメー
 タ (枝) は '疑似変数' を使うことで選択できます。例えば、データ行番号
 (-1; 'データ列' の番号) またはデータファイル番号 (-2) を 2 つ目の独立
 変数とします。

 例: 2 つの指数減衰形 z=f(x) が与えられていて、それぞれ異なるデータ集合
 を記述しているが、共通した減衰時間を持ち、そのパラメータの値を評価する。
 データファイルが x:z:s の形式であったとすると、この場合以下のようにす
 ればよい。
      f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
      fit f(x,y) 'datafile' using  1:-2:2:3  via a, b, tau

 より複雑な例については、デモファイル "fit.dem" で使われる "hexa.fnc"
 を参照してください。

 もし従属変数のスケールに差がある場合、単位の重み付けでは 1 つの枝が支
 配してしまう可能性があるので、適当な重み付けが必要になります。各枝をバ
 ラバラに当てはめるのに複数当てはめ法の解を初期値として用いるのは、全体
 を合わせた解の各枝に対する相対的な影響に関する表示を与えることになるで
 しょう。
3 初期値 (starting values)
?commands fit starting_values
?fit starting_values
?starting_values
 非線形当てはめは、大域的な最適値 (残差の自乗和 (SSR) の最小値を持つ解)
 への収束は保証はしませんが、局所的な極小値を与えることはできます。その
 サブルーチンはそれを決定する方法を何も持ち合わせていないので、これが起
 こったかどうかを判断するのはあなたの責任となります。

 `fit` は、解から遠くから始めると失敗するかも知れませんし、しばしばそれ
 は起こり得ます。遠くというのは、SSR が大きく、パラメータの変化に対して
 その変化が小さい、あるいは数値的に不安定な領域 (例えば数値が大きすぎて
 浮動小数の桁あふれを起こす) に到達してしまって、その結果 "未定義値
 (undefined value)" のメッセージか `gnuplot` の停止を引き起こしてしまう
 ような場合を意味します。

 大域的な最適値を見つける可能性を改善するには、最初の値をその解に少なく
 ともほぼ近くに取るべきでしょう。例えば、もし可能ならば一桁分の大きさの
 範囲内で。最初の値が解に近いほど他の解で終了してしまう可能性は低くなり
 ます。最初の値を見つける一つの方法は、データと当てはめ関数を同じグラフ
 の上に描画して適当な近さに達するまで、パラメータの値を変更して `replot`
 することを繰り返すことです。その描画は、よくない当てはめの極小値で当て
 はめが終了したかどうかをチェックするのにも有用です。

 もちろん、適度に良い当てはめが、"それよりよい" 当てはめ (ある改良され
 た当てはめの良さの基準によって特徴付けられた統計学的な意味で、あるいは
 そのモデルのより適切な解である、という物理的な意味で) が存在しないこと
 の証明にはなりません。問題によっては、各パラメータの意味のある範囲をカ
 バーするような様々な初期値の集合に対して `fit` することが望ましいかも
 知れません。
3 ヒント (tips)
?commands fit tips
?fit tips
?tips
 ここでは、`fit` を最大限に利用するためにいくつか覚えておくべきヒントを
 紹介します。それらは組織的ではないので、その本質がしみ込むまで何回もよ
 く読んでください。

 `fit` の引数の `via` には、2 つの大きく異なる目的のための 2 つの形式が
 あります。`via "file"` の形式は、バッチ処理 (非対話型での実行が可能)
 で最も良く使われ、そのファイルで初期値を与え、またその後で結果を他の
 (または 同じ) パラメータファイルにコピーするために `update` を使うこ
 とも出来ます。

 `via var1, var2, ...` の形式は対話型の実行で良く使われ、コマンドヒスト
 リの機構が使ってパラメータリストの編集を行い、当てはめを実行したり、あ
 るいは新しい初期値を与えて次の実行を行なったりします。これは難しい問題
 に対しては特に有用で、全てのパラメータに対して 1 度だけ当てはめを直接
 実行しても、良い初期値でなければうまくいかないことが起こり得るからです。
 それを見つけるには、いくつかのパラメータのみに対して何回か反復を行ない、
 最終的には全てのパラメータに対する 1 度の当てはめがうまくいくところに
 十分近くなるまでそれを繰り返すことです。

 当てはめを行なう関数のパラメータ間に共通の依存関係がないことは確認して
 おいてください。例えば、a*exp(x+b) を当てはめに使ってはいけません。そ
 れは a*exp(x+b)=a*exp(b)*exp(x) だからです。よってこの場合は a*exp(x)
 または exp(x+b) を使ってください。

 技術的なお話: パラメータの大きさはあまり違いすぎてはいけません。絶対値
 が最も大きいパラメータと最も小さいパラメータの比が大きい程当てはめの収
 束は遅くなります。その比が、マシンの浮動小数の精度の逆数に近いか、また
 はそれ以上ならば、ほとんど永久に収束しないか、拒否されるでしょう。よっ
 てその関数をこれを避けるように改良しなければいけません。例えば、関数の
 定義で 'parameter' を '1e9*parameter' にするとか、または最初の値を 1e9
 で割るとか。

 もし、関数を、当てはめるパラメータを係数とする、単純な関数の線形結合で
 書けるなら、それはとてもいいので是非そうしてください。何故なら、問題が
 もはや非線形ではないので、反復は少ない回数で収束するでしょう。もしかし
 たらたった一回ですむかもしれません。

 実際の実験の講義ではデータ解析に対するいくつかの指示が与えられ、それで
 データへの最初の関数の当てはめが行なわれます。もしかすると、基礎理論の
 複数の側面にひとつずつ対応する複数回のプロセスが必要かも知れませんが、
 そしてそれらの関数の当てはめのパラメータから本当に欲しかった情報を取り
 出すでしょう。しかし、`fit` を使えば、求めるパラメータの視点から直接モ
 デル関数を書くことにより、それはしばしば 1 回で済むのです。時々はより
 難しい当てはめ問題の計算コストがかかりますが、データ変換もかなりの割合
 で避けることが出来ます。もしこれが、当てはめ関数の単純化に関して、前の
 段落と矛盾してると思うなら、それは正解です。

 "singular matrix" のメッセージは、この Marquardt-Levenberg アルゴリズ
 ムのルーチンが、次の反復に対するパラメータの値の計算が出来ないことを意
 味します。この場合、別な初期値から始めるか、関数を別な形で書き直すか、
 より簡単な関数にしてみてください。

 最後に、他の当てはめパッケージ (fudgit) のマニュアルから、これらの文書
 を要約するようないい引用を上げます: "Nonlinear fitting is an art! (非
 線形当てはめ法は芸術だ !)"
2 help
?commands help
?help
 `help`コマンドは、組み込みヘルプを表示します。ある項についての説明を指
 定したいときには、次の書式を使って下さい:

         help {<項目名>}

 もし <項目名> が指定されなかった場合は、`gnuplot` についての簡単な説明
 が表示されます。指定した項目についての説明が表示された後、それに対する
 細目のメニューが表示され、その細目名を入力することで細目に対するヘルプ
 を続けることができます。そして、その細目の説明が表示された後に、さらな
 る細目名の入力を要求されるか、または 1 つ前の項目のレベルへ戻ります。
 これを繰り返すとやがて、`gnuplot` のコマンドラインへと戻ります。

 また、疑問符 (?) を項目として指定すると、現在のレベルの項目のリストが
 表示されます。
2 history
?commands history
?history
 コマンド `history` は、過去に編集したコマンドラインの履歴 (history) の
 一覧を表示したり、その一部を保存したり、その一つを実行したりします。

 具体例で使用法を紹介します:

       history               # 履歴全体を表示
       history 5             # 履歴内の直前の 5 つを表示
       history quiet 5       # エントリ番号なしで直前の 5 つを表示
       history "hist.gp"     # 履歴全体をファイル hist.gp に書き出す
       history "hist.gp" append # 履歴全体をファイル hist.gp に追加する
       history 10 "hist.gp"  # 直前の 10 個をファイル hist.gp に出力
       history 10 "|head -5 >>diary.gp" # パイプで履歴を 5 つ書き出す
       history ?load         # 履歴内の "load" で始まるものすべてを表示
       history ?"set c"      # 上と同様 (複数の語は引用符で囲む)
       hi !reread            # "reread" で始まる最も新しい行を実行
       hist !"set xr"        # 上と同様 (複数の語は引用符で囲む)
       hi !hi                # 当ててみて :-))

 popen 関数をサポートするようなシステム (Unix など) では、履歴の出力を
 パイプ経由で他の外部プログラムに渡すことができます。その場合、上の例の
 一つにあるように、ファイル名としてコマンド名の先頭に '|' をつけたもの
 を使います。
2 if
?commands if
?if
 `if` コマンドは、条件付でコマンドを実行させることができます。

 書式:
       if (<条件>) <コマンド行> [; else if (<条件>) ...; else ...]

 <条件> が評価され、もしそれが真 (ゼロでない) ならば、<コマンド行> のコ
 マンドが実行されます。もし、<条件> が偽 (ゼロ) ならば、次の `else` ま
 での <コマンド行> 全体が無視されます。`;` を使うと同じ行に複数のコマン
 ド置くことが可能ですが、これで条件付きのコマンド (`if` の構文自体) は
 終っていないことに注意してください。

 例:
       pi=3
       if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi
 を実行すると、
       ?Fixing pi!
       3.14159265358979
 と表示されますが、
       if (1==2) print "Never see this"; print "Or this either"
 とすると、何も表示されません。

 その他:
       v=0
       v=v+1; if (v%2) print "2" ; else if (v%3) print "3" ; else print "fred"
 (何度も最後の行を繰り返してみてください !)

 `if` と `reread` を使ってループを構成する例については、以下参照:
 `reread`。
2 繰り返し (iteration)
?iteration
 `plot`, `splot`, `set`, `unset` コマンドでは、繰り返し節を使うこともで
 きます。これは、基本的なコマンドを複数回実行する効果を持ち、そのおのお
 のの実行では繰り返し制御変数によって数式は再評価されます。繰り返し節は
 現在は以下の 2 つの形式をサポートしています:

       for [intvar = start:end{:increment}]
       for [stringvar in "A B C D"]

 例:

       plot for [filename in "A.dat B.dat C.dat"] filename using 1:2 with lines
       plot for [basename in "A B C"] basename.".dat" using 1:2 with lines
       set for [i = 1:10] style line i lc rgb "blue"
       unset for [tag = 100:200] label tag

 さらなる説明については、以下参照: `plot iteration`。

2 load
?commands load
?load
 `load` コマンドは、指定された入力ファイルの各行を、それが対話的に入力
 されたかのように実行します。`save` コマンドでつくられたファイルは、
 `load` することができます。有効なコマンドの書かれたテキストファイルを
 つくれば、それは、`load`コマンドによって、実行することができます。
 `load` 中のファイルの中にさらに `load` または `call` コマンドがあって
 も構いません。コマンド中のコメントについては、以下参照: `comments`。
 `load` するときに引数を与える方法については、以下参照: `call`。

 書式:
         load "<入力ファイル名>"

 入力ファイル名は引用符で囲まなければなりません。

 `load` コマンドは、標準入力からのコマンドの入力のために、特別なファイ
 ル名 "-" を用意しています。これは、`gnuplot` のコマンドファイルが、い
 くつかのコマンドを標準入力から受け付けることを意味します。詳細について
 は、以下参照: `batch/interactive`。

 Unix のように popen 関数をサポートするようなシステムでは、'<' で始まる
 ファイル名にすることで、入力ファイルをパイプから読み込むことができます。

 例:
         load 'work.gnu'
         load "func.dat"
         load "< loadfile_generator.sh"

 `gnuplot` への引数として与えられたファイル名は、暗黙のうちに `load` コ
 マンドによって実行されます。これらは、指定された順にロードされ、その後
 `gnuplot` は終了します。
2 lower
?commands lower
?lower
 書式:
       lower {plot_window_nb}

 コマンド `lower` (`raise` の反対) は、`pm`, `win`, `wxt`, `x11` 等の
 gnuplot の対話型出力形式の実行中に、描画ウィンドウを下 (背後) に下げま
 す。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z 方向の
 ウィンドウの重なりの下に置きます。

 `x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デ
 フォルトではこのコマンドはそれらの複数のウィンドウを降順に下げ、最初に
 作られたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べま
 す。オプション引数の描画番号が与えられた場合、それに対応する描画ウィン
 ドウが存在すればそれのみが下げられます。

 オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
 `win` では無視されます。
2 pause
?commands pause
?pause
?pause mouse
 `pause` コマンドは、コマンドに続く任意の文字列を表示した後、指定され
 た時間または、改行キーが押されるまで待ちます。`pause` コマンドは、
 `load` 用のファイルと共に使用すると、便利になるでしょう。

 書式:
       pause <time> {"<string>"}
       pause mouse {<endcondition>}{, <endcondition>} {"<string>"}

 <time> は、任意の定数または式です。-1 を指定すると改行キーが押されるま
 で待ちます。0 を指定すると一切待たず、正の数を指定するとその秒数だけ待
 ちます。実行環境が秒以下の時間指定をサポートしていない場合、その時間は
 整数の秒数に丸められます。`pause 0` は `print` と同じです。

 使用している出力形式がマウス機能をサポートしている場合、`pause mouse`
 は、マウスクリックがあるか ctrl-C が押されるまで待つようになります。そ
 うでない出力形式、またはマウス機能が有効になってない場合 `pause mouse`
 は `pause -1` と同じです。

 一つ、あるいは複数の終了条件 (endcondition) が `pause mouse` の後に与
 えられた場合、そのうちのどの一つでも pause は終了します。指定できる終
 了条件は、`keypress`, `button1`, `button2`, `button3`, `close`, `any`
 のいずれかです。pause がキー入力によって終了した場合、押されたキーの
 ascii コードは MOUSE_KEY に保存され、文字それ自身は、1 文字の文字列値
 として MOUSE_CHAR に返されます。`keypress` が終了条件の一つであれば、
 ホットキー (キー割り当てコマンド) は無効になります。`buttons3` が終了
 条件の一つであれば、拡大機能は無効になります。

 どの場合でもマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2, MOUSE_Y2 に
 保存されます。以下参照: `mouse variables`。

 注意: `pause` コマンドは OS へのコマンドであり描画の一部ではないので、
 異なる出力装置では異なる動作をする可能性があります。(これは、テキスト
 とグラフィックスが、どのように混在するかによります。)

 例:
       pause -1    # 改行キーが押されるまで待つ
       pause 3     # 3 秒待つ
       pause -1  "続けるには return を打ってください"
       pause 10  "これは美しくないですか ? 3 次の spline です"
       pause mouse "選択したデータ点上で任意のボタンをクリックしてください"
       pause mouse keypress "有効なウィンドウ内で A-F の文字を入力してください"
       pause mouse button1,keypress
       pause mouse any "任意のキー、ボタンで終了します"

 亜種である "pause mouse key" は、有効な描画ウィンドウ内での任意のキー
 入力によって再開されます。特別なキー入力まで待つようにしたい場合は、以
 下のような reread によるループを使うことができます:

       print "描画ウィンドウ内で Tab キーを打つと復帰します。"
       load "wait_for_tab"

 ファイル "wait_for_tab" は以下のようなものです:

       pause mouse key
       if (MOUSE_KEY != 9) reread

2 plot
?commands plot
?plot
 `plot` は `gnuplot` で図を描くための基本的なコマンドです。 それは関数
 やデータを実に多くの方法で表示します。`plot` は 2 次元の関数やデータを
 描くのに使われ、`splot` は 3 次元の曲面やデータの 2 次元投影を描きます。
 `plot` と `splot` は多くの共通の特徴点を持ちますが、その違いについては
 以下参照: `splot`。特に注意しておきますが、`binary <binary list>` オプ
 ションは `plot`, `splot` の両方で動作しますが、両者には小さな違いがあ
 ります。

 書式:
     plot {<範囲 (ranges)>}
          {<繰返し (iteration)>}
          { <関数 (function)>
            |  {"<データファイル (datafile)>" {データファイル修飾子}}}
          {axes <軸 (axes)>}{<表題 (title)>}{with <スタイル (style)>}
          {, {定義,} <関数> ...}

 <関数> または引用符で囲まれたデータファイル名のどちらか一方を与えます。
 関数は一本の数式、または parametric mode においては 2 つの数式の組です。
 数式は完全に定義してもいいですし、前の方の `gnuplot` のコマンド列で部
 分的に定義してもいいです (以下参照: `user-defined`)。

 関数とパラメータは `plot` コマンド自身の上で定義をすることも可能です。
 これは単に他の項目とコンマで分離して記述することでなされます。

 例:
       plot sin(x)
       plot sin(x), cos(x)
       plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
       plot "datafile.1" with lines, "datafile.2" with points
       plot [t=1:10] [-pi:pi*2] tan(t), \
            "data.1" using (tan($2)):($3/$4) smooth csplines \
                     axes x1y2 notitle with lines 5
       plot for [datafile in "spinach.dat broccoli.dat"] datafile

 以下参照: `show plot`。
3 軸 (axes)
?commands plot axes
?plot axes
?axes
 軸は、4 種類の組が利用できます; キーワード <軸> は、特定の直線をどの軸
 に尺度を合わせるか、ということを選択するのに使われます。`x1y1` は下の
 軸と左の軸を指定; `x2y2` は上と右の軸の指定; `x1y2` は下と右の軸の指定;
 `x2y1` は上と左の軸の指定です。`plot` コマンドで指定された範囲は、この
 最初の軸の組 (下と左) にのみ適用されます。
3 データ (data)
?commands plot datafile
?plot datafile
?data-file
?datafile
?data
?file
?volatile
?plot datafile volatile
 ファイルに納められた離散的なデータは、`plot` コマンドライン上で、その
 データファイル名 (単一引用符または二重引用符で囲まれた) を指定すること
 によって表示できます。

 書式：
       plot '<file_name>' {binary <binary list>}
                          {matrix}
                          {index <index list> | index "<name>"}
                          {every <every list>}
                          {thru <thru expression>}
                          {using <using list>}
                          {smooth <option>}
                          {volatile} {noautoscale}

 修正子の `binary`, `index`, `every`, `thru`, `using`, `smooth` は、そ
 れぞれに分けて説明します。簡単に言うと、`binary` はデータ列をバイナリ
 ファイルから取得できるようにし (デフォルトは ASCII ファイル)、`index`
 はマルチデータ集合ファイルからどのデータ集合を表示するのかを選び、
 `every` が、一つのデータ集合からどの点を表示するのかを選び、`using` は
 一行からどの列を解釈するのかを決定し (`thru` は、`using` の特別な場合
 である)、そして `smooth` が、単純な補間と近似を行います。(`splot` は、
 よく似た書式を持っていますが、`smooth` オプションと `thru` オプション
 はサポートしていません)

 キーワード `volatile` は、データファイルの内容が、再読み込み時には変化
 しうることを意味します。これは、可能な限りプログラムに、`replot` コマ
 ンドの代わりに `refresh` コマンドを使わせようとします。以下参照:
 `refresh`。

 キーワード `noautoscale` は、自動的に軸の範囲が決定される機能が有効で
 ある場合に、この描画を構成するデータ点については、それを無視させる (自
 動縮尺機能の計算対象から外す) ようにします。


 ASCII データファイル:

 データファイルは、一行につき少なくとも一つのデータ点を含む必要がありま
 す (`using` は一行から一つのデータポイントを選ぶことができます)。`#`
 (VMS では `!`) で始まる行は、コメントとして扱われ、無視されます。各デ
 ータ点は、(x,y) の組を表します。エラーバー、または折れ線表示付エラーバ
 ーの `plot` では (以下参照: `set style errorbars`,
 `set style errorlines`)、各データ点は、(x,y,ydelta), (x,y,ylow,yhigh),
 (x,y,xdelta), (x,y,xlow,xhigh), (x,y,xlow,xhigh,ylow,yhigh) のいずれか
 を意味します。

 どんな場合でも、書式の指定子が `using` オプションによって与えられてい
 なければ、データファイルの各行の数字は、ホワイトスペース (一つまたは複
 数の空白かタブ) によって区切られている必要があります。このホワイトスペ
 ースは、各行を列の項目に区切ります。ただし、二重引用符で囲まれたホワイ
 トスペースは列の勘定では無視され、よって次のようなデータ行は 3 列、と
 見なされます:
       1.0 "second column" 3.0

 データは、指数部に e, E の文字をつけた指数表記で書かれていても構いませ
 ん。コマンド `set datafile fortran` が有効な場合は、fortran の指数指定
 子 d, D, q, Q も使えます。

 必要であるのはただ一つの列 (y の値) のみです。もし x の値が省略された
 ら、`gnuplot` はそれを 0 で始まる整数値として用意します。

 データファイルにおいて、ブランク行 (空白と改行、復帰以外に文字を含まな
 い行) は重要です。

 1 行のブランク行は、`plot` に不連続を指示します; ブランク行によって区
 切られた点は線で結ばれることはありません (line style で書かれている場
 合には)。

 2 行のブランク行は、別々のデータ集合間の区切りを示します。以下参照:
 `index`。

 もし autoscale の状態であれば (以下参照: `set autoscale`)、軸は全ての
 データポイントを含むように自動的に引き伸ばされて、目盛りが書かれる状態
 ならば全ての目盛りがマークされます。これは、2 つの結果を引き起こします:
 i) `splot` では、曲面の角は底面の角に一致していないことがあります。こ
 の場合、縦の線は書かれることはありません。ii) 2 種類の軸での、同じ x
 の範囲のデータの表示の際、もし x2 の軸に対する目盛りが書かれていない場
 合は、x 座標があっていないことがあります。これは x 軸 (x1) は全ての目
 盛りにまで自動的に引き延ばされるのに対し、x2 軸はそうではないからです。
 次の例でその問題を見ることができます:

       reset; plot '-', '-' axes x2y1
       1 1
       19 19
       e
       1 1
       19 19
       e

 これを避けるには、`set autoscale` コマンドの `fixmin`/`fixmax` オプシ
 ョンを使うことができます。これは、軸の範囲を自動的に拡張して、次の目盛
 りの刻みに合うようにする機能を無効にします。

 ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
 照: `labels`)。


 バイナリデータファイル:

 gnuplot はバイナリデータファイルを読むこともできます。しかし、そのファ
 イルフォーマットに関する十分詳細な情報は、ユーザがコマンドラインから与
 えるか、またはサポートされている `filetype` のバイナリ形式のファイルそ
 れ自身から抜き出されるかする必要があります。バイナリファイルには 2 つ
 の形式、matrix バイナリ形式と general バイナリ形式があります。

 matrix バイナリ形式は、32 ビット IEEE 規格の浮動小数値 (float) が 2 次
 元配列の形で並び、それらの座標値を表す行と列が追加されています。ASCII
 matrix 同様、`using` リストにおいては、座標用の列の並び (1 列目) が
 using の 1 番目の要素 (x 座標) に対応し、座標用の行の並び (1 行目) が
 using の 2 番目の要素 (y 座標) に対応し、配列の各値が using の 3 番目
 の要素 (z 座標) に対応します。

 general バイナリ形式は、任意個の列のデータを含み、それらの情報はコマン
 ドラインで指定する必要があります。例えば `array`, `record`, `format`,
 `using` などでサイズや形式、データの次元を指定できます。他にも、ファイ
 ルヘッダ読み飛ばしたり、エンディアン (endian) を変更するための有用なコ
 マンドがありますし、配置、データの変換を行なうコマンドの組があります。
 それは、一様に標本化されたデータの場合、その座標がファイルには含まれな
 いことが良くあるからです。matrix バイナリや ASCII データと違っていると
 ころですが、general バイナリは 1,2,3 といった `using` リストで生成され
 る列番号を使わず、むしろ 1 列目はファイルの 1 列目、あるいは `format`
 リストで指定されたもの、になります。

 さまざまな binary オプションに対する大域的なデフォルトの設定も可能で、
 それは `(s)plot <filename> binary ...` コマンドに与えるオプションと全
 く同じ書式で指定できます。その書式は `set datafile binary ...` です。
 一般的な規則として、デフォルトのパラメータはファイルから抜き出されたパ
 ラメータで上書きされ、それはコマンドラインで指定された共通なパラメータ
 で上書きされます。

 例えば `array`, `record`, `format`, `filetype` の general バイナリ形式
 を特定するようなキーワードが何もついていなければ、デフォルトのバイナリ
 形式は matrix バイナリです。

 general バイナリデータは、特別なファイル名 '-' を使ってコマンドライン
 から入力することもできます。しかし、これはキーボードからの入力を意図し
 たものではなく、パイプを使ってプログラムにバイナリ形式を変換させるため
 のものです。バイナリデータには最後を表す記号がありませんので、gnuplot
 はパイプからデータを読み込む場合、`array` 指定子で指定した数の点数にな
 るまでデータを読み込み続けます。

 詳細に関しては、以下参照: `datafile binary`。
4 binary
?commands plot datafile binary
?plot datafile binary
?splot datafile binary
?plot binary
?splot binary
?data-file binary
?datafile binary
?binary
 キーワード `binary` はデータファイルを ASCII ではなくてバイナリファイ
 ルと認識させます。バイナリファイルフォーマットには、matrix バイナリと
 general binary の 2 つがあります。matrix バイナリは固定フォーマットで、
 データは、2 次元配列の形で並び、その座標を表す余分な列と行がついていま
 す。general バイナリは柔軟なフォーマットで、そのファイルに関する詳細は
 コマンドラインで指示する必要があります。

 詳細に関しては、以下参照: `binary matrix`, `binary general`。
4 binary general
?commands plot datafile binary general
?commands splot datafile binary general
?plot binary general
?splot binary general
?binary general
 general バイナリデータは、その形式に関する情報が必ずしもファイル内には
 なくても良く、ファイルの形式に関する詳細な情報をコマンドラインから与え
 ることで、そのデータを読み込むことが可能になります。そのオプションの書
 式は一時的なユーザにはやや難解ですが、general バイナリは特に gnuplot
 を使い、多くのデータを送るようなアプリケーションに取っては有用です。

 書式:
       plot '<file_name>' {binary <binary list>} ...
       splot '<file_name>' {binary <binary list>} ...

 general バイナリ形式は、ファイル構造に関する情報に関連するキーワード、
 すなわち `array`, `record`, `format`, `filetype` などを <binary list>
 内に与えることで有効になります。それ以外の場合は matrix バイナリ形式と
 見なされます。(詳細に関しては、以下参照: `binary matrix`。)

 バイナリ形式に関する情報が自動的にファイルから読み取ることができるよう
 な標準的なファイル形式もいくつかあります (その一覧を見るには、gnuplot
 の対話画面から `show datafile binary` してください)。それ以外の場合は
 コマンドライン、あるいはデフォルトの値を設定する必要があります。キーワ
 ードに関しては以下で説明します。

 <binary list> に与えるキーワード `filetype` は、ファイルを読み込むのに
 使用されるルーチン、すなわちデータの形式の扱いを制御します。サポートし
 ている filetype の一覧を見るには、`show datafile binary filetypes` と
 してください。filetype を指定しない場合の規則は、`splot` 用に `binary`
 キーワードが単独で与えられた場合は古典的な gnuplot バイナリ形式だと見
 なされ、その他全ての状況、すなわち `plot` 用かまたは少なくとも一つの
 <binary list> キーワードが与えられたような場合は、raw バイナリファイル
 とみなされ、そのキーワードによってバイナリ形式が指定されます。

 general バイナリデータファイルは 2 つの基本的なクラスに分かれますが、
 それがどのように扱われるのかによって両方のクラスに入る場合もあります。
 一つのクラスは、データは一様にサンプリングされていると見なされ、点の座
 標は必然的にそこから生成されます。このクラスでは <binary list> キーワ
 ードを用いて全ての制御が行なわれます。そして、このクラスでの設定の優先
 順位は、コマンドラインパラメータがファイル内のパラメータを上書きし、そ
 れはデフォルトの設定を上書きします。もう一つのクラスは、座標情報がファ
 イル内に含まれた複数のファイルの組のためのもの、あるいは gnuplot バイ
 ナリのような非一様な標本化を含み得る一つのファイルのためのものです。

 gnuplot バイナリのような特殊なデータファイル以外では、一般にバイナリデ
 ータは概念上は ASCII データと同様に考えられます。各点は情報の列を持っ
 ていて、それは `using` によって結びつけられる <using list> で選択され
 ます。`format` 文字列が何も指定されなかった場合、gnuplot はバイナリ変
 数の数を `<using list>` で与えられる最大の列番号に等しく取ります。例え
 ば `using 1:3` の場合は 3 列ずつデータが読み取られ、2 番目のものは無視
 されます。各描画スタイルにはその典型的なパラメータの個数があり、それに
 基づく `<using list>` がデフォルトとして選択されます。例えば
 `with image` では デフォルトで `using 1` が、`with rgbimage` ではデフ
 ォルトで `using 1:2:3` が使われます。`using` で 点/線/index を表す特別
 な文字は、一般にはバイナリデータでは使うべきではないことに注意してくだ
 さい。これを制御する <binary list> のキーワードがあります。
5 array
?binary array
?binary general array
 バイナリファイルの標本の配列の大きさを設定します。座標は gnuplot が生
 成してくれます。各方向の次元を表す数を指定しなければいけません。例えば
 `array=(10,20)` は、2 次元で最初の次元方向 (x) には 10 点、2 番目の次
 元方向 (y) には 20 点の標本化データがあることを意味します。ファイルの
 終了までデータが続くことを示すのに負の値を使えます。データ次元が 1 の
 場合は、カッコは省略できます。複数のデータのサイズ指定を分離するのに、
 コロンを使うことができます。例えば `array=25:35` は 2 つの 1 次元デー
 タがファイルの中にあることを意味します。
       注意:  gnuplot version 4.2 では array=(128,128) という書式ではな
              く、array=128x128 という書式を使用していました。古い書式
              は推奨されていませんが、あなたの gnuplot が後方互換性をサ
              ポートするようコンパイルされていれば一応今でも使えます。
5 record
?binary record
?binary general record
 このキーワードは `array` と同じ書式で、同じ機能を提供します。しかし
 `record` は gnuplot に座標情報を自動生成させません。これは、そのような
 座標情報が、バイナリデータファイルのある列に含まれている場合のためのも
 のです。
5 skip
?binary skip
?binary general skip
 このキーワードは、バイナリファイルのある区画のスキップを可能にします。
 例えば、そのファイルがデータ領域の開始位置の前に 1024 バイトのヘッダを
 持つような場合には、以下のようにしたいと思うでしょう:
       plot '<file_name>' binary skip=1024 ...
 ファイルに複数のレコードがある場合、そのそれぞれに対する先頭のずらし位
 置を指定することができます。例えば、最初のレコードの前の 512 バイトを
 スキップし、2 番目、3 番目のレコードの前の 256 バイトをスキップするに
 は以下のようにします:
       plot '<file_name> binary record=356:356:356 skip=512:256:256 ...
5 format
?binary general format
 デフォルトのバイナリ形式は、単精度浮動小数 (float) が一つ、です。それ
 をより柔軟に設定するために、この format で変数のサイズに関する詳細な情
 報を指定できます。例えば `format="%uchar%int%float"` は、最初の using
 列として符号なし文字型変数 (unsigned char) を、2 番目の列は符号つき整
 数 (int) を、3 番目の列は単精度浮動小数 (float) を指定しています。もし
 サイズ指定子の数が最大列数より小さい場合は、残りの列の変数サイズは暗黙
 のうちに最後に与えた変数サイズに等しく取られます。

 さらに `using` 指定同様、`*` 文字がついた読み捨てる列を書式に指定する
 こともできますし、繰り返しフィールドへの回数指定によって暗黙の繰り返し
 を指定することもできます。例えば、`format="%*2int%3float"` は、3 つの
 実数データを読む前に、2 つの整数データを読み捨てます。使用できる変数サ
 イズの一覧は、`show datafile binary datasizes` で見ることができます。
 それらは、それぞれのコンパイルによってそのバイトサイズとともにマシンに
 依存する変数名のグループと、マシンに依存しない変数名のグループに分かれ
 ています。
5 endian
?binary general endian
 ファイルのバイナリデータのエンディアンは、gnuplot が動作するプラットホ
 ームのエンディアンとは異なる場合も良くあります。いくつかの指定で
 gnuplot がバイトをどのように扱うかを制御できます。例えば
 `endian=little` は、バイナリファイルを、そのバイトの並びが小さい桁から
 大きい桁へ並んでいると見なされます。オプションは以下のものが使えます。

               little:  小さい桁から大きな桁へ並ぶ
                  big:  大きな桁から小さな桁へ並ぶ
              default:  compiler と同じエンディアンと見なす
          swap (swab):  エンディアンを変更する (おかしいようならこれを
                        使ってみてください)

 gnuplot は、コンパイル時にオプションが指定されていれば、"middle" (や
 "pdp") エンディアンもサポートできます。
5 filetype
?binary general filetype
 gnuplot は、いくつか標準的なバイナリファイル形式については必要な情報を
 そのファイルから抜き出すことができます。例えば "format=edf" は ESRF ヘ
 ッダーファイル形式のファイルとして読み込みます。現在サポートしているフ
 ァイル形式については、`show datafile binary filetypes` で見てください。

 特別なファイル形式として `auto` があり、この場合 gnuplot はバイナリフ
 ァイルの拡張子が、サポートされている形式の標準的な拡張子であるかをチェ
 ックします。

 コマンドラインキーワードはファイルから読み取る設定を上書きするのに使わ
 れ、ファイルから読み取る設定はデフォルトの設定を上書きします (詳細は
 以下参照: `set datafile binary`)。
6 avs
?binary general filetype avs
?filetype avs
?avs
 `avs` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。AVS は非常単純なフォーマットで、アプリケーション間でやりとり
 するのに最も適しています。これは、2 つの long (xwidth と ywidth) と、
 その後続くピクセルの列から成り、その各ピクセルは alpha/red/green/blue
 の 4 バイトから成ります。
6 edf
?binary general filetype edf
?filetype edf
?edf
?filetype ehf
?ehf
 `edf` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。EDF は ESRF データフォーマット (ESRF Data Format) を意味して
 いて、それは edf と ehf の両方の形式をサポートしています (後者は ESRF
 Header Format)。画像の使用に関する詳しい情報は以下で見つかるでしょう:

   http://www.edfplus.info/specs

 以下も参照: `binary`。
5 keywords
?binary general keywords
?filetype keywords
 以下のキーワード (keyword) は、座標の生成のときにのみ適用されます。よ
 って、これらは `array` キーワードが使われるときのためのものです。
6 scan
?binary general keywords scan
 gnuplot がバイナリファイルをどのように走査するか、ということと実際の描
 画で見られる軸の方向との間の関係については多くの混乱が起こり得ます。そ
 の混乱を減らすには、gnuplot はバイナリファイルを "常に" 点/線/面、また
 は速い/普通/遅い、と走査すると考えるといいでしょう。このキーワードは
 gnuplot に、その走査の方向を描画内のどの座標方向 (x/y/z) に割り当てる
 かを指定します。指定は 2 つ、または 3 つの文字の並びで表現し、最初の文
 字が点に、次の文字が線に、3 つ目の文字が面に対応します。例えば、
 `scan=yx` は、最も速い走査 (点の選択) は y 方向に対応し、普通の速さの
 走査 (線の選択) が x 方向に対応することを意味します。

 描画モードが `plot` の場合、指定には x と y の 2 つの文字を使うことが
 でき、`splot` に対しては x, y, z の 3 つの文字を使うことができます。

 割り当てに関しては、点/線/面から直交座標方向へのみに制限する内部事情は
 別にありません。この理由で、円柱座標への割り当てのための指定子も用意さ
 れていて、それらは直交座標の x, y, z に類似した形で t (角度), r, z と
 なっています。
6 transpose
?binary general keywords transpose
 `scan=yx`、または `scan=yxz` と同じです。
6 dx, dy, dz
?binary general keywords dx
 gnuplot が座標を生成する場合、その間隔はこれらのキーワードで指定された
 ものが使用されます。例えば `dx=10 dy=20` は x 方向に 10、y 方向に 20
 の間隔で標本化されたことを意味します。`dy` は `dx` がなければ使えませ
 ん。同様に `dz` は `dy` がなければ使えません。もしデータの次元が指定し
 たキーワードの次元よりも大きい場合、残りの次元方向の間隔は、指定された
 最も高い次元のものと同じ値が使用されます。例えば画像がファイルから読み
 込まれ、`dx=3.5` のみ指定された場合、gnuplot は x 方向の間隔も y 方向
 の間隔も 3.5 を使用します。

 以下のキーワードも座標の生成時にのみ適用されます。しかし、以下のものは
 matrix バイナリファイルにも使われます。
6 flipx, flipy, flipz
?binary general keywords flipx
 バイナリデータファイルの走査方向が gnuplot の走査方向と一致しないこと
 がたまにあります。これらのキーワードは、それぞれ x, y, z 方向のデータ
 の走査方向を逆向きにします。
6 origin 
?binary general keywords origin
 gnuplot は転置 (transpose) や反転 (flip) において座標を生成する場合、
 常に配列の左下の点が原点になるようにします。すなわち、データが、転置や
 反転の行なわれた後の直交座標系の第 1 象限に来るようにします。

 配列をグラフのその他の場所に配置したい場合、`origin` キーワードで指定
 した場所に gnuplot は配列の左下の点を合わせます。その指定は、`plot` で
 は 2 つの座標の組、`splot` では 3 つの座標の組を指定してください。例え
 ば `origin=(100,100):(100,200)` は、一つのファイルに含まれる 2 つのデ
 ータに対する指定で、2 次元の描画に対する指定です。2 つ目の例として
 `origin=(0,0,3.5)` をあげると、これは 3 次元描画用の指定です。
6 center
?binary general keywords center
?center
 `origin` と似ていますが、このキーワードは、配列の中心がこのキーワード
 で指定した点になるように配置します。例えば `center=(0,0)` のようにしま
 す。配列のサイズが `Inf` のときは center は適用されません。
6 rotate
?binary general keywords rotate
?rotate
 転置 (transpose) と反転 (flip) コマンドは座標の生成と座標軸の方向にあ
 る種の柔軟性を与えてくれます。しかし、角度に関する完全な制御は、2 次元
 の回転角を記述した回転角ベクトルを与えることにより行なうことが可能にな
 ります。

 キーワード `rotate` は, `plot`, `splot` の両方で、2 次元面に対して適用
 されます。回転は座標平面の正の角度に関して行なわれます。

 角度は、ラジアン単位ですが、pi や degrees の倍数としてのラジアンでも表
 現できます。例えば、`rotate=1.5708`, `rotate=0.5pi`, `rotate=90deg` は
 すべて同じ意味です。

 `origin` が指定された場合、回転は平行移動の前に左下の点を中心にして行
 なわれます。それ以外では回転は配列の中心 (`center`) に関して行なわれま
 す。
6 perpendicular
?binary general keywords perpendicular
 `splot` に関して回転ベクトルの設定が、ベクトルを表現する 3 つの数字の
 組を指定することで実装されていて、このベクトルは 2 次元の xy 平面に対
 して向き付けられた法線ベクトル (perpendicular) を表しています。もちろ
 んそのデフォルトは (0,0,1) です。rotate と perpendicular の両方を指定
 することにより、3 次元空間内で無数の方向へデータを向き付けられることに
 なります。

 まず最初に 2 次元の回転が行なわれ、その次に 3 次元の回転が行なわれます。
 つまり、R' をある角による 2 x 2 の回転行列とし、P を (0,0,1) を
 (xp,yp,zp) へ子午線方向に回転させる 3 x 3 の行列とし、R' を左上の部分
 行列として持ち 3,3 成分が 1 でその他の成分が 0 であるような行列 (つま
 り z 軸周りの回転行列) とすれば、この変換を表す行列による関係式は
 v' = P R v となります。ここで、v はデータファイルから読み込まれた
 3 x 1 の位置ベクトルです。ファイルのデータが 3 次元的なものでない場合
 は、論理的なルールが適用されて 3 次元空間内のデータと見なされます (例
 えば、通常は z 座標は 0 とされ、xy 平面内の 2 次元データと見なされます)。
5 binary の例 (binary examples)
?binary_examples
?binary examples
?binary general examples
=skip
 例:

       # 2 つの float の値を選択し (2 つ目の値は無意味)、一方を読み捨て、
       # 一つおきの float 値を無限に長く続く 1 次元データとして使用
       plot '<file_name>' binary format="%float%*float" using 1:2 with lines

       # データファイルから座標を生成するのに必要な情報をすべてそのヘッ
       # ダに含んでいる EDF ファイルの場合
       plot '<file_name>' binary filetype=edf with image
       plot '<file_name>.edf' binary filetype=auto with image

       # 3 つの符号なし文字型整数値 (unsigned char) を生の RGB 画像の色
       # 成分として選択し、y 方向は反転させ画像の方向を座標平面上で変更
       # する (左上が原点になるように)。ピクセルの間隔も指定し、ファイ
       # ルには 2 つの画像が含まれていて、そのうち一つは origin で平行
       # 移動する。
       plot '<file_name>' binary array=(512,1024):(1024,512) format='%uchar' \
            dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage

       # 4 つの別のデータからなり、座標情報もデータファイルに含まれてい
       # る。ファイルは gnuplot が実行されているシステムとは異なるエン
       # ディアンで生成されている。
       splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3

       # 同じ入力ファイルで、今回は 1 番目と 3 番目のレコードをスキップ
       splot '<file_name>' binary record=30:26 skip=360:348 endian=swap u 1:2:3


 以下参照: `binary matrix`。
4 every
?commands plot datafile every
?plot datafile every
?plot every
?data-file every
?datafile every
?every
 キーワード `every` は、描画するデータをデータ集合から周期的にサンプリ
 ングすることを可能にします。

 ここでは 「ポイント」はファイル中の 1 つの行によって定義されるデータと
 し、ここでの「ブロック」は「データ・ブロック」(以下参照: `glossary`)
 と同じものを意味することとします。

 書式：
          plot 'file' every {<ポイント増分>}
                            {:{<ブロック増分>}
                              {:{<開始ポイント>}
                                {:{<開始ブロック>}
                                  {:{<終了ポイント>}
                                    {:<終了ブロック>}}}}}

 プロットされるデータポイントは、<開始ポイント> から <終了ポイント> ま
 で <ポイント増分> の増加で選ばれ、ブロックは <開始ブロック> から <終了
 ブロック> まで <ブロック増分> の増加で選ばれます。

 各ブロックの最初のデータは、ファイル中の最初のブロックと同じように、
 「0 番」とされます。

 プロットできない情報を含んでいる行もカウントされることに注意して下さい。

 いくつかの数字は省略することができます; 増分のデフォルトは 1 、開始の
 値は最初のポイントか最初のブロック、そして終了の値は最後のポイントか最
 後のブロックに設定されます。`every` が指定されないなら、全ての行の全て
 のポイントがプロットされます。

 例:
        every :::3::3   # 4 番目のブロックだけ選ばれます (0 番が最初)
        every :::::9    # 最初の 10 ブロックが選ばれます
        every 2:2       # 1 つおきのブロックで 1 つおきのポイントが選ば
                        # れます
        every ::5::15   # それぞれのブロックでポイント 5 から 15 までが
                        # 選ばれます

 参照:
^ <a href="http://www.gnuplot.info/demo/simple.html">
 単純な plot デモ (simple.dem)
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface1.html">
 非パラメータモードでの splot デモ
^ </a>
 ,
^ <a href="http://gnuplot.sourceforge.net/demo/surface2.html">
 パラメータモードでの splot デモ
^ </a>
 。
4 データファイルの例 (example)
?commands plot datafile example
?plot datafile example
?plot example
?datafile example
?data-file example
?example
 次の例は、ファイル "population.dat" 中のデータと理論曲線を図にするもの
 です。

       pop(x) = 103*exp((1965-x)/10)
       plot [1960:1990] 'population.dat', pop(x)

 ファイル "population.dat" は次のようなファイルです。

       # Gnu population in Antarctica since 1965
          1965   103
          1970   55
          1975   34
          1980   24
          1985   10

^ <img align=bottom src="http://www.gnuplot.info/doc/population.gif" alt="[population.gif]" width=640 height=480>
4 index
?commands plot datafile index
?plot datafile index
?plot index
?data-file index
?datafile index
?index
 キーワード `index` は、描画用に複数のデータ集合を持つファイルから、特
 定のデータ集合を選択することを可能にします。

 書式:
       plot 'file' index { <m>{:<n>{:<p>}} | "<name>" }

 データ集合は 2 行の空白で分離されています。`index <m>` は <m> 番目の集
 合だけを選択します; `index <m>:<n>` は <m> から <n> までのデータ集合の
 選択; `index <m>:<n>:<p>` は、<m>, <m>+<p>, <m>+2<p>, など、<p> おきの
 集合を選択し、集合 <n> で終了します。C 言語の添字 (index) の付け方に従
 い、index 0 はそのファイルの最初のデータ集合を意味します。大きすぎる
 index の指定にはエラーメッセージが返されます。`index` が指定されない場
 合は、全てのデータ集合が単一のデータ集合として描かれます。

 例:
       plot 'file' index 4:5

 ファイルの各点に対して、それが含まれるデータ集合の index 値は、疑似列
 `column(-2)` で利用できます。これは、以下に見るように、そのファイル内
 の個々のデータ集合を区別する別の方法を提供します。これは、描画用に 1
 つのデータ集合の選択しかしない場合は `index` コマンドよりも不恰好です
 が、個々のデータ集合に異なる属性を割り当てたい場合にはとても便利です。
 以下参照: `pseudocolumns`, `lc variable`。

 例:
       plot 'file' using 1:(column(-2)==4 ? $2 : NaN)        # とても不恰好
       plot 'file' using 1:2:(column(-2)) linecolor variable # とても便利 !

 `index '<name>'` は、データ集合を名前 '<name>' で選択します。名前はコ
 メント行に書いてデータ集合に割り当てます。コメント文字とそれに続く空白
 をそのコメント行から取り除いて、その結果が <name> から始まっていれば、
 それに続くデータ集合に <name> という名前がつけられて、それを指定できま
 す。

 例:
       plot 'file' index 'Population'

 <name> で始まるすべてのコメントがそれに続くデータ集合の名前になること
 に注意してください。問題を避けるために、例えば '== Popolation ==' や
 '[Population]' などの命名法を選択すると便利でしょう。

^ 以下の Web ページも参照:
^ <a href="http://www.gnuplot.info/demo/multimsh.html">
^ index を使った splot のデモ
^ </a>
4 smooth
?commands plot datafile smooth
?plot datafile smooth
?plot smooth
?data-file smooth
?datafile smooth
?smooth
 `gnuplot` は、データの補間と近似を行う汎用的なルーチンをいくつか持っ
 ています。これ `smooth` オプションの中にグループ化されています。より
 洗練されたデータ処理をしたければ、外部においてデータの前処理をするか、
 または適切なモデルで fit を使うのがいいでしょう。

 書式:
       smooth {unique | frequency | cumulative | kdensity | csplines
               | acsplines | bezier | sbezier}

 `unique`, `frequency`, `cumulative` は、データを単調に揃えた後でそれら
 を plot します。他のルーチンはいずれも、データの両端の点の間を結ぶ、あ
 る連続曲線の係数を決定するためにデータを使います。この曲線は、関数とし
 て同じ方法で描画されます。すなわち、それらの値は x 座標に沿う同じ幅の
 区間ごとに選ばれ (以下参照: `set samples`)、それらの点を線分でつなぐこ
 とにより (もし line style が選ばれているのならば) 描画されます。

 もし `autoscale` の状態であれば、描画範囲はグラフの境界線の中に曲線が
 収まるように計算されます。

 もし `autoscale` の状態でなく、smooth のオプションが `acspline` か
 `cspline` であれば、生成する曲線の標本化は、入力データを含むような x
 の範囲と、`set xrange` などで定義される固定された横座標の範囲の共通部
 分の上で行なわれます。

 選択されたオプションを適用するのにデータの点数が少なすぎる場合は、エ
 ラーメッセージが表示されます。その最小のデータ数は `unique` と
 `frequency` では 1 つ、`acsplines` では 4 つ、他のオプションでは 3 つ
 です。

 `smooth` オプションは、関数の描画のときには無視されます。
5 acsplines
?commands plot datafile smooth acsplines
?plot datafile smooth acsplines
?data-file smooth acsplines
?datafile smooth acsplines
?plot smooth acsplines
?plot acsplines
?smooth acsplines
?acsplines
 `acsplines` オプションは「自然な滑らかなスプライン」でデータを近似しま
 す。データが x に関して単調にされた後 (以下参照: `smooth unique`)、1
 つの曲線が、いくつかの 3 次多項式の一部分により区分的に構成されます。
 それらの 3 次式の係数は、いくつかのデータポイントの重み付けによって求
 められます。重みは、データファイルの 3 列目に与えます。そのデフォルト
 の値は、`using` の 3 番目の項目によって変更することができます。例えば
 次のようにします。
       plot 'data-file' using 1:2:(1.0) smooth acsplines

 性質上、重みの絶対的な大きさは、曲線を構成するのに使われる区分の数を決
 定します。もし重みが大きければ、個々のデータの影響は大きくなり、そして
 その曲線は、隣り合う点同志を自然 3 次スプラインでつないで得られるもの
 に近づきます。もし重みが小さければ、その曲線はより少ない区分で構成され、
 それによってより平滑的になります。その最も極端な場合はただ 1 つの区分
 からなる場合であり、それは全てのデータに重みの付き線形最小 2 乗近似に
 よって作られます。誤差の立場から言えば、平滑さの重みは、その曲線に対す
 る「平滑化因子」によって分割された各点への、統計的な重みと見ることがで
 きます。それにより、そのファイル中の (標準的な) 誤差は平滑さの重みとし
 て使うことができます。

 例:
       sw(x,S)=1/(x*x*S)
       plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines
5 bezier
?commands plot datafile smooth bezier
?plot datafile smooth bezier
?plot smooth bezier
?data-file smooth bezier
?datafile smooth bezier
?plot bezier
?smooth bezier
?bezier
 `bezier` オプションは、n 次 (データ点の個数) のベジェ曲線でデータを近
 似します。この曲線は両端の点をつなぎます。
5 csplines
?commands plot datafile smooth csplines
?plot datafile smooth csplines
?plot smooth csplines
?data-file smooth csplines
?datafile smooth csplines
?plot csplines
?smooth csplines
?csplines
 `csplines` オプションはデータを単調に揃えた後で (以下参照:
 `smooth unique`) 自然 3 次スプライン曲線で引き続く点をつなぎます。
5 sbezier
?commands plot datafile smooth sbezier
?plot datafile smooth sbezier
?plot smooth sbezier
?data-file smooth sbezier
?datafile smooth sbezier
?plot sbezier
?smooth sbezier
?sbezier
 `sbezier` オプションは、最初にデータを単調に揃え (以下参照: `unique`)
 そして `bezier` アルゴリズムを適用します。
5 unique
?commands plot datafile smooth unique
?plot datafile smooth unique
?plot smooth unique
?data-file smooth unique
?datafile smooth unique
?plot unique
?smooth unique
?unique
 `unique` オプションは、データを x 方向に単調にします。同じ x を持つデ
 ータ点は y の値を平均して一つの点で置き換えます。そしてその結果として
 得られる点を線分で結びます。
5 frequency
?commands plot datafile smooth frequency
?plot datafile smooth frequency
?plot smooth frequency
?data-file smooth frequency
?datafile smooth frequency
?plot frequency
?smooth frequency
?frequency
 オプション `frequency` は、データを x に関して単調にします。x 座標が同
 じ点は、それらの y の値の合計を y の値として持つ一つの点に置き換えられ
 ます。結果としてそれらの点は真っすぐな線分で結ばれることになります。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 cumulative
?commands plot datafile smooth cumulative
?plot datafile smooth cumulative
?plot smooth cumulative
?data-file smooth cumulative
?datafile smooth cumulative
?plot cumulative
?smooth cumulative
?cumulative
 オプション `cumulative` は、データを x に関して単調にします。x 座標が
 同じ点は、それ以下の x の値を持つすべての点 (すなわち現在のデータ点の
 左側の点) に対する y の値の累積的な合計を y の値として持つ一つの点に置
 き換えられます。これは、データから累積分布関数を得るのに利用できます。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 kdensity
?commands plot datafile smooth kdensity
?plot datafile smooth kdensity
?plot smooth kdensity
?data-file smooth kdensity
?datafile smooth kdensity
?plot kdensity
?smooth kdensity
?kdensity
 オプション `kdensity` は、ガウス核を用いた、ランダム選択点の核密度評価
 (それは滑らかなヒストグラムになります) を描画する方法の一つです。ガウ
 ス核が第 1 列の各点の位置に置かれ、これらのガウス核すべての和が関数と
 して描画されます。2 列目の値は、ガウス核の重みとして使用されます。(正
 規化されたヒストグラムを得るには、これを 1/(点の個数) とすべきです。)
 3 列目の値があれば、それはガウス核のバンド幅として使用されます。2 列し
 か指定しない、あるいは 3 列目の値が 0 以下であれば、gnuplot は入力デー
 タが正規分布である場合に最適となるようなバンド幅を計算します。(これは
 通常はとても保守的で、すなわち幅広いバンド幅です。)
4 特別なファイル名 (special-filenames)
?commands plot datafile special-filenames
?plot datafile special-filenames
?plot special-filenames
?datafile special-filenames
?special-filenames
 特別な意味を持つファイル名として、次のものがあります: '', '-', '+',
 '++'

 空のファイル名 '' は、同じ plot コマンド上で、直前の入力ファイルを再び
 使用することを gnuplot に指示します。よって、同じ入力ファイルの 2 つの
 データ列を描画するには以下のようにします:

       plot 'filename' using 1:2, '' using 1:3

 '+' と '++' という特別なファイル名は、`using` 指定の全体と描画スタイル
 にインライン関数を使えるようにするための仕組みです。通常、関数描画はサ
 ンプル点毎に単一の y (または z) の値しか持てません。しかし疑似ファイル
 '+' はそれがあたかも実際の入力ファイルであるように、`using` 指定による
 1 列目の値を標本点として扱い、さらに追加の列の値を指定することも可能で
 す。返される標本点の数は、`set samples` で制御できます。
 例:

       plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves

 同様に、疑似ファイル '++' は、x 方向は `set samples` で制御される点の
 数、y 方向は `set isosamples` で制御される点の数の、標準的な [x,y] 座
 標の格子を生成する 2 列のデータを返します。'++' の描画の前に、xrange
 と yrange を設定する必要があります。
 例:

       splot '++' using 1:2:(sin($1)*sin($2)) with pm3d
       plot '++' using 1:2:(sin($1)*sin($2)) with image

 `'-'` という特別なファイル名は、データがインラインであることを指示し
 ます。すなわち、データをコマンドの後に続けて指定します。このときはデ
 ータのみがコマンドに続き得ます。よって、`plot` コマンドに対するフィル
 ター、タイトル、ラインスタイルといったオプションは、`plot` のコマンド
 ラインの方に書かないといけません。これは、unix シェルスクリプトにおけ
 る << (ヒアドキュメント)、あるいは VMS DCL における $DECK と同様です。
 そのデータは、それらがファイルから読み込まれたかのように、1 行につき
 1 つずつのデータ点が入力されます。そしてデータの終りは、1 列目の始めに
 文字 "e" を置くことで指示します。`using` オプションをこれらのデータに
 適用することは可能です。ある関数を通しデータをフィルターすることに使う
 のは意味があるでしょうが、列を選ぶのに使うことは多分意味がないでしょう。

 `'-'` は、データとコマンドを一緒に持つことが有用である場合のためにあ
 ります。例えば、`gnuplot` があるフロントアプリケーションのサブプロセ
 スとして起動される場合などがこれにあたります。例として、デモンストレ
 ーションでこの機能を使うものがあるでしょう。`index` や `every` のよう
 な `plot` のオプションが与えられていると、それらはあなたに使われるこ
 とのないデータを入力する事を強要します。次の例を見てください。

       plot '-' index 0, '-' index 1
       2
       4
       6


       10
       12
       14
       e
       2
       4
       6


       10
       12
       14
       e

 これは、実際に動作しますが、

       plot '-' , '-'
       2
       4
       6
       e
       10
       12
       14
       e

 とタイプする方が楽でしょう。

 もし、`replot` コマンドで `'-'` を使うなら、あなたは 1 度以上データを
 入力する必要があるでしょう。以下参照: `replot`, `refresh`。

 空のファイル名 ('') は、直前のファイル名が再び使われることを指示しま
 す。これは、

       plot 'ある/とても/長い/ファイル名' using 1:2, '' using 1:3, '' using 1:4

 のようなときに便利です。(もし同じ plot コマンド上で、`'-'` と `''` の
 両方を使用すると、上の例にあるように、インラインデータの 2 つの集合を
 与える必要があります。)

 popen 関数を持っているシステム上では、データファイルは、'<' で始まるフ
 ァイル名によって、シェルコマンドからパイプ入力することができます。例え
 ば

       pop(x) = 103*exp(-x/10)
       plot "< awk '{print $1-1965, $2}' population.dat", pop(x)

 は、最初の人口の例と同じ情報を描画します。ただし、x 座標は 1965 年か
 らの経過年を表すようになります。この例を実行するときは、上のデータフ
 ァイルのコメント行をすべて削除しなければなりませんが、または上のコマ
 ンドの最初の部分を次のように変えることもできます (コンマに続く部分):

       plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"

 このアプローチは最も柔軟性がありますが、`using` あるいは `thru` キー
 ワードを用いた単純なフィルタリングで行うことも可能です。
4 thru
?commands plot datafile thru
?plot datafile thru
?plot thru
?data-file thru
?datafile thru
?thru
 `thru` 関数は前のバージョンとの互換性のために用意されています。

 書式:
       plot 'file' thru f(x)

 これは次と同様です:

       plot 'file' using 1:(f($2))

 後者の方がより複雑に見えますが、この方が柔軟性を持っています。さらに
 自然な

       plot 'file' thru f(y)

 も動作します (すなわち、y をダミー変数として使うことができます)。

 `thru` は `splot` と `fit` でも通りますが、何の効果も持ちません。
4 using
?commands plot datafile using
?plot datafile using
?plot using
?data-file using
?datafile using
?using
 最もよく使われるデータファイルの修飾子は `using` です。

 書式:
       plot 'file' using {<entry> {:<entry> {:<entry> ...}}} {'format'}

 もし、フォーマット (format) が指定されれば、C のライブラリ関数 'scanf'
 を使ってデータファイルの各行をそのフォーマット文字列に従って読み込みま
 す。そうでなければ、行は列に分割されて読み込まれますが、デフォルトでは
 ホワイトスペース (スペースやタブ) で列の分離が行われていると見なします。
 以下参照: `datafile separator`。

  各 <entry> は、適切な入力の一つのフィールドから値を選択するための単な
 る列の番号か、またはカッコで囲まれた数式の指定、または何も指定しないか
 のいずれかです。

 そのエントリがカッコで囲まれた数式の場合、N 列目の値を指定するのに関数
 column(N) を使用できます。つまり、column(1) は読み込まれた最初の項目を
 参照し、column(2) は次の項目、といった具合です。column(1), column(2),
 ... の略記として、特別な記号 $1, $2, ... を使用できます。関数
 `valid(N)` で、N 番目の列が有効な数字であるかどうかテストできます。

 入力データファイルの 1...N という実際の列に加えて、gnuplot は管理情報
 を持ついくつかの "疑似列" を提供します。例えば、$0 または column(0) は、
 データ集合内のそのデータ行の行番号を返します。以下参照:
 `pseudocolumns`。

 <entry> に何も書かなければ、そのエントリのリストの順にデフォルトの値が
 使われます。例えば `using ::4` は、`using 1:2:4` と解釈されます。

 `using` にただ一つのエントリを指定した場合は、その <entry> は y の値と
 して使われ、データ点の番号 (疑似列 $0) が x として使われます。例えば
 "`plot 'file' using 1`" は "`plot 'file' using 0:1`" と同じ意味です。
 `using` に 2 つのエントリを与えた場合、それらは x, y として使われます。
 さらにエントリを追加して、入力からのデータを利用するような描画スタイル
 の詳細については、以下参照: `set style`, `fit`。

 'scanf' 関数では色々なデータ形式の数値入力が使えますが、`gnuplot` は全
 ての入力データを倍精度浮動小数とみなしますから、`gnuplot` では `%lf`
 が本質的に唯一の数値入力指定、ということになります。
 書式文字列には、少なくとも一つ、そして 7 つ以下の、そのような入力指定子
 を入れる必要があります。
 'scanf' は数と数の間にホワイトスペース、すなわち空白、タブ ("\t")、改行
 ("\n")、または改ページ ("\f") があると期待します。それ以外の入力は明示
 的にスキップされるべきです。

 "\t", "\n", "\f" を使うときはシングルクォートよりむしろダブルクォートを
 使うべきであることに注意してください。
5 using の例 (using_examples)
?examples
?commands plot datafile using examples
?plot datafile using examples
?datafile using examples
?using examples
 次の例は、1 番目のデータに対する 2 番目と 3 番目の和の値を plot します。
 書式文字列は、各列データがスペース区切りでなく、カンマ区切りであること
 を指示していますが、同じことが `set datafile separator ","` を指定する
 ことでも可能です。
       plot 'file' using 1:($2+$3) '%lf,%lf,%lf'

 次の例は、より複雑な書式指定でデータをファイル "MyData" から読み込み
 ます。
       plot 'MyData' using "%*lf%lf%*20[^\n]%lf"

 この書式指定の意味は以下の通りです:

       %*lf        数値を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは x の値)
       %*20[^\n]   20 個の改行以外の文字を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは y の値)

 3 項演算子 `?:` を使ってデータをフィルタする一つの芸当を紹介します。

       plot 'file' using 1:($3>10 ? $2 : 1/0)

 これは、1 列目のデータに対して、3 列目のデータが 10 以上であるような
 2 列目のデータを plot します。`1/0` は未定義値であり、`gnuplot` は未定
 義の点を無視するので、よって適切でない点は隠されることになります。
 または、あらかじめ定義されている値 NaN を使っても同じことになります。
=NaN

 カッコで始まっていない限りは定数式を列番号として使うことができます。
 例えば `using 0+(複雑な式)` の様なことができます。そして、その数式は、
 カッコでスタートしていなければ数式の値が一度評価され、カッコでスタート
 していれば個々のデータ点を読み込むためにその値が一度評価される、という
 点が重要です。

 時系列フォーマットデータを使っている場合、その時間のデータは複数の列に
 渡らせることができます。その場合、他のデータの開始位置を計算するとき、
 時間のデータに空白が含まれていることに注意してください。例えば、データ
 行の最初の要素がスペースが埋め込まれた時間データであるならば、y の値は
 3 列目の値として指定されるべきです。

 `plot 'file'` と `plot 'file' using 1:2`、そして
 `plot 'file' using ($1):($2)` には微妙な違いがあることに注意してくださ
 い。1) `file` が 1 列と 2 列のデータを持つ行をそれぞれ含んでいるとする
 と、データが 1 列のみの行に対しては、最初のものは x の値を作り出し、2
 番目のものはその行は無視し、3 番目のものはそれを未定義の値として保存し
 ます (折れ線で plot している場合 (plot with lines)、その未定義の点を通
 過する線を結ばないように)。2) 1 列目に文字列を含んでいるような行がある
 場合、最初のものはエラーとして plot を中止しますが、2 番目と 3 番目の
 ものはその不要な行を読みとばします。

 実際、最初に単に

       plot 'file' using 1:2

 と指定することで、大抵の場合どんなにゴミのデータを含む行を持つファイル
 をも plot することが可能になります。しかし、どうしてもデータファイルに
 文字列を残しておきたいならば、そのテキスト行の第一列にコメント文字 (#)
 を置く方がより安全でしょう。
^ 以下の Web ページ参照
^ <a href="http://www.gnuplot.info/demo/using.html">
 弱々しい using のデモ
^ </a>
5 疑似列 (pseudocolumns)
?pseudocolumns
?commands plot datafile using pseudocolumns
?plot datafile using pseudocolumns
?datafile using pseudocolumns
?using pseudocolumns
 plot 文の `using` 項目内の式では、入力ファイルに含まれる実際のデータ値
 に加えて管理情報も参照でき、これらは "疑似列" (pseudocolumns) に含まれ
 ています。
       column(0)   データ集合内での各点の順番。順番は 0 から始まり、2
                   行のブランク行でリセットされます。略記 $0 も使用可。
       column(-1)  この番号は 0 から始まり、1 行のブランク行でリセット
                   されます。これは、行列、または格子状データ内のデータ
                   行に対応します。
       column(-2)  複数のデータ集合を持つファイル内の、現在のデータ集合
                   の index 番号。以下参照: `index`。
5 xticlabels
?xticlabels
?using xticlabels
?plot using xticlabels
 入力データのある列を軸の刻みのラベルとして使えます。そのような描画コマ
 ンドの書式は以下の通りです。

   plot 'datafile' using <xcol>:<ycol>:xticlabels(<labelcol>) with <plotstyle>

 目盛りの見出し、任意の描画軸 x,x2,y,y2,z 用に読みだすことができます。
 `ticlabels(<labelcol>)` 指定は、`using` 指定の中で、そのデータの座標指
 定が全て済んだ後に行う必要があります。有効な X,Y[,Z] 座標の組を持つ各
 データ点に対して、<labelcol> 列に見つかるテキスト部分は、その点の X 座
 標と同じ位置の x 軸の刻みのラベルに追加されます。
 `xticlabels(<labelcol>)` は `xtic(<labelcol>)` と省略することもできま
 す。

 例:

       splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)

 この例では、x 軸、y 軸の見出しは x,y 座標値とは別の列から取り出されま
 すが、z 軸の見出しは、対応する点の z 座標値から生成されます。
5 x2ticlabels
?using x2ticlabels
?plot using x2ticlabels
 以下参照: `plot using xticlabels`。
5 yticlabels
?using yticlabels
?plot using yticlabels
 以下参照: `plot using xticlabels`。
5 y2ticlabels
?using y2ticlabels
?plot using y2ticlabels
 以下参照: `plot using xticlabels`。
5 zticlabels
?using zticlabels
?plot using zticlabels
 以下参照: `plot using xticlabels`。
3 errorbars
?commands plot errorbars
?commands splot errorbars
?plot errorbars
?splot errorbars
?errorbars
 エラーバーは、1 から 4 個の追加されたデータを読む (またはエントリを
 `using` で追加選択する) ことにより、2 次元データの描画において実現され
 ています。これら追加される値は、それぞれのエラーバースタイルで異なった
 形で使われます。

 デフォルトでは、`gnuplot` はデータファイルの各行に以下のような 3 つ、
 4 つ、あるいは 6 つの列があることを期待しています:

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は必ず指定しなければいけません。各数値を書く順序も上で挙げた通りで
 なくてはなりません。ただ、`using` 修飾子を使えばその順序を操作できますし、
 欠けている列の値も補うことは可能ですが。例えば、

       plot 'file' with errorbars
       plot 'file' using 1:2:(sqrt($1)) with xerrorbars
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 最後の例は、相対的な x の誤差と絶対的な y の誤差、という、サポートされて
 いない組のファイルに対するものです。`using` エントリが相対的な x の誤差
 から絶対的な x の最小値と最大値を生成しています。

 y のエラーバーは、(x, ylow) から (x, yhigh) への鉛直な線として描かれます。
 ylow と yhigh の代わりに ydelta が指定されたときは、ylow = y - ydelta,
 yhigh = y + ydelta となります。ある行にデータが 2 つしかなければ、ylow と
 yhight はともに y となります。x エラーバーは同様に計算された水平線です。
 データの各点を結ぶ折れ線を引きたい場合は、with errorbars と with lines を
 指定して、同じデータファイルを 2 回 `plot` して下さい (ただし、キーの中に
 2 つのエントリを作らないように、その一方には `notitle` オプションを使う
 ことを忘れないで下さい)。他の選択肢として、errorlines コマンドもあります
 (以下参照: `errorlines`)。

 エラーバーには、もし `set bars` を使っていなければ、そのそれぞれの端に垂直な
 線分がつきます (詳細は、以下参照: `set bars`)。

 自動範囲指定が有効であれば、その描画範囲はエラーバーも含むように調整
 されます。

 以下も参照
^ <a href="http://gnuplot.sourceforge.net/demo/mgr.html">
 エラーバーのデモ
^ </a>

 更なる情報に関しては、以下参照: `plot using`, `plot with`, `set style`。
3 errorlines
?commands plot errorlines
?commands splot errorlines
?plot errorlines
?splot errorlines
?errorlines
 誤差線 (errorbar) を伴う線描画は、2 次元データファイルの描画でサポート
 されていて、それは 1 個から 4 個の追加の (または `using` で指定する)
 列データを与えることで行なわれます。これらの追加される値は、様々な
 errorline スタイルのそれぞれで異なった形で使われます。

 デフォルトの状態では、`gnuplot` は、データファイルの各行に 3 個、4 個、
 6 個のいずれかの個数のデータがあることを期待し、それぞれ以下のいずれか
 に対応します。

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は指定する必要がありますし、データの順番も上の形式である必要があ
 りますが、`using` 修飾子でその順番を操作したり、欠けている列に対する値
 を与えたりすることができます。例えば

       plot 'file' with errorlines
       plot 'file' using 1:2:(sqrt($1)) with xerrorlines
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 最後の例は、相対的な x の誤差と絶対的な y の誤差、というサポートされて
 いない組合せのデータのファイルに対するもので、`using` で相対的な誤差か
 ら絶対的な x の最小値と最大値を生成しています。

 y 誤差線は (x, ylow) から (x, yhigh) へ描画される縦線です。ylow, yhigh
 代わりに ydelta が指定された場合は、ylow = y - ydelta, yhigh = y + ydelta
 と扱われます。ある行に 2 つのデータしかない場合、yhigh, ylow は両方と
 も y になります。x 誤差線は同様の方法で計算される水平線です。

 誤差線には、`set bars` が指定されていない場合、その両端で垂直に交わる
 線分が付きます (詳細は、以下参照: `set bars`)。

 自動縮尺 (autoscaling) が ON の場合、描画範囲は誤差線が入るように調整
 されます。

 更なる情報については、以下参照: `plot using`, `plot with`, `set style`。
3 parametric
?commands plot parametric
?commands splot parametric
?plot parametric
?splot parametric
 媒介変数モード (`set parametric`) では、`plot` では 2 つの数式の組を、
 `splot` では 3 つの数式の組を与える必要があります。

 例:
       plot sin(t),t**2
       splot cos(u)*cos(v),cos(u)*sin(v),sin(u)

 データファイルは前と同じように描画されます。ただし、データファイルが
 描画のために与えられる前に、任意の媒介変数関数が先に完全に指定された
 場合を除いてです。言い換えると、x の媒介変数関数 (上の例では `sin(t)`)
 と y の媒介変数関数 (上の例では `t**2`) との間に、他の修飾子やデータ
 関数をはさみこんではいけません。そのようなことをすると、構文エラーにな
 り、媒介変数関数が完全には指定されていない、と表示されます。

 `with` や `title` のような他の修飾子は、媒介変数関数の指定が完了した
 後に指定しなければいけません。

       plot sin(t),t**2 title 'Parametric example' with linespoints

 以下も参照
^ <a href="http://www.gnuplot.info/demo/param.html">
 媒介変数モードのデモ。
^ </a>
3 範囲 (ranges)
?commands plot ranges
?commands splot ranges
?plot ranges
?splot ranges
?ranges
 オプションの範囲は、表示されるグラフの領域範囲を指定します。

 書式:
       [{<dummy-var>=}{{<最小値>}:{<最大値>}}]
       [{{<最小値>}:{<最大値>}}]

 最初の範囲指定は独立変数の範囲 (`xrange` またはパラメトリックモードで
 は `trange`) で、2 番目のものは従属変数の範囲 `yrange` (パラメトリック
 モードでは `xrange`) となります。<dummy-var> には独立変数の新しい別名を
 指定します (デフォルトの変数名は `set dummy` で変更できます)。<最小値>,
 <最大値> には定数式、あるいは * を書くことができます。

 パラメトリックモードでなければ、与えられるべき範囲指定は `xrange`,
 `yrange` の順になります。

 パラメトリックモードでは、`plot` コマンドに対してはその順序は `trange`,
 `xrange`, `yrange` になります。以下の `plot` コマンドは、`trange` を
 [-pi:pi], `xrange` を [-1.3:1.3], `yrange` を [-1:1] に設定する例です。

       plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2

 x2 の範囲と y2 の範囲はここでは指定できないことに注意してください。
 それには `set x2range` や `set y2range` が使われます。

 範囲は適切なモードに対して、上に示した順序で解釈されます。必要な範囲指
 定が一度全て指定されると、再び指定し直すことはありませんが、必要ない部
 分を全く指定しないようにはできません。その代わり、そこに空の範囲指定
 `[]` を置きます。

 `*` は、最小値や最大値に自動範囲指定 (autoscale) の機能を使うことを
 可能にします。以下も参照: `set autoscale`。

 `plot` や `splot` のコマンド行で指定された範囲はそのグラフにのみ影響を
 及ぼします。よって、その後のグラフのデフォルトの範囲を変更するには、
 `set xrange` や `set yrange` を使用してください。

 時間データに対しては、範囲はクォートで囲んで指定する必要があります (デ
 ータファイルに現われる時間データと同じ形式の)。`gnuplot` はその範囲を
 読みこむのに時間書式文字列 (`timefmt`) を使用します。詳しくは以下参照:
 `set timefmt`。

 例:

 以下は現在の範囲を使用します:
       plot cos(x)

 以下は x の範囲のみの指定です:
       plot [-10:30] sin(pi*x)/(pi*x)

 以下は上と同じですが、仮変数として t を使います:
       plot [t = -10 :30]  sin(pi*t)/(pi*t)

 以下は x と y の両方の範囲の指定です:
       plot [-pi:pi] [-3:3]  tan(x), 1/x

 以下は、y の範囲のみの指定で、両方の軸の自動範囲指定機能を無効にします:
       plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)

 以下は x の最大値と y の最小値のみの指定です。
       plot [:200] [-pi:]  exp(sin(x))

 以下は x の範囲を時系列データとして指定しています:
       set timefmt "%d/%m/%y %H:%M"
       plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'

3 繰り返し (iteration)
?commands plot iteration
?commands splot iteration
?plot iteration
?splot iteration
=iteration
 多くの同等のファイルや関数を同時に描画する場合は、それぞれの plot コマ
 ンドの繰り返し (iteration) でそれを行うのが便利です。

 書式:
       plot for [<variable> = <start> : <end> {:<increment>}]
       plot for [<variable> in "string of words"]

 繰り返しの適用範囲 (scope) は、次のコンマ (,) かコマンドの終わり、のい
 ずれか先に現れたところまでです。繰り返しは入れ子 (nest) にすることもで
 きます。

 例:
       plot for [dataset in "apples bananas"] dataset."dat" title dataset

 この例では、繰り返しはファイル名と対応するタイトルの生成の両方で使われ
 ています。

 例:
       file(n) = sprintf("dataset_%d.dat",n)
       splot for [i=1:10] file(i) title sprintf("dataset %d",i)

 この例は、ファイル名で生成される文字列値関数を定義し、そのような 10 個
 のファイルを同時に描画します。繰り返しの変数 (この例では 'i') は一つの
 整数として扱われ、それを 2 度以上使用できます。

 例:
       set key left
       plot [0:1] for [n=1:4] x**n sprintf("%d",n)

 この例は、関数の組を描画します。

 例:
       list = "apple banana cabbage daikon eggplant"
       item(n) = word(list,n)
       plot for [i=1:words(list)] item(i).".dat" title item(i)
       list = "new stuff"
       replot

 この例では、リストに従って各ステップが進行し、その各項目に対して一つの
 描画が行われます。この各項目は動的に取得されますので、そのリストを変更
 し、そのまま replot することができます。

 例:
       list = "apple banana cabbage daikon eggplant"
       plot for [i in list] i.".dat" title i
       list = "new stuff"
       replot

 この例は、整数の繰り返し変数ではなく、文字列の繰り返し変数形式を用いて
 いること以外は前の例と全く同じです。

3 title
?commands plot title
?commands splot title
?plot title
?splot title
?columnheader
 各関数やデータに対する曲線のタイトルは、その曲線のサンプル、および
 (または) それを表示されるのに使われる記号とともにキーの中に表示されま
 す。それは `title` オプションで変更できます。

 書式:
       title <text> | notitle [<ignored text>]
       title columnheader | title columnheader(N)

 ここで <text> は引用符で囲まれた文字列か、文字列変数のいずれかです。引
 用符はキーには表示されません。特殊文字も、バックスラッシュに続く 8 進
 値 (例えば "\345" のように) を使うことで用いることができます。タブ文字
 "\t" は認識されます。バックスラッシュのそのような作用は二重引用符で囲
 まれた文字列でしか効きません。逆にその作用を働かさないようにするには、
 単一引用符を使ってください。改行文字 "\n" はどちらの型の引用符でもキー
 では働きません。

 入力データの列の最初の項目 (すなわち列の先頭) を文字列フィールドと解釈
 し、それをキータイトルとして利用するオプションもあります。以下参照:
 `datastrings`。これは、`set key autotitle columnhead` を指定すればデフ
 ォルトの挙動となります。

 曲線タイトルとサンプルは予約語 `notitle` を使うことでキーから削除でき
 ます。何もないタイトル (`title ''`) は `notitle` と同じ意味を持ちます。
 サンプルだけが欲しいときは、一つ以上の空白をタイトルの後ろに入れてく
 ださい (`tilte ' '`)。`notilte` の後ろに文字列をつけた場合、その文字列
 は無視されます。

 `key autotitles` が設定されて (デフォルト)、かつ `title` も `notitle`
 も指定されなかった場合、曲線のタイトルは `plot` コマンド上にある関数名
 かデータファイル名になります。ファイル名の場合は、指定される任意のデー
 タファイル修飾子もそのデフォルトタイトルに含まれます。

 位置やタイトルの位置揃えなどのキーのレイアウトは、`set key` で制御でき
 ます。詳細は、以下参照: `set key`。

 例:

 以下は y=x をタイトル 'x' で表示します:
       plot x

 以下は、x の 2 乗をタイトル "x^2" で、ファイル "data.1" をタイトル
 "measured data" で表示します:
       plot x**2 title "x^2", 'data.1' t "measured data"

 以下は、極座標グラフの周りに円形の境界を書き、タイトルなしで表示します:
       set polar; plot my_function(t), 1 notitle

 以下は、ファイルの各列にタイトルを含む複数列のデータを描画します:
       plot for [i=1:4] 'data' using i title columnhead

3 with
?commands plot with
?commands splot with
?commands plot style
?commands splot style
?plot with
?plot style
?splot with
?splot style
?style
?with
 関数やデータの表示にはたくさんのスタイルのうちの一つを使うことができます。
 キーワード `with` がその選択のために用意されています。

 書式:
       with <style> { {linestyle | ls <line_style>}
                      | {{linetype  | lt <line_type>}
                         {linewidth | lw <line_width>}
                         {linecolor | lc <colorspec>}
                         {pointtype | pt <point_type>}
                         {pointsize | ps <point_size>}
                         {fill | fs <fillstyle>}
                         {nohidden3d} {nocontours} {nosurface}
                         {palette}}
                    }


 ここで、<style> は以下のいずれか:

      lines        dots       steps     errorbars     xerrorbar    xyerrorlines
      points       impulses   fsteps    errorlines    xerrorlines  yerrorbars
      linespoints  labels     histeps   financebars   xyerrorbars  yerrorlines
                                        vectors
 または、
       boxes            candlesticks   image      circles
       boxerrorbars     filledcurves   rgbimage
       boxxyerrorbars   histograms     rgbalpha   pm3d

 最初のグループのスタイルは、線、点、文字の属性を持ち、第 2 のグループ
 のスタイルは、さらに塗り潰し属性も持っています。以下参照: `fillstyle`。
 さらにサブスタイルを持つスタイルもあります。個々のスタイルの詳細につい
 ては、以下参照: `plotting styles`。

 デフォルトのスタイルは、`set style function` と `set style data` で選
 択できます。

 デフォルトでは、それぞれの関数やデータファイルは、使うことができる型の
 最大数に達するまで異なる線種、点種を使います。すべての端末用ドライバは
 最低 6 つの異なる点種をサポートしていて、もしたくさん要求された場合、
 それらを順に再利用していきます。使用中の出力形式での線種、点種の集合全
 体を見たければ、`test` としてください。

 一つの描画で線種や点種を選びたいならば、<line_type> や <point_type> を
 指定してください。これらの値は、その描画で使われる線種や点種を指定する
 正の整定数 (または数式) です。使用する端末で使える線種、点種を表示する
 には `test` コマンドを使ってください。

 描画の線の幅や点の大きさは <line_width> や <point_size> で変更できます。
 これらはその各々の端末のデフォルトの値に対する相対的な値として指定しま
 す。点の大きさは全体に通用するように変更できます。詳細は、以下参照:
 `set pointsize`。しかし、ここでセットされる <point_size> と、
 `set pointsize` でセットされる大きさは、いずれもデフォルトのポイントサ
 イズに掛けられることに注意してください。すなわち、それらの効果は累積は
 しません。例えば、`set pointsize 2; plot x w p ps 3` は、デフォルトの
 サイズの 3 倍であって、6 倍ではありません。

 ラインスタイルの一部分、あるいは各 plot において `pointsize variable`
 という指定も可能です。この場合、入力には追加の 1 列が要求されます。例
 えば 2D 描画では 3 列、3D 描画では 4 列のデータが必要になります。個々
 の点のサイズは、全体を通しての pointsize に、データファイルからの入力
 による値をかけたものとして決定されます。

 `set style line` を使って線種/線幅、点種/点幅の組を定義すれば、そのス
 タイルの番号を <line_style> にセットすることでそれらを使うことができま
 す。

 gnuplot が `pm3d` をサポートするようにインストールされているならば、
 `splots` において lines, points, dots の色を滑らかに変化させるための特
 別なキーワード `palette` が使えます。その色は、コマンド `set palette`
 であらかじめ設定された滑らかに変化するカラーパレットから選択します。色
 の値は、点の z 座標の値か、または `using` で 4 番目のパラメータとして
 指定される色座標に対応します。2 次元、3 次元の描画 (`plot` と `splot`
 コマンド) の両方で、パレット色を小数値かまたはカラーボックスの範囲へ対
 応づけられた値のいずれかで指定することができます。パレット色の値は、
 `using` 指定で明示的に指定された入力列から読み込むことも可能です。
 以下参照: `colors`, `set palette`, `linetype`。

 キーワード `nohidden3d` は、`splot` コマンドで生成される描画にのみ適用
 されます。通常、グローバルなオプション `set hidden3d` はグラフ上の全て
 の描画に適用されますが、各々の描画に `nohidden3d` オプションをつけるこ
 とで、それを hidden3d の処理から除外することができます。`nohidden3d`
 がマークされた曲面以外の個々の描画要素 (線分、点、ラベル等) は、通常は
 他の何らかの描画要素で隠されてしまう場合も全て描画されます。

 同様に、キーワード `nocontours` は、グローバルに `set contour` 指定が
 有効な場合でも、個別の plot に対する等高線描画機能をオフにします。

 同様に、キーワード `nosurface` は、グローバルに `set surface` 指定が有
 効な場合でも、個別の plot に対する 3 次元曲面描画をオフにします。

 キーワードは暗示するような形で省略可能です。

 `linewidth`, `pointsize`, `palette` オプションは全ての端末装置でサポー
 トされているわけではないことに注意してください。

 例:

 以下は、sin(x) を鉛直線で描画します:
       plot sin(x) with impulses

 以下は、x を点で描画し、x**2 をデフォルトの方式で描画します:
       plot x w points, x**2

 以下は、tan(x) を関数のデフォルトの方式で、"data.1" を折れ線で描画します:
       plot [ ] [-2:5] tan(x), 'data.1' with l

 以下は、"leastsq.dat" を鉛直線で描画します:
       plot 'leastsq.dat' w i

 以下は、データファイル "population" を矩形で描画します:
       plot 'population' with boxes

 以下は、"exper.dat" をエラーバー付きの折れ線で描画します (エラーバーは
 3 列、あるいは 4 列のデータを必要とします):
       plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars

 もう一つの "exper.dat" のエラーバー付きの折れ線 (errorlines) での描画
 方法 (エラーバーは 3 列、あるいは 4 列のデータが必要):
       plot 'exper.dat' w errorlines

 以下は、sin(x) と cos(x) をマーカー付きの折れ線で描画します。折れ線は
 同じ線種ですが、マーカーは異なったものを使います:
       plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4

 以下は、"data" を点種 3 で、点の大きさを通常の 2 倍で描画します:
       plot 'data' with points pointtype 3 pointsize 2

 以下は、"data" を描画しますが、4 列目から読んだデータを pointsize の値
 として使用します:
       plot 'data' using 1:2:4 with points pt 5 pointsize variable

 以下は、2 つのデータ集合に対して、幅のみ異なる線を用いて描画します:
       plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1

 以下は、x*x の曲線の内部の塗りつぶしと色の帯を描画します:
       plot x*x with filledcurve closed, 40 with filledcurve y1=10

 以下は、x*x の曲線と色の箱を描画します:
       plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y1=10 lt 8

 以下は、滑らかに変化する色の線で曲面を描画します:
       splot x*x-y*y with line palette

 以下は、2 つの色のついた曲面を、異なる高さで表示します:
       splot x*x-y*y with pm3d, x*x+y*y with pm3d at t

2 print
?commands print
?print
 `print` コマンドは <式> の値を画面に表示します。これは `pause 0` と同
 じです。<式> は、数を生成する `gnuplot` の数式か、または文字列です。

 書式:
         print <式> {, <式>, ...}

 以下参照: `expressions`。出力ファイルは `set print` で設定できます。
2 pwd
?commands pwd
?pwd
 `pwd` コマンドはカレントディレクトリの名前を画面に表示します。

 カレントディレクトリを文字列変数に保存したり、文字式の中で使いたい場合
 は、変数 GPVAL_PWD を使うことができることに注意してください。以下参照:
 `show variables all`。これは、"`pwd`" によるシェル呼び出しよりも優れて
 います。
2 quit
?commands quit
?quit
 `exit` と `quit` の両コマンドと END-OF-FILE 文字は、`gnuplot` を終了
 させます。これらのコマンドは、出力装置を (`clear` コマンドと同様に)
 クリアしてから終了させます。
2 raise
?commands raise
?raise
 書式:
       raise {plot_window_nb}

 コマンド `raise` (`lower` の反対) は、`pm`, `win`, `wxt`, `x11` 等の
 gnuplot の対話型出力形式の実行中に、描画ウィンドウを上 (前面) に上げま
 す。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z 方向の
 ウィンドウの重なりの前 (上) に置きます。

 `x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デ
 フォルトではこのコマンドはそれらの複数のウィンドウを降順に上げ、最初に
 作られたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べま
 す。オプション引数の描画番号が与えられた場合、それに対応する描画ウィン
 ドウが存在すればそれのみが上げられます。

 オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
 `win` では無視されます。

 ウィンドウが X11 で前面に出ない場合、もしかすると描画ウィンドウは、異
 なる X11 セッションで動作している (例えば telnet や ssh セッションなど
 によって) か、または前面に出すことがウィンドウマネージャの設定によって
 防害されている可能性があります。
2 refresh
?commands refresh
?refresh
 コマンド `refresh` は、`replot` に似ていますが、主に 2 つの点で違いが
 あります。`refresh` は、既に読み込んだデータを用いて、現在の描画を再整
 形し再描画します。これは、`refresh` を (疑似デバイス '-' からの) イン
 ラインデータの描画、および内容が変化しうるデータファイルからの描画に使
 えるということを意味します。ただし、コマンド `refresh` は、既に存在す
 る描画に新しいデータを追加するのには使えません。

 マウス操作、特にズームインとズームアウトでは、適切な場合は `replot` の
 代わりにむしろ `refresh` を使用します。例:

       plot 'datafile' volatile with lines, '-' with labels
       100 200 "Special point"
       e
       # 色んなマウス操作をここで実行
       set title "Zoomed in view"
       set term post
       set output 'zoom.ps'
       refresh

2 replot
?commands replot
?replot
 `replot` コマンドを引数なしで実行すると、最後に実行した `plot` または
 `splot` コマンドを再実行します。これは、あるプロットを異なる `set` オ
 プションでみたり、同じプロットを異なる装置に出力したりするときに便利
 でしょう。

 `replot` コマンドに対する引数は最後に実行した `plot` または `splot`
 コマンドの引数に (暗黙の ',' と共に) 追加され、それから再実行されます。
 `replot` は、範囲 (range) を除いては、`plot` や `splot` と同じ引数を
 とることができます。よって、直前のコマンドが `splot` ではなく `plot`
 の場合は、関数をもう一つの軸刻でプロットするのに `replot` を使うことが
 できます。

 注意:

       plot '-' ; ... ; replot

 という使い方は推奨されません。それは、これがあなたに再び同じデータすべ
 ての入力を要求することになるからです。たいていの場合、代わりにコマンド
 `refresh` を使えます。これは、以前に読み込んだデータを使ってグラフを再
 描画します。

 `replot` コマンドは `multiplot` モードでは働きません。それは、それが
 画面全体にではなく直前のプロットのみを再実行するものだからです。

 最後に実行した `plot` (`splot`) コマンドの内容を修正する方法については
 以下も参照: `command-line-editing`。

 直前の描画コマンドの全体を表示させることや、それを `history` の中に
 コピーする方法については、以下も参照: `show plot`。
2 reread
?commands reread
?reread
 `reread` コマンドは、`load` コマンドまたはコマンドラインで指定した
 `gnuplot` のコマンドファイルを、その次のコマンドが読まれる前に、開
 始点に再設定します。これは、コマンドファイルの最初から `reread` コマ
 ンドまでのコマンドの無限ループを本質的に実装していることになります。
 (しかし、これは何も悪いことではありません。`reread` は `if` と組み合
 わせることでとても有用なコマンドとなります。詳細は、以下参照: `if`。)
 標準入力からの入力の場合は、`reread` コマンドは何も影響を与えません。

 例:

 ファイル "looper" が次のようなファイルで
       a=a+1
       plot sin(x*a)
       pause -1
       if(a<5) reread
 そして、`gnuplot` から次のように実行するとします。
       a=0
       load 'looper'
 すると、pause のメッセージで分割された 5 回のプロットが行われることに
 なります。

 ファイル "data" が、各行に、0 から 10 までの範囲 (yrange) の 6 つのデ
 ータ を持ち、最初が x 座標で、その他は 5 つの異なる関数の、その x での
 値であるとします。そして、ファイル "plotter" が
       c_p = c_p+1
       plot "$0" using 1:c_p with lines linetype c_p
       if(c_p <  n_p) reread
 で、`gnuplot` から次のように実行するとします。
       n_p=6
       c_p=1
       unset key
       set yrange [0:10]
       set multiplot
       call 'plotter' 'data'
       unset multiplot
 すると、5 つのプロットを合わせた 1 つのグラフができます。yrange は、
 multiplot モードで最初のものに続けて書かれる 5 つのグラフが、同じ軸を
 持つように、明示的に指定する必要があります。線種も指定しなければなりま
 せん。さもないと、全てのグラフが同じ線種で書かれることになります。
 アニメーションのサンプルとして、demo ディレクトリの animate.dem も参照
 してください。

2 reset
?commands reset
?reset
?reset errors
?reset bind
 コマンド `reset` は `set` コマンドで定義できる、グラフに関する全てのオ
 プションをデフォルトの値に設定します。このコマンドは、例えばコマンドフ
 ァイルの最後にグラフのデフォルトの設定に復帰する、あるいはコマンドファ
 イル内でたくさんの設定を行なった場合に元の状態に戻すときなどに便利です。
 様々なオプションの取るデフォルトの値を知るには、`set` コマンドの結果を
 参照してください。

 以下のものは、`reset` の影響を受けません。
      `set term` `set output` `set loadpath` `set fontpath`
      `set encoding` `set decimalsign` `set locale`

=error state
 `reset errors` は、エラー状態変数 GPVAL_ERRNO と GPVAL_ERRMSG のみをク
 リアします。

=bind
 `reset bind` は、キー定義をデフォルトの状態に復帰します。
2 save
?commands save
?save
^ <a name="save set"></a>
 `save` コマンドは、ユーザ定義関数、変数、`set term` の状態、`set` で設
 定する全てのオプションのいずれかか、あるいはこれらすべてと、それに加え
 て最後に実行した `plot` (または `splot`) コマンドを、指定したファイル
 に保存します。

 書式:
         save  {<オプション>} '<ファイル名>'

 ここで、<オプション> は、`functions`, `variables`, `terminal`, `set`
 のいずれかです。どれも指定されなかった場合には、`gnuplot` は、ユーザ定
 義関数、変数、set で設定するオプション、最後に実行した `plot` (または
 `splot`) コマンドの全てを保存します。

 `save` は、テキスト形式で出力します。また、このファイルは `load` コマ
 ンドで読み込むことができます。`set` オプション付き、または何もオプショ
 ンをつけずに `save` を実行した場合、`terminal` の選択と `output` のフ
 ァイル名はコメント記号つきで書き出されます。これはその出力ファイルを
 他の環境にインストールされた gnuplot 上で動かす場合に、修正なしに使え
 るようにする、あるいはうっかりファイルを上書きしてしまったりする危険性
 を避ける、といった意味があります。

 `save terminal` は、`terminal` の状態を、コメント記号をつけずに書き出
 します。これは主に、ちょっとの間だけ `terminal` の設定を入れ替え、その
 後保存しておいた `terminal` の状態を読み込むことで以前の terminal の設
 定に戻す場合などに役立ちます。ただ、単一の gnuplot セッションでは、現
 在の terminal を保存/復元する他の方法であるコマンド `set term push` と
 `set term pop` を使う方がむしろいいかもしれません。以下参照:
 `set term`。

 ファイル名は引用符に囲われていなければなりません。

 特別なファイル名 "-" により `save` コマンドに標準出力に出力させること
 ができます。popen 関数をサポートするようなシステム (Unix など) では、
 save の出力をパイプ経由で他の外部プログラムに渡すことができます。その
 場合、ファイル名としてコマンド名の先頭に '|' をつけたものを使います。
 これは、`gnuplot` とパイプを通して通信するプログラムに、`gnuplot` の内
 部設定に関する首尾一貫したインターフェースを提供します。詳細は、以下参
 照: `batch/interactive`。

 例:
       save 'work.gnu'
       save functions 'func.dat'
       save var 'var.dat'
       save set 'options.dat'
       save term 'myterm.gnu'
       save '-'
       save '|grep title >t.gp'
2 set-show
?commands set
?commands show
?set
?show
?show all
 `set` コマンドは実に多くのオプションを設定するのに使われます。しかし、
 `plot`, `splot`, `replot` コマンドが与えられるまで何も表示しません。

 `show` コマンドはそれらの設定値を表示します。`show all` でそれら全て
 を表示します。

 `set` コマンドで変更されたオプションは、それに対応する `unset` コマン
 ドを実行することでデフォルトの状態に戻すことができます。以下も参照:
 `reset`。これは全てのパラメータの設定をデフォルトの値に戻します。

 もし変数が日時のデータを含むならば、`show` は、`set timefmt` によって
 現在設定されている書式に従って表示します。それは変数が最初に設定されて
 いてその書式が効果を持たなかったとしてもです。
=iteration
 `set` と `unset` コマンドには繰り返し節も利用できます。以下参照:
 `iteration`。

3 angles
?commands set angles
?commands show angles
?set angles
?show angles
?angles
?commands set angles degrees
?set angles degrees
?angles degrees
?degrees
 デフォルトでは `gnuplot` は極座標グラフの独立変数の単位はラジアンを仮定
 します。`set polar` の前に `set angles degrees` を指定すると、その単位
 は度になり、デフォルトの範囲は [0:360] となります。これはデータファイル
 の描画で特に便利でしょう。角度の設定は、`set mapping` コマンドを設定す
 ることにより 3 次元でも有効です。

 書式:
       set angles {degrees | radians}
       show angles

 `set grid polar` で指定される角度も、`set angles` で指定した単位で読まれ
 表示されます。

 `set angles` は組み込み関数 sin(x), cos(x), tan(x) の引数や asin(x),
 acos(x), atan8x), atan2(x), arg(x) の出力にも影響を与えます。双曲線関
 数や、ベッセル関数の引数には影響を与えません。しかし、複素数を引数とす
 る逆双曲線関数の出力には影響が出ます。それらの関数が使われるときは、
 `set angles radians` は入出力の引数の間に一貫性を持った管理を実現して
 いなければなりません。

       x={1.0,0.1}
       set angles radians
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{1.0, 0.1} と表示
 しかし、
       set angles degrees
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{57.29578, 5.729578} と表示
 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 poldat.dem: `set angles` を用いた極座標描画のデモ
^ </a>
3 arrow
?commands set arrow
?commands unset arrow
?commands show arrow
?set arrow
?unset arrow
?show arrow
?arrow
?noarrow
 `set arrow` コマンドを使うことにより、グラフ上の任意の位置に矢印を表示
 することができます。

 書式:
       set arrow {<tag>} {from <position>} {to|rto <position>}
                 { {arrowstyle | as <arrow_style>}
                   | { {nohead | head | backhead | heads}
                       {size <length>,<angle>{,<backangle>}}
                       {filled | empty | nofilled}
                       {front | back}
                       { {linestyle | ls <line_style>}
                         | {linetype | lt <line_type>}
                           {linewidth | lw <line_width} } } }

       unset arrow {<tag>}
       show arrow {<tag>}

 タグ <tag> は各矢印を識別する整数です。タグを指定しない場合は、その
 時点で未使用の最も小さい数が自動的に割り当てられます。タグを使うこと
 で、特定の矢印を変更したり、削除したりできます。既に存在する矢印の属性を
 変更する場合は、タグを明示した set arrow コマンドで変更箇所を指定して
 ください。

 <position> は  x,y あるいは x,y,z で指定します。そしてその前に座標系を
 選択するために `first`, `second`, `graph`, `screen`, `character` を置
 くことができます。座標を指定しなければデフォルトでは 0 と見なされます。
 矢印の端点は、5 つの座標系、すなわち `first` か `second` の軸、あるい
 は `graph`, `screen`, `character` のうちの 1 つを選択して指定できます。
 詳細は、以下参照: `coordinates`。"from" の場所の座標系指定子は、"to"
 の場所に影響を及ぼすことはありません。グラフの枠をはみ出る矢印を書くこ
 ともできますが、出力端末によってはエラーを生ずることがあります。終点が
 "to" の代わりに "rto" で指定されている場合、始点からの相対的な位置に描
 かれます。この場合、線形軸 (非対数軸)、および `graph`, `screen` 座標に
 対しては、始点と終点の距離が与えられた相対的な値に対応します。一方、対
 数軸に対しては、与えられた相対的な値は、始点から終点への積因子 (比) に
 対応します。よって、対数軸の場合、相対的な値として 0 や負の値を与える
 ことは許されません。

 `nohead` を指定することで、矢先のない矢、すなわち線分を書くこともでき
 ます。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1
 つの矢は 1 つの矢先をその終端に持っています。`backhead` は始点に矢先を
 描き、`heads` は線分の両端に矢先を描きます。全ての出力形式が両端の矢先
 の描画をサポートしているわけではありません。

 矢先の大きさは `size <length>,<angle>` または
 `size <length>,<angle>,<backangle>` で制御できます。`<length>` は矢先
 の各枝の長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
 `<length>` の単位は x 軸と同じですが、それは `<length>` の前に
 `first`, `second`, `graph`, `screen`, `character` をつけることで変更で
 きます。詳細は、以下参照: `coordinates`。`<backangle>` は、`filled` か
 または `empty` がともに使われた場合のみ効力を持ち、その場合、
 `<backangle>` は矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方向;
 単位は度) になります。
 出力形式 `fig` は、制限された切り角関数を持っていて、それは 3 つの異な
 る形をサポートしていて、それは 2 つの閾値で決定します: 70 度未満の場合、
 矢先はへこんだ切り角を持ち、110 度を超える場合、後ろの部分に尖った角を
 持ち、その間の角では、矢先の後ろは直線になります。

 `filled` を指定すると、塗りつぶされた矢先を作ります (`heads` が使われ
 ている場合)。塗りつぶしは、多角形の塗りつぶしが行えるような出力形式で
 サポートされていて、そのリストについては、以下参照: `pm3d`。他の出力形
 式では矢先は閉じられますが塗りつぶされません。それと同じ効果 (閉じらる
 が塗られない) は、`empty` を指定しても得られます。また、`metafont`,
 `metapost`, `latex`, `tgif` のように、矢をそれら自身の独自のルーチンで
 描くような出力形式では、矢先の塗りつぶしや矢先の枠線描きはもちろんサポ
 ートされません。

 線種はユーザの定義したラインスタイルのリストから選ぶこともできますし
 (以下参照: `set style line`)、用意されている <line_type> の値 (デフォ
 ルトのラインスタイルのリストの番号) そして <linewidth> (デフォルトの幅
 の倍数) を使ってここで定義することもできます。

 しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
 幅) は、単に他の `set arrow` コマンドで適当な番号や `lt`, `lw` などを
 指定しても、変更はできないことに注意して下さい。

 `front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指
 定された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`
 を使えば、密集したデータで矢が見えなくなることを防ぐことができます。

 例:

 原点から (1,2) への矢印をユーザ定義済のラインスタイル 5 で描くには:
       set arrow to 1,2 ls 5

 描画領域の左下角から (-5,5,3) へタグ番号 3 の矢印を描くには:
       set arrow 3 from graph 0,0 to -5,5,3

 矢印の端を 1,1,1 に変更し、矢先を外して幅を 2 にするには:
       set arrow 3 to 1,1,1 nohead lw 2

 x=3 の所へグラフの下から上まで鉛直線を描くには:
       set arrow from 3, graph 0 to 3, graph 1 nohead

 T 字型の矢先を両端に持つ鉛直方向の矢を描くには:
       set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90

 始点からの相対的な距離をグラフ座標で与えて矢を描くには:
       set arrow from 0,-5 rto graph 0.1,0.1

 x の対数軸に相対的な終点を指定して矢を描く場合:
       set logscale x
       set arrow from 100,-5 rto 10,10
 これは 100,-5 から 1000,5 までの矢を描きます。線形軸 (y) に対しては相
 対的な座標 10 が "差 10" を意味するのに対し、対数軸 (x) に対しては相対
 的な座標 10 は "積因子 10" として働きます。

 2 番の矢印を消すには:
       unset arrow 2

 全ての矢印を消すには:
       unset arrow

 全ての矢印の情報を (タグの順に) 見るには:
       show arrow

^ <a href="http://gnuplot.sourceforge.net/demo/arrowstyle.html">
 矢印のデモ
^ </a>

3 autoscale
?commands set autoscale
?commands unset autoscale
?commands show autoscale
?set autoscale
?unset autoscale
?show autoscale
?autoscale
?noautoscale
 自動縮尺機能 (autoscale) は x, y, z の各軸に対して独立に、または一括し
 て指定できます。デフォルトでは全ての軸に対して自動縮尺設定を行います。
 図の中の一部の描画 (`plot`) の組のみを元に autoscale したい場合は、そ
 の対象でない `plot` にフラグ `noautoscale` をつけることができます。
 以下参照: `datafile`。

 書式:
       set autoscale {<axes>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
       unset autoscale {<axes>}
       show autoscale

 ここで、<axes> (軸) は `x`, `y`, `z`, `cb`, `x2`, `y2`, `xy` のいずれ
 かです。`min` または `max` を軸に追加指定すると (`xy` では使えませんが)
 それは `gnuplot` にその軸の最小値、または最大値のみを自動縮尺させるこ
 とになります。軸も何も指定されていない場合は全ての軸が対象となります。

 `fixmin` や `fixmax` や `fix` を追加指定すると、等間隔の目盛りの自動縮
 尺時の、次の目盛り位置までの範囲の自動拡大を gnuplot に行わせないよう
 にします。`set autoscale fix` はこれを全ての軸に対して設定します。コマ
 ンド `set autoscale keepfix` は、直前の `fix` の設定を維持したまま全て
 の軸を自動縮尺にします。

 自動縮尺機能を使うときは、描画範囲は自動的に割り出され、従属変数軸
 (`plot` のときは y 軸、`splot` のときは z 軸) は、関数やデータの値域が
 収まるように設定されます。

 従属変数軸 (y または z) の自動縮尺機能が指定されていない場合は、現在の
 y や z の描画範囲がそのまま使われます。

 独立変数軸 (`plot` のときは x 軸、`splot` のときは x,y 軸) の自動縮尺
 機能が指定されている場合は、描画される全てのデータファイルの点が収まる
 ように定義域をとるようになります。データファイルが 1 つも指定されてい
 ない場合は、自動縮尺機能はなんの効果もありません。つまり、関数のみが
 指定されていてデーターファイルを使わない場合は、x 軸の描画範囲
 (z = f(x,y) を描画しているときは y 軸も) は影響をうけません。

 範囲に関するより詳しい情報に関しては、以下参照: `set xrange`。

 媒介変数モード (parametric) でも自動縮尺機能は有効です (以下参照:
 `set parametric`)。この場合、より多くの従属変数があるので、x, y, z 各
 軸に関して、より多くの制御が行われます。媒介変数モードでの独立変数 (仮
 変数) は `plot` では t で `splot` では u, v です。そして媒介変数モード
 では、自動縮尺機能は (t, u, v, x, y, z) の全ての描画範囲を制御し、x,
 y, z の範囲の自動設定を完全に行います。

 自動縮尺機能は、極座標モード (polar mode) でも `plot` の媒介変数モード
 と同様に機能しますが、極座標モードでは `set dummy` で独立変数を t から
 変更するできる (以下参照: `set dummy`) という拡張があります。

 目盛りが第二の軸に表示され、しかもこれらの軸に対する描画が行われなかっ
 た場合には、x2range と y2range は xrange と yrange の値を受け継ぎます。
 これは、xrange と yrange が整数個の目盛り幅に自動縮尺される「前」に行わ
 れますので、場合によって予期しない結果をもたらす可能性があります。それ
 を避けるために `fixmin`, `fixmax` オプションを使うことができます。

 例:

 以下は y 軸の自動縮尺機能を指定します (他の軸には影響を与えません):
       set autoscale y

 以下は y 軸の最小値に対してのみ自動縮尺機能を指定します (y 軸の最大値、
 および他の軸には影響を与えません):
       set autoscale ymin

 以下は x2 軸の隣の目盛りへの自動範囲拡大機能を無効にし、よって描画デー
 タ内、または関数に対する丁度の描画範囲を維持します:
       set autoscale x2fixmin
       set autoscale x2fixmax

 以下は x, y 両軸の自動縮尺機能を指定します:
       set autoscale xy

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を指定します:
       set autoscale

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を禁止します:
       unset autoscale

 以下は z 軸のみについて自動縮尺機能を禁止します:
       unset autoscale z
4 媒介変数モード (parametric)
?commands set autoscale parametric
?set autoscale parametric
?set autoscale t
 媒介変数表示モード (`set parametric`) においては、xrange も yrange と
 同様に縮尺を変えることができます。つまり、媒介変数モードにおいては、
 x 軸方向も自動的に縮尺が調整され、描こうとしている媒介変数表示の関数が
 収まるようになります。もちろん、y 軸方向も媒介変数モードでない時同様に
 自動的に縮尺を変えます。x 軸について自動縮尺機能が設定されていない場合
 は、現在の x の範囲が使われます。

 データファイルは媒介変数モードでもそうでない状態でも同様に描画され
 ます。しかし、データファイルと関数が混在している場合には、違いがあ
 ります: 媒介変数モードでなければ、x の自動縮尺機能は、関数の範囲を
 データの描画範囲に合わせます。しかし媒介変数モードではデータの範囲
 は関数の範囲に影響しません。

 それには、片手落ちにならないように `set autoscale t` というコマンド
 も用意されています。しかしその効果は非常に小さいものです。自動縮尺
 機能が設定されていると、`gnuplot` が t の範囲が無くなってしまうと
 判断した場合に範囲を少し調整します。自動縮尺機能が設定されていないと
 このようなときにはエラーとなります。このような動作は実はあまり意味が
 なく、よって `set autoscale t` というコマンドは存在意義に疑問があり
 ます。

 `splot` では上記の発想の元に拡張されています。自動縮尺機能が設定され
 ている場合、x, y, z の各描画範囲は計算結果が収まるように設定され縮尺
 調整されます。
4 極座標モード (polar)
?commands set autoscale polar
?set autoscale polar
 極座標モード (`set polar`) では、xrange と yrange は極座標から求められ、
 それによって自動的に範囲設定がなされます。言いかえると、極座標モードでは
 描こうとしている極座標関数が収まるように x 軸、y 軸が自動的に縮尺が調整
 されます。

 極座標モードで関数を描画する場合、rrange も自動範囲設定されます。データ
 ファイルを描画する場合はさらに trange も自動範囲設定がなされます。もし、
 trange がある象限 (四分円) に収まるならば、自動縮尺機能によりその象限のみ
 の描画が行われることに注意してください。

 1 つ、あるいは 2 つの範囲は明示的に設定してその他のものを指定しない場合は
 予期しない結果を引き起こすかも知れません。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標のデモ。
^ </a>
3 bars
?commands set bars
?commands show bars
?set bars
?show bars
?bars
 コマンド `set bars` は誤差グラフ (errorbar) の両端のマークの幅、および
 描画スタイル candlesticks, financebars の箱の幅を制御します。

 書式:
       set bars {small | large | fullwidth | <size>} {front | back}
       unset bars
       show bars

 `small` は 0.0, `large` は 1.0 と同じです。サイズを指定しなければデフォ
 ルトの値は 1.0 です。

 キーワード `fullwidth` は errorbar を伴うヒストグラム (histgrams) にの
 み関連します。これは errorbar の両端の幅を、関連するヒストグラムの箱の
 幅と同じに設定しますが、箱の幅自体を変更することはありません。

 キーワード `front`, `back` は、塗り潰し長方形のついた errorbar のみに
 関連します (boxes, candlesticks, histograms)。
3 bind
?commands show bind
?show bind
=bind
 現在のホットキーの割り当て (binding) を表示します。以下参照: `bind`。
3 bmargin
?commands set bmargin
?set bmargin
?bmargin
 コマンド `set bmargin` は、下部の余白のサイズを設定します。詳細は
 以下参照: `set margin`。
3 border
?commands set border
?commands unset border
?commands show border
?set border
?unset border
?show border
?border
?noborder
 `set border` と `unset border` は `plot` や `splot` でのグラフの枠の
 表示を制御します。枠は必ずしも軸とは一致しないことに注意してください。
 `plot` では大抵一致しますが、`splot` では大抵一致していません。

 書式:
       set border {<integer>} {front | back} {linewidth | lw <line_width>}
                  {{linestyle | ls <line_style>} | {linetype | lt <line_type>}}
       unset border
       show border

 `set view 56,103` のように任意の方向で表示されうる `splot` では、 x-y
 平面上の 4 つの角は 手前 (`front`), 後ろ (`back`) , 左 (`left`), 右
 (`right`) のように呼ばれます。もちろんこの同じ 4 つの角は天井の面にも
 あります。よって、例えば x-y 平面上の後ろと右の角をつなぐ境界を
 "底の右後ろ (bottom right back)" と言い、底と天井の手前の角をつなぐ境
 界を "鉛直手前 (front vertical)" と呼ぶことにします (この命名法は、読
 者が下の表を理解するためだけに使われます)。

 枠は、12 ビットの整数に符号化されています: 下位 4 ビットは `plot` に対
 する外枠、`splot` に対しては底面の外枠、次の 4 ビットは `splot` の鉛直な
 外枠、そして上位 4 ビットは `splot` の天井面の外枠を制御します。その
 `<整数>` 値は次の表の対応する項目の数字の和になります:

@start table - first is interactive cleartext form
          ビット     plot        splot
               1      下      底の左手前
               2      左      底の左後ろ
               4      上      底の右手前
               8      右      底の右後ろ
              16    効果なし  鉛直左
              32    効果なし  鉛直後ろ
              64    効果なし  鉛直右
             128    効果なし  鉛直手前
             256    効果なし  天井の左後ろ
             512    効果なし  天井の右後ろ
            1024    効果なし  天井の左手前
            2048    効果なし  天井の右手前
#\begin{tabular}{|c|c|c|} \hline
#\multicolumn{3}{|c|}{グラフ境界の符号化} \\ \hline \hline
#ビット & plot & splot \\ \hline
#1 & 下 & 底の左手前 \\
#2 & 左 & 底の左後ろ  \\
#4 & 上 & 底の右手前  \\
#8 & 右 & 底の右後ろ  \\
#16 & 効果なし & 鉛直左  \\
#32 & 効果なし & 鉛直後ろ  \\
#64 & 効果なし & 鉛直右  \\
#128 & 効果なし & 鉛直の手前  \\
#256 & 効果なし & 天井の左後ろ \\
#512 & 効果なし & 天井の右後ろ  \\
#1024 & 効果なし & 天井の左手前  \\
#2048 & 効果なし & 天井の右手前  \\
%c c c .
%ビット @plot@splot
%_
%1@下@底の左手前
%2@左@底の左後ろ
%4@上@底の右手前
%8@右@底の右後ろ
%16@効果なし@鉛直左
%32@効果なし@鉛直後ろ
%64@効果なし@鉛直右
%128@効果なし@鉛直手前
%256@効果なし@天井の左後ろ
%512@効果なし@天井の右後ろ
%1024@効果なし@天井の左手前
%2048@効果なし@天井の右手前
@end table

 ビットは一つ一つ、あるいはいくつかをまとめて一緒にこのコマンドで付加で
 きます。

 デフォルトの値は 31 で、これは `plot` では 4 方向の外枠全て、`splot`
 では底面の枠線全部と z 軸を描くことを意味します。

 2 次元描画では境界はすべての描画要素の一番上に描かれます (`front`)。
 もし境界を描画要素の下に描かせたい場合は、`set border back` としてくだ
 さい。

 <line_style>, <line_type>, <line_width> を指定して、枠線の描画にそれ
 らを反映させることができます (現在の出力装置がサポートするものに限定
 されます)。

 `plot` では、第 2 軸を有効にすることで、下と左以外の境界に目盛りを描く
 ことができます。詳細は、以下参照: `xtics`。

 "`unset surface; set contour base`" などによって `splot` で底面にのみ
 描画する場合、鉛直線や天井はそれらが指定されていても描画されません。

 `set grid` のオプション 'back', 'front', 'layerdefault' でも、描画出力
 の境界線を書く順番を制御できます。

 例:

 以下は、デフォルトの枠線を描きます:
       set border

 以下は、`plot` では左と下、`splot` では底面の左手前と左後ろの枠線を描
 きます:
       set border 3

 以下は、`splot` で周りに完全な箱を描きます:
       set border 4095

 以下は、手前の鉛直面と天井のない箱を描きます:
       set border 127+256+512 # または set border 1023-128

 以下は、`plot` に対して上と右枠線のみを描き、それらを軸として目盛りづ
 けします:
       unset xtics; unset ytics; set x2tics; set y2tics; set border 12

3 boxwidth
?commands set boxwidth
?commands show boxwidth
?set boxwidth
?show boxwidth
?boxwidth
 コマンド `set boxwidth` は `boxes`, `boxerrorbars`, `candlesticks`,
 `histograms` スタイルにおける棒のデフォルトの幅を設定するために使いま
 す。

 書式:
       set boxwidth {<width>} {absolute|relative}
       show boxwidth

 デフォルトでは、隣り合う棒が接するように各々の棒の幅が広げられます。そ
 れとは異なるデフォルトの幅を設定するには `set boxwidth` コマンドを使用
 します。`relative` の場合の幅は、デフォルトの幅に対する比であると解釈
 されます。

 修飾子 `relative` を指定しなかった場合、棒の幅 (boxwidth) として指定さ
 れた明示的な値は、現在の x 軸の単位での数字 (`absolute`) であると解釈
 されます。x 軸が対数軸 (以下参照: `set log`) である場合、boxwidth の値
 は実際には x=1 でのみ "絶対的" となり、その物理的な長さが軸全体を通じ
 て保持されます (すなわち、棒は x 座標の増加にともなって狭くなったりは
 しません)。対数軸の x 軸の範囲が x=1 から離れている場合は、適切な幅を
 見出すには何度か試してみる必要があるかも知れません。

 デフォルトの値は、`boxes` や `boxerrorbars` スタイルの幅指定用の追加の
 データ列の明示的な値があればそれによって置き換えられます。4 列のデータ
 の場合、第 4 列目の値が棒の幅として使われます。ただし、その幅が -2.0
 の場合には棒の幅は自動計算されます。詳細は、以下参照: `style boxes`,
 `style boxerrorbars`。

 棒の幅を自動的にセットするには
       set boxwidth

 とする、あるいは 4 列のデータに対しては以下のようにします。
       set boxwidth -2

 `plot` のキーワード `using` を使っても同じ効果を得ることができます:
       plot 'file' using 1:2:3:4:(-2)

 棒の幅を自動的な値の半分にするには
       set boxwidth 0.5 relative

 棒の幅を絶対的な値 2 にするには
       set boxwidth 2 absolute
3 clabel
?commands set clabel
?commands unset clabel
?commands show clabel
?set clabel
?unset clabel
?show clabel
?clabel
 `gnuplot` は、clabel が設定されている時には、各々の等高線のレベルに対
 して使う線種を変化させます。このオプションが有効である場合 (デフォ ル
 ト)、凡例によって各々の線種を、それが表す z のレベルとともに表示されま
 す。

 書式:
       set clabel {'<format>'}
       unset clabel
       show clabel

 書式文字列のデフォルトは %8.3g で、小数部分は 3 桁表示されます。もし
 key がそのデフォルトの値から変更されていれば、その配置は不十分なもの
 になるかもしれません。

 最初の等高線の線種、または clabel が無効である場合の唯一つの等高線の
 線種は、(曲面の線種 +1) になります。等高線の点は曲面の点と同じものに
 なります。

 以下参照: `set contour`。
3 clip
?commands set clip
?commands unset clip
?commands show clip
?set clip
?unset clip
?show clip
?clip
?noclip
 `gnuplot` はグラフの端の辺りのデータ点や線をクリッピングすることができ
 ます。

 書式:
         set clip <clip-type>
         unset clip <clip-type>
         show clip

 `gnuplot` は点や線に対するクリップ型 (clip-type) として、`points`,
 `one`, `two` の 3 種類をサポートしています。ある描画に対して、これらの
 クリップ型は任意の組み合せで設定することができます。`pm3d` の色地図や
 カラー曲面で塗りつぶされた四辺形はこのコマンドでは制御できませんが、
 `set pm3d clip1in` や `set pm3d clip4in` によって可能であることに注意
 してください。

 クリップ型 `points` を設定すると、描画領域内にはあるけれど境界線に非
 常に近いような点をクリップする (実際には描画しないだけですが) ように
 `gnuplot` に指示します。これは点として大きなマークを使用したときに、
 そのマークが境界線からはみ出さないようにする効果があります。`points`
 をクリップしない場合、境界線の辺りの点が汚く見えるかもしれません。
 その場合、x や y の描画範囲 (xrange, yrange) を調整してみて下さい。

 クリップ型 `one` を設定すると、一端のみが描画領域にあるような線分も
 描画するように `gnuplot` に指示します。この際、描画領域内にある部分
 のみが実際に描画される範囲です。設定しなかった場合、このような線分は
 描画対象とならず、どの部分も描画されません。

 両端は共に描画範囲に無いが描画領域を通過するという線分もあります。
 クリップ型 `two` を設定することによって、このような線分の描画領域の
 部分を描画することができます。

 どのような状況でも、描画範囲の外に線が引かれることはありません。

 デフォルトでは、`noclip points`, `clip one`, `noclip two` となって
 います。

 全てのクリップ型の設定状況を見るには以下のようにします:
         show clip

 過去のバージョンとの互換性のため以下の書式も使用可能です:
        set clip
        unset clip

 `set clip` は `set clip points` と同義です。`unset clip` は 3 種の
 クリップ型全てを無効にします。
3 cntrparam
?commands set cntrparam
?commands show cntrparam
?set cntrparam
?show cntrparam
?cntrparam
 `set cntrparam` は等高線の生成方法、およびそれを滑らかに描画する方法を
 制御します。`show contour` は現在の `contour` の設定だけでなく `cntrparam`
 の設定をも表示します。

 書式:
       set cntrparam { { linear
                       | cubicspline
                       | bspline
                       | points <n>
                       | order <n>
                       | levels { auto {<n>} | <n>
                                  | discrete <z1> {,<z2>{,<z3>...}}
                                  | incremental <start>, <incr> {,<end>}
                                }
                       }
                     }
       show contour

 このコマンドは 2 つの機能を持っています。一つは等高線上の点 (データ点
 の線形補間、あるいは関数の標本化 (isosample) による点) での z の値の設
 定で、もう一つは、そのように決定された z が等しい点同士を等高線で結ぶ
 方法の制御です。<n> は整数型の定数式、<z1>, <z2> ... は任意の定数式で
 す。各オプション変数の意味は次の通りです:

 `linear`, `cubicspline`, `bspline` --- 近似 (補間) 方法を指定します。
 `linear` ならば、等高線は曲面から得られた値を区分的に直線で結びます。
 `cubicspline` (3 次スプライン) ならば、区分的な直線はいくぶんなめらか
 な等高線が得られるように補間されますが、多少波打つ可能性があります。
 `bspline` (B-spline) は、より滑らかな曲線を描くことが保証されますが、
 これは z の等しい点の位置を近似しているだけです。

 `points` --- 最終的には、全ての描画は、区分的な直線で行われます。ここ
 で指定する数は、`bspline` または `cubicspline` での近似に使われる線分
 の数を制御します。実際には cubicspline と bspline の区間 (曲線線分) の
 数は `points` と線分の数の積に等しくなります。

 `order` --- bspline 近似の次数です。この次数が大きくなるにつれて、等高
 線はなめらかになります (もちろん、高次の bspline 曲線になるほど、元の
 区分的直線からは離れていきます)。このオプションは `bspline` モードでの
 み有効です。指定できる値は、2 (直線) から 10 までの整数です。

 `levels` --- 等高線のレベルの数は、`auto` (デフォルト), `discrete`,
 `incremental` と等高線のレベル数 <n> で制御します。

 `auto` では、<n> は仮のレベルの数であり、実際のレベルの数は、簡単なラ
 ベルを生成するように調節されます。曲面の z 座標が zmin から zman の範
 囲にあるとき、等高線はその間の dz の整数倍になるように生成されます。こ
 こで、dz は 10 のあるべき乗の 1, 2, 5 倍、のいずれかです (2 つの目盛り
 の間を丁度割り切るように)。

 `levels discrete` では、等高線は指定された z = <z1>, <z2> ... に対して
 生成されます。指定した個数が等高線のレベルの個数となります。`discrete`
 モードでは、`set cntrparams levels <n>` という指定は常に無視されます。

 `incremental` では、等高線は z = <start> から始まり、<increment> ずつ
 増えて行き限界の個数に達するまで書かれます。<end> はその等高線の数を決
 定するのに使われますが、これは後の `set cntrparam levels <n>` によって
 常に変更されます。z 軸が対数軸の場合、`set ztics` の場合と同様に、
 <increment> は積因子として解釈されます。

 コマンド `set cntrparam` が引数なしに呼ばれた場合は、次のデフォルトの
 値が使われます: linear, 5 points, order 4, 5 auto levels

 例:
       set cntrparam bspline
       set cntrparam points 7
       set cntrparam order 10

 以下はレベルの基準が合えば 5 個のレベルがに自動的に選択されます:
       set cntrparam levels auto 5

 以下は .1, .37, .9 にレベルを設定します:
       set cntrparam levels discrete .1,1/exp(1),.9

 以下は 0 から 4 まで、1 ずつ増やすレベルを設定します:
       set cntrparam levels incremental  0,1,4

 以下はレベルの数を 10 に設定します (増加の最後の値 (end) または自動で
 設定されるレベルの数は変更されます):
       set cntrparam levels 10

 以下はレベルの数は保持したままレベルの開始値と増分値を設定します:
       set cntrparam levels incremental 100,50

 等高線を描く場所の制御に関しては、以下参照: `set contour`。等高線のラ
 ベルの書式と線種の制御に関しては、以下参照: `set clabel`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
3 カラーボックス (colorbox)
?commands set colorbox
?commands show colorbox
?commands unset colorbox
?set colorbox
?show colorbox
?unset colorbox
?colorbox

 色の一覧表、すなわち `pm3d` の `palette` の min_z から max_z までの滑
 らかな色の勾配は、`unset colorbox` が使われていない限りカラーボックス
 (colorbox) に描かれます。

       set colorbox
       set colorbox {
                  { vertical | horizontal }
                  { default | user }
                  { origin x, y }
                  { size x, y }
                  { front | back }
                  { noborder | bdefault | border [line style] }
                }
       show colorbox
       unset colorbox

 カラーボックスの位置は、`default` または `user` で指定でき、後者の場合
 その位置や大きさを `origin` や `size` コマンドで設定します。カラーボッ
 クスは、グラフや曲面の後 (`front`) あるいは先 (`back`) に描画させるこ
 ともできます。

 色勾配の方向は、オプション `vertical` と `horizontal` で切替えることが
 可能です。

 `origin x, y` と `size x, y` は `user` オプションとの組でのみ使用され
 ます。x, y の値は、デフォルトではスクリーン座標と解釈されますが、これ
 は 3 次元描画用のかしこまったオプションに過ぎません。`set view map` に
 よる splot を含む 2 次元描画では、任意の座標系での指定が可能です。例え
 ば以下を試してみてください:
     set colorbox horiz user origin .1,.02 size .8,.04
 これは水平方向の色勾配をグラフの下の辺りに描画します。

 `border` は境界描画を ON にします (デフォルト) し、`noborder` は境界描
 画を OFF にします。`border` の後ろに正の整数を与えると、それを境界を描
 画する時の line style のタグとして使います。例えば:
     set style line 2604 linetype -1 linewidth .4
     set colorbox border 2604
 は line style `2604`、すなわち細い線のデフォルトの境界色 (-1) で境界を
 描画します。`bdefault` (デフォルト) は、カラーボックスの境界の描画にデ
 フォルトの境界の line style を使います。

 カラーボックスの軸は `cb` と呼ばれ、通常の軸のコマンドで制御されます。
 すなわち `set/unset/show` で `cbrange`, `[m]cbtics`, `format cb`,
 `grid [m]cb`, `cblabel` などが、そして多分 `cbdata`, `[no]cbdtics`,
 `[no]cbmtics` なども使えるでしょう。

 パラメータ無しの `set colorbox` はデフォルトの位置へ切替えます。
 `unset colorbox` はカラーボックスのパラメータをデフォルト値にリセット
 し、その上でカラーボックスを OFF にします。

 以下も参照: `set pm3d`, `set palette`, `x11 pm3d`, `set style line`。
3 色名 (colornames)
?colornames
?show colornames
?commands show colornames
?show palette colornames
 gnuplot は限定された個数の色の名前を持っています。これらは、pm3d パレ
 ットでつながれる色の範囲を定義するのに、あるいは個々の線種やラインスタ
 イルの色を出力形式に依存しない形で定義したりするのに使えます。gnuplot
 の持つ色名の一覧を見るには、コマンド `show colornames` を使用してくだ
 さい。例:

       set style line 1 linecolor rgb "sea-green"
3 等高線 (contour)
?commands set contour
?commands unset contour
?commands show contour
?set contour
?unset contour
?show contour
?contour
?nocontour
 コマンド `set contour` は曲面の等高線を引くことを指示します。このオプ
 ションは `splot` でのみ有効です。これは、格子状データ (grid data) を必
 要とします。詳細は、以下参照: `grid_data`。非格子状データで等高線を描
 きたい場合は、格子を生成するために `set dgrid3d` を使用します。

 書式:
       set contour {base | surface | both}
       unset contour
       show contour

 これらの 3 つのオプションは等高線をどこに引くかを指定します。`base` で
 は等高線を x/y 軸の刻みのある底面に描かれ、`surface` では等高線はその
 曲面自体の上に描かれ、`both` では底面と曲面上の両方に描かれます。オプ
 ションが指定されていない場合は `base` であると仮定されます。

 等高線の描画に影響を与えるパラメータについては、以下参照:
 `set cntrparam`。等高線のラベルの制御に関しては、以下参照:
 `set clabel`。

 等高線のみのグラフが得るために、曲面自身の描画をしないようにすることも
 できます (以下参照: `set surface`)。`set size` を使って、グラフを画面
 一杯に描画することも可能ですが、そういった出力形式よりも、等高線のデー
 タをファイルに書き出し、それを再び 2 次元データとして読み込んで描画す
 ればよりよい制御が可能になります:

       unset surface
       set contour
       set cntrparam ...
       set table 'filename'
       splot ...
       unset table
       # contour info now in filename
       set term <whatever>
       plot 'filename'

 等高線を描くためには、データは格子状データ ("grid data") である必要が
 あります。そのようなファイルでは、一つの y-孤立線上の全ての点が順に
 並べられていきます。そして隣の y-孤立線上の点が順に並べられ、そして隣、
 と続いていきます。y-孤立線同士を分離するには一行の空行 (空白、復帰、改
 行以外の文字を含まない行) を挟みます。以下参照: `splot datafile`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
3 data style
?set data style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style data`。
3 datafile
?set datafile
?show datafile
 コマンド `set datafile` は、`plot`, `splot`, `fit` コマンドで入力デー
 タを読む場合に、その列 (field) の解釈の仕方を制御するオプションを持ち
 ます。現在は、6 つのそのようなオプションが実装されています。
4 set datafile fortran
?set datafile fortran
?show datafile fortran
?fortran
 コマンド `set datafile fortran` は、入力ファイルの Fortran D 型、Q 型
 の定数値の特別なチェックを可能にします。この特別なチェックは入力処理を
 遅くしますので、実際にそのデータファイルが Fortran D 型、Q 型の定数を
 持っている場合にのみこれを選択すべきです。このオプションは、その後で
 `unset datafile fortran` を行えば無効にできます。
4 set datafile nofpe_trap
?set datafile nofpe_trap
?fpe_trap
?nofpe_trap
=floating point exceptions
 コマンド `set datafile nofpe_trap` は、入力ファイルからデータの読み込
 みの際に、すべての数式の評価の前に浮動小数点例外ハンドラの再初期化をし
 ないように gnuplot に命令します。これにより、大きなファイルからのデー
 タの入力がかなり速くなりますが、浮動小数点例外が起きた場合にプログラム
 が異常終了してしまう危険はあります。
4 set datafile missing
?set datafile missing
?show datafile missing
?set missing
?missing
 コマンド `set datafile missing` は `gnuplot` に、どのような文字列がデ
 ータファイル中の欠けたデータ (missing data) を意味するのかを指示します。
 実際にその文字列がどのように取り扱われるかは、`plot` や `splot` コマン
 ドの `using` 指定子にも依存します。

 書式:
       set datafile missing {"<string>"}
       show datafile missing
       unset datafile

 例:
       # IEEE NaN ("Not a Number") コードを含むエントリを無視する
       set datafile missing "NaN"

 例:
       set datafile missing "?"
       set style data lines
       plot '-'
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:2
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:($2)
          1 10
          2 20
          3 ?
          4 40
          5 50
          e

 最初の `plot` は、"3 ?" の行では最初のデータのみを認識し、そこでは 1
 行に 1 つしかデータがなかった場合の規則が適用され、行番号が "x" でデー
 タが "y" と見なされ、その点は (2,3) に (この場合は誤って) 描画されます。

 2 番目の `plot` は、真中の行を正しく無視します。描画される曲線は、
 (2,20) と (4,40) が結ばれます。

 3 番目の `plot` も真中の行を正しく無視しますが、この場合は  (2,20) と
 (4,40) は結ばれません。

 デフォルトの `missing` 用の文字は何も定義されていませんが、多くの場合
 数値が期待されるべき所にそれと認識できない文字が見つかったらそれは欠け
 たデータ (missing data) であると見なされます。

4 set datafile separator
?set datafile separator
?show datafile separator
?datafile separator
?separator
 コマンド `set datafile separator "<char>"` は、`gnuplot` に、この後の
 入力ファイルのデータ列の分離文字が、空白 (whitespace) でなくて <char>
 であると指示します。このコマンドの最も一般的な使用例は、表計算ソフトや
 データベースソフトによって作られた csv (コンマ区切り) ファイルを読む時
 でしょう。デフォルトのデータ列の分離文字は空白 (whitespace) です。

 書式:
       set datafile separator {"<char>" | whitespace}

 例:
       # タブ区切りのファイルを入力
       set datafile separator "\t"

       # コンマ区切りのファイルを入力
       set datafile separator ","
4 set datafile commentschars
?set datafile commentschars
?commentschars
 コマンド `set datafile commentschars` は `gnuplot` に、どの文字がデー
 タファイル中のコメントを意味するのかを指示します。gnuplot は、指定され
 た文字の中の一つがデータ行の最初の非空白文字として現われた場合、その文
 字以下を無視します。

 書式:
       set datafile commentschars {"<string>"}
       show datafile commentschars
       unset commentschars

 デフォルトの string は、VMS では "#!" で、それ以外では "#" です。

 よって、データファイルの以下の行は完全に無視されます
     # 1 2 3 4
 が、以下の行
     1 # 3 4
 は、もし
     set datafile missing '#'
 が指定されていなければ、予期せぬ結果を生じます。

 例:
       set datafile commentschars "#!%"
4 set datafile binary
?set datafile binary
 コマンド `set datafile binary` は、データファイルの読み込み時にバイナ
 リファイルをデフォルトと設定するのに使われます。書式は、それが `plot`
 または `splot` コマンドで使われるのと正確に同じです。<binary list>
 に関しては、詳しくは、以下参照: `binary`。

 書式:
       set datafile binary <binary list>
       show datafile binary
       show datafile
       unset datafile

 例:
       set datafile binary filetype=auto
       set datafile binary array=(512,512) format="%uchar"

?show datafile binary
       show datafile binary   # 現在の設定の一覧表示
3 decimalsign
?commands set decimalsign
?commands show decimalsign
?commands unset decimalsign
?set decimalsign
?show decimalsign
?unset decimalsign
?decimalsign
=locale
 コマンド `set decimalsign` は、目盛りの見出し、あるいは `set label` 文
 字列に書かれる数の小数点記号を選択します。

 書式:
       set decimalsign {<value> | locale {"<locale>"}}
       unset decimalsign
       show decimalsign

 引数 <value> は、通常の小数点記号に置き換えて使う文字列です。典型的な
 ものはピリオド '.' やコンマ ',' ですが他にも有用なものがあるでしょう。
 引数 <value> を省略すると、小数点の区切りはデフォルト (ピリオド) から
 変更されません。unset decimalsign も <value> を省略するのと同じ効果を
 持ちます。

 例:

 多くのヨーロッパ諸国での正しい出力形式を得るには:
       set decimalsign ','

 次のことに注意してください: 明示的な文字列を設定した場合、これは軸の目
 盛りなどの gnuplot の gprintf() 書式関数で出力される数値のみに影響し、
 入力データの書式指定や sprintf() 書式関数で出力される数値には影響しま
 せん。それらの入力や出力の形式の挙動も変更したい場合は、代わりに以下を
 使用してください:

       set decimalsign locale

 これは、gnuplot に、入力と出力の書式を、環境変数 LC_ALL, LC_NUMERIC,
 LANG の現在の設定に従ったものを使わせるようにします。

       set decimalsign locale "foo"

 これは、gnuplot に、入力と出力の書式を、ロケール "foo" に従ったものに
 しますが、そのロケールがインストールされている必要があります。もしロケ
 ール "foo" が見つからなかった場合、エラーメッセージが出力され、小数点
 の設定は変更されません。linux システム上では、そこにインストールされて
 いるロケールの一覧は "locale -a" で見ることができます。linux のロケー
 ル文字列はだいたい "sl_SI.UTF-8" のような形式をしていますが、Windows
 のロケール文字列は "Slovenian_Slovenia.1250"、または "slovenian" のよ
 うな形式です。ロケール文字列の解釈は、C のランタイムライブラリが行うこ
 とに注意してください。古い C ライブラリでは、ロケール設定のサポート
 (例えば数字の 3 桁毎の区切り文字など) を部分的にしか提供していないかも
 しれません。

       set decimalsign locale; set decimalsign "."

 これは、現在のロケールに合ったどんな小数点でも、全ての入出力に対して使
 用するように設定しますが、gnuplot の内部関数 gprintf() を使って書式化
 する数値は明示的に指定された '.' になります (上書き)。
3 dgrid3d
?commands set dgrid3d
?commands unset dgrid3d
?commands show dgrid3d
?set dgrid3d
?unset dgrid3d
?show dgrid3d
?dgrid3d
?nodgrid3d
 コマンド `set dgrid3d` は、非格子状データから格子状データへの写像機能を
 有効にし、そのためのパラメータを設定します。格子状データの構造について
 の詳細は、以下参照: `splot grid_data`。

 書式:
       set dgrid3d {<rows>} {,{<cols>}}
                   { splines |
                     qnorm {<norm>} |
                     gauss | cauchy | exp | box | hann {<dx>} {,{dy}} }
       unset dgrid3d
       show dgrid3d

 デフォルトでは `dgrid3d` は無効になっています。有効になると、ファイル
 から読み込まれる 3 次元のデータは「散在した」データ (非格子状データ)
 であると見なされます。格子は、グラフと等高線の描画のために、散在したデ
 ータを囲む矩形から得られる寸法と、row_size/col_size で指定される数の行
 と列を持つように生成されます。格子は x 方向 (行) と y 方向 (列) に等間
 隔です。z の値は散在するデータの z の値の重み付きの平均、またはスプラ
 イン補間として計算されます。言い変えれば、規則的な間隔の格子が生成され、
 全ての格子点で元のデータの滑かな近似値が評価されます。元のデータではな
 く、この近似値のみが描画されます。

 デフォルトの列の数は行の数に等しく、そのデフォルトの値は 10 です。

 元のデータから近似値を計算するためのいくつかのアルゴリズムが用意されて
 いて、追加のパラメータを指定できるものもあります。これらの補間は、格子
 点に近いデータ点ほど、その格子点に対してより強い影響を与えます。

 `splines` アルゴリズムは、"薄いつぎ板" を元にした補間計算を行います。
 これは追加パラメータを取りません。

 `qnorm` アルゴリズムは各格子点で入力データの重み付き平均を計算します。
 各点は格子点からの距離の norm 乗の逆数で重み付けされます。(実際には、
 dx, dy を各データ点と格子点との差の成分であるとすると、重みは dx^norm
 + dy^norm で与えられます。2 のべきのノルム、特に 4, 8, 16 に関しては、
 その重みの計算はユークリッド距離を使うことで (dx^2+dy^2)^norm/2 のよう
 に最適化されてますが、任意の負でない整数を使うことも可能です。) ノルム
 のべきの値をただ一つの追加パラメータとして指定できます。このアルゴリズ
 ムがデフォルトになっています。

 最後に、重み付き平均の計算用に、いくつかの平滑化重み付け関数 (kernel)
 が用意されています: z = Sum_i w(d_i) * z_i / Sum_i w(d_i), ここで z_i
 は i 番目のデータの値で、d_i は現在の格子点と i 番目のデータ点の位置と
 の距離です。すべての重み付け関数が、現在の格子点に近い方のデータ点には
 大きな重み、遠い方のデータ点には小さい重みを付けます。

 以下の重み付け関数が使用できます:
       gauss :     w(d) = exp(-d*d)
       cauchy :    w(d) = 1/(1 + d*d)
       exp :       w(d) = exp(-d)
       box :       w(d) = 1                     d<1 の場合
                        = 0                     その他
       hann :      w(d) = 0.5*(1-cos(2*pi*d))   d<1 の場合
                   w(d) = 0                     その他

 これら 5 つの平滑化重み付け関数のうち一つを使用する場合、2 つまでの追
 加パラメータ dx と dy を指定できます。これらは、距離の計算時に座標の違
 いをスケール変換するのに使えます:
 d_i = sqrt( ((x-x_i)/dx)**2 + ((y-y_i)/dy)**2 ), ここで、x,y は現在の
 格子点の座標で、x_i,y_i は i 番目のデータ点の座標です。dy のデフォルト
 の値は dx で、そのデフォルトの値は 1 になっています。パラメータ dx と
 dy は、データ点が格子点へ「データそれ自身の単位で」の寄与を行う範囲の
 制御を可能にします。

 後方互換性のために、わずかに異なる書式もサポートされています。どのアル
 ゴリズムも明示的に選択しなかった場合、`qnorm` アルゴリズムが仮定され、
 3 つ以下の、コンマ (,) 区切りのオプションパラメータを指定した場合は、
 それらをそれぞれ行数、列数、そして norm 値であると解釈します。

 オプション `dgrid3d` は、散在するデータを重み付き平均で規則的な格子に
 置き変える単純な仕組みに過ぎません。この問題に対するより洗練された手法
 が存在しますので、この単純な方法が不十分であれば、`gnuplot` の外でその
 ような方法でデータを前処理するべきでしょう。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/dgrid3d.html">
 dgrid3d.dem: dgrid3d のデモ
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/scatter.html">
 scatter.dem: dgrid3d のデモ
^ </a>

3 dummy
?commands set dummy
?commands show dummy
?set dummy
?show dummy
?dummy
 コマンド `set dummy` はデフォルトの仮変数名を変更します。

 書式:
       set dummy {<dummy-var>} {,<dummy-var>}
       show dummy

 デフォルトでは、`gnuplot` は `plot` では、媒介変数モード、あるいは極座
 標モードでは "t", そうでなければ "x" を独立変数 (仮変数) とし、同様に
 `splot` では、媒介変数モードでは (`splot` は極座標モードでは使えません)
 "u" と "v", そうでなければ "x" と "y" を独立変数とします。

 仮変数は、物理的に意味のある名前、あるいはより便利な名前として使う方が
 便利でしょう。例えば、時間の関数を描画する場合:

       set dummy t
       plot sin(t), cos(t)

 このコマンドでは、少なくとも一つの仮変数が設定される必要があります。
 `set dummy` だけだとエラーメッセージが表示されます。

 例:
       set dummy u,v
       set dummy ,s

 第二の例は、2 番目の変数を s とします。
3 encoding
?commands set encoding
?commands show encoding
?set encoding
?show encoding
?encoding
?encodings
=UTF-8
 コマンド `set encoding` は文字のエンコード (encoding) を選択します。
 書式:
       set encoding {<value>}
       set encoding locale
       show encoding

 有効な値 (value) は以下の通りです。
    default     - 出力形式にデフォルトのエンコードの使用を命令
    iso_8859_1  - 多くの Unix ワークステーションや MS-Windows で使用可
                  能な最も一般的な西ヨーロッパエンコード。このエンコー
                  ドは PostScript の世界で 'ISO-Latin1' として知られて
                  いるものです。
    iso_8859_15 - ユーロ記号を含む iso_8859_1 の亜種
    iso_8859_2  - 中央/東ヨーロッパで使用されるエンコード
    iso_8859_9  - (Latin5 として知られる) トルコで使用されるエンコード
    koi8r       - 良く使われる Unix のキリル文字エンコード
    koi8u       - Unix のウクライナ地方のキリル文字エンコード
    cp437       - MS-DOS のコードページ
    cp850       - 西ヨーロッパの OS/2 のコードページ
    cp852       - 中央/東ヨーロッパの OS/2 のコードページ
    cp1250      - 中央/東ヨーロッパの MS Windows のコードページ
    cp1254      - トルコの MS Windows のコードページ (Latin5 の拡張)
    utf8        - 各文字の Unicode エントリポイントの、可変長 (マルチバ
                  イト) 表現

 コマンド `set encoding locale` は、他のオプションとは違い、これは現在
 のロカールを実行時の環境から決定しようとします。たいていのシステムでは
 これは環境変数 LC_ALL, LC_CTYPE, LANG のいずれかによって制御されます。
 この仕組みは、例えば wxt, cairopdf 出力形式で、UTF-8 や EUC-JP のよう
 なマルチバイト文字エンコードを通すために必要です。このコマンドは日付や
 数字などのロカール特有の表現には影響を与えません。
 以下も参照: `set locale`, `set decimalsign`。

 一般に、エンコードの設定は出力形式の設定の前に行なう必要があります。こ
 のエンコードはどんな出力形式でもサポートされているとは限らず、そして出
 力形式は要求されたどんな非標準文字も生成できなければいけません。
3 fit
?commands set fit
?commands show fit
?set fit
?show fit
 `fit` の設定は、コマンド `fit` がその出力を行うファイルを定義します。
 使用している gnuplot が使えるように作られていれば、このコマンドは当て
 はめのパラメータ誤差を変数に書き出すかどうかも制御できます。

 書式:
       set fit {logfile {"<filename>"}} {{no}errorvariables}
       unset fit
       show fit

 引数 <filename> は、単一引用符か二重引用符で囲む必要があります。

 ファイル名を指定しなかった場合、または `unset fit` を使用した場合は、
 ログファイルはデフォルトの値である "fit.log"、または環境変数 `FIT_LOG`
 の値にリセットされます。

 与えられたログファイル名が / か \ で終っている場合、それはディレクトリ
 名と解釈され、ログファイルはそのディレクトリの "fit.log" となります。

 オプション `errorvariables` が ON にされると、`fit` コマンドで計算され
 たここの当てはめパラメータの誤差が、そのパラメータの名前に "_err" をつ
 けた名前のユーザ定義変数にコピーされます。これは主に、当てはめ関数とデ
 ータの描画グラフの上にパラメータとその誤差を参照用に出力するのに使われ
 ます。例えば:

        set fit errorvariables
        fit f(x) 'datafile' using 1:2 via a, b
        print "error of a is:", a_err
        set label 'a=%6.2f', a, '+/- %6.2f', a_err
        plot 'datafile' using 1:2, f(x)
3 fontpath
?commands set fontpath
?commands show fontpath
?set fontpath
?show fontpath
?fontpath
 `fontpath` の設定は、フォントファイルを読み込む場合のファイルの検索パ
 スを追加定義します。今のところ、postscript 出力形式のみが `fontpath`
 をサポートしています。ファイルが現在のディレクトリに見つからなかった場
 合、`fontpath` のディレクトリが検索されます。サポートしているフォント
 ファイルの形式に関するより詳しい説明は `terminal postscript` セクショ
 ンの文書中にあります。

 書式:
       set fontpath {"pathlist1" {"pathlist2"...}}
       show fontpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), DOS//Windows/OS/2/Amiga ではセミコロン (';') 等で区切
 ります。`show fontpath`, `save`, `save set` コマンドは、可搬性のために
 OS 固有のパス区切りをスペース (' ') で置き換えます。ディレクトリ名がエ
 クスクラメーションマーク ('!') で終っている場合、そのディレクトリのサ
 ブディレクトリも検索されます。

 環境変数 GNUPLOT_FONTPATH が設定されている場合、その内容は `fontpath`
 に追加されますが、それが設定されていない場合システムに依存したデフォル
 トの値が使用されます。最初にフォントパスを使ったときに、その幾つかのデ
 ィレクトリが存在するかテストされ、セットされます。よって、一番最初の
 `set fontpath`, `show fontpath`, `save fontpath` や、埋め込みフォント
 を使用した場合の `plot`, `splot` は、少し時間がかかります。それを少し
 でも短くしたければ、環境変数 GNUPLOT_FONTPATH を設定してください。そう
 すればディレクトリのチェックは OFF になります。デフォルトのフォントパ
 スが何であるかは、`show fontpath` で見ることができます。

 しかし、`show fontpath` は、ユーザ定義の fontpath と環境変数によるシス
 テム fontpath を別々に表示しますし、`save`, `save set` コマンドは、可
 搬性の目的のためにユーザ定義の `fontpath` のみを保存します。

 gd ライブラリを通じて TrueType フォントにアクセスできる出力ドライバも
 たくさんあります。これらのドライバに対するフォントの検索パスは、環境変
 数 GDFONTPATH で制御されます。
3 format
?commands set format
?commands show format
?set format
?show format
?format
?format cb
 座標軸の刻みの見出しは、コマンド `set format` または `set tics format`
 または個別にコマンド `set {軸}tics format` で書式を設定できます。

 書式:
       set format {<axes>} {"<format-string>"}
       set format {<axes>} {'<format-string>'}
       show format

 ここで、<axes> (軸) は `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb`、または何
 も指定しないか (その場合その書式はすべての軸に適用されます) のいずれか
 です。以下の 2 つのコマンドは全く同等です:
       set format y "%.2f"
       set ytics format "%.2f"

 書式文字列の長さは 100 文字まで、と制限されています。デフォルトの書式
 文字列は "% g" ですが、、"%.2f" や "%3.0em" などの書式が好まれることも
 多いでしょう。。LaTeX 用にはよく "$%g$" が好まれます。書式文字列を何も
 与えない場合は、format はデフォルトに戻ります。空文字列 "" を指定した
 場合、刻み自身は表示されますが見出しはつきません。刻み自身を消すには、
 `unset xtics` または `set tics scale 0` を使用してください。

 書式文字列では、改行文字 (\n) や拡張文字列処理 (enhanced text) 用のマ
 ークアップも使えます。 この場合は、単一引用符 (') でなく (") を使って
 ください。以下も参照: `syntax`。
 "%" が頭につかない文字はそのまま表示されます。よって、書式文字列内に
 スペースや文字列などを入れることができます。例えば "%g m" とすれば、
 数値の後に " m" が表示されます。"%" 自身を表示する場合には "%g %%" の
 ように 2 つ重ねます。

 刻みに関するより詳しい情報については、以下も参照: `set xtics`。また、
 この方法で出力される数字にデフォルト以外の小数分離文字を使うやり方につ
 いては、以下参照: `set decimalsign`。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/electron.html">
 エレクトロン (電子) デモ (electron.dem).
^ </a>
4 gprintf
?gprintf
 文字列関数 gprintf("format",x) は、gnuplot コマンドの `set format`,
 `set timestamp` などと同様の、gnuplot 独自の書式指定子を使います。これ
 らの書式指定子は、標準的な C 言語の関数である sprintf() のものと全く同
 じではありません。gprintf() は、整形化される引数は一つしか受けつけませ
 ん。そのために、gnuplot には sprintf("format",x1,x2,...) 関数も用意さ
 れています。gnuplot の書式オプションの一覧については、以下参照:
 `format specifiers`。
4 書式指定子 (format specifiers)
?commands set format specifiers
?set format specifiers
?format specifiers
?format_specifiers
 使用可能な書式 (時間/日付モードでない場合) は以下の通りです:

@start table - first is interactive cleartext form
       書式       説明
       %f         固定小数点表記
       %e, %E     指数表記; 指数の前に "e", "E" をつける
       %g, %G     %e (または %E) と %f の略記
       %x, %X     16 進表記
       %o, %O     8 進表記
       %t         10 進の仮数部
       %l         現在の対数尺の底を基数とする仮数部
       %s         現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
       %T         10 進の指数部
       %L         現在の対数尺の底を基数とする指数部
       %S         補助単位の指数部 (scientific power)
       %c         補助単位文字
       %P         πの倍数
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{目盛りラベルの数値書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%f@ & 固定小数点表記 \\
#\verb@%e@, \verb@%E@ & 指数表記; 指数の前に "e", "E" をつける \\
#\verb@%g@, \verb@%G@ & \verb@%e@ (または \verb@%E@) と \verb@%f@ の略記 \\
#\verb@%x@, \verb@%X@ & 16 進表記 \\
#\verb@%o@, \verb@%O@ & 8 進表記 \\
#\verb@%t@ & 10 進の仮数部 \\
#\verb@%l@ & 現在の対数尺の底を基数とする仮数部 \\
#\verb@%s@ & 現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power) \\
#\verb@%T@ & 10 進の指数部 \\
#\verb@%L@ & 現在の対数尺の底を基数とする指数部 \\
#\verb@%S@ & 補助単位の指数部 (scientific power) \\
#\verb@%c@ & 補助単位文字 \\
#\verb@%P@ & πの倍数 \\
%c l .
%書式@説明
%_
%%f@固定小数点表記
%%e, %E@指数表記; 指数の前に "e", "E" をつける
%%g, %G@%e (または %E) と %f の略記
%%x, %X@16 進表記
%%o, %O@8 進表記
%%t@10 進の仮数部
%%l@現在の対数尺の底を基数とする仮数部
%%s@現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
%%T@10 進の指数部
%%L@現在の対数尺の底を基数とする指数部
%%S@補助単位の指数部 (scientific power)
%%c@補助単位文字
%%P@πの倍数
%_
@end table

 補助単位 ('scientific' power) は、指数が 3 の倍数であるようなものです。
 補助単位指数 (`"%c"`) の文字への変換は -18 から +18 までの指数に対して
 サポートされています。この範囲外の指数の場合、書式は通常の指数形式に
 戻ります。

 ほかに使うことのできる修飾詞 ("%" と書式指定子の間に書くもの) には、
 次のいくつかがあります: "-" は数字を左詰めにし、"+" は正の数にも符号を
 つけ、" " (空白一つ) は負の数に "-" をつけるべき場所に正の数の場合に空
 白を一つつけ、"#" は小数点以下の数字が 0 だけであっても小数点をつけ、
 正の整数は出力幅を定め、出力幅指定の直前の "0" (文字でなく数字) は先頭
 に空いた部分を空白で埋める代わりに 0 で埋め、小数点の後に非負の整数を
 書いたものは精度を意味します (整数の場合は最小桁、小数の場合は小数点以
 下の桁数)。

 これらの全ての修飾詞をサポートしていない OS もあるでしょうし、逆にこれ
 以外のものをもサポートする OS もあるでしょう。疑わしい場合は、適切な資
 料を調べ、そして実験してみてください。

 例:
       set format y "%t"; set ytics (5,10)          # "5.0" と "1.0"
       set format y "%s"; set ytics (500,1000)      # "500" と "1.0"
       set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
       set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
       set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
       set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
       set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
       set format y "%.0f%%"; set ytic(50)          # "50%"

       set log y 2; set format y '%l'; set ytics (1,2,3)
       #"1.0", "1.0", "1.5" と表示される (3 は 1.5 * 2^1 なので)

 丸めと指数が必要となるような書式で 9.999 の様な数字が書かれる場合は
 問題が起こることがあります。

 軸のデータ型が日時データ (time/date) の場合、書式文字列は 'strftime'
 関数 ('gnuplot' 外。"man strftime" としてみてください) に関する有効な
 指定を行う必要があります。使える入力書式指定の一覧に関しては、以下参照:
 `set timefmt`。
4 日時データ指定子 (time/date specifiers)
?commands set format date_specifiers
?commands set format time_specifiers
?set format date_specifiers
?set format time_specifiers
?set date_specifiers
?set time_specifiers
?date_specifiers
?time_specifiers
 日時データモード (time/date mode) では、次の書式が使用できます:

@start table - first is interactive cleartext form
       書式         説明
       %a           曜日名の省略形 (Sun,Mon,...)
       %A           曜日名 (Sunday,Monday,...)
       %b, %h       月名の省略形 (Jan,Feb,...)
       %B           月名 (January,February,...)
       %d           日 (01--31)
       %D           "%m/%d/%y" の簡略形 (出力のみ)
       %F           "%Y-%m-%d" の簡略形 (出力のみ)
       %k           時 (0--23; 1 桁または 2 桁)
       %H           時 (00--23; 常に 2 桁)
       %l           時 (1--12; 1 桁または 2 桁)
       %I           時 (01--12; 常に 2 桁)
       %j           その年の通算日 (1--366)
       %m           月 (01--12)
       %M           分 (0--60)
       %p           "am" または "pm"
       %r           "%I:%M:%S %p" の簡略形 (出力のみ)
       %R           "%H:%M" の簡略形 (出力のみ)
       %S           秒 (0--60)
       %T           "%H:%M:%S" の簡略形 (出力のみ)
       %U           その年の通算週 (週は日曜日からと数える)
       %w           曜日番号 (0--6, 日曜 = 0)
       %W           その年の通算週 (週は月曜日からと数える)
       %y           西暦 (0-99)
       %Y           西暦 (4 桁)
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{目盛りラベルの日時書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%a@ & 曜日名の省略形 (Sun,Mon,...) \\
#\verb@%A@ & 曜日名 (Sunday,Monday,...) \\
#\verb@%b@, \verb@%h@ & 月名の省略形 (Jan,Feb,...) \\
#\verb@%B@ & 月名 (January,February,...) \\
#\verb@%d@ & 日 (01--31) \\
#\verb@%D@ & \verb@"%m/%d/%y"@ の簡略形 (出力のみ)\\
#\verb@%F@ & \verb@"%Y-%m-%d"@ の簡略形 (出力のみ)\\
#\verb@%k@ & 時 (0--23; 1 桁または 2 桁) \\
#\verb@%H@ & 時 (00--23; 常に 2 桁) \\
#\verb@%l@ & 時 (1--12; 1 桁または 2 桁) \\
#\verb@%I@ & 時 (01--12; 常に 2 桁) \\
#\verb@%j@ & その年の通算日 (1--366) \\
#\verb@%m@ & 月 (01--12) \\
#\verb@%M@ & 分 (0--60) \\
#\verb@%p@ & "am" または "pm" \\
#\verb@%r@ & \verb@"%I:%M:%S %p"@ の簡略形 (出力のみ)\\
#\verb@%R@ & \verb@"%H:%M"@ の簡略形 (出力のみ)\\
#\verb@%S@ & 秒 (0--60) \\
#\verb@%T@ & \verb@"%H:%M:%S"@ の簡略形 (出力のみ)\\
#\verb@%U@ & その年の通算週 (週は日曜日からと数える) \\
#\verb@%w@ & 曜日番号 (0--6, 日曜 = 0) \\
#\verb@%W@ & その年の通算週 (週は月曜日からと数える) \\
#\verb@%y@ & 西暦 (0-99) \\
#\verb@%Y@ & 西暦 (4 桁) \\
%c l .
%書式@説明
%_
%%a@曜日名の省略形 (Sun,Mon,...)
%%A@曜日名 (Sunday,Monday,...)
%%b, %h@月名の省略形 (Jan,Feb,...)
%%B@月名 (January,February,...)
%%d@日 (01--31)
%%D@"%m/%d/%y" の簡略形 (出力のみ)
%%F@"%Y-%m-%d" の簡略形 (出力のみ)
%%k@時 (0--23; 1 桁または 2 桁)
%%H@時 (00--23; 常に 2 桁)
%%l@時 (1--12; 1 桁または 2 桁)
%%I@時 (01--12; 常に 2 桁)
%%j@その年の通算日 (1--366)
%%m@月 (01--12)
%%M@分 (0--60)
%%p@"am" または "pm"
%%r@"%I:%M:%S %p" の簡略形 (出力のみ)
%%R@"%H:%M" の簡略形 (出力のみ)
%%S@秒 (0--60)
%%T@"%H:%M:%S" の簡略形 (出力のみ)
%%U@その年の通算週 (週は日曜日からと数える)
%%w@曜日番号 (0--6, 日曜 = 0)
%%W@その年の通算週 (週は月曜日からと数える)
%%y@西暦 (0-99)
%%Y@西暦 (4 桁)
%_
@end table

 数字を表す書式では、これらの指定子 (% の後ろ、指定子の前) に "0" ("オー"
 でなく "ゼロ") をつけることで、先頭に空白ができる場合に空白の代わりに 0
 で埋めることができ、また最小の出力幅を正の整数で指定することもできます
 (出力される数字を表示するのに指定した幅が足りない場合は無視されます)。
 表示する文字の長さは 24 文字まで、という制限があり、長すぎた部分は切り
 捨てられます。

 例:

 日時のデータが "76/12/25 23:11:11" の場合
       set format x                 # デフォルトでは "12/25/76" \n "23:11"
       set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
       set format x "%r %D"         # "11:11:11 pm 12/25/76"

 日時のデータが "98/07/06 05:04:03" の場合
       set format x "%1y/%2m/%3d %01H:%02M:%03S"  # "98/ 7/  6 5:04:003"
3 function style
?set function style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style function`。
3 functions
?commands show functions
?show functions
 `show functions` コマンドはユーザーが定義した関数とその定義内容を表示
 します。

 書式:
         show functions

 gnuplot における関数の定義とその使い方については、以下参照:
 `expressions`。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/spline.html">
 ユーザ定義関数でのスプライン (spline.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 関数と複素変数を翼に使用 (airfoil.dem)。
^ </a>
3 grid
?commands set grid
?commands unset grid
?commands show grid
?set grid
?unset grid
?show grid
?grid
?nogrid
 コマンド `set grid` は格子線を描きます。

 書式:
       set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                {{no}{m}x2tics} {{no}{m}y2tics}
                {{no}{m}cbtics}
                {polar {<angle>}}
                {layerdefault | front | back}
                { {linestyle <major_linestyle>}
                  | {linetype | lt <major_linetype>}
                    {linewidth | lw <major_linewidth>}
                  { , {linestyle | ls <minor_linestyle>}
                      | {linetype | lt <minor_linetype>}
                        {linewidth | lw <minor_linewidth>} } }
       unset grid
       show grid

 格子線は任意の軸の任意の主目盛/副目盛に対して有効/無効にでき、その主目
 盛りと副目盛りに対する線種、線幅も指定でき、現在の出力装置がサポートす
 る範囲で、あらかじめ定義したラインスタイルを使用することもできます。

 さらに、2 次元の描画では極座標格子も使うことができます。定義可能な区間
 に対して、選択された目盛りを通る同心円と中心からの放射状の線が描かれま
 す (その区間は `set angles` の設定にしたがって度、またはラジアンで指定
 します)。極座標格子は現在は極座標モードでは自動的には生成されないこと
 に注意してください。

 `set grid` が描く前に、必要な目盛りは有効になっていなければなりません。
 `gnuplot` は、存在しない目盛りに対する格子の描画の命令は単に無視します。
 しかし、後でその目盛りが有効になればそれに対する格子も描きます。

 副格子線に対する線種を何も指定しなければ、主格子線と同じ線種が使われま
 す。デフォルトの極座標の角度は 30 度です。

 `front` を指定すると、格子線はグラフのデータの上に描かれます。`back`
 が指定された場合は格子線はグラフのデータの下に描かれます。`front` を使
 えば、密集したデータで格子線が見えなくなることを防ぐことができます。デ
 フォルトでは `layerdefault` で、これは 2D 描画では `back` と同じです。
 3D 描画のデフォルトは、格子とグラフの枠を 2 つの描画単位に分離し、格子
 は後ろに、枠は描画データまたは関数の前に書きます。ただし、`hidden3d`
 モードでは、それがそれ自身の並び換えをしていますので、格子線の順番のオ
 プションは全て無視され、格子線も隠線処理にかけられます。これらのオプシ
 ョンは、実際には格子線だけでなく、`set border` による境界線とその目盛
 りの刻み (以下参照: `set xtics`) にも影響を及ぼします。

 z の格子線は描画の底面に描かれます。これは描画の周りに部分的な箱が描画
 されている場合にはいいでしょう。以下参照: `set border`。
3 hidden3d
?commands set hidden3d
?commands unset hidden3d
?commands show hidden3d
?set hidden3d
?unset hidden3d
?show hidden3d
?hidden3d
?nohidden3d
 `set hidden3d` コマンドは曲面描画 (以下参照: `splot`) で隠線処理を行な
 うように指示します。その処理の内部アルゴリズムに関する追加機能もこのコ
 マンドで制御できます。

 書式:
       set hidden3d {defaults} |
                    { {front|back}
                      {{offset <offset>} | {nooffset}}
                      {trianglepattern <bitpattern>}
                      {{undefined <level>} | {noundefined}}
                      {{no}altdiagonal}
                      {{no}bentover} }
       unset hidden3d
       show hidden3d

 gnuplot の通常の表示とは異なり、隠線処理では与えられた関数、またはデー
 タの格子線を、実際の曲面がその曲面の背後にあって隠されている描画要素は
 見せないのと同じように処理します。これが機能するためには、その曲面が
 '格子状' (以下参照: `splot datafile`) である必要があり、またそれらは
 `with lines` か `with linespoints` で描かれていなければいけません。

 `hidden3d` が有効なときは、格子線だけでなく、面部分や土台の上の等高線
 (以下参照: `set contour`) も隠されます。複数の面を描画している場合は、
 各曲面は自分自身と他の曲面で隠される部分も持ちます。曲面上への等高線の
 表示 (`set contour surface`) は機能しません。

 見出しと矢印は常に表示され、影響を受けません。グラフの説明 (key) も曲
 面に隠されることはありません。gnuplot バージョン 4.2 ではグラフ上に曲
 面が一つもない状態でも、`set hidden3d` は `with points`, `with labels`
 `with vectors` の 3 次元の描画スタイルに影響を与えます。グラフ内の各々
 の描画をこの処理から明示的に除外したいときは、`with` 指定に特別のオプ
 ション `nohidden3d` を追加してください。

 hidden3d は、pm3d モードで描画された、塗り潰された曲面には影響を与えま
 せん。pm3d の曲面に対して同様の効果を純粋に得たいならば、これの代わり
 に `set pm3d depthorder` を使ってください。複数の pm3d 曲面に通常の
 `hidden3d` 処理を組み合わせるには、hidden3d 処理の全ての要素を強制的に
 残りの他の描画要素の後に描画するためのオプション `set hidden3d front`
 を使用し、そして曲面を 2 度描画してください。最初は `with lines lt -2`
 で、2 度目は `with pm3d` で描画します。最初の方では、隠される描画要素
 の計算を行っている間は隠す方の曲面も含まれているのですが、実際にはその
 曲面自体は描画されません。

 関数値は格子孤立線の交点で評価されます。見ることの出来る線分を求めると
 きは個々の関数値、あるいはデータ点の間はそのアルゴリズムによって線形補
 間されます。これは、`hidden3d` で描画する場合と `nohidden3d` で描画す
 る場合で関数の見かけが異なることを意味します。なぜならば、後者の場合関
 数値は各標本点で評価されるからです。この違いに関する議論については、
 以下参照: `set samples`, `set isosamples`。

 曲面の隠される部分を消去するのに使われるアルゴリズムは、このコマンドで
 制御されるいくつかの追加オプションを持っています。`defaults` を指定す
 ればそれらはすべて、以下で述べるようなデフォルトの値に設定されます。
 `defaults` が指定されなかった場合には、明示的に指定されたオプションの
 みが影響を受け、それ以外のものは以前の値が引き継がれます。よって、それ
 らのオプションの値をいちいち修正することなく、単に `set {no}hidden3d`
 のみで隠線処理をオン/オフできることになります。

 最初のオプション `offset` は '裏側' の線を描画する線の線種に影響を与え
 ます。通常は曲面の表裏を区別するために、裏側の線種は、表側の線種より一
 つ大きい番号の線種が使われます。`offset <offset>` によって、その追加す
 る値を、デフォルトの 1 とは異なる増分値に変更できます。`nooffset` オプ
 ションは `offset 0` を意味し、これは表裏で同じ線種を使うことになります。

 次のオプションは `trianglepattern <bitpattern>` です。<bitpattern> は
 0 から 7 までの数字で、ビットパターンと解釈されます。各曲面は三角形に
 分割されますが、このビットパターンの各ビットはそれらの三角形の各辺の表
 示を決定します。ビット 0 は格子の水平辺、ビット 1 は格子の垂直辺、ビッ
 ト 2 は、元々の格子が 2 つの三角形に分割されるときの対角辺です。デフォ
 ルトのビットパターンは 3 で、これは全ての水平辺と垂直辺を表示し、対角
 辺は表示しないことを意味します。対角辺も表示する場合は 7 を指定します。

 オプション `undefined <level>` は、定義されていない (欠けているデータ
 または未定義の関数値) か、または与えられた x,y,z の範囲を超えているデ
 ータ点に適用させるアルゴリズムを指示します。そのような点は、それでも
 表示されてしまうか、または入力データから取り除かれます。取り除かれて
 しまう点に接する全ての曲面要素は同様に取り除かれ、よって曲面に穴が生
 じます。<level> = 3 の場合、これは `noundefined` と同じで、どんな点も
 捨てられません。これは他の場所であらゆる種類の問題を引き起こし得るので
 使わないべきです。<level> = 2 では未定義の点は捨てられますが、範囲を超
 えた点は捨てられません。<level> = 1 では、これがデフォルトですが、範囲
 を超えた点も捨てられます。

 `noaltdiagonal` を指定すると、`undefined` が有効のとき (すなわち <level>
 が 3 でない場合) に起こる以下の場合のデフォルトでの取扱いを変更できま
 す。入力曲面の各格子状の部分は一方の対角線によって 2 つの三角形に分割
 されます。通常はそれらの対角線の全てが格子に対して同じ方向を向いていま
 す。もし、ある格子の 4 つの角のうち一つが `undefined` 処理によりとり除
 かれていて、その角が通常の方向の対角線に乗っている場合は、その両方の三
 角形が取り除かれてしまいます。しかし、もしデフォルトの設定である
 `altdiagonal` が有効になっている場合、その格子については他方向の対角線
 が代わりに選択され、曲面の穴の大きさが最小になるようにします。

 `bentover` オプションは今度は `trianglepattern` とともに起こる別のこと
 を制御します。かなりしわくちゃの曲面では、下の ASCII 文字絵に書いたよ
 うに、曲面の 1 つの格子が 2 つに分けられた三角形の表と裏の反対側が見え
 てしまう場合 (すなわち、元の四角形が折り曲げられている ('bent over')
 場合) があります:

                                                               C----B
          元の 4 角形:     A--B      表示される 4 角形:        |\   |
       ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                           |/ |                                |  \ |
                           C--D                                |   \|
                                                               A    D

 曲面の格子の対角辺が <bitpattern> の 2 bit によって見えるようにはなっ
 てはいない場合、上の対角辺 CB はどこにも書かれないことになり、それが結
 果の表示を理解しにくいものにします。デフォルトで定義される `bentover`
 オプションは、このような場合それを表示するようにします。もしそうしたく
 ないなら、`nobentover` を選択してください。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/hidden.html">
 隠線処理のデモ (hidden.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/singulr.html">
 複雑な隠線のデモ (singulr.dem).
^ </a>
3 historysize
?commands set historysize
?set historysize
?unset historysize
?historysize
?nohistorysize
 注意: コマンド `set historysize` は、gnuplot が GNU readline ライブラ
 リを使うように configure された場合のみ有効です。

 書式:
       set historysize <int>
       unset historysize

 historysize の値は、gnuplot の終了時に history の行を高々その行数まで
 に切り捨てるために使われます。デフォルトは 500 です。
 `unset historysize` は history の切捨てを無効にしますので、history フ
 ァイルに書き出す行数の制限をしません。
3 isosamples
?commands set isosamples
?commands show isosamples
?set isosamples
?show isosamples
?isosamples
 関数を面として描画する場合の孤立線 (格子) の密度はコマンド `set isosamples`
 で変更できます。

 書式:
       set isosamples <iso_1> {,<iso_2>}
       show isosamples

 各曲面グラフは <iso_1> 個の u-孤立線と <iso_2> 個の v-孤立線を持ちます。
 <iso_1> のみ指定すれば、<iso_2> は <iso_1> と同じ値に設定されます。
 デフォルトでは、u, v それぞれ 10 本の標本化が行われます。標本数をもっと
 多くすればより正確なグラフが作られますが、時間がかかります。これらの
 パラメータは、データファイルの描画には何も影響を与えません。

 孤立線とは、曲面の一つの媒介変数を固定して、もう一つの媒介変数によって
 描かれる曲線のことです。孤立線は、曲面を表示する単純な方法を与えます。
 曲面 s(u,v) の媒介変数 u を固定することで u-孤立線 c(v) = s(u0,v) が
 作られ、媒介変数 v を固定することで v-孤立線 c(u) = s(u,v0) ができます。

 関数の曲面グラフが隠線処理なしで描かれている場合、`set samples` は
 各孤立線上で標本化される点の数を制御します。以下参照: `set samples`,
 `set hidden3d`。等高線描画ルーチンは、関数の点の標本化は各孤立線の交点
 で行われると仮定しているので、関数の曲面と等高線の解像度を変更するとき
 は、`isosamples` と同じように `samples` を変更するのが望ましいでしょう。
3 key
?commands set key
?commands unset key
?commands show key
?set key
?unset key
?show key
?key
?nokey
?legend
 コマンド `set key` は描画された曲線の説明や表題を表示することを可能に
 します。

 説明 (key) の内容、すなわち描画される個々のデータ集合や関数につける名
 前、およびそれらグラフの曲線とグラフ上の点を表す記号からなるサンプルは、
 `plot` (または `splot`) コマンドの `title`, `with` オプションにより決
 定されます。より詳しい情報については、以下参照: `plot title`,
 `plot with`。

 書式:
       set key {on|off} {default}
               {{inside | outside} | {lmargin | rmargin | tmargin | bmargin}
                 | {at <position>}}
               {left | right | center} {top | bottom | center}
               {vertical | horizontal} {Left | Right}
               {{no}reverse} {{no}invert}
               {samplen <sample_length>} {spacing <vertical_spacing>}
               {width <width_increment>}
               {height <height_increment>}
               {{no}autotitles {columnheader}}
               {title "<text>"} {{no}enhanced}
               {font "<face>,<size>"} {textcolor <colorspec>}
               {{no}box { {linestyle | ls <line_style>}
                          | {linetype | lt <line_type>}
                            {linewidth | lw <line_width>}}}
       unset key
       show key

 キー (説明) は、グラフ内の各描画に対するタイトルとサンプル (凡例; 線、
 点、箱) から成ります。キーの機能は、`set key off` または `unset key`
 で無効にできます。個々のキーのエントリは、対応する plot コマンド内にキ
 ーワード `notitle` を使うことで無効にできます。

 キー内の各要素は `vertical` (縦) または `horizontal` (横) に従って重ね
 られます。`vertical` の場合、key は可能ならば 2,3 個の縦の列を使います。
 すなわち、各要素は垂直スペースがなくなるまでは 1 つの列に整列されます
 が、そこから新しい列が開始されます。`horizontal` の場合は、key は可能
 ならば 2,3 個の横の行を使用します。

 デフォルトでは、key はグラフ領域の内側の右上の角に置かれます。キーワー
 ド `left`, `right`, `top`, `bottom`, `center`, `inside`, `outside`,
 `lmargin`, `rmargin`, `tmargin`, `bmargin` (, `above`, `over`, `below`,
 `under`) は、グラフ領域の他の場所への自動的な配置のために使用します。
 key の描画をどこに置くかをより詳しく指示するための `at <position>` も
 あります。この場合、キーワード `left`, `right`, `top`, `bottom`,
 `center` が同様の基準点合わせの設定の目的で使われます。
 より詳しくは、以下参照: `key placement`。

 グラフのタイトルの行揃えは `Left`, `Right` (デフォルト) で指示し
 ます。ラベル文字列と曲線のサンプルは左右入れ替えることができます
 (`reverse`) し、 全体を枠で囲むこともできます (`box {...}`)。その枠の
 線は、線種 (`linetype`), 線幅 (`linewidth`)、あるいは定義済のラインス
 タイル (`linestyle`) を指定することもできます。

 デフォルトでは最初の描画のラベルが説明の一番上に現われ、それに続くラベ
 ルがその下に並んで行きます。オプション `invert` は、最初のラベルを説明
 の一番下に置き、それに続くラベルをその上に並べて行きます。このオプショ
 ンは、説明のラベルの縦の並びの順番を、積み上げ形式のヒストグラム
 (`histograms`) の箱の順番に合わせるときに便利でしょう。

 <height_increment> は、説明の箱の高さに加えたり減らしたりする高さ (何
 文字分か) を表す数値です。これは主に、説明の回りに箱を描く場合で、説明
 の並びの回りの境界線をより大きくしたい場合のものです。

 `plot` や `splot` で描画される全ての曲線は、デフォルトのオプション
 `autotitles` に従って表題 (title) がつけられます。表題の自動生成は、
 `noautotaitle` で抑制できますがその場合、`(s)plot ... title ...` で明
 示的に指定された表題のみが描かれることになります。

=columnheader
 コマンド `set key autotitle columnheader` は、各入力データの先頭行の各
 列のエントリをテキスト文字列と解釈し、対応する描画グラフのタイトルとし
 て使用します。描画される量が、複数の列データの関数である場合は、
 gnuplot はどの列をタイトルの描画に使えばいいのかわかりませんので、その
 ような場合、plot コマンド上で、例えば以下のように明示的にタイトルの列
 を指定する必要があります。

       plot "datafile" using (($2+$3)/$4) title columnhead(3) with lines

 全体に渡る表題は説明の上につけることもできます (`title "<text>"`)。単
 一引用符 (') と二重引用符 (") の違いについては、以下も参照: `syntax`。
 説明の表題の行揃えは、グラフの表題の行揃えと同じものが使われます。

 `set key` のデフォルトは、`on`,  `right`, `top`, `vertical`, `Right`,
 `noreverse`, `noinvert`, `samplen 4`, `spacing 1.25`, `title ""`,
 `nobox` です。説明の枠の線種はデフォルトではグラフ描画の外枠と同じもの
 が使われます。`set key default` とするとデフォルトの設定に戻ります。

 説明は、1 行に 1 曲線分ずつの数行のまとまりとして書かれます。各行の右
 側には (`reverse` を使っていれば左側には) その曲線と同じ種類の直線のサ
 ンプルが引かれ、他の側には `plot` コマンドから得られる文字列 (title)
 が置かれます。これらの行は、架空の直線が説明の左側と右側を分けるかのよ
 うに垂直に整列されます。コマンド `set key` で指定する座標はこの架空の
 線分の上の端の座標です。`plot` では直線の位置を指定するために x と y
 だけが使われ、`splot` では、x, y, z の値全てを使い、グラフを 2 次元面
 へ投影するのと同じ方法を使って、架空の直線の 2 次元画面での位置を生成
 します。

 TeX, PostScript, またはこれらと同等の、整形情報が文字列に埋め込まれる
 出力を使う場合は、`gnuplot` は説明の位置合わせのための文字列の幅を
 正しく計算できません。よって説明を左に置く場合は
 `set key left Left reverse` という組合せを使うのがいいでしょう。そうす
 れば説明の枠と枠内のすき間は文字列そのままの幅に合わせられます。

 `splot` で等高線を書く場合、説明には等高線のラベルも表示されます。
 これらのラベルの並び具合がうまくいかない、または別な位置に小数点を
 置きたい場合はそのラベルの書式を指定できます。詳細は、以下参照:
 `set clabel`。

 例:

 以下はデフォルトの位置に説明を表示します:
       set key default

 以下は説明を表示しなくします:
       unset key

 以下はデフォルトの (第一の) 座標系での (2,3.5,2) の位置に説明を表示
 します:
       set key at 2,3.5,2

 以下は説明をグラフの下に表示します:
       set key below

 以下は説明を左下角に表示し、テキストは左に行揃えで、タイトルをつけ、
 線種 3 の外枠を書きます:
       set key left bottom Left title 'Legend' box 3
4 キーの配置 (key placement)
?commands set key placement
?set key placement
?key placement
 配置の仕組みを理解ための最も重要な概念は、グラフ領域、すなわち内か外か
 ということと、グラフ領域の境界との間の余白 (margin) を考えることです。
 グラフ領域に沿って、キーワード `left/center/right` (l/c/r) と
 `top/center/bottom` (t/c/b) は、key をその領域の内側のどこに置くかを制
 御します。

 モード `inside` では、key はキーワード `left` (l), `right` (r), `top`
 (t), `bottom` (b), `center` (c) によって以下の図のように描画領域の境界
 に向かって出力されます:

      t/l   t/c   t/r

      c/l    c    c/r

      b/l   b/c   b/r


 モード `outside` でも上と同様に自動的に配置されますが、グラフ領域の境
 界に対して、というよりもむしろ見た目に対して、というべきでしょう。すな
 わち、グラフの境界は、グラフ領域の外の key の場所を作るために、内側に
 移動することになります。しかし、これは他のラベルの邪魔をしますし、もし
 かしたら出力デバイスによってはエラーを引き起こすかもしれません。key の
 出力に合わせてどの描画境界が移動するかは、上に述べた key の位置、およ
 び重ね上げの方向に依存します。4 方向の中心揃えのオプション (`center`)
 に関しては、どの境界が動くのかに関するあいまいさはありませんが、角への
 出力のオプションについては、重ね上げ方向が `vertical` の場合は左または
 右の境界が、`horizontal` の場合は上または下の境界が、それぞれ内側に適
 切に移動します。

 余白 (margin) の書き方は、重ね上げの方向にかかわない自動的な配置を可能
 にしています。`lmargin` (lm), `rmargin` (rm), `tmargin` (tm),
 `bmargin` (bm) のうちの一つを、矛盾しない 1 方向のキーワードと組み合わ
 せて使用した場合、以下の図に示した場所に key が配置されます:

           l/tm  c/tm  r/tm

      t/lm                  t/rm

      c/lm                  c/rm

      b/lm                  b/rm

           l/bm  c/bm  r/bm


 キーワード `above` と `over` は `tmargin` と同じ意味です。以前のバージ
 ョンとの互換性のために、`above` と `over` は l/c/r や重ね上げ方向のキ
 ーワードなしで使用すると、`center` で `horizontal` を使います。キーワ
 ード `below` と `under` は `bmargin` と同じ意味です。互換性のために、
 `below` と `under` は l/c/r や重ね上げ方向のキーワードなしで使用すると
 `center` で `horizontal` を使います。さらに、`outside` も互換性のため
 に t/b/c や重ね上げ方向のキーワードがなければ、`top`, `right`,
 `vertical` (つまり上の t/rm と同じ) を使用します。

 説明の位置 (<position>) は、以前のバージョンと同様単に x,y,z を指定し
 てもいいですが、その最初のサンプル行の座標の座表系を選択するための 5
 つのキーワード (`first`, `second`, `graph`, `screen`, `character`) を
 頭につけることもできます。詳細は、以下参照: `coordinates`。<position>
 が与えられた場合の `left`, `right`, `top`, `bottom`, `center` の効果は、
 label コマンドで配置される文字列の場合と同じように基準位置の位置合わせ
 に使用されます。すなわち、`left` は key が <position> の右に置かれて左
 合わせで出力されます。他の場合も同様です。
4 キーの凡例 (key samples)
?commands set key samples
?set key samples
?key samples
 デフォルトでは、グラフ上の各描画はキー内にそれぞれに対応するエントリを
 生成します。このエントリには、描画タイトルと、その描画で使われるのと同
 じ色、同じ塗りつぶし属性による線/点/箱 のサンプルが入ります。font と
 textcolor 属性は、キー内に現われる個々の描画タイトルの見た目を制御しま
 す。textcolor を "rgb variable" にセットすると、キーの各エントリの文字
 列は、描画グラフの線や塗りつぶし色と同じ色になります。これは、以前のあ
 る時期の gnuplot のデフォルトの挙動でした。

 グラフ曲線のサンプルの線分の長さは `samplen` で指定できます。その長さ
 は目盛りの長さと、<sample_length>*(文字幅) の和として計算されます。
 `sapmlen` は、グラフ上の点のサンプルの位置にも (もしサンプル線分自身が
 書かれなくても) 影響を与えています。それは、点の記号はサンプル線分の中
 央に書かれるためです。

 行間の垂直スペースは、`spacing` で指定できます。その幅は、点のサイズ
 (pointsize) と垂直な目盛りのサイズと <vertical_spacing> の積になります。
 この垂直スペースは、文字の高さよりも小さくはならないことが保証されてい
 ます。

 <width_increment> は、文字列の長さに加えたり減らしたりする幅 (何文字分
 か) を表す数値です。これは、説明に外枠を書き、文字列に制御文字を使う場
 合にだけ有用でしょう。`gnuplot` は外枠の幅を計算するときは、ラベル文字
 列の文字数を単純に数えるだけなので、それを修正するのに使えます。
3 label
?commands set label
?commands unset label
?commands show label
?set label
?unset label
?show label
?label
?nolabel
 `set label` コマンドを使うことによって任意の見出し (label) をグラフ中
 に表示することができます。

 書式:
       set label {<tag>} {"<label text>"} {at <position>}
                 {left | center | right}
                 {norotate | rotate {by <degrees>}}
                 {font "<name>{,<size>}"}
                 {noenhanced}
                 {front | back}
                 {textcolor <colorspec>}
                 {point <pointstyle> | nopoint}
                 {offset <offset>}
       unset label {<tag>}
       show label

 位置 (<position>) は x,y か x,y,z のどちらかで指定し、座標系を選択する
 にはその座標の前に `first`, `second`, `graph`, `screen`, `character`
 をつけます。詳細は、以下参照: `coordinates`。

 タグ (<tag>) は見出しを識別するための整数値です。タグを指定しなかった
 場合未使用のもので最も小さい値が自動的に割り当てられます。現在の見出し
 を変更するときはそのタグと変更したい項目を指定して `set label` コマン
 ドを使います。

 <label text> は文字列定数でも構いませんし、文字列変数、または文字列の
 値を持つ式でも構いません。以下参照: `strings`, `sprintf`, `gprintf`。

 デフォルトでは、指定した点 x,y,z に見出しの文章の左端が来るように配置
 されます。x,y,z を見出しのどこに揃えるかを変更するには変数
 <justification> を指定します。これには、`left`, `right`, `center` の
 いずれかが指定でき、それぞれ文章の左、右、真中が指定した点に来るよう
 に配置さるようになります。描画範囲の外にはみ出るような指定も許されま
 すが、座標軸の見出しや他の文字列と重なる場合があります。

 `rotate` を指定するとラベルは縦書きになります (もちろん出力ドライバが
 対応していれば、ですが)。`rotate by <degrees>` が与えられた場合は、そ
 れに適合している出力ドライバは指定された角度で文字列を書こうとしますが
 そうでない出力形式では、垂直な文字列として扱われます。

 フォントとそのサイズは、出力形式がフォントの設定をサポートしていれば
 `font "<name>{,<size>}"` で明示的に選択できます。そうでない出力形式で
 は、デフォルトのフォントが使われます。

 通常は、現在の出力形式がサポートしていれば、ラベル文字列の全ての文字列
 に拡張文字列処理モード (enhanced text mode) が使用されます。
 `noenhanced` を使用することで、特定のラベルを拡張文字列処理から外すこ
 とができます。これは、ラベルが例えばアンダースコア (_) を含んでいる場
 合などに有用です。以下参照: `enhanced text`。

 `front` が与えられると、見出しはデータのグラフの上に書かれます。`back`
 が与えられると (デフォルト)、見出しはグラフの下に書かれます。`front`
 を使うことで、密なデータによって見出しが隠されてしまうことを避けること
 が出来ます。

 `textcolor <colorspec>` は見出し文字列の色を変更します。<colorspec> は
 線種、rgb 色、またはパレットへの割当のいずれかが指定できます。
 以下参照: `colorspec`, `palette`。`textcolor` は、`tc` と省略可能です。
    `tc default` は、文字色をデフォルトにします。
    `tc lt <n>` は、文字色を線種 <n> (line type)と同じものにします。
    `tc ls <n>` は、文字色を line style <n> と同じものにします。
    `tc palette z` は、見出しの z の位置に対応したパレット色になります。
    `tc palette cb <val>` は、色見本 (colorbar) の <val> の色になります。
    `tc palette fraction <val>` (0<=val<=1) は、[0:1] から `palette` の
        灰色階調/カラーへの写像に対応した色になります。
    `tc rgb "#RRGGBB"` は、任意の 24-bit RGB 色を選択します。

 <pointstyle> がキーワード `lt`, `pt`, `ps` とともに与えられると (以下
 参照: `style`)、与えられたスタイルと、与えられた線種の色で見出し位置に
 点 (point) が描画され、見出し文字列は少し移動されます。このオプション
 は `mouse` 拡張された出力形式でのラベルの配置に、デフォルトで使用され
 ています。見出し文字列近くの点の描画機能を off (これがデフォルト) にす
 るには、`nopoint` を使用してください。

 その移動は、デフォルトでは、<pointstyle> が与えられれば `pointsize` の
 単位で 1,1 で、<pointstyle> が与えられていなければ 0,0 です。移動は、
 追加の `offset <offset>` でも制御できます。ここで、<offset> は x,y か
 または x,y,z の形式ですが、それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。

 もし一つ (あるいはそれ以上の) 軸が時間軸である場合、座標は `timefmt`
 の書式にしたがって引用符で囲まれた文字列で与える必要があります。以下参
 照: `set xdata`, `set timefmt`。

 EEPIC, Imagen, LaTeX, TPIC で出力する場合は、\\ を使うことで見出しを
 改行させることができます。

 ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
 照: `labels`)。

 例:

 (1,2) の位置に "y=x" と書く場合:
       set label "y=x" at 1,2

 Symbol フォントのサイズ 24 の "シグマ" (Σ) をグラフの真中に書く場合:
       set label "S" at graph 0.5,0.5 center font "Symbol,24"

 見出し "y=x^2" の右端が (2,3,4) に来るようにし、タグ番号として 3 を使う
 場合:
       set label 3 "y=x^2" at 2,3,4 right

 その見出しを中央揃えにする場合:
       set label 3 center

 タグ番号 2 の見出しを削除する場合:
       unset label 2

 全ての見出しを削除する場合:
       unset label

 全ての見出しをタグ番号順に表示する場合:
       show label

 x 軸が時間軸であるグラフに見出しを設定する例:
       set timefmt "%d/%m/%y,%H:%M"
       set label "Harvest" at "25/8/93",1

 データと、新たに当てはめられたパラメータによる当てはめ関数を描画したい
 場合、`fit` の後でかつ `plot` の前に以下を実行します:
       set label sprintf("a = %3.5g",par_a) at 30,15
       bfit = gprintf("b = %s*10^%S",par_b)
       set label bfit at 30,20

 当てはめられるパラメータのついた関数の定義式を表示したい場合:
       f(x)=a+b*x
       fit f(x) 'datafile' via a,b
       set label GPFUN_f at graph .05,.95
       set label sprintf("a = %g", a) at graph .05,.90
       set label sprintf("b = %g", b) at graph .05,.85

 見出し文字列を小さい点から少しだけ移動する場合:
       set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1

 pm3d を使った 3 次元のカラー曲面上のある点の位置に、その z の値 (この
 場合 5.5) に対応した色を見出し文字列につける場合:
       set label 'text' at 0,0,5.5 tc palette z

3 lmargin
?commands set lmargin
?set lmargin
?lmargin
 コマンド `set lmargin` は左の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 loadpath
?commands set loadpath
?commands show loadpath
?set loadpath
?show loadpath
?loadpath
 `loadpath` の設定は、`call`, `load`, `plot`, `splot` コマンドのデータ
 ファイル、コマンドファイルの検索パスを追加定義します。ファイルが現在の
 ディレクトリに見つからなかった場合、`loadpath` のディレクトリが検索さ
 れます。

 書式:
       set loadpath {"pathlist1" {"pathlist2"...}}
       show loadpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), DOS//Windows/OS/2/Amiga ではセミコロン (';') 等で区切
 ります。`show loadpath`, `save`, `save set` コマンドは、可搬性のために
 OS 固有のパス区切りをスペース (' ') で置き換えます。

 環境変数 GNUPLOT_LIB が設定されている場合、その内容は `loadpath` に追
 加されますが、`show loadpath` は、ユーザ定義の loadpath と環境変数によ
 るシステム loadpath を別々に表示しますし、`save`, `save set` コマンド
 は、可搬性の目的のためにユーザ定義の `loadpath` のみを保存します。
3 locale
?commands set locale
?set locale
?locale
 `locale` の設定は `{x,y,z}{d,m}tics` が書く日付の言語を決定します。

 書式:
       set locale {"<locale>"}

 <locale> にはインストールされたシステムで使うことの出来る任意の言語を
 指定できます。可能なオプションについてはシステムのドキュメントを参照し
 てください。コマンド `set locale ""` は、環境変数 LC_TIME, LC_ALL, ま
 たは LANG からロカールの値を決定しようとします。

 小数点に関する locale を変更したい場合は、以下参照: `set decimalsign`。
 文字エンコードを現在のロカールのものに変更したい場合は、以下参照:
 `set encoding`。
3 logscale
?commands set logscale
?commands unset logscale
?commands show logscale
?set logscale
?unset logscale
?show logscale
?set log
?logscale
?nologscale
 書式:
         set logscale <axes> <base>
         unset logscale <axes>
         show logscale

 ここで、<axes> (軸) は、`x`, `x2`, `y`, `y2`, `z`, `cb` の任意の順序の
 組み合せが可能です。また、<base> は、対数スケールの底です。<base> が指
 定されなかった場合は 10 になります。もし、<axes> が指定されなかった場
 合は、全部が指定されたことになります。コマンド `unset logscale` は、指
 定した軸の対数スケールを解除します。

 例:

 x, z 両軸について対数スケールを設定する:
        set logscale xz

 y 軸について底 2 とする対数スケールを設定する:
        set logscale y 2

 pm3d plot 用に z と色の軸に対数スケールを設定する:
        set logscale zcb

 z 軸の対数スケールを解除する:
        unset logscale z
3 macros
?commands set macros
?commands show macros
?set macros
?show macros
 これによりコマンドラインのマクロ置換機能を有効にすると、コマンドライン
 内の @<stringvariablename> の形式の部分文字列は、文字列変数
 <stringvariablename> に含まれるテキスト文字列に置き換えられます。以下
 参照: `substitution`。

 書式:
      set macros

3 mapping
?commands set mapping
?commands show mapping
?set mapping
?show mapping
?mapping
 データが `splot` に球面座標や円柱座標で与えられた場合、`set mapping`
 コマンドは `gnuplot` にそれをどのように扱うかを指定するのに使われます。

 書式:
       set mapping {cartesian | spherical | cylindrical}

 デフォルトではカーテシアン座標 (通常の x,y,z 座標) が使われます。

 球面座標では、データは 2 つか 3 つの列 (またはその個数の `using` エン
 トリ) として与えられます。最初の 2 つは、`set angles` で設定された単位
 での方位角 (theta) と仰角 (phi) (すなわち "経度" と "緯度") とみなされ
 ます。半径 r は、もし 3 列目のデータがあればそれが使われ、もしなければ
 1 に設定されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta) * cos(phi)
       y = r * sin(theta) * cos(phi)
       z = r * sin(phi)

 これは、"極座標系" というより、むしろ "地学上の座標系" (緯度、経度) に
 相当することに注意してください (すなわち、phi は z 軸となす角、という
 より赤道から計った仰角、になります)。

 円柱座標では、データはやはり 2 つか 3 つの列で与えられ、最初の 2 つは
 theta (`set angle` で指定された単位の) と z と見なされます。半径 r は
 球面座標の場合と同様、3 列目のデータがあればそれが、なければ 1 と設定
 されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta)
       y = r * sin(theta)
       z = z

 `mapping` の効果は、`splot` コマンド上の `using` によるフィルタで実現
 することも可能ですが、多くのデータファイルが処理される場合は `mapping`
 の方が便利でしょう。しかし、`mapping` を使っていても、もしファイルのデ
 ータの順番が適切でなかったら結局 `using` が必要になってしまいます。

 `mapping` は `plot` では何もしません。
^ 以下も参照
^ <a href="http://www.gnuplot.info/demo/world.html">
 world.dem: mapping のデモ。
^ </a>
3 margin
?commands set margin
?commands show margin
?set margin
?show margin
?margin
 自動的に計算される周囲の余白 (margin) はコマンド `set margin` で変更で
 きます。`show margin` は現在の設定を表示します。

 書式:
       set bmargin {{at screen} <margin>}
       set lmargin {{at screen} <margin>}
       set rmargin {{at screen} <margin>}
       set tmargin {{at screen} <margin>}
       show margin

 <margin> のデフォルトの単位には、適切と思われる、文字の高さと幅が使わ
 れます。正の値は余白の絶対的な大きさを定義し、負の値 (または無指定) は
 `gnuplot` によって自動計算される値を使うことになります。3 次元描画では
 左の余白 (lmargin) のみが文字の大きさを単位として設定できます。

 キーワード `at screen` は、その余白の指定が全体の描画領域に対する割合
 であることを意味します。これは、多重描画 (multiplot) モードでの 2D, 3D
 グラフの角を正確に揃えるのに使えます。この配置は現在の `set origin` や
 や `set size` の値を無視するようになっていて、それは多重描画内のグラフ
 の配置の別の方法として使われることを意図しています。

 描画の余白は通常目盛り、目盛りの見出し、軸の見出し、描画のタイトル、
 日付、そして境界の外にある場合の key (グラフ見出し) のサイズ等を元に計
 算されます。しかし、目盛りの刻みが境界でなく軸の方についている場合 (例
 えば `set xtics axis` によって)、目盛りの刻み自身とその見出しは余白の
 計算には含まれませんし、余白に書かれる他の文字列の位置の計算にも含まれ
 ません。これは、軸と境界が非常に近い場合、軸の見出しが他の文字列を上書
 きする可能性を示唆します。
3 mouse
?commands set mouse
?commands unset mouse
?set mouse
?unset mouse
?mouse
?nomouse
 コマンド `set mouse` はマウス機能を有効にします。現在、pm, x11, ggi,
 windows, wxt の各出力ドライバがマウス拡張されています。2 種類のマウス
 モードがあります。2 次元グラフモードは、2 次元グラフ、または地図型表示
 (すなわち、z の回転角が 0, 90, 180, 270, 360 度の `set view` での
 splot、および `set view map`) で動作し、グラフ上の位置の追跡、拡大表示、
 グラフの注釈づけ等を可能にします。`splot` による 3 次元グラフに対して
 は、グラフの視方向 (view) と伸縮の変更が、マウスボタン 1 と 2 (による
 ドラッグ) で行えます。これらのボタンにさらに <ctrl> キーを押すと、座標
 系のみが回転、拡大されますが、これは大きなデータに対して有用でしょう。
 ボタン 2 の垂直方向のドラッグを shift キーと同時に行うと、z 軸の一番下
 の位置 (`ticslevel`) を上下します。

 マウスは多重描画 (multiplot) モードでは無効ですが、`unset multiplot`
 で多重描画が終了すれば、マウス機能は ON になり、直前の描画 (ほぼ
 replot で描画されるもの) に対して作用します。

 書式:
       set mouse {doubleclick <ms>} {nodoubleclick} \
                 {{no}zoomcoordinates} \
                 {noruler | ruler {at x,y}} \
                 {polardistance{deg|tan} | nopolardistance} \
                 {format <string>} \
                 {clipboardformat <int>/<string>} \
                 {mouseformat <int>/<string>} \
                 {{no}labels {"labeloptions"}} \
                 {{no}zoomjump} {{no}verbose}
       unset mouse

 ダブルクリックの解像度はミリ秒 (ms) 単位で与えます。これは、ボタン 1
 用のもので、現在のマウス位置を `clipboard` にコピーするのに使います。
 シングルクリックでそれを行うようにするには、0 ms を指定してください。
 デフォルトの値は 300 ms です。

 オプション `zoomcoordinates` は、拡大 (zoom) の時に、ズームの枠の端に
 その座標を書くかどうかを決定し、デフォルトでは ON になっています。

 オプション `noruler` と `ruler` は、定規 (ruler) 機能を off, on にしま
 す。`ruler` には座標を与えて原点を設定することもできます。`ruler` が
 on の間、ruler の原点からマウスまでのユーザ単位での距離が連続的に表示
 されます。デフォルトでは、ruler のトグルスイッチは 'r' にキー割り当て
 されています。

 オプション `polardistance` は、マウスカーソルから定規 (ruler) までの距
 離を極座標でも表示 (距離、および角度または傾き) するかどうかを決定しま
 す。これはデフォルトのキー割り当て '5' に対応します。

 オプション `format` は、fprintf と似た書式文字列で、ドライバウィンドウ
 とクリップボード上で実数をどのように表示するかを決定します。デフォルト
 は "% #g" です。

 `clipboardformat` と `mouseformat` は、ボタン 1 とボタン 2 の作用時
 (座標をクリップボードへコピー、マウス位置に一時的に注釈をつける) の文
 字列の書式用に使われます。これは、キー割り当て '1', '2', '3', '4' に対
 応します (ドライバのマニュアル参照)。引数が文字列の場合、その文字列は
 C 言語の書式で、2 つの実数の指定子を含んでいる必要があります。例:
 `set mouse mouseformat "mouse = %5.2g, %10.2f"`。この文字列を再び OFF
 にするには `set mouse mouseformat ""` としてください。

 以下の書式が組み込まれています (書式 6 は書式文字列が既に指定されてい
 る場合のみ使用可):

  0   カッコ内に実際の座標           例: [1.23, 2.45]
  1   カッコ無に実際の座標           例:  1.23, 2.45
  2   x == 時間書式 (timefmt)            [(`set timefmt` の設定), 2.45]
  3   x == 日付                          [31. 12. 1999, 2.45]
  4   x == 時刻                          [23:59, 2.45]
  5   x == 日付 / 時刻                   [31. 12. 1999 23:59, 2.45]
  6   文字列で与えられた代替書式         ""

=labels
 ボタン 2 の gnuplot の永続的なラベルを定義するには、オプション
 `labels` を使用します。デフォルトは `nolabels` で、ボタン 2 は単に一時
 的なラベルをマウス位置に描画します。ラベルは現在の `mouseformat` の設
 定に従って書かれます。`labeloptions` 文字列は、コマンド `set label` コ
 マンドに渡されます。そのデフォルトは "point pointstyle 1" で、これはラ
 ベル位置に小さいプラス (`+`) を描画します。一時的なラベルは、その次の
 `replot`、またはマウスズーム操作では現れません。永続的なラベルは、ラベ
 ルの点の上で Ctrl キーを押してボタン 2 をクリックすることで消すことが
 できます。実際のラベルの位置にどれ位近くでクリックしなければいけないか
 の閾値も `pointsize` で決定されます。

 オプション `zoomjump` が ON の場合、ボタン 3 によるズーム領域の選択を
 開始すると、マウスポインタは自動的に少しだけずれた位置に移動します。
 これは、ごく小さい (または空でさえある) ズーム領域を選択してしまうこと
 を避けるのに便利でしょう。デフォルトでは `zoomjump` は OFF です。

 オプション `verbose` が ON の場合、実行時の報告コマンドが表示されます。
 このオプションはドライバウィンドウ上で `6` を打つことで ON/OFF がスイ
 ッチできます。デフォルトでは `verbose` は OFF になっています。

 ドライバウィンドウ上で 'h' を打つと、マウスとキー割当の短い説明が表示
 されます。これは、ユーザ定義のキー割当、すなわち `bind` コマンドによる
 `hotkeys` (以下参照: `bind`) も表示されます。ユーザ定義の `hotkeys` は
 デフォルトのキー割当を無効にします。

 ドライバウィンドウ上で 'q' を打つと、ウィンドウを閉じます。このキーは
 `bind` コマンドでは無効にできません。

 以下も参照: `bind`, `label`。
4 X11 でのマウス (X11 mouse)
?mouse x11_mouse
?x11_mouse
?x11 mouse
 x11 の出力形式のオプション `set term x11 <n>` を使って複数の X11 描画
 ウィンドウが開いている場合、マウスコマンドとホットキーの機能をちゃんと
 使えるのは現在の描画ウィンドウのみです。しかし、他のウィンドウも左下に
 マウスの座標を表示位はしてくれるでしょう。

 他のスクリーン出力形式との統一性も考え、X11 でのマウスサポートは、標準
 入力がどこからであっても、デフォルトで ON になります。しかし、UNIX 風
 の OS の中には、/dev/null のような特殊な入力デバイスを選択してはいけな
 いものがあり、そのようなデバイスでマウスを ON にすると gnuplot がハン
 グアップしてしまうことがあります。このような状況では、`unset mouse` で
 マウス機能を OFF にしてください。
3 multiplot
?commands set multiplot
?commands unset multiplot
?set multiplot
?unset multiplot
?multiplot
?nomultiplot
 コマンド `set multiplot` は `gnuplot` を多重描画モードにします。これ
 は複数の描画を同じページ、ウィンドウ、スクリーンに表示するものです。

 書式:
       set multiplot { layout <rows>,<cols>
                       {rowsfirst|columnsfirst} {downwards|upwards}
                       {title <page title>}
                       {scale <xscale>{,<yscale>}} {offset <xoff>{,<yoff>}}
                     }
       unset multiplot

 出力形式 (terminal) によっては、コマンド `unset multiplot` が与えられ
 るまで何の描画も表示されないことがあります。この場合このコマンドにより
 ページ全体の描画が行なわれ、gnuplot は標準の単一描画モードになります。
 それ以外の出力形式では、各 `plot` コマンドがそれぞれ表示を更新しますが、
 それは、それまで出力したものすべてを再描画し、それに新しいものを追加す
 る方法、あるいは、現在の表示に単に新しいものを追加するだけのやり方、の
 いずれかです。

 次の描画で使われる領域は、新しい描画が行われる前に消されることはありま
 せんから、描画を "挿入" するような場合などでそうしたいなら、`clear` コ
 マンドを使用してください。

 定義済の見出しやベクトルは、各描画において、毎回現在のサイズと原点に従
 って書かれます (それらが `screen` 座表系で定義されていない場合)。それ
 以外の全ての `set` で定義されるものも各描画すべてに適用されます。もし
 1 度の描画にだけ現われて欲しいものを作りたいなら、それが例えば日付
 (timestamp) だとしたら、`set multiplot` と `unset multiplot` で囲まれ
 たブロック内の `plot` (または `splot`, `replot`) 命令の一つを `set time`
 と `unset time` ではさんでください。

 multiplot のタイトルは、個々の描画タイトルがあったとしても、それとは別
 のもので、ページの上部にそのためのキャンバス全体の幅にわたるスペースが
 確保されます。

 layout が指定されていない場合、あるいはより良い位置合わせをしたい場合
 は、コマンド `set origin` と `set size` 各描画で正しい位置に設定する必
 要があります。詳細は、以下参照: `set origin`, `set size`。

 例:
       set multiplot
       set size 0.4,0.4
       set origin 0.1,0.1
       plot sin(x)
       set size 0.2,0.2
       set origin 0.5,0.5
       plot cos(x)
       unset multiplot

 これは、cos(x) のグラフを、sin(x) の上に積み重ねて表示します。

 `set size` と `set origin` は全体の描画領域を参照し、それは各描画で利
 用されます。以下も参照: `set term size`。描画境界を一列に揃えたいなら
 ば、`set margin` コマンドで、境界の外の余白サイズを同じサイズに揃える
 ことが出来ます。その使用に関しては、以下参照: `set margin`。余白サイズ
 は文字サイズ単位の絶対的な数値単位を使用することに注意してください。よ
 って残ったスペースに描かれるグラフは表示するデバイスの表示サイズに依存
 します。例えば、プリンタとディスプレイの表示は多分違ったものになるでし
 ょう。

 オプション `layout` により、各描画の前にそれぞれ与えていた `set size`
 や `set origin` コマンドなしに、単純な複数グラフの描画を作成できます。
 それらの設定は自動的に行なわれ、いつでもその設定を変更できます。
 `layout` では表示は <rows> 行と <cols> 列の格子に分割され、各格子は、
 その後に続く対応する名前のオプションによって列 (rowsfirst)、あるいは行
 (columnsfirst) が先に埋められて行きます。描画グラフの積み上げは下方向
 (`downwards`) に、または上方向 (`upwards`) に伸びるようにできます。デ
 フォルトは `rowsfirst` で `downwards` です。

 各描画は `scale` で伸縮を、`offset` で位置の平行移動を行なうことができ
 ます。scale や offset の y の値が省略された場合は、x の値がそれに使用
 されます。`unset multiplot` により自動配置機能はオフになり、そして
 `set size` と `set origin` の値は `set multiplot layout` の前の状態に
 復帰されます。

 例:
       set size 1,1
       set origin 0,0
       set multiplot layout 3,2 columnsfirst scale 1.1,0.9
       [ ここには 6 つまでの描画コマンド ]
       unset multiplot

 上の例では 6 つの描画が 2 列の中に上から下へ、左から右へと埋められて行
 きます。各描画は水平サイズが 1.1/2、垂直サイズが 0.9/3 となります。

 以下も参照
^ <a href="http://gnuplot.sourceforge.net/demo/multiplt.html">
 multiplot のデモ (multiplt.dem)
^ </a>
3 mx2tics
?commands set mx2tics
?commands unset mx2tics
?commands show mx2tics
?set mx2tics
?unset mx2tics
?show mx2tics
?mx2tics
?nomx2tics
 x2 (上) 軸の小目盛り刻みの印は `set mx2tics` で制御されます。以下参照:
 `set mxtics`。
3 mxtics
?commands set mxtics
?commands unset mxtics
?commands show mxtics
?set mxtics
?unset mxtics
?show mxtics
?mxtics
?nomxtics
 x 軸の小目盛り刻みの印は `set mxtics` で制御されます。`unset mxtics`
 によってそれを表示させなくすることが出来ます。同様の制御コマンドが各軸
 毎に用意されています。

 書式:
       set mxtics {<freq> | default}
       unset mxtics
       show mxtics

 これらの書式は `mytics`, `mztics`, `mx2tics`, `my2tics`, `mcbtics` に
 対しても同じです。

 <freq> は大目盛り間の、小目盛りによって分割される区間の数 (小目盛りの
 数ではありません) です。通常の線形軸に対してはデフォルトの値は 2 か 5
 で、これは大目盛りによって変化します。よって大目盛り間に 1 つ、または
 4 つの小目盛りが入ることになります。`default` を指定することによって小
 目盛りの数はデフォルトの値に戻ります。

 軸が対数軸である場合、分割区間の数はデフォルトでは有意な数にセットされ
 ます (10 個の長さを元にして)。<freq> が与えられていればそちらが優先さ
 れます。しかし、対数軸では通常の小目盛り (例えば 1 から 10 までの 2, 3,
 ..., 8, 9 の刻み) は、9 つの部分区間しかありませんが、<freq> の設定は
 10 とすることでそうなります。

 小目盛りを任意の位置に設定するには、("<label>" <pos> <level>, ...) の
 形式を `set {x|x2|y|y2|z}tics` で使用してください。ただし、<label> は
 空 ("") で、<level> を 1 にします。

 コマンド `set m{x|x2|y|y2|z}tics` は、大目盛りが一様の間隔の場合にのみ
 働きます。もし全ての大目盛りが `set {x|x2|y|y2|z}tics` によって手動で
 配置された場合は、この小目盛りのコマンドは無視されます。自動的な大目盛
 りの配置と手動の小目盛りの配置は、`set {x|x2|y|y2|z}tics` と
 `set {x|x2|y|y2|z}tics add` とを使うことで共存できます。

 例:
       set xtics 0, 5, 10
       set xtics add (7.5)
       set mxtics 5
 この場合、大目盛りは 0,5,7.5,10、小目盛は 1,2,3,4,6,7,8,9 の場所
       set logscale y
       set ytics format ""
       set ytics 1e-6, 10, 1
       set ytics add ("1" 1, ".1" 0.1, ".01" 0.01, "10^-3" 0.001, \
                      "10^-4" 0.0001)
       set mytics 10
 この場合、大目盛りは指定された書式で、小目盛は対数的に配置

 デフォルトでは小目盛りの表示は、線形軸ではオフで、対数軸ではオンになっ
 ています。その設定は、大目盛りに対する `axis|border` と `{no}mirror`
 の指定を継承します。これらに関する情報については、以下参照:
 `set xtics`。
3 my2tics
?commands set my2tics
?commands unset my2tics
?commands show my2tics
?set my2tics
?unset my2tics
?show my2tics
?my2tics
?nomy2tics
 y2 (右) 軸の小目盛り刻みの印は `set my2tics` で制御されます。以下参照:
 `set mxtics`。
3 mytics
?commands set mytics
?commands unset mytics
?commands show mytics
?set mytics
?unset mytics
?show mytics
?mytics
?nomytics
 y 軸の小目盛り刻みの印は `set mytics` で制御されます。以下参照:
 `set mxtics`。
3 mztics
?commands set mztics
?commands unset mztics
?commands show mztics
?set mztics
?unset mztics
?show mztics
?mztics
?nomztics
 z 軸の小目盛り刻みの印は `set mztics` で制御されます。以下参照:
 `set mxtics`。
3 object
?object
?commands set object
?commands show object
?set object
?show object
 コマンド `set object` は、その後の 2 次元描画すべてに表われる単一のオ
 ブジェクトを定義します。オブジェクトはいくつでも定義できます。オブジェ
 クトの型は、現在は `rectangle` (長方形)、`circle` (円)、`ellipse`
 (楕円) をサポートしています。長方形は、コマンド `set style rectangle`
 によって設定されたスタイルの属性の組 (塗り潰し、色、境界) をデフォルト
 として受け継ぎますが、個々のオジェクトを別々のスタイル属性で描画するこ
 とももちろん可能です。円と楕円は、`set style fill` による塗り潰しスタ
 イルを受け継ぎます。

 書式:
     set object <index>
         <object-type> <object-properties>
         {front|back|behind} {fc|fillcolor <colorspec>} {fs <fillstyle>}
         {default} {lw|linewidth <width>}

 <object-type> は、`rectangle`, `ellipse`, `circle`, `polygon` のいずれ
 かです。個々のオブジェクトの型は、その型に特有の性質もいくつか持ってい
 ます。

 `front` を指定すると、オブジェクトはすべての描画要素の前 (上) に描画さ
 れますが、`front` と指定されたラベルよりは後ろ (下) になります。`back`
 を指定すると、すべての描画要素、すべてのラベルの後ろに配置されます。
 `behind` は、軸や `back` の長方形を含むすべてのものの後ろに配置されま
 す。よって、
     set object rectangle from screen 0,0 to screen 1,1 behind
 は、グラフやページ全体の背景に色をつけるのに利用できます。

 オブジェクトの塗り潰しの色は <colorspec> で指定します。`fillcolor` は
 `fc` と省略できます。塗り潰しスタイルは <fillstyle> で指定します。詳細
 は、以下参照: `colorspec`, `fillstyle`。キーワード `default` を指定す
 ると、これらの属性は描画が実際に行われるときのデフォルトの設定を受け継
 ぎます。以下参照: `set style rectangle`。
4 rectangle
?rectangle
?commands set object rectangle
?commands show object rectangle
?set object rectangle
?show object rectangle
 書式:
     set object <index> rectangle
         {from <position> {to|rto} <position> |
          center <position> size <w>,<h> |
          at <position> size <w>,<h>}

 長方形の位置は、対角に向かい合う 2 つの頂点 (左下と右上) の位置、ある
 いは中心点の位置と横幅 (<w>) と縦幅 (<h>) で指定できます。いずれの場合
 も点の位置は、軸の座標 (`first`, `second`)、グラフ領域内の相対座標
 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用できます
 (以下参照: `coordinates`)。オプション `at` と `center` は同じ意味です。

 例:
     # 座標軸で囲まれた領域全体の背景を水色に
     set object 1 rect from graph 0, graph 0 to graph 1, graph 1 back
     set object 1 rect fc rgb "cyan" fillstyle solid 1.0

     # 左下角が 0,0, 右上角が 2,3 の赤い四角を一つ置く
     set object 2 rect from 0,0 to 2,3 fc lt 1

     # 青い境界の空 (塗り潰さない) 長方形を置く
     set object 3 rect from 0,0 to 2,3 fs empty border rgb "blue"

     # 頂点は移動しないまま、塗り潰しと色をデフォルトに変更
     set object 2 rect default
4 ellipse
?ellipse
?commands set object ellipse
?commands show object ellipse
?set object ellipse
?show object ellipse
 書式:
     set object <index> ellipse {at|center} <position> size <w>,<h>
         {angle <orientation>}
         {<other-object-properties>}

 楕円の位置は、中心を指定し、その後ろに幅と高さ (長軸と短軸) を指定しま
 す。キーワード `at` と `center` は同じ意味です。中心の位置の指定には、
 軸の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリ
 ーン座標 (`screen`) のいずれかを使用できます (以下参照: `coordinates`)。
 長軸と短軸の長さは、軸の座標で与えなければいけません。楕円の向き
 (orientation) は、水平軸と楕円の最初の軸との間の角度で指定します。
 注意: x 軸と y 軸の縮尺が合っていない場合、回転後の長軸と短軸の比は正
 しくはなりません。これは、gnuplot の今後の版で修正されるでしょう。

 `set object ellipse size <2r>,<2r>` と `set object circle <r>` とは、
 一般には同じことにはならないことに注意してください。circle の半径は常
 に x 軸の単位で計られ、よって x 軸と y 軸の縮尺が違ったり、描画のアス
 ペクト比が 1 でなくても、常に円が生成されます。`set object ellipse` で
 は、最初の '2r' は x 軸の単位で、後ろの '2r' は y 軸の単位で計られます
 ので、こちらは x 軸と y 軸の縮尺が同じで、かつ描画のアスペクト比が 1
 である場合のみ円が生成されることになります。

4 circle
?circle
?commands set object circle
?commands show object circle
?set object circle
?show object circle
 書式:
     set object <index> circle {at|center} <position> size <radius>
         {arc [<begin>:<end>]}
         {<other-object-properties>}

 円の位置は、中心を指定し、その後ろに半径を指定します。キーワード `at`
 と `center` は同じ意味です。その位置と半径には、x 軸の座標、グラフ領域
 内の相対座標 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用でき
 ます (以下参照: `coordinates`)。そのいずれの場合でも、半径は軸、グラフ、
 スクリーンの水平方向の縮尺に対して計られ、水平方向と垂直方向の縮尺にず
 れがあっても、結果が常に正しく円になるように直されます。

 デフォルトでは、完全な円が描画されます。オプションの `arc` に開始角と
 終了角を度を単位として指定すると円弧を描画します。円弧は、常に反時計回
 りに描かれます。

4 polygon
?polygon
?commands set object polygon
?commands show object polygon
?set object polygon
?show object polygon
 書式:
     set object <index> polygon
         from <position> to <position> ... {to <position>}
 または
         from <position> rto <position> ... {rto <position>}

 多角形の位置は、頂点の位置の列を与えることで指定できます。それらは、軸
 の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリー
 ン座標 (`screen`) のいずれかを使用できます。相対的な座標 (rto) を指定
 する場合は、その座標系は前の頂点と同じ座標系でなければいけません。以下
 参照: `coordinates`。

 例:
     set object 1 polygon from 0,0 to 1,1 to 2,0
     set object 1 fc rgb "cyan" fillstyle solid 1.0 border lt -1

3 offsets
?commands set offsets
?commands unset offsets
?commands show offsets
?set offsets
?unset offsets
?show offsets
?offsets
?nooffsets
 オフセットは、自動縮尺されたグラフの中のデータの周りに空の境界を置く仕
 組みを提供します。オフセットは、x1,y1 軸と 2 次元の `plot` コマンドの
 みで意味を持ちます。

 書式:
       set offsets <left>, <right>, <top>, <bottom>
       unset offsets
       show offsets

 各オフセットは定数、または数式が使え、それらのデフォルトの値は 0 です。
 デフォルトでは、左右のオフセットは x1 軸と同じ単位で指定し、上下のオフ
 セットは y1 軸と同じ単位で指定しますが、キーワード "graph" を用いるこ
 とで軸の全範囲に対する割合としてオフセットを指定することもできます。正
 のオフセットの値は、軸の範囲を指定された方向へ伸ばします。例えば正の下
 方向のオフセットは y の最小値をより小さな値にします。許されている範囲
 での負のオフセットは、自動縮尺、あるいはクリッピングとの思いもよらぬ結
 果を生む可能性があります。自動縮尺機能から軸の範囲の調節を守りたい場合
 は、"set auto fix" も指定するといいでしょう。

 例:
       set auto fix
       set offsets graph 0.05, 0, 2, 2
       plot sin(x)

 この sin(x) のグラフの y の範囲は [-3:3] になります。それは、関数の
 y の範囲は [-1:1] に自動縮尺されますが、垂直方向のオフセットがそれぞ
 れ 2 であるためです。x の範囲は [-11:10] になりますが、これはデフォ
 ルトが [-10:10] でその全範囲が左に 0.05 の割合だけ伸ばされるためです。
3 origin
?commands set origin
?commands show origin
?set origin
?show origin
?origin
 コマンド `set origin` はスクリーン上で曲面描画の原点を指定 (すなわち、
 グラフとその余白) するのに使用します。その座標系はスクリーン座標系
 (`screen`) で与えます。この座標系に関する情報については、以下参照:
 `coordinates`。

 書式:
       set origin <x-origin>,<y-origin>
3 output
?commands set output
?commands show output
?set output
?show output
?output
?output file
 デフォルトでは、グラフは標準出力に表示されます。コマンド `set output` は
 その出力を指定されたファイルやデバイスにリダイレクトします。

 書式:
       set output {"<filename>"}
       show output

 ファイル名は引用符で囲まなければなりません。ファイル名が省略された場合
 は、直前の `set output` で開かれたファイルがクローズされ、新たな出力が
 標準出力 (STDOUT) に送られます。(もし、`set output "STDOUT"` とすると
 出力は "STDOUT" という名前のファイルに送られるかもしれません ! ["かも
 しれない" というのは、例えば `x11` や `wxt` などの terminal (出力形式)
 では `set output` が無視されるからです。])

 `set terminal` と `set output` の両方を指定する場合、`set terminal` を
 先に指定する方が安全です。それは、ある種の terminal では、OS が必要と
 するフラグをセットすることがあるからです。例えば、OS がファイルを開く
 ときに (礼儀良く) ファイルがフォーマットされているかどうかを知る必要が
 あるような OS などがそれ該当します。

 popen 関数を持つようなマシン (Unix 等) では、ファイル名の最初を '|' と
 することにより、出力をシェルコマンドにパイプで渡すことが可能です。例え
 ば以下の通りです:

       set output "|lpr -Plaser filename"
       set output "|lp -dlaser filename"

 MSDOS では、`set output "PRN"` とすると標準のプリンタに出力されます。
 VMS では出力は任意のスプール可能なデバイスに送ることが出来ます。出力を
 DECnet 透過なタスクに送ることも可能で、それはある種の柔軟性を与えてく
 れます。
3 parametric
?commands set parametric
?commands unset parametric
?commands show parametric
?set parametric
?unset parametric
?show parametric
?parametric
?noparametric
 `set paramaetric` コマンドは `plot` および `splot` の意味を通常の関数描
 画から媒介変数表示 (parametric) 関数描画に変更します。`unset parametric`
 を使えば元の描画モードに戻ります。

 書式:
       set parametric
       unset parametric
       show parametric

 2 次元グラフにおいては、媒介変数表示関数はひとつの媒介変数に対する 2
 つの関数で定められます。例としては plot sin(t),cos(t) とすることによっ
 て円が描けます (アスペクト比が正しく設定されていれば。以下参照:
 `set size`)。`gnuplot` は、両方の関数が媒介変数による `plot` のために
 与えられていなければエラーメッセージを出します。

 3 次元グラフにおいては面は x = f(u,v), y = g(u,v), z = h(u,v) で定め
 られます。よって 3 つの関数を組で指定する必要があります。例としては、
 `cos(u)*cos(v),cos(u)*sin(v),sin(u)` とすることによって球面が描けます。
 `gnuplot` は、3 つ全部の関数が媒介変数による `splot` のために与えられ
 ていなければエラーメッセージを出します。

 これによって表現できる関数群は、単純な f(x) 型の関数群の内包することに
 なります。なぜならば、2 つ (3 つ) の関数は x, y (, z) の値を独立に計算
 する記述ができるからです。実際、t,f(t) のグラフは、一番目の関数のよう
 な恒等関数を用いて x の値が計算される場合に f(x) によって生成されるグ
 ラフと等価です。同様に、3 次元での u,v,f(u,v) の描画は、f(x,y) と等価
 です。

 媒介変数表示関数は、x の関数、y の関数 (、z の関数)の順に指定し、それ
 らは共通の媒介変数およびその変域で定義されることに留意して下さい。

 さらに、`set parametric` の指定は、新しい変数変域を使用することを暗に
 宣言します。通常の f(x) や f(x,y) が xrange、yrange (、zrange) を使用
 するのに対して、媒介変数モードではそれに加えて、trange, urange, vrange
 を使用します。これらの変域は `set trange`, `set urange`, `set vrange`
 によって直接指定することも、`plot` や `splot` で指定することもできます。
 現時点では、これらの媒介変数のデフォルトの変域は [-5:5] となっています。
 将来的にはこれらのデフォルト値をもっと有意なものに変更する予定です。
3 plot
?commands show plot
?show plot
 コマンド `show plot` は現在の描画コマンド、すなわち `replot` コマンド
 で再現される、直前に行われた `plot` や `splot` コマンドを表示します。

 さらにコマンド`show plot add2history` は、この現在の描画コマンドを
 `history` に書き出します。これは、`replot` を使って直前の描画コマンド
 に曲線を追加した場合、そしてコマンド行全体をすぐに編集したい場合に便利
 です。
3 pm3d
?commands set pm3d
?commands show pm3d
?set pm3d
?show pm3d
?pm3d
 pm3d は `splot` の一つのスタイルで、パレットに割り付けられた 3 次元、
 4 次元データを、カラー/灰色の色地図/曲面として描画します。これは pm3d
 アルゴリズムを用いていて、これはデータが格子状であっても、データ走査毎
 に点の数が違っているような非格子状のデータであっても、前処理することな
 く描画できます。

 カラー曲面の描画は、`palette` で指定した色割当による多角形の塗りつぶし
 をサポートしている出力形式で行えます。現在サポートしている出力形式には
 以下のものが含まれます。

   画像出力ドライバ:
     OS/2 Presentation Manager
     X11
     Linux VGA (vgagl)
     GGI
     Windows
     AquaTerm (Mac OS X)
     wxWidgets (wxt)
   画像ファイル出力ドライバ:
     PostScript
     pslatex, pstex, epslatex
     gif, png, jpeg
     (x)fig
     tgif
     cgm
     pdf
     svg
     emf

 まず、地図/曲面がどのように描かれるのかについて記述します。入力データ
 は、関数を評価して得られるかまたは `splot data file` から得られます。
 曲面は、走査 (孤立線) の繰り返しで構成されます。pm3d アルゴリズムでは、
 最初の走査で検出された隣り合う 2 点と、次の走査で検出された他の 2 点の
 間の領域が、これら 4 点の z の値 (または追加された 'color' 用の列の値、
 以下参照: `using`) に従って灰色で (または カラーで) 塗られます。デフォ
 ルトでは 4 つの角の値の平均値が使われますが、それはオプション
 `corners2color` で変更できます。それなりの曲面を描くためには、隣り合う
 2 点の走査が交差してはいけなくて、近接点走査毎の点の数が違いすぎてはい
 けません。もちろん、最も良いのは走査の点の数が同じことです。他には何も
 必要ではありません (例えばデータは格子状である必要もない)。他にもこの
 pm3d アルゴリズムは、入力された (計測された、あるいは計算された) 領域
 の外には何も描かない、という長所があります。

 曲面の色づけは、以下のような入力データに関して行われます:

 1. 関数、または 1 つか 3 つのデータ列からなるデータの splot: 上に述べ
 た四辺形の 4 つの角の z 座標の平均値 (または `corners2color`) から、灰
 色の範囲 [0:1] を与える `zrange` または `cbrange` の範囲
 [min_color_z,max_color_z] への対応により、灰色/カラーの値が得られます。
 この値は、直接灰色の色地図用の灰色の値として使うことができます。正規化
 された灰色の値をカラーに対応させることもできます。完全な説明は、以下参
 照: `set palette`。

 2. 2 つか 4 つのデータ列からなるデータの splot: 灰色/カラーの値は、z
 の値の代わりに最後の列の座標を使って得られますので、色と z 座標が独立
 なものになります。これは 4 次元データの描画に使うことができます。

 他の注意:

 1. 物理学者の間では、gnuplot の文書やソースに現われる 'iso_curve' (孤
 立線) という言葉よりも、上で言及した '走査 (scan)' という言葉の方が使
 われています。1 度の走査と他の走査の記録により色地図を評価する、という
 のはそういう意味です。

 2. 'gray' や 'color' の値 (scale) は、滑らかに変化するカラーパレットへ
 の、連続な変数の線形写像です。その写像の様子は描画グラフの隣に長方形で
 表示されます。この文書ではそれを "カラーボックス (colorbox)" と呼び、
 その変数をカラーボックス軸の変数と呼びます。以下参照: `set colorbox`,
 `set cbrange`。

 3. pm3d の色づけを 3 次元曲面ではなく 2 次元描画に使うには、
 `set view map` か `set pm3d map` を使用してください。

 書式 (オプションは任意の順で与えることができます):
       set pm3d
       set pm3d {
                  { at <bst combination> }
                  { interpolate <steps/points in scan, between scans> }
                  { scansautomatic | scansforward | scansbackward | depthorder }
                  { flush { begin | center | end } }
                  { ftriangles | noftriangles }
                  { clip1in | clip4in }
                  { corners2color { mean|geomean|median|min|max|c1|c2|c3|c4 } }
                  { hidden3d <linestyle> | nohidden3d }
                  { implicit | explicit }
                  { map }
                }
       show pm3d
       unset pm3d

 データまたは関数の描画スタイル (`style`) がグローバルに、または `with`
 オプションで pm3d に設定されている場合、色付きの曲面が描画されます。
 オプション `implicit` が有効になっている場合、pm3d の曲面は線分による
 曲面の網目による表示も一緒に行なわれます。詳しいことは、この節の下の方
 をご覧ください。

 色の曲面は底面か天井 (この場合は灰色/カラーの平面地図) か曲面上の点の
 z 座標 (灰色/カラー曲面) に描くことができます。その選択は、オプション
 `at` に、`b`, `t`, `s` の 6 つまでの組合せの文字列をつけて指定すること
 で行えます。例えば `at b` は底面のみに描画しますし、`at st` は最初に曲
 面に描いて次に天井面に色地図を描きますし、`at bstbst` は ... 真面目な
 話、こんなものは使いません。

 塗られた四辺形は、次から次へと描画されて行きます。曲面を描画する場合
 (`at s`)、後の四辺形が前のものに重なり (上書きし) ます (gnuplot は塗ら
 れた多角形の網の重なりの相互作用を計算するような仮想現実ツールではあり
 ません)。 最初に走査されるデータを最初に描くか最後に描くかを切替えるス
 イッチオプション `scansforward` と `scansbackward` を試してみてくださ
 い。デフォルトは `scansautomatic` で、これは gnuplot 自身に走査の順を
 推測させます。一方で、オプション `depthorder` は四辺形の順序を完全に再
 構成します。塗りつぶしは深さ順に並び変えされた後で行われ、これによりか
 なり複雑な曲面でも視覚的なものにすることができます。詳細は、以下参照:
 `pm3d depthorder`。

 2 回の連続する走査で点の数が同じでなかった場合、四辺形の点の取り始めを、
 両方の走査の最初から (`flush begin`) にするか、最後から (`flush end`)
 にするか、真中から (`flush center`) にするかを決定しなければいけません。
 `flush (center|end)` は `scansautomatic` とは両立せず、よって
 `flush center` または `flush end` を指定して `scansautomatic` が設定さ
 れた場合、それは無言で `scansforward` に変更されます。

 2 回の連続する走査で点の数が同じでなかった場合、個々の走査で点が足りな
 い場合に、走査の最後に色三角形を描くかどうかをオプション `ftriangles`
 は指示します。これは滑らかな色地図の境界を描くのに使われます。

 四辺形の x,y 座標に関するクリッピングは 2 つの方法で行われます。
 `clip1in`: 各四辺形の全ての 4 点が定義されていなければならず、少なくと
 もそのうちの 1 点が x, y の範囲におさまっていなければなりません。
 `clip4in`: 各四辺形の全ての 4 点が x, y の範囲におさまっていなければな
 りません。

 描画される各 pm3d 四辺形には一つの灰色/カラー値が対応します (4 頂点間
 で滑らかなカラー変化は起こりません)。その値は、`corners2color <option>`
 に従って周囲の角の z 座標から計算されます。<option> は 'mean' (デフォ
 ルト)、'geomean', 'median' で、曲面のカラーの平滑化に幾つかの種類を与
 え、'min','max' はそれぞれ最小値、最大値を選択します。これらは鋭敏な、
 あるいは急激なピーク値を持つようなピクセルイメージや色地図を作るときに
 は必要ありません。そのような場合には、むしろオプション 'c1', 'c2',
 'c3', 'c4' を使って、四辺形の色の割当にただ一つの角の z 座標を使うよう
 にすればいいでしょう。どの角が 'c1' に対応するのかを知るためには何回か
 実験してみる必要があるでしょう。その向きは描画の方向に依存しています。
 pm3d アルゴリズムは、カラー曲面を入力データ点の範囲の外には描かないの
 で、オプション 'c<j>' は、格子の 2 つのへりに沿ったピクセルが、どの四
 辺形の色にも寄与しない、という結果をもたらします。例えば、pm3d アルゴ
 リズムを 4x4 のデータ点の格子に適用するスクリプト `demo/pm3d.dem` (是
 非見てください) では、(4-1)x(4-1)=9 色しかない長方形が生成されます。

 与えられた節点に対して、その周りの 4 つの節点の平均化された (x,y) 座標
 から角を得て四辺形を作って、その四辺形を節点の色で塗る、といったような
 他の描画アルゴリズムが将来実装されるかもしれません。
 これは、イメージの描画 (2 次元の格子) に対しては `image` と `rgbimage`
 スタイルによって既に行なわれています。

 z の値の範囲と曲面の色の値の範囲は、z と cb に関する `set log` 同様、
 `set zrange` と `set cbrange` によって独立に調整し得ることに注意して
 ください。色地図は cb 軸のみで調節されます。以下も参照: `set view map`,
 `set colorbox`。

 オプション `hidden3d` は、線種 (linestyle) を引数に取りますが、それは
 `set style line ...` で生成しなければなりません (その線種は pm3d の設
 定時には存在している必要はありませんが、描画時には必要です)。これが設
 定されると、線は隠線処理を考慮に入れながら、指定された線種で描画されま
 す。これは、`set hidden3d` コマンドを使うよりもはるかに効果的で、これ
 は実際に隠線処理を計算することはしませんが、塗りつぶされた多角形を正し
 い順序で描いて行きます。よって、pm3d を使う場合のお勧めの選択は以下の
 通りです:
       set pm3d at s hidden3d 100
       set style line 100 lt 5 lw 0.5
       unset hidden3d
       unset surf
       splot x*x+y*y

 従来、このコマンドに {transparent|solid} のオプションが用意されていま
 したが、現在はそれらはそれぞれ `set grid {front|layerdefault}` で行な
 うことができます。

 `set pm3d map` は `set pm3d at b`; `set view map`; `set style data pm3d`;
 `set style func pm3d`; を省略したものです。これは、`set view map` がな
 かったころの旧バージョンへの互換性のためのものです。入力データ点をフィ
 ルタするための `zrange`、および色の範囲の変更用の `cbrange` を注意して
 適切に使用してください。`set (no)surface` も 効果 (副作用 ?) があるよ
 うです。

 オプション `interpolate m,n` は、格子点をより細かな網目に補間し、色四
 角形も近似的に補間します。データ描画に対しては、これは曲面の色の変化を
 滑らかにし、曲面の色の尖りを補正します。関数描画に対しては、この補間は
 細かさの代わりにメモリを消費してしまう、といったことくらいの意味しかあ
 りませんから、関数描画の場合は普通 `samples` や `isosamples` を使うべ
 きでしょう。正の m, n に対しては、各四辺形、または三角形は、それぞれの
 方向に m 回、n 回補間されます。負の m, n では補間の頻度は、少なくとも
 |m|, |n| 点が描画されるように選択されます。これは特別な格子関数と見な
 すことができます。0 の場合、すなわち `interpolation 0,0` は、自動的に
 最適な補間曲面点数を選択します。

 色づけの設定はカラーボックスの描画と同様に `set palette` で決定されま
 す。一つの描画では一つのパレットのみが存在し得ます。いくつもの曲面を
 異なるパレットで描画するには、`origin` と `size` を固定して `mutiplot`
 を使うことで行えます。出力ドライバが利用できる色を使い尽くしてしまう場
 合には `set palette maxcolors` を使うことを忘れずに。

 gnuplot の起動時はモードは `explicit` になっています。歴史的な、よって
 互換性のために、コマンド `set pm3d;` (すなわちオプションを指定しない場
 合) と `set pm3d at X ...` (すなわち `at` が最初のオプションの場合) は
 モードを `implicit` に設定します。`set pm3d;` はさらにその他のオプショ
 ンをデフォルトの値に設定します。

 オプション `implicit` が ON の場合、全ての曲面の描画が追加的にデフォル
 トの型で行われます。例えば
       splot 'fred.dat' with lines, 'lola.dat' with lines
 は、両方の描画 (網目の曲面) を追加的に pm3d 曲面に描きます。`set pm3d;`
 の後はこちらの方が慣れているでしょう。

 オプション `explicit` が ON (または `implicit` が OFF) の場合、属性
 `with pm3d` が指定された描画のみが pm3d 曲面として描画されます。例えば
       splot 'fred.dat' with lines, 'lola.dat' with pm3d
 は、'freq.dat' は線で (線のみで) 描画され、'lola.dat' は pm3d 曲面とし
 て描かれます。

 デフォルトのデータ/関数の描画スタイルを `pm3d` にしたい場合は、例えば
       set style data pm3d
 とします。この場合、オプション `implicit` と `explicit` は効力を持ちま
 せん。

 いくつかの描画においては、それらはコマンドラインで与えられた順に描画さ
 れることに注意してください。これは特に、以前の描画を上書きしてそれで一
 部を隠してしまう可能性がある、曲面の塗りつぶしに関して関心を持たれるこ
 とです。

 `splot` コマンドライン上で `with pm3d` が指定されている場合はオプショ
 ン `at` も使えます。以下の描画は、異なった高さで 3 つのカラー曲面を描き
 ます:
       set border 4095
       set pm3d at s
       splot 10*x with pm3d at b, x*x-y*y, x*x+y*y with pm3d at t

 以下も参照: `set palette`, `set cbrange`, `set colorbox`, `x11 pm3d`。
 そしてもちろんデモファイル `demo/pm3d.dem` も参考になるでしょう。
4 depthorder
?commands set pm3d depthorder
?set pm3d depthorder
?pm3d depthorder
?depthorder
 デフォルトでは、pm3d の塗り潰し曲面を構成する四角形は、それらが曲面の
 格子点に沿って出会う順番に塗り潰されます。この順番は、オプション
 `scansautomatic`|`scansforward`|`scansbackward` で制御できます。これら
 の走査 (scan) オプションは、一般には隠面処理とは両立しません。

 gnuplot は、曲面の塗り潰しにおいては、本当の隠面処理は行いませんが、た
 いていは遠い方から近い方へ順に四角形要素を塗り潰すことで十分なできあが
 りになります。このモードは、以下のオプションを使うことで選択できます:
       set pm3d depthorder hidden3d
 オプション `depthorder` は塗り潰し四角形への指示で、オプション
 `hidden3d` は同様に境界線 (もし描くなら) への指示です。大域的なオプシ
 ョンである `set hidden3d` は、pm3d 曲面には影響しないことに注意してく
 ださい。
3 palette
?commands set palette
?commands show palette
?set palette
?show palette
?palette
 パレットは、`pm3d` で、カラー等高線や多角形、カラーヒストグラム、色勾
 配の背景、その他実装されている、あるいは実装されるものの塗りつぶしで使
 われる、色の記憶場所です。ここではそれは滑らかで "連続的な" カラーや灰
 色階調のパレットを意味しますが、それを単にパレットと呼ぶことにします。

 カラーパレットは、多角形の色の塗りつぶしと滑らかな色のパレットをサポー
 トした出力形式を必要とし、それは現在、`pm3d` で一覧表示される出力形式
 で使用可能です。色の値の範囲は、`set cbrange` と `set log cb` で独立に
 調整可能です。カラーパレット全体は `colorbox` 中に表示されます。

 書式:
       set palette
       set palette {
                  { gray | color }
                  { gamma <gamma> }
                  {   rgbformulae <r>,<g>,<b>
                    | defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }
                    | file '<filename>' {datafile-modifiers}
                    | functions <R>,<G>,<B>
                  }
                  { model { RGB | HSV | CMY | YIQ | XYZ } }
                  { positive | negative }
                  { nops_allcF | ps_allcF }
                  { maxcolors <maxcolors> }
                }
       show palette
       show palette palette <n> {{float | int}}
       show palette gradient
       show palette fit2rgbformulae
       show palette rgbformulae
       show colornames

 `set palette` は (すなわちオプションなしでは) デフォルトの値を設定しま
 す。それ以外の場合、オプションは任意の順に与えることができます。
 `show palette` は、現在のパレットの属性を表示します。

 `show palette gradient` は、パレットの勾配 (gradient) の定義が (それが
 適切であれば) 表示されます。`show palette rgbformulae` は、定義済で利
 用できる、灰色値からカラーへの変換公式が表示されます。
 `show colornames` は、認識できる色名を表示します。

 `show palette palette <n>` は、<n> 個の離散的な色を持つパレットの、現
 在のパレットの設定によって計算される RGB の値の組とパレットの表を、画
 面、または `set print` で指定されたファイルに書き出します。デフォルト
 の広い表は、追加のオプション float または int によって、3 列の [0..1]
 の実数値だけにするか [0..255] の整数値だけにするかをそれぞれ指定できま
 す。この方法で gnuplot のカラーパレットを、Octave のような他の画像アプ
 リケーションに渡すことができます。このようなテキスト形式の RGB の一覧
 表に加え、`test palette` コマンドにより、現在のパレットの R,G,B の状態
 を描画させることもできます。

 以下のオプションは、色付けの属性を決定します。

 このパレットを使用する図は、`gray` か `color` になります。例えば、
 `pm3d` カラー曲面では、範囲 [min_z,max_z] が灰色の範囲 [0:1] に対応し
 ていて、微小曲面四辺形の 4 つの角の z 座標の平均値をこの範囲の中に対応
 させることで各微小部分の灰色の値 (gray) が得られます。この値は、灰色階
 調の色地図での灰色の値として直接使うことができますし、カラーの色地図で
 は、その灰色の値から (R,G,B) への変換、すなわち [0:1] から
 ([0:1],[0:1],[0:1]) への写像が使われます。

 基本的に、2 種類の異なる写像方式が利用可能です: 1 つは灰色からカラーへ
 の解析的な公式、もう一つは離散的な対応表の補間によるものです。
 `palette rgbformulae` と `palette functions` が解析的な公式用で、
 `palette defined` と `palette file` が補間表用です。`palette rgbformulae`
 は postscript 出力のサイズを小さくすることができます。

 コマンド `show palette fit2rgbformulae` は、現在の `set palette` に最
 も良く対応する `set palette rgbformulae` を見つけ出します。当然、それ
 は rgbformulae パレット以外に対しても意味を持ちます。このコマンドは主
 に、パレットの rgbformulae 定義が gnuplot と同じ物を使っている外部プロ
 グラム、例えば zimg などにとって有用です (
^ <a href="http://zimg.sourceforge.net">
           http://zimg.sourceforge.net
^ </a>
 )。

 `set palette gray` は、灰色階調のみのパレットにし、
 `set palette rgbformulae`, `set palette defined`, `set palette file`,
 `set palette functions` はカラーパレットにします。灰色パレットから直前
 のカラーパレットへ、`set palette color` で簡単に復帰できます。

 `set palette gamma <gamma>` による自動的なガンマ補正は、灰色のパレット
 (`set palette gray`) のみに行われます。灰色階調への線形写像は gamma=1
 に相当します (以下参照: `test palette`)。カラーパレットに対してはガン
 マ値は無視されます。

 ほとんどの出力形式は、有限個の色数しかサポートしていません (例えば gif
 では 256 個)。デフォルトでは、パレットは、gnuplot のデフォルトの線種の
 色の宣言の後に残ったものが全て pm3d 用に割り当てられます。よって、出力
 形式が利用できる色の場所がなくなってしまった場合、`multiplot` は失敗し
 てしまうでしょう。その場合、`set palette maxcolors <maxcolors>` で適当
 に小さい値を設定すべきです。このオプションは、z=定数の高低を離散個に分
 割し、よって等高線の疑似的な塗りつぶしを行うことにも使えます。デフォル
 トの値は 0 で、これは出力形式のパレットの残りの全てを割り当てる、ある
 いは正確な RGB への対応を使用することを意味します。

 RGB 色空間が作業を行うのに常にもっとも有用な色空間であるとは限らない、
 という理由で、色空間は `model` を使うことで、`RGB`, `HSV`, `CMY`,
 `YIQ`, `XYZ` のいずれかに変更できます。RGB 以外の色空間では
 `set palette defined` の表で色名を使うと、それはおかしな色になります。
 全ての説明は RGB 色空間用に書いてありますが、それぞれの色空間で、例え
 ば `R` は `H`, `C`, `Y`, `X` のことを意味することに注意してください
 (`G`, `B` も同様)。

 全ての色空間で、全ての値は [0,1] に制限されています。

 RGB は赤、緑、青を、CMY は水色 (Cyan)、紫 (Magenta)、黄 (Yellow) を、
 HSV は色相 (Hue)、彩度 (Saturation)、明度 (Value) をそれぞれ意味します。
 YIQ は 全米商業カラーテレビ放送協会 (the U.S. Commercial Color
 Television Broadcasting) の使ったカラーモデルで、RGB 記録方式を元にし
 ていますが、白黒テレビに対する後方互換性を持っています。XYZ は CIE
 ('Commission Internationale de l'Eclairage'; 国際照明委員会) が定義し
 た色モデルの 3 つの原刺激値です。
 色モデルのより詳しい情報については以下を参照してください:
^ <a href="http://en.wikipedia.org/wiki/Color_space">
           http://en.wikipedia.org/wiki/Color_space
^ </a>

4 rgbformulae
?commands set palette rgbformulae
?set palette rgbformulae
?palette rgbformulae
?rgbformulae
=colors
 `rgbformulae` 用には 3 つの適切な割り当て関数が選ばれる必要があります。
 この選択は `rgbformulae <r>,<g>,<b>` を通して行われます。使うことがで
 きる割り当て関数の一覧は `show palette rgbformulae` で見ることができま
 す。デフォルトは `7,5,15` で、他の例としては `3,11,6`, `21,23,3`,
 `3,23,21` などがあります。`3,-11,-6` のような負の値は、逆のカラーを意
 味します (すなわち、1-gray をその関数に代入します。下記の以下参照:
 オプション `positive`, `negative`)。

 RGB の色空間では、いくつかの良い割り当て公式があります:
    7,5,15   ... 伝統的 pm3d (黒-青-赤-黄)
    3,11,6   ... 緑-赤-紫
    23,28,3  ... 海 (緑-青-白); 他の組み合わせも試してみてください
    21,22,23 ... 温度色 (黒-赤-黄-白)
    30,31,32 ... 白黒のカラー表示化 (黒-青-紫-黄-白)
    33,13,10 ... 虹 (青-緑-黄-赤)
    34,35,36 ... AFM 温度色 (黒-赤-黄-白)

 HSV 色空間でのフルカラーパレット:
    3,2,2    ... 赤-黄-緑-水色-青-紫-赤

 `rgbformulae` という名前で呼ばれていても、例の通り、それらの関数は実際
 には <H>,<S>,<V> または <X>,<Y>,<Z>, ... といった色の成分を決定するか
 もしれないということに注意してください。

 図の色を反転させるには `positive` や `negative` を使ってください。
^ <a name="positive"></a>
^ <a name="negative"></a>

 他の色体系に対する最も良い rgbformulae の集合は、以下のコマンドで見つ
 けることができることを覚えておいてください。
    show palette fit2rgbformulae
4 defined
?commands set palette defined
?set palette defined
?palette defined
=colors
 灰色から RGB への対応は `palette defined` を使うことで手動で設定できま
 す: 色勾配 (gradient) は RGB の値を与えるために定義され使用されます。
 勾配は、[0,1] の灰色値から [0,1]x[0,1]x[0,1] の RGB 空間への、区分的に
 線形な写像です。その線形補間に使われる灰色値と RGB 値の組を指定する必
 要があります:

 書式:
       set palette  defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }

 <grayX> は [0,1] に割り当てられるべき灰色値で、<colorX> はそれに対応す
 る RGB 色です。カラー値は 3 種類の方法で指定することができます:

      <color> :=  { <r> <g> <b> | '<color-name>' | '#rrggbb' }

 赤、緑、青に対応する空白で区切られた 3 つの値 (それぞれ [0,1] 内)、引
 用符でくくられた色名、または引用符でくくられた X 形式の指定方式、のい
 ずれかです。勾配の定義では、これらの 3 種の型を自由に組み合わせること
 ができますが、色空間として RGB でないものが選択された場合色名 "red" は
 少し違ったものになるでしょう。使用できる色名は `show colornames` でそ
 の一覧を見ることができます。

 <r> と書いても、HSV 色空間ではそれは <H> 成分を、CIE-XYZ 空間では <X>
 を、といったように選択されたカラーモデルに依存して意味が違うことに注意
 してください。

 <gray> の値は実数の昇順に並べる必要があります。その列の値は自動的に
 [0,1] に変換されます。

 カッコつきの勾配の定義なしで `set palette defined` とした場合、RGB 色
 空間にし、あらかじめ設定されたフルスペクトル色勾配を使用します。勾配を
 表示するには `show palette gradient` を使用してください。

 例:

 灰色のパレット (役に立たないが教訓的な) を生成するには:
       set palette model RGB
       set palette defined ( 0 "black", 1 "white" )

 青黄赤のパレット (全てが等価の) を生成するには:
       set palette defined ( 0 "blue", 1 "yellow", 2 "red" )
       set palette defined ( 0 0 0 1, 1 1 1 0, 2 1 0 0 )
       set palette defined ( 0 "#0000ff", 1 "#ffff00", 2 "#ff0000" )

 虹のようなパレットを生成するには:
       set palette defined ( 0 "blue", 3 "green", 6 "yellow", 10 "red" )

 HSV 色空間でのフルカラースペクトル:
       set palette model HSV
       set palette defined ( 0 0 1 1, 1 1 1 1 )
       set palette defined ( 0 0 1 0, 1 0 1 1, 6 0.8333 1 1, 7 0.8333 0 1)

 あまり色を使わないパレットを生成するには:
       set palette model RGB maxcolors 4
       set palette defined ( 0 "blue", 1 "green", 2 "yellow", 3 "red" )

 '交通信号' (滑らかではなく gray = 1/3, 2/3 で跳びを持つ):
       set palette model RGB
       set palette defined (0 "dark-green", 1 "green", 1 "yellow", \
                            2 "dark-yellow", 2 "red", 3 "dark-red" )

4 functions
?commands set palette functions
?set palette functions
?palette functions
 色の割り当ての R(gray), G(gray), B(gray) の 3 つの関数を与えるには
 `set palette functions <Rexpr>, <Gexpr>, <Bexpr>` を使ってください。
 それらの 3 つの関数の変数は、[0,1] の値を取る変数 `gray` であり、その
 値も [0,1] の中に取る必要があります。
 <Rexpr> は、HSV 色空間が選択されている場合は、H の値を表す式でなければ
 いけないことに注意してください (他の式、または他の色空間でも同様です)。

 例:

 フルカラーパレットを生成するには:
       set palette model HSV functions gray, 1, 1

 黒から金色への良いパレット:
       set palette model XYZ functions gray**0.35, gray**0.5, gray**0.8

 ガンマ補正の白黒のパレット:
       gamma = 2.2
       color(gray) = gray**(1./gamma)
       set palette model RGB functions color(gray), color(gray), color(gray)

4 file
?commands set palette file
?set palette file
?palette file
 `set palette file` は基本的に `set palette defined (<gradient>)` と同
 じで、この <gradient> がデータファイルから読み込まれます。4 列 (gray,
 R,G,B) かまたは 3 列 (R,G,B) のデータが `using` データファイル修飾子に
 よって選択される必要があります。3 列の場合、行番号が gray の値として使
 われますが、その gray の範囲は自動的に [0,1] にスケール変換されます。
 ファイルは通常のデータファイルとして読まれるので、全てのデータファイル
 修飾子が使えます。
 例えば HSV 色空間が選択されている場合には、`R` は実際には `H` を指すと
 いうことに注意してください。

 例によって、<filename> が `'-'` の場合は、データがインライン形式で引き
 続いて与えられ、一つの `e` のみの行でそれが終了することを意味します。

 勾配 (gradient) を表示するには `show palette gradient` を使用してくだ
 さい。

 例:

 RGB のパレットを [0,255] の範囲で読み込む:
       set palette file 'some-palette' using ($1/255):($2/255):($3/255)

 等距離の虹色 (青-緑-黄-赤) パレット:
       set palette model RGB file "-"
       0 0 1
       0 1 0
       1 1 0
       1 0 0
       e

 バイナリパレットファイルも同様にサポートされています。以下参照:
 `binary general`。R,G,B の double のデータの 64 個の 3 つ組をファイル
 palette.bin に出力し、それを読み込む例:
       set palette file "palette.bin" binary record=64 using 1:2:3


4 ガンマ補正 (gamma correction)
?commands set palette gamma-correction
?set palette gamma-correction
?palette gamma-correction
?gamma-correction
 灰色の配色に対するガンマ補正は `set palatte gamma <gamma>` で ON にで
 きます。<gamma> のデフォルトは 1.5 で、これは多くの出力形式に適切な値
 です。

 カラーの配色に対しては gnuplot では自動的なガンマ補正は行いません。し
 かしガンマ補正は簡単に実装できます。ここに例として、ガンマの値の少し異
 なる赤、緑、青の成分に、明示的な関数を与えた灰色階調画像の例を紹介しま
 す。

 例:
       set palette model RGB
       set palette functions gray**0.64, gray**0.67, gray**0.70

 補間された勾配を使ってガンマ補正を行うには、適当なカラーに中間の値を指
 定します。

       set palette defined ( 0 0 0 0, 1 1 1 1 )

 の代わりに例えば以下を指定してください:

       set palette defined ( 0 0 0 0, 0.5 .73 .73 .73, 1 1 1 1 )

 または、線形補間が "ガンマ補正" の補間に十分良く適合するまでより良い中
 間の点を探してください。

4 postscript
?commands set palette postscript
?set palette postscript
 postscript ファイルのサイズを小さくする目的で、灰色の輝度値、そして全
 てではないいくつかの計算された RGB の輝度値がそのファイル中に書かれま
 す。成分関数は postscript 言語で直接コード化され、pm3d の描画の直前に
 ヘッダとしておかれます。/g や /cF の定義を参照してください。通常その定
 義をその中に書くことは、3 つの式のみが使われる場合に意味を持ちます。し
 かし、multiplot やその他の理由で postscript ファイル中のその変換関数を
 直接手で編集したいと思うかも知れません。これがデフォルトのオプション
 `nops_allcF` です。オプション `ps_allcF` を使うと、全ての公式の定義が
 postscript ファイル中に書かれます。一つのグラフ中で、異なる曲面に異な
 るパレットを持たせたいという目的で postscript ファイルを編集したい場合
 に、このオプションに関心を持つでしょう。その機能は、`origin` と `size`
 を固定して `multiplot` を使うことで実現できるでしょう。

 pm3d 色地図が、格子状、あるいはほぼ規則正しいデータから postscript フ
 ァイルとして描画された場合、gnuplot と同時に配布される awk スクリプト
 `pm3dCompress.awk` を使うことで、この postscript ファイルのサイズをほ
 ぼ 50% 位まで小さくすることができます。このファイルを文書に取り込む場
 合、あるいは低速のプリンタに大きなファイルを印刷する前などに、この機能
 に関心を持つことでしょう。使用法は以下の通りです:
     awk -f pm3dCompress.awk thefile.ps >smallerfile.ps

 pm3d 色地図が四角形の格子状データから postscript ファイルとして描画さ
 れた場合、同時に配布される awk スクリプト `pm3dConvertToImage.awk` を
 使うことで、そのサイズを更に小さくすることができます。使用法:
     awk -f pm3dConvertToImage.awk <thefile.ps >smallerfile.ps

 postscript 出力の灰色階調をカラーへ、またはその逆、そして <maxcolors>
 の定義などを、手動で変更することができます。
3 pointsize
?commands set pointsize
?commands show pointsize
?set pointsize
?show pointsize
?pointsize
 コマンド `set pointsize` は描画で使われる点の大きさを変更します。

 書式:
       set pointsize <multiplier>
       show pointsize

 デフォルトは 1.0 倍です。画像データ出力では、大きいポイントサイズの方
 が見やすいでしょう。

 一つの描画に対するポイントサイズは `plot` コマンドの上でも変更できます。
 詳細は、以下参照: `plot with`。

 ポイントサイズの設定は、必ずしも全ての出力形式でサポートされているわけ
 ではないことに注意してください。
3 polar
?commands set polar
?commands unset polar
?commands show polar
?set polar
?unset polar
?show polar
?polar
?nopolar
 コマンド `set polar` はグラフの描画方法を xy 直交座標系から極座標系に
 変更します。

 書式:
       set polar
       unset polar
       show polar

 極座標モードでは、仮変数 (t) は角度を表します。t のデフォルトの範囲は
 [0:2*pi] ですが、単位として度が選択されていれば [0:360] となります
 (以下参照: `set angles`)。

 コマンド `unset polar` は描画方法をデフォルトの xy 直交座標系に戻しま
 す。

 `set polar` コマンドは `splot` ではサポートされていません。`splot` に
 対する同様の機能に関しては、以下参照: `set mapping`。

 極座標モードでは t の数式の意味は r=f(t) となり、t は回転角となります。
 trange は関数の定義域 (角度) を制御し、xrange と yrange はそれぞれグラ
 フの x,y 方向の範囲を制御することになります。これらの範囲と rrange は
 自動的に設定されるか、または明示的に設定できます。これらすべての
 `ranges` コマンドの詳細に関しては、以下参照: `set xrange`。

 例:
       set polar
       plot t*sin(t)
       plot [-2*pi:2*pi] [-3:3] [-3:3] t*sin(t)

 最初の `plot` はデフォルトの角度の範囲の 0 から 2*pi を使います。半径
 とグラフのサイズは自動的に縮尺されます。2 番目の `plot` は角度の定義域
 を拡張し、グラフのサイズを x,y のいずれの方向にも [-3:3] に制限します。

 `set size square` とすると `gnuplot` はアスペクト比 (縦横の比) を 1 に
 するので円が (楕円でなく) 円に見えるようになります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/polar.html">
 極座標のデモ (polar.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標データの描画 (poldat.dem)。
^ </a>
3 print
?commands set print
?commands show print
?set print
?show print
 コマンド `set print` は `print` コマンドの出力をファイルにリダイレクト
 します。

 書式:
       set print
       set print "-"
       set print "<filename>"
       set print "<filename>" append
       set print "|<shell_command>"

 "<filename>" がない場合は出力は <STDERR> になります。"-" という
 <filename> は <STDOUT> を意味します。`append` フラグはファイルを追加
 (append) モードで開くことを意味します。パイプをサポートするプラットホ
 ーム上では、<filename> が "|" で始まっていたら、<shell_command> へのパ
 イプが開かれます。
3 rmargin
?commands set rmargin
?set rmargin
?rmargin
 コマンド `set rmargin` は右の余白のサイズをセットします。
 詳細は、以下参照: `set margin`。
3 rrange
?commands set rrange
?commands show rrange
?set rrange
?show rrange
?rrange
 コマンド `set rrange` は極座標モードのグラフの半径方向の範囲を設定しま
 す。詳細は、以下参照: `set xrange`。
3 samples
?commands set samples
?commands show samples
?set samples
?show samples
?samples
 関数、またはデータの補間に関するサンプリング数はコマンド `set samples`
 で変更できます。

 書式:
       set samples <samples_1> {,<samples_2>}
       show samples

 デフォルトではサンプル数は 100 点と設定されています。この値を増やすと
 より正確な描画が出来ますが遅くなります。このパラメータはデータファイル
 の描画には何の影響も与えませんが、補間/近似のオプションが使われている
 場合はその限りではありません。2 次元描画については `plot smooth` を、
 3 次元描画に関しては、以下参照: `set dgrid3d`。

 2 次元のグラフ描画が行なわれるときは <samples_1> の値のみが関係します。

 隠線処理なしで曲面描画が行なわれるときは、samples の値は孤立線毎に評価
 されるサンプル数の指定になります。各 v-孤立線は <samples_1> 個のサンプ
 ル点を持ち、u-孤立線は <samples_2> 個のサンプル数を持ちます。<samples_1>
 のみ指定すると、<samples_2> の値は <samples_1> と同じ値に設定されます。
 以下も参照: `set isosamples`。
3 size
?commands set size
?commands show size
?set size
?show size
?size
?aspect ratio
 書式:
       set size {{no}square | ratio <r> | noratio} {<xscale>,<yscale>}
       show size

 <xscale> と <yscale> は描画全体の拡大の倍率で、描画全体とはグラフとラ
 ベルと余白の部分を含みます。

 重要な注意:
       gnuplot の以前の版では、`set size` の値を、出力する描画領域
       (キャンバス) のサイズを制御するのにも使っていた出力形式もありま
       したが、すべての出力形式がそうだったわけではありませんでした。
       version 4.2 では、ほとんどの出力形式が以下のルールに従うようにな
       りました:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。サイズパラメータの有効な値に
 ついては、個々の出力形式のヘルプを参照してください。デフォルトでは、グ
 ラフはそのキャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
 形式では問題が起こるかもしれないことに注意してください。

 `ratio` は、指定した <xscale>, <yscale> の描画範囲内で、グラフのアスペ
 クト比 (縦横比) を <r> にします (<r> は x 方向の長さに対する y 方向の
 長さの比)。

 <r> の値を負にするとその意味は違って来ます。<r>=-1 のとき、x 軸、y 軸
 の双方の単位 (つまり 1) の目盛の長さが同一になるよう設定されます。(例
 えば地理データ表示に向く)。<r>=-2 のとき、y 軸の単位目盛の長さは x 軸
 の単位目盛の長さの 2 倍に設定されます。<r> が負の値に関して以下同様で
 す。

 `gnuplot` が指定されたアスペクト比のグラフをちゃんと書けるかは選択され
 る出力形式に依存します。グラフの領域は出力の指定された部分にちゃんと収
 まり、アスペクト比が <r> であるような最大の長方形となります (もちろん
 適当な余白も残しますが)。

 `square` は `ratio 1` と同じ意味です。

 `noratio` と `nosquare` はいずれもグラフをその出力形式 (terminal) での
 デフォルトのアスペクト比に戻しますが、<xscale> と <yscale> はそのデフ
 ォルトの値 (1.0) には戻しません。

 `ratio` と `square` は 3 次元描画では意味を持ちませんが、`set view map`
 を使用した 3 次元描画の 2 次元射影には影響を与えます。 以下も参照:
 `set view equal`。これは、3 次元の x 軸と y 軸を強制的に同じスケールに
 します。

 例:

 グラフが現在のキャンバスを埋めるような大きさに設定します:
       set size 1,1

 グラフを通常の半分の大きさで正方形にします:
       set size square 0.5,0.5

 グラフの高さを横幅の 2 倍にします:
       set size ratio 2

 以下も参照
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 翼のデモ。
^ </a>
3 style
?set style
?show style
?unset style
^ <a name="set style <style>"></a>
 デフォルトの描画スタイルは、`set style data` と `set style function`
 で設定できます。関数やデータのデフォルトの描画スタイルを個々に変更す
 る方法については、以下参照: `plot with`。スタイルの一覧全体は、以下参
 照: `plotting styles`。

 書式:
       set style function <style>
       set style data <style>
       show style function
       show style data

 指定できる描画要素のデフォルトスタイルも設定できます。

       set style arrow <n> <arrowstyle>
       set style fill <fillstyle>
       set style histogram <histogram style options>
       set style line <n> <linestyle>

4 set style arrow
?commands set style arrow
?commands unset style arrow
?commands show style arrow
?set style arrow
?unset style arrow
?show style arrow
?arrowstyle
^ <a name="arrowtype"></a>
^ <a name="arrowwidth"></a>
 各出力形式は矢や点の形のデフォルトの集合を持っていて、それはコマンド
 `test` で参照できます。`set style arrow` は矢の形、幅、点の形、サイズ
 を定義し、それらを後で使うときにいちいち同じ情報を繰り返して指定しなく
 てもインデックスで参照できるようにします。

 書式:
       set style arrow <index> default
       set style arrow <index> {nohead | head | heads}
                               {size <length>,<angle>{,<backangle>}}
                               {filled | empty | nofilled}
                               {front | back}
                               { {linestyle | ls <line_style>}
                                 | {linetype | lt <line_type>}
                                   {linewidth | lw <line_width} }
       unset style arrow
       show style arrow

 <index> は整数で、それで矢のスタイル (arrowstyle) を特定します。

 `default` を指定すると、全ての arrow スタイルパラメータはそのデフォル
 トの値になります。

 <index> の arrowstyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 `nohead` を指定することで、矢先のない矢、すなわち線分を書くこともでき
 ます。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1
 つの矢先がついています。`heads` の指定で線分の両端に矢先が描かれます。

 矢先の大きさは `size <length>,<angle>` または
 `size <length>,<angle>,<backangle>` で制御できます。`<length>` は矢先
 の各枝の長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
 `<length>` の単位は x 軸と同じですが、それは `<length>` の前に
 `first`, `second`, `graph`, `screen`, `character` をつけることで変更で
 きます。詳細は、以下参照: `coordinates`。`<backangle>` は、`filled` か
 または `empty` がともに使われた場合のみ効力を持ち、その場合、
 `<backangle>` は矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方向;
 単位は度) になります。出力形式 `fig` は、制限された切り角関数を持って
 いて、それは 3 つの異なる形をサポートしていて、それは 2 つの閾値で決定
 します: 70 度未満の場合、矢先はへこんだ切り角を持ち、110 度を超える場
 合、後ろの部分に尖った角を持ち、その間の角では、矢先の後ろは直線になり
 ます。

 `filled` を指定すると、塗りつぶされた矢先を作ります (`heads` が使われ
 ている場合)。塗りつぶしは、多角形の塗りつぶしが行えるような出力形式で
 サポートされていて、そのリストについては、以下参照: `pm3d`。他の出力形
 式では矢先は閉じられますが塗りつぶされません。それと同じ効果 (閉じらる
 が塗られない) は、`empty` を指定しても得られます。また、`metafont`,
 `metapost`, `latex`, `tgif` のように、矢をそれら自身の独自のルーチンで
 描くような出力形式では、矢先の塗りつぶしや矢先の枠線描きはもちろんサポ
 ートされません。

 線種はユーザの定義したラインスタイルのリストから選ぶこともできますし
 (以下参照: `set style line`)、用意されている `<line_type>` の値 (デフ
 ォルトのラインスタイルのリストの番号) そして `<linewidth>` (デフォルト
 の幅の倍数) を使ってここで定義することもできます。

 しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
 幅) は、単に他の `set style arrow` コマンドで適当な番号や `lt`, `lw`
 などを指定しても、変更はできないことに注意して下さい。

 `front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指
 定された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`
 を使えば、密集したデータで矢が見えなくなることを防ぐことができます。

 例:

 矢先がなく、倍の幅が矢を描くには:
       set style arrow 1 nohead lw 2
       set arrow arrowstyle 1

 その他の例については、以下参照: `set arrow`。

4 set style data
?commands set style data
?commands show style data
?set style data
?show style data
?data style
 コマンド `set style data` はデータ描画に対するデフォルトの描画スタイル
 を変更します。

 書式:
       set style data <plotting-style>
       show style data

 選択項目については、以下参照: `plotting styles`。項目を指定しなかった
 場合、その一覧が表示されます。`show style data` は現在のデフォルトのデ
 ータ描画スタイルを表示します。
4 set style fill
?commands set style fill
?commands show style fill
?set style fill
?show style fill
?fillstyle
 コマンド `set style fill` は、boxes, histograms, candlesticks,
 filledcurves での描画における描画要素のデフォルトのスタイルの設定に使
 われます。このデフォルトは、個々の描画に塗り潰しスタイル (fillstyle)
 を指定することで上書きできます。以下参照: `set style rectangle`。

 書式:
       set style fill {empty
                       | {transparent} solid {<density>}
                       | {transparent} pattern {<n>}}
                      {border {<colorspec>} | noborder}

 デフォルトの塗りつぶしスタイル (fillstyle) は `empty` です。

 オプション `solid` は、出力形式がサポートしている場合、その色でのベタ
 塗りを行います。パラメータ <density> は塗りつぶし色の強さを表していて
 <density> が 0.0 なら箱は空、<density> が 1.0 なら箱はその内部は現在の
 線種と完全に同じ色で塗られます。出力形式によっては、この強さを連続的に
 変化させられるものもありますが、その他のものは、部分的な塗りつぶしの幾
 つかのレベルを実装しているに過ぎません。パラメータ <density> が与えら
 れなかった場合はデフォルトの 1 になります。

 オプション `pattern` は、出力ドライバによって与えられるパターンでの塗
 りつぶしを行います。利用できる塗りつぶしパターンの種類と数は出力ドライ
 バに依存します。塗りつぶしの boxes スタイルで複数のデータ集合を描画す
 る場合そのパターンは、複数の曲線の描画における線種の周期と同様、有効な
 パターンを、パターン <n> から始めて周期的に利用します。

 オプション `empty` は、箱を塗りつぶしませんが、これがデフォルトです。

 デフォルトの `border` は、現在の線の種類の実線で箱の境界を描きます。
 `border <colorspec>` で境界の色を変更することができます。`noborder` は
 境界の線が描かれないようにします。
5 set style fill transparent
?commands set style fill transparent
?set style fill transparent
?fillstyle transparent
?transparent
 いくつかの出力形式は、塗りつぶし領域の `transparent` (透明化) 属性をサ
 ポートしています。transparent solid の領域塗りつぶしでは、`density`
 (密度) パラメータはアルファ値として使用されます。つまり、密度 0 は完全
 な透明を、密度 1 は完全な不透明を意味します。transparent pattern の塗
 りつぶしでは、パターンの背景が完全な透明か完全な不透明のいずれかです。

@start table - 透明化のドライバのサポート
       出力形式   solid pattern    pm3d
       --------------------------------
       gif           no     yes      no
       jpeg         yes      no     yes
       pdf          yes     yes     yes
       png    TrueColor   index     yes
       post          no     yes      no
       svg          yes      no     yes
       wxt          yes     yes     yes
       x11           no     yes      no
#\begin{tabular}{|cccl|} \hline
#出力形式   &   solid & pattern &    pm3d \\ \hline
#gif        &      no &     yes &      no \\
#jpeg       &     yes &      no &     yes \\
#pdf        &     yes &     yes &     yes \\
#png        &TrueColor&   index &     yes \\
#post       &      no &     yes &      no \\
#svg        &     yes &      no &     yes \\
#wxt        &     yes &     yes &     yes \\
#x11        &      no &     yes &      no \\
%c l .
%出力形式@solid@pattern@pm3d
%_
%gif@no@yes@no
%jpeg@yes@no@yes
%pdf@yes@yes@yes
%png@TrueColor@index@yes
%post@no@yes@no
%svg@yes@yes@yes
%wxt@yes@yes@yes
%x11@no@yes@no
%_
@end table
 透明な塗りつぶし領域を含むグラフを見たり作ったりするのには、別な制限が
 ありうることに注意してください。例えば、png 出力形式では、"truecolor"
 オプションが指定されている場合にのみ透明化の塗り潰しが利用できます。
 PDF ファイルには透明化領域が正しく記述されていても、PDF の表示ソフトに
 よってはそれを正しく表示できないこともありえます。実際に PostScript プ
 リンタでは問題はないのに、Ghostscript/gv ではパターン塗りつぶし領域を
 正しく表示できません。
4 set style function
?commands set style function
?commands show style function
?set style function
?show style function
?function style
 コマンド `set style function` は関数描画に対するデフォルトの描画スタイ
 ルを変更します。

 書式:
       set style function <plotting-style>
       show style function

 選択項目については、以下参照: `plotting styles`。項目を指定しなかった
 場合、その一覧が表示されます。`show style function` は現在のデフォルト
 の関数描画スタイルを表示します。
4 set style increment
?commands set style increment
?commands show style increment
?set style increment
?show style increment
 書式:
       set style increment {default|userstyles}
       show style increment

 デフォルトでは、同じグラフ上の次の描画は、現在の出力形式でデフォルトで
 定義されている線種の次のもので行われます。
 しかし、`set style increment user` を選択すると、デフォルトの線種では
 なく、ユーザ定義ラインスタイル番号のものを使用させることができます。

 例:

       set style line 1 lw 2 lc rgb "gold"
       set style line 2 lw 2 lc rgb "purple"
       set style line 4 lw 1 lc rgb "sea-green"
       set style increment user

       plot f1(x), f2(x), f3(x), f4(x)

 これは、関数 f1, f2, f4 は新たにユーザ定義されたラインスタイルで描画さ
 れます。ユーザ定義ラインスタイルが見つからない場合は、代わりにそれに対
 応するデフォルトの線種が利用されます。例えば、上の例では、f3(x) はデフ
 ォルトの線種 3 で描画されます。

4 set style line
?commands set style line
?commands unset style line
?commands show style line
?set style line
?unset style line
?show style line
?linestyle
?linewidth
=linewidth
 出力装置にはおのおのデフォルトの線種と点種の集合があり、それらはコマン
 ド `test` で見ることができます。`set style line` は線種と線幅、点種と
 点の大きさを、個々の呼び出しで、それらの情報を全部指定する代わりに、単
 なる番号で参照できるようにあらかじめ定義するものです。

 書式:
       set style line <index> default
       set style line <index> {{linetype  | lt} <line_type> | <colorspec>}
                              {{linecolor | lc} <colorspec>}
                              {{linewidth | lw} <line_width>}
                              {{pointtype | pt} <point_type>}
                              {{pointsize | ps} <point_size>}
                              {palette}
       unset style line
       show style line

 `default` を指定すると、全ての line スタイルパラメータはそのデフォルト
 の値になります。

 <index> の linestyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 線種と点種現在の出力装置が持つデフォルトの種類から選ばれます。線幅と点
 の大きさはデフォルトの幅、大きさに対する乗数です (しかし、ここでの
 <point_size> は、`set pointsize` で与えられる乗数には影響を受けないこ
 とに注意してください)。

 線種と線幅のデフォルトの値はそのラインスタイル番号 (index) です。幅と
 大きさのデフォルトの大きさはどちらも 1 です。

 このようにつくられるラインスタイルは、デフォルトの型 (線種, 点種) を
 別なものに置き換えることはしないので、ラインスタイル、デフォルトの型、
 どちらも使えます。もし、定義したスタイルをデフォルトの線種の代わりに使
 いたい場合は、以下参照: `set style increment`。

 全ての出力装置が `linewidth` や `pointsize` をサポートしているわけでは
 ありません。もしサポートされていない場合はそれらのオプションは無視され
 ます。

 出力形式に依存しない色を `linecolor <colorspec>` か `linetype <colorspec>`
 (省略形は `lc`, `lt`) のいずれかを使って割り当てることができます。この
 場合、色は RGB の 3 つ組で与えるか、gnuplot の持つパレットの色名、現在
 のパレットに対する小数指定、または cbrange への現在のパレットの対応に
 対する定数値、のいずれかで与えます。以下参照: `colors`, `colorspec`,
 `set palette`, `colornames`, `cbrange`。

 `set style line <n> linetype <lt>` は、出力形式に依存した点線/破線のパ
 ターンと色の両方をセットします。`set style line <n> linecolor <colorspec>`
 や `set style line <n> linetype <colorspec>` は、現在の点線/破線のパタ
 ーンを変更せずに新しい線色を設定します。

 3 次元モード(`splot` コマンド) では、"linetype palette z" の省略形とし
 て特別にキーワード `palette` を使うことも許されています。その色の値は、
 splot の z 座標 (高さ) に対応し、曲線、あるいは曲面に沿って滑らかに変
 化します。

 例:
 以下では、番号 1, 2, 3 に対するデフォルトの線種をそれぞれ赤、緑、青とし、
 デフォルトの点の形をそれぞれ正方形、十字、三角形であるとします。このとき
 以下のコマンド

       set style line 1 lt 2 lw 2 pt 3 ps 0.5

 は、新しいラインスタイルとして、緑でデフォルトの 2 倍の幅の線、および
 三角形で半分の幅の点を定義します。また、以下のコマンド

       set style function lines
       plot f(x) lt 3, g(x) ls 1

 は、f(x) はデフォルトの青線で、g(x) はユーザの定義した緑の線で描画しま
 す。同様に、コマンド

       set style function linespoints
       plot p(x) lt 1 pt 3, q(x) ls 1

 は、p(x) を赤い線で結ばれたデフォルトの三角形で、q(x) は緑の線で結ばれ
 た小さい三角形で描画します。

       splot sin(sqrt(x*x+y*y))/sqrt(x*x+y*y) w l pal

 は、`palette` に従って滑らかな色を使って曲面を描画します。これはそれを
 サポートした出力形式でしかちゃんとは動作しないことに注意してください。
 以下も参照: `set palette`, `set pm3d`。

       set style line 10 linetype 1 linecolor rgb "cyan"

 は、RGB カラーをサポートするすべての出力形式で、ラインスタイル 10 に実
 線の水色を割り当てます。

4 set style rectangle
?commands set style rectangle
?commands unset style rectangle
?commands show style rectangle
?set style rectangle
?unset style rectangle
?show style rectangle

 コマンド `set object` で定義された長方形には別々のスタイルを設定できま
 す。しかし、個別のスタイル指定をしなければ、そのオブジェクトはコマンド
 `set style rectangle` によるデフォルトを受け継ぎます。

 書式:
     set style rectangle {front|back} {lw|linewidth <lw>}
                         {fillcolor <colorspec>} {fs <fillstyle>}

 以下参照: `colorspec`, `fillstyle`。`fillcolor` は `fc` と省略できます。

 例:
     set style rectangle back fc rgb "white" fs solid 1.0 border lt -1
     set style rectangle fc linsestyle 3 fs pattern 2 noborder

 デフォルトの設定は、背景色での塗り潰しで、境界は黒になっています。

3 surface
?commands set surface
?commands unset surface
?commands show surface
?set surface
?unset surface
?show surface
?surface
?nosurface
 コマンド `set surface` は `splot` による曲面の表示を制御します。

 書式:
       set surface
       unset surface
       show surface

 曲面はデータや関数に対して、`with` で指定されたスタイル、あるいは他の
 適切なスタイルで書かれます。

 `unset surface` により `splot` は、関数やデータファイルの点に対するど
 んな点や線も描かなくなります。個別にある関数やあるデータファイルの曲面
 描画を無効にしてその他を有効にしたい場合には、コマンド `splot` のキー
 ワード `nosurface` を使用してください。その場合でも `set contour` の設
 定により曲面の等高線は書かれます。`unset surface; set contour base` の
 組は、等高線を格子の土台に表示する際に便利です。以下も参照:
 `set contour`。
3 table
?commands set table
?set table
?table
 `table` モードが有効な場合、`plot` と `splot` コマンドは、現在の出力形
 式に対する実際の描画を生成する替わりに X Y {Z} R の値の複数列からなる
 表形式のアスキー出力を行ないます。文字 R は、次の 3 種類のうちの一つで
 す: その点が有効な範囲内にある場合は "i"、範囲外の場合は "o"、未定義値
 (undefined) の場合は "u" です。データの書式は、軸のラベルの書式
 (以下参照: `set format`) によって決まり、列は一つの空白で区切られます。
 これは、等高線を生成し、例えば `plot` で描画するなど、それを再利用する
 ために保存したいときに便利です。例については、以下参照: `set contour`。
 この方法は、補間されたデータを保存するのにも使うことができます (以下参
 照: `set samples`, `set dgrid3d`)。

 書式:
       set table {"outfile"}
       plot <whatever>
       unset table

 表形式の出力は、指定されたファイルに書き出されますが、指定がない場合は
 現在 `set output` で指定されている値に出力されます。現在の出力形式の標
 準的な描画に戻すには、`unset table` を明示的に行なう必要があります。
3 terminal
?commands set terminal
?commands show terminal
?set terminal
?set term
?show terminal
?show term
?set terminal push
?set term push
?terminal push
?term push
?push
?set terminal pop
?set term pop
?terminal pop
?term pop
?pop
 `gnuplot` は数多くのグラフィック形式をサポートしています。コマンド
 `set terminal` を使って `gnuplot` の出力の対象となる形式の種類を選んで
 ください。出力先をファイル、または出力装置にリダイレクトするには
 `set output` を使ってください。

 書式:
       set terminal {<terminal-type> | push | pop}
       show terminal

 <terminal-type> が省略されると `gnuplot` は利用可能な出力形式の一覧を
 表示します。<terminal-type> の指定には短縮形が使えます。

 `set terminal` と `set output` の両方を使う場合、`set terminal` を最初
 にする方が安全です。それは、OS によっては、それが必要とするフラグをセ
 ットする出力形式があるからです。

 いくつかの出力形式はたくさんの追加オプションを持ちます。例えば、以下参
 照: `png`, `postscript`。
 各 `<term>` に対し、直前の `set term <term> <options>` で使用されたオ
 プションは記憶され、その後の `set term <term>` がそれをリセットするこ
 とはありません。これは例えば印刷時に有用です。幾つかの異なる出力形式を
 切替える場合、前のオプションを繰り返し唱える必要はありません。

 コマンド `set term push` は、現在の出力形式とその設定を `set term pop`
 によって復帰するまで記憶しています。これは `save term`, `load term` と
 ほぼ同等ですが、ファイルシステムへのアクセスは行わず、よって例えばこれ
 は、印刷後にプラットホームに依存しない形で出力形式を復帰する目的に使え
 ます。gnuplot の起動後、デフォルト、または `startup` ファイルに書かれ
 た出力形式が自動的に記憶 (push) されます。よって、明示的に出力形式を記
 憶させることなく、任意のプラットホーム上でデフォルトの出力形式を
 `set term pop` によって復帰させる、という動作を期待したスクリプトを可
 搬性を失わずに書くことが出来ます。

 有効な出力形式の一覧全体については、以下参照: `terminal`。
3 termoption
?commands set termoption
?set termoption
?termoption
 コマンド `set termoption` は、現在使用している出力形式の振舞いを、新た
 な `set terminal` コマンドの発行なしに変更することを可能にします。この
 コマンド一つに対して一つのオプションのみが変更できます。そしてこの方法
 で変更できるオプションはそう多くはありません。現在使用可能なオプション
 は以下のもののみです。

      set termoption {no}enhanced
      set termoption font "<fontname>{,<fontsize>}"
      set termoption {solid|dashed}

3 tics
?commands set tics
?commands unset tics
?commands show tics
?set tics
?unset tics
?show tics
?tics
 全ての軸の (見出しのつく) 大目盛りの制御を一度に行うことは、コマンド
 `set tics` で可能です。

 全ての軸の (見出しのつく) 大目盛りは コマンド `set tics` で一度に制御
 できます。目盛りは `unset tics` で消え、`set tics` で (デフォルトの状
 態の) 目盛りがつきます。各単一軸の大目盛りの制御を行なう同様のコマンド
 があります (`tics` の前に軸名をつけたもの)。

 書式
       set tics {axis | border} {{no}mirror}
                {in | out} {scale {default | <major> {,<minor>}}}
                {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                { format "formatstring" } { font "name{,<size>}" }
                { textcolor <colorspec> }
       set tics {front | back}
       unset tics
       show tics

 上の最初のオプションの形式は、別々に任意の、またはすべての軸 x, y, z,
 x2, y2, cb に適用できます。

 tics の `front` または `back` の設定は、2D 描画 (splot は不可) にのみ
 すべての軸に 1 度適用されます。これは、目盛と描画要素が重なった場合に
 目盛を描画要素の前面に出すか、奥に置くかを制御します。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると境界が表示されていれば (以下参照:
 `set border`) 目盛りの見出し文字を境界の外に出してしまうでしょう。この
 場合自動的なレイアウトアルゴリズムによる余白設定は大抵よくないものとな
 ってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 目盛りの刻みのサイズは `scale` で調整できます。<minor> の指定が省略さ
 れた場合は、それは 0.5*<major> になります。デフォルトのサイズは、大目
 盛りが 1.0 で小目盛りが 0.5 で、これは `scale default` で呼びだせます。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸のデフォルトは
 `nomirror` です。

 <offset> は x,y かまたは x,y,z の形式ですが、それに座標系を選択して、
 その前に `first`, `second`, `graph`, `screen`, `character` のいずれか
 をつけることもできます。<offset> は、目盛りの見出し文字列のデフォルト
 の位置からのずらし位置で、そのデフォルトの単位系は `character` です。
 詳細は、以下参照: `coordinates`。`nooffset` は offset を OFF にします。

 オプションなしの `set tics` は、目盛りの刻みを内側にしますが、その他の
 全てのオプションは直前の値を保持します。

 大目盛り (ラベルのつく) の他の制御に関しては、以下参照: `set xtics`。
 小目盛りの制御に関しては、以下参照: `set mxtics`。これらのコマンドは、
 各軸毎にその一つの軸の制御を提供します。
3 ticslevel
?commands set ticslevel
?commands show ticslevel
?set ticslevel
?show ticslevel
?ticslevel
 現在は推奨されていません。以下参照: `set xyplane`。
3 ticscale
?commands set ticscale
?commands show ticscale
?set ticscale
?show ticscale
?ticscale
 コマンド `set ticscale` は現在は推奨されていません。代わりに
 `set tics scale` を使ってください。
3 timestamp
?commands set timestamp
?commands unset timestamp
?commands show timestamp
?set timestamp
?unset timestamp
?show timestamp
?timestamp
?notimestamp
 コマンド `set timestamp` は描画の日付と時刻を左の余白に表示します。

 書式:
       set timestamp {"<format>"} {top|bottom} {{no}rotate}
                     {offset <xoff>{,<yoff>}} {font "<fontspec>"}
       unset timestamp
       show timestamp

 書式文字列 (format) を使って、書かれる日付と時刻の書式を選択することが
 できます。デフォルトは asctime() が使用する "%a %b %d %H:%M:%S %Y" で
 す (曜日、月名、日、時、分、秒、4 桁の西暦)。`top` と `bottom` を使っ
 て日付を左の余白の上に配置するか、下に配置するかを選択できます (デフォ
 ルトは下)。`rotate` は、もし出力形式がサポートしていればですが、日付を
 垂直方向の文字列にします。定数 <xoff>、<yoff> はずれ (offset) を意味し、
 これによってより適切な位置合わせが行えます。<font> は日付が書かれるフ
 ォントを指定します。

 `timestamp` の代わりに省略名 `time` を使っても構いません。

 例:
       set timestamp "%d/%m/%y %H:%M" offset 80,-2 font "Helvetica"

 日付の書式文字列に関する詳しい情報については、以下参照: `set timefmt`。
3 timefmt
?commands set timefmt
?commands show timefmt
?set timefmt
?show timefmt
?timefmt
 このコマンドは、データが日時の形式になっている場合に、その時系列データ
 に適用されます。これはコマンド `set xdata time` も与えられていないと意
 味がありません。

 書式:
       set timefmt "<format string>"
       show timefmt

 文字列引数 (<format string>) は `gnuplot` に日時データをデータファイル
 からどのように読むかを指示します。有効な書式は以下の通りです:

@start table - まずは対話型テキスト形式
       書式         説明
       %d           何日, 1--31
       %m           何月, 1--12
       %y           何年, 0--99
       %Y           何年, 4-digit
       %j           1 年の何日目, 1--365
       %H           何時, 0--24
       %M           何分, 0--60
       %s           Unix epoch (1970-01-01, 00:00 UTC) からの秒数
       %S           何秒, 0--60
       %b           月名 (英語) の 3 文字省略形
       %B           月名 (英語)
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{時系列データ書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%d@ & 何日, 1--31 \\
#\verb@%m@ & 何月, 1--12 \\
#\verb@%y@ & 何年, 0--99 \\
#\verb@%Y@ & 何年, 4 桁 \\
#\verb@%j@ & 1 年の何日目, 1--365 \\
#\verb@%H@ & 何時, 0--24 \\
#\verb@%M@ & 何分, 0--60 \\
#\verb@%s@ & Unix epoch (1970-01-01, 00:00 UTC) からの秒数\\
#\verb@%S@ & 何秒, 0--60 \\
#\verb@%b@ & 月名 (英語) の 3 文字省略形 \\
#\verb@%B@ & 月名 (英語) \\
%c l .
%書式@説明
%_
%%d@何日, 1--31
%%m@何月, 1--12
%%y@何年, 0--99
%%Y@何年, 4 桁
%%j@1 年の何日目, 1--365
%%H@何時, 0--24
%%M@何分, 0--60
%%s@Unix epoch (1970-01-01, 00:00 UTC) からの秒数
%%S@何秒, 0--60
%%b@月名 (英語) の 3 文字省略形
%%B@月名 (英語)
%_
@end table
 任意の文字を文字列中で使用できますが、規則に従っている必要があります。
 \t (タブ) は認識されます。バックスラッシュ + 8 進数列 (\nnn) はそれが
 示す文字に変換されます。日時要素の中に分離文字がない場合、%d, %m, %y,
 %H, %M, %S はそれぞれ 2 桁の数字を読み込み、%Y は 4 桁、%j は 3 桁の数
 字を読み込みます。%b は 3 文字を、%B は必要な分だけの文字を要求します。

 空白 (スペース) の扱いはやや違います。書式文字列中の 1 つの空白は、フ
 ァイル中の 0 個、あるいは 1 つ以上の空白文字列を表します。すなわち、
 "%H %M" は "1220" や "12     20" を "12 20" と同じように読みます。

 データ中の非空白文字の集まりそれぞれは、`using n:n` 指定の一つ一つの列
 とカウントされます。よって `11:11  25/12/76  21.0` は 3 列のデータと認
 識されます。混乱を避けるために、日時データが含まれる場合 `gnuplot` は、
 あなたの `using` 指定が完璧なものであると仮定します。

 `gnuplot` は数字でない文字列を読めないので、日付データが曜日、月の名前
 を含んでいる場合、書式文字列でそれを排除しなければいけません。しかし、
 "%a", "%A", "%b", "%B" でそれらを表示することはできます: これら、及び
 日時データの出力の他のオプションの詳細に関しては、以下参照:
 `set format`。(`gnuplot` は数値から月や曜日を正しく求めます。)

 他の情報については、以下も参照: `set xdata`, `Time/date`。

 例:
       set timefmt "%d/%m/%Y\t%H:%M"
 は、`gnuplot` に日付と時間がタブで分離していることを教えます (ただし、
 あなたのデータをよーく見てください。タブだったものがどこかで複数のスペ
 ースに変換されていませんか ? 書式文字列はファイル中に実際にある物と一
 致していなければなりません)。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/timedat.html">
 時系列データ (time data) デモ。
^ </a>
3 title
?commands set title
?commands show title
?set title
?show title
?title
 コマンド `set title` は、描画の上の真中に書かれる描画タイトルを生成し
 ます。`set title` は `set label` の特殊なもの、とみなせます。

 書式:
       set title {"<title-text>"} {offset <offset>} {font "<font>{,<size>}"}
                 {{textcolor | tc} {<colorspec> | default}} {{no}enhanced}
       show title

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、タイトルは与え
 られた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set title offset 0,-1`" はタイトルの y 方向
 の位置のみ変更し、大ざっぱに言って 1 文字分の高さだけタイトルを下に下
 げます。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> はタイトルが書かれるフォントを指定するのに使われます。<size> の
 単位は、どの出力形式 (terminal) を使っているかによって変わります。

 `textcolor <colorspec>` は、文字の色を変更します。<colorspec> は、線
 種、rgb 色、またはパレットへの割当のいずれかが指定できます。以下参照:
 `colorspec`, `palette`。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、タイトルを拡張文字列処理させないようにします。

 `set title` をパラメータなしで使うとタイトルを消去します。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いについては、以下参照: `syntax`。
3 tmargin
?commands set tmargin
?set tmargin
?tmargin
 コマンド `set tmargin` は上の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 trange
?commands set trange
?commands show trange
?set trange
?show trange
?trange
 コマンド `set trange` は、媒介変数モード、あるいは極座標モードでの x,y
 の値を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
3 urange
?commands set urange
?commands show urange
?set urange
?show urange
?urange
 `set urange` と `set vrange` は、`splot` の媒介変数モードで x,y,z の値
 を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
3 variables
?commands show variables
?show variables all
?show variables
 `show variables` コマンドはユーザ定義変数と内部変数の現在の値の一覧を
 表示します。gnuplot は、GPVAL_, MOUSE_, FIT_, TERM_ で始まる名前を持つ
 変数を内部で定義しています。

 書式:
       show variables      # GPVAL_ で始まるもの以外の変数を表示
       show variables all  # GPVAL_ で始まるものも含め全ての変数を表示
       show variables NAME # NAME で始まる変数のみを表示

3 version
?show version
 コマンド `show version` は現在起動している gnuplot のバージョン、最終
 修正日、著作権者と、FAQ や info-gnuplot メーリングリスト、バグレポート
 先のメールアドレスを表示します。対話的にプログラムが呼ばれているときは
 スクリーン上にその情報を表示します。

 書式:
       show version {long}

 `long` オプションを与えると、さらにオペレーティングシステム、`gnuplot`
 インストール時のコンパイルオプション、ヘルプファイルの置き場所、そして
 (再び) 有用なメールアドレスを表示します。
3 view
?commands set view
?commands show view
?set view
?set view map
?show view
?view
 コマンド `set view` は `splot` の視線の角度を設定します。これは、グラ
 フ描画の 3 次元座標をどのように 2 次元の画面 (screen) に投影するかを制
 御します。これは、描画されたデータの回転と伸縮の制御を与えてくれますが
 正射影しかサポートしていません。3 次元射影、および 2 次元描画的地図上
 への 2 次元直交射影がサポートされています。

 書式:
       set view <rot_x>{,{<rot_z>}{,{<scale>}{,<scale_z>}}}
       set view map
       set view {no}equal {xy|xyz}
       show view

 ここで <rot_x> と <rot_z> は、画面に投影される仮想的な 3 次元座標系の
 回転角 (単位は度) の制御で、最初は (すなわち回転が行なわれる前は)
 画面内の水平軸は x, 画面内の垂直軸は y, 画面自身に垂直な軸が z となっ
 ています。最初は x 軸の周りに <rot_x> だけ回転されます。次に、新しい
 z 軸の周りに <rot_z> だけ回転されます。

 コマンド `set view map` は、描画を地図として表示するのに使います。これ
 は等高線 (`contour`) の描画、およびカラー表示 (`pm3d`) の色地図に使え
 ます。後者に関しては、入力データ点のフィルタ用の `zrange` の設定、およ
 び色の範囲の縮尺に関する `cbrange` の設定を適切に行うことに注意してく
 ださい。

 <rot_x> は [0:180] の範囲に制限されていて、デフォルトでは 60 度です。
 <rot_z> は [0:360] の範囲に制限されていて、デフォルトでは 30 度です。
 <scale> は `splot` 全体の伸縮率を制御し、<scale_z> は z 軸の伸縮のみを
 行ないます。伸縮率のデフォルトはどちらも 1.0 です。

 例:
       set view 60, 30, 1, 1
       set view ,,0.5

 最初の例は 4 つの全てをデフォルトの値にしています。2 つめの例は縮小率
 のみを 0.5 に変更しています。
4 equal
?set view equal_axes
?set view equal
?view equal_axes
?view equal
 コマンド `set view equal xy` は x 軸と y 軸の単位の長さが強制的に等し
 くなるように縮尺を合わせ、グラフがページに丁度合うようにその縮尺を選択
 します。コマンド `set view equal xyz` は、さらに z 軸も x と y 軸に合
 うようにしますが、現在の z 軸の範囲が、描画境界の範囲に合う保証はあり
 ません。デフォルトでは、3 つの軸は独立に有効な領域を埋めるように縮尺さ
 れます。

 以下も参照: `set ticslevel`。
3 vrange
?commands set vrange
?commands show vrange
?set vrange
?show vrange
?vrange
 コマンド `set urange` と `set vrange` は、`splot` の媒介変数 (パラメー
 タ) モードで x, y, z の値を計算するのに使われる媒介変数の範囲を設定し
 ます。 詳細は、以下参照: `set xrange`。
3 x2data
?commands set x2data
?commands show x2data
?set x2data
?show x2data
?x2data
 コマンド `set x2data` は x2 (上) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 x2dtics
?commands set x2dtics
?commands unset x2dtics
?commands show x2dtics
?set x2dtics
?unset x2dtics
?show x2dtics
?x2dtics
?nox2dtics
 コマンド `set x2dtics` は x2 (上) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 x2label
?commands set x2label
?commands show x2label
?set x2label
?show x2label
?x2label
 コマンド `set x2label` は x2 (上) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 x2mtics
?commands set x2mtics
?commands unset x2mtics
?commands show x2mtics
?set x2mtics
?unset x2mtics
?show x2mtics
?x2mtics
?nox2mtics
 コマンド `set x2mtics` は、x2 (上) 軸を 1 年の各月に設定します。詳細は、
 以下参照: `set xmtics`。
3 x2range
?commands set x2range
?commands show x2range
?set x2range
?show x2range
?x2range
 コマンド `set x2range` は x2 (上) 軸の表示される水平範囲を設定します。
 詳細は、以下参照: `set xrange`。
3 x2tics
?commands set x2tics
?commands unset x2tics
?commands show x2tics
?set x2tics
?unset x2tics
?show x2tics
?x2tics
?nox2tics
 コマンド `set x2tics` は x2 (上) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 x2zeroaxis
?commands set x2zeroaxis
?commands unset x2zeroaxis
?commands show x2zeroaxis
?set x2zeroaxis
?unset x2zeroaxis
?show x2zeroaxis
?x2zeroaxis
?nox2zeroaxis
 コマンド `set x2zeroaxis` は、原点を通る x2 (上) 軸 (y2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 xdata
?commands set xdata
?commands show xdata
?set xdata
?show xdata
?xdata
 このコマンドは x 軸のデータ形式を日時データにセットします。同様のコマ
 ンドが他の軸それぞれに用意されています。

 書式:
       set xdata {time}
       show xdata

 `ydata`, `zdata`, `x2data`, `y2data`, `cbdata` にも同じ書式が当てはま
 ります。

 `time` オプションはデータが日時データであることを伝えます。オプション
 をつけない場合、データ型は通常のものに戻ります。

 gnuplot にどのように日時データを読みこませるかについては、以下参照:
 `set timefmt`。日時データは今世紀の始まり (訳注: 厳密には 2000 年 1 月
 1 日の始まり) からの秒数に変換されます。時間書式 (timefmt) は現在はた
 だ一つだけしか使えません。それは、全ての日時データ項目がこの書式に一致
 しなければならないことを意味します。また、範囲の指定は、日時指定が数式
 と解釈されるのを避けるために、その書式に従った文字列を引用符で囲んで指
 定すべきです。

 目盛り刻みの見出し (label) を表示するのには関数 'strftime' (unix でそ
 れを調べるには "man strftime" とタイプしてください) が使われます。
 `set format x "string"` で、10 進数の書式ではなさそうなもの (2 つ以上
 の '%'、または %f でも %g でもないもの) が与えられていなければ、
 `gnuplot` はこれを適当に意味のある書式で計算して表示します。

 他の情報については、以下参照: `Time/date`。
3 xdtics
?commands set xdtics
?commands unset xdtics
?commands show xdtics
?set xdtics
?unset xdtics
?show xdtics
?xdtics
?noxdtics
 コマンド `set xdtics` は x 軸の目盛りの刻みを曜日に変換します (0=Sun,
 6=Sat)。6 を越える場合は 7 による余りが使われます。`unset xdtics` は
 その見出しをデフォルトの形式に戻します。他の軸にも同じことを行なう同
 様のコマンドが用意されています。

 書式:
       set xdtics
       unset xdtics
       show xdtics

 `ydtics`, `zdtics`, `x2dtics`, `y2dtics`, `cbdtics` にも同じ書式が当て
 はまります。

 以下も参照: `set format`。
3 xlabel
?commands set xlabel
?commands show xlabel
?set xlabel
?show xlabel
?xlabel
 コマンド `set xlabel` は x 軸の見出しを設定します。他の軸にも見出しを
 設定する同様のコマンドがあります。

 書式:
       set xlabel {"<label>"} {offset <offset>} {font "<font>{,<size>}"}
                  {{textcolor | tc} {lt <line_type> | default}} {{no}enhanced}
                  {rotate by <degrees>}
       show xlabel

 同じ書式が `x2label`, `ylabel`, `y2label`, `zlabel`, `cblabel` にも適
 用されます。

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、見出しは与えら
 れた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set xlabel offset -1,0`" は見出しの x 方向の
 位置のみ変更し、大ざっぱに言って 1 文字分の幅だけ見出しを左にずらしま
 す。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> は見出しが書かれるフォントを指定するのに使われます。フォントの
 <size> (大きさ) の単位は、どんな出力形式を使うかに依存します。

 `textcolor lt <n>` は、見出し文字列を線種 <n> の色にします。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、ラベル文字列を拡張文字列処理させないようにします。

 見出しを消去するには、オプションをつけずに実行します。例: "`set y2label`"

 軸の見出しのデフォルトの位置は以下の通りです:

 xlabel: x 軸の見出しは下の軸の下の真中

 ylabel: y 軸の見出しは出力形式依存で、以下の 3 つのいずれか:

 1. 水平方向の文字列で描画の左上に左端に合わせて配置されます。文字列の
 回転を行なえない出力形式では多分これが選択されます。`set x2tics` が同
 時に使われている場合、ylabel は x2 軸の見出しの左端と重なるかも知れま
 せん。これは ylabel の位置か左の余白を調整することで対処できるでしょ
 う。

 2. 垂直方向の文字列で、描画の左で垂直方向に中央揃えされます。文字列を
 回転できる出力形式では多分これが選択されます。

 3. 水平方向の文字列で、描画の左で垂直方向に中央揃えされます。LaTeX,
 TPIC ドライバではこれが選択されます。EEPIC ドライバでは、描画に重なら
 ないような、文字の積み重ねを生成しますが、その他のドライバ (LaTeX や
 TPIC のような) では、ylabel が描画に上書きするのを避けるために、\\ を
 使って改行を入れる必要があるかもしれません。

 zlabel: z 軸の見出しは軸の表示範囲より上で、見出しの真中が z 軸の真上

 cblabel: 色見本 (color box) の軸の見出しは箱に沿って中央揃えされ、箱の
 向きが水平なら下に、垂直なら右

 y2label: y2 軸の見出しは y2 軸の右。その位置は、出力形式依存で y 軸と
 同様の規則で決定。

 x2label: x2 軸の見出しは上の軸の上で、描画タイトルよりは下。これは、
 改行文字を使えば、それによる複数の行からなる描画タイトルで x2 軸の見
 出しを生成することも可能。例:

       set title "This is the title\n\nThis is the x2label"

 これは二重引用符を使うべきであることに注意してください。この場合、もち
 ろん 2 つの行で同じフォントが使われます。

 x, x2, y, y2 軸のラベルの方向 (回転角) は、デフォルトの設定に対して明
 示的に変更することができますが、これは 2 次元描画で、かつ文字列の回転
 をサポートする出力形式のみで有効です。

 もし軸の位置のデフォルトの位置が気に入らないならば、代わりに `set label`
 を使ってください。このコマンドは文字列をどこに配置するかをもっと自由に
 制御できます。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いに関するより詳しい情報については、以下参照: `syntax`。
3 xmtics
?commands set xmtics
?commands unset xmtics
?commands show xmtics
?set xmtics
?unset xmtics
?show xmtics
?xmtics
?noxmtics
 コマンド `set xmtics` は x 軸の目盛りの見出しを月に変換します。1=Jan
 (1 月)、12=Dec (12 月) となります。12 を越えた数字は、12 で割ったあまりの
 月に変換されます。`unset xmtics` で目盛りはデフォルトの見出しに戻ります。
 他の軸に対しても同じ役割をする同様のコマンドが用意されています。

 書式:
       set xmtics
       unset xmtics
       show xmtics

 `x2mtics`, `ymtics`, `y2mtics`, `zmtics`, `cbmtics` にも同じ書式が適用
 されます。

 以下も参照: コマンド `set format`。
3 xrange
?commands set xrange
?commands show xrange
?set xrange
?show xrange
?writeback
?restore
?xrange
 コマンド `set xrange` は表示される水平方向の範囲を指定します。他の軸
 にも同様のコマンドが存在しますし、極座標での半径 r, 媒介変数 t, u, v
 にも存在します。

 書式:
       set xrange { [{{<min>}:{<max>}}] {{no}reverse} {{no}writeback} }
                  | restore
       show xrange

 ここで <min> と <max> には定数、数式、または '*' で、'*' は自動縮尺機
 能を意味します。日時データの場合、範囲は `set timefmt` の書式に従った
 文字列を引用符で囲む必要があります。省略された値は変更されません。

 `yrange`, `zrange`, `x2range`, `y2range`, `cbrange`, `rrange`, `trange`,
 `urange`, `vrange` は同じ書式を使用します。

 オプション `reverse` は軸の方向を逆にします。例えば
 `set xrange [0:1] reverse` は、1 が左、0 が右であるような軸にします。
 これは、もちろん `set xrange [1:0]` と同じですが、`reverse` は主に自動
 縮尺 (`autoscale`) で用いられることを意図しています。

 オプション `writeback` は、`set xrange` で占められているバッファの中に
 自動縮尺機能により作られた範囲を保存します。これは、いくつかの関数を同
 時に表示し、しかしその範囲はそのうちのいくつかのものから決定させたい場
 合に便利です。`writeback` の作用は、`plot` の実行中に機能するので、その
 コマンドの前に指定する必要があります。最後に保存した水平方向の範囲は
 `set xrange restore` で復元できます。例を上げます。

       set xrange [-10:10]
       set yrange [] writeback
       plot sin(x)
       set yrange restore
       replot x/2

 この場合、y の範囲 (yrange) は sin(x) の値域として作られた [-1:1] の方
 になり、x/2 の値域 [-5:5] は無視されます。上記のそれぞれのコマンドの後
 に `show yrange` を実行すれば、上で何が行なわれているかを理解する助け
 になるでしょう。

 2 次元描画において、`xrange` と `yrange` は軸の範囲を決定し、`trange`
 は、媒介変数モードの媒介変数の範囲、あるいは極座標モードの角度の範囲を
 決定します。同様に 3 次元媒介変数モードでは、`xrange`, `yrange`, `zrange`
 が軸の範囲を管理し、`urange` と `yrange` が媒介変数の範囲を管理します。

 極座標モードでは、`rrange` は描画される半径の範囲を決定します。<rmin>
 は半径への追加の定数として作用し、一方 <rmax> は半径を切り捨てる (clip)
 ように作用し、<rmax> を越えた半径に対する点は描画されません。`xrange`
 と `yrange` は影響されます。これらの範囲は、グラフが r(t)-rmin のグラ
 フで、目盛りの見出しにはそれぞれ rmin を加えたようなものであるかのよう
 にセットされます。

 全ての範囲は部分的に、または全体的に自動縮尺されますが、データの描画で
 なければ、パラメータ変数の自動縮尺機能は意味がないでしょう。

 範囲は `plot` のコマンドライン上でも指定できます。コマンドライン上で与
 えられた範囲は単にその `plot` コマンドでだけ使われ、`set` コマンドで設
 定された範囲はその後の描画で、コマンドラインで範囲を指定していないもの
 全てで使われます。これは `splot` も同じです。

 例:

 x の範囲をデフォルトの値にします:
       set xrange [-10:10]

 y の範囲が下方へ増加するようにします:
       set yrange [10:-10]

 z の最小値には影響を与えずに (自動縮尺されたまま)、最大値のみ 10 に設
 定します:
       set zrange [:10]

 x の最小値は自動縮尺とし、最大値は変更しません:
       set xrange [*:]
3 xtics
?commands set xtics
?commands unset xtics
?commands show xtics
?set xtics
?unset xtics
?show xtics
?xtics
?noxtics
 x 軸の (見出しのつく) 大目盛りは コマンド `set xtics` で制御できます。
 目盛りは `unset xtics` で消え、`set xtics` で (デフォルトの状態の) 目
 盛りがつきます。y,z,x2,y2 軸の大目盛りの制御を行なう同様のコマンドがあ
 ります。

 書式:
       set xtics {axis | border} {{no}mirror}
                 {in | out} {scale {default | <major> {,<minor>}}}
                 {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                 {add}
                 {  autofreq
                  | <incr>
                  | <start>, <incr> {,<end>}
                  | ({"<label>"} <pos> {<level>} {,{"<label>"}...) }
                 { format "formatstring" } { font "name{,<size>}" }
                 { rangelimited }
                 { textcolor <colorspec> }
       unset xtics
       show xtics

 同じ書式が `ytics`, `ztics`, `x2tics`, `y2tics`, `cbtics` にも適用され
 ます。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると目盛りの見出し文字を境界の外に出して
 しまうでしょう。この場合自動的なレイアウトアルゴリズムによる余白設定は
 大抵よくないものとなってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 目盛りの刻みのサイズは `scale` で調整できます。<minor> の指定が省略さ
 れた場合は、それは 0.5*<major> になります。デフォルトのサイズは、大目
 盛りが 1.0 で小目盛りが 0.5 で、これは `scale default` で呼びだせます。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸には、
 `{axis | border}` オプションは無効で、デフォルトは `nomirror` です。z
 軸の目盛りをミラー化したいなら、多分 `set border` でそのための空間をあ
 ける必要があるでしょう。

 <offset> は x,y かまたは x,y,z の形式で指定しますが、それに座標系を選
 択して、その前に `first`, `second`, `graph`, `screen`, `character` の
 いずれかをつけることもできます。<offset> は刻み文字のデフォルトの位置
 からのずれを表し、デフォルトの座標系は `character` です。詳細は、以下
 参照: `coordinates`。`nooffset` はずらしを無効にします。

 例:

 xtics をより描画に近づける:
       set xtics offset 0,graph 0.05

 オプションなしで `set xtics` を実行すると、目盛りが表示される状態であ
 れば、それはデフォルトの境界、または軸を復元し、そうでなければ何もしま
 せん。その前に指定した目盛りの間隔、位置 (と見出し) は保持されます。

 目盛りの位置は、デフォルト、またはオプション `autofreq` が指定されてい
 れば自動的に計算されます。そうでなければ、次の 2 つの形式で指定されま
 す:

 暗示的な <start>, <incr>, <end> 形式は、目盛りの列を <start> から <end>
 の間を <incr> の間隔で表示します。<end> を指定しなければ、それは無限大
 とみなされます。<incr> は負の値も可能です。<start> と <end> の両方が指
 定されていない場合、<start> は -∞、<end> は +∞とみなされ、目盛りは
 <incr> の整数倍の位置に表示されます。軸が対数軸の場合、目盛りの間隔
 (増分) は、積因子として使用されます。

 負の <start> や <incr> を、数値の後ろに指定すると (例えば
 `rotate by <angle>` とか `offset <offset>` の後ろ)、gnuplot の構文解析
 器は、その値からその負の <start> や <incr> の値の引き算を行おうとする
 間違いを犯します。これを回避するには、そのような場合は、`0-<start>` や
 `0-<incr>` のように指定してください。

 例:
       set xtics border offset 0,0.5 -5,1,5
 最後の ',' のところで失敗します。
       set xtics border offset 0,0.5 0-5,1,5
 か
       set xtics offset 0,0.5 border -5,1,5
 ならば、ちゃんと指示通りに、目盛りを境界に、目盛り見出し文字列を 0,0.5
 文字分だけずらして、start, increment, end をそれぞれ -5,1,5 に設定しま
 す。

 `set grid` のオプション 'front', 'back', 'layerdefault' も、x 軸の目盛
 りの描画の順序に影響します。

 例:

 目盛りを 0, 0.5, 1, 1.5, ..., 9.5, 10 の位置に生成
       set xtics 0,.5,10

 目盛りを ..., -10, -5, 0, 5, 10, ... に生成
       set xtics 5

 目盛りを 1, 100, 1e4, 1e6, 1e8 に生成
       set logscale x; set xtics 1,100,1e8

 明示的な ("<label>" <pos> <level>, ...) の形式は、任意の目盛りの位置、
 あるいは数字でない見出しの生成も可能にします。この形式では、目盛りは位
 置の数字の順に与える必要はありません。各目盛りは位置 (pos) と見出し
 (label) を持ちますが、見出しは必須ではありません。見出しは二重引用符で
 囲まれた文字列であることに注意してください。それは、"hello" のような固
 定文字列でも構いませんし、"%3f clients" のようにその位置を数字に変換す
 る書式文字列を含んでも構いませんし、空文字列 "" でも構いません。より詳
 しい情報については、以下参照: `set format`。もし、文字列が与えられなけ
 れば、デフォルトの数字の見出しが使用されます。

 明示的な形式では 3 つ目のパラメータとして "レベル" (level) を与えるこ
 とができます。デフォルトのレベルは 0 で、これは大目盛りを意味し、レベ
 ルが 1 の場合小目盛りが生成されます。レベルを指定する場合はラベルも必
 ず指定する必要があります。

 例:
       set xtics ("low" 0, "medium" 50, "high" 100)
       set xtics (1,2,4,8,16,32,64,128,256,512,1024)
       set ytics ("bottom" 0, "" 10, "top" 20)
       set ytics ("bottom" 0, "" 10 1, "top" 20)

 2 番目の例では、全ての目盛りが見出し付けされます。3 番目の例では、端の
 ものだけが見出し付けされます。4 番目の例の、見出しのない目盛りは小目盛
 りになります。

 通常明示的な (手動の) 目盛り位置が与えられた場合、自動的に生成される目
 盛りは使われません。逆に、`set xtics auto` のようなものが指定された場
 合は、以前に手動で設定した目盛りは消されてしまします。この手動の目盛り
 と自動的な目盛りを共存させるにはキーワード `add` を使用してください。
 これは追加する目盛りのスタイルの前に書かなければいけません。

 例:
       set xtics 0,.5,10
       set xtics add ("Pi" 3.14159)

 これは自動的に目盛りの刻みを x 軸に 0.5 間隔でつけますが、πのところに
 明示的な見出しも追加します。

 しかし指定しても、表示されるのはあくまで描画範囲のものだけです。

 目盛りの見出しの書式 (または省略) は `set format` で制御されます。ただ
 しそれは `set xtics (`<label>`)` の形式の明示的な見出し文字列が含まれ
 ていない場合だけです。

 (見出し付けされない) 小目盛りは、`set mxtics` コマンドで自動的に追加す
 るか、または位置を手動で `set xtics ("" <pos> 1, ...)` の形式で与える
 こともできます。
4 xtics time_data
?set xtics time_axis tics
?xtics time_axis tics
?time_axis tics
 時系列データの場合、軸の目盛り位置の値は `timefmt` の書式にしたがった
 日付、または時刻を引用符で囲んで与えなければいけません。<start>,
 <incr>, <end> 形式を使う場合、<start> と <end> は `timefmt` に従って与
 えますが、<incr> は秒単位で与える必要があります。その時刻は実際には
 `set format` で与えた書式に従って表示されます。

 例:
       set xdata time
       set timefmt "%d/%m"
       set xtics format "%b %d"
       set xrange ["01/12":"06/12"]
       set xtics "01/12", 172800, "05/12"

       set xdata time
       set timefmt "%d/%m"
       set xtics format "%b %d"
       set xrange ["01/12":"06/12"]
       set xtics ("01/12", "" "03/12", "05/12")
 これらは両方とも "Dec 1", "Dec 3", "Dec 5", の目盛りを生成しますが、2
 番目の例 "Dec 3" の目盛りは見出し付けされません。
4 xtics rangelimited
?set xtics rangelimited
?xtics rangelimited
?rangelimited
?range-frame
 このオプションは、自動的に生成される軸の目盛りの見出しと、描画されたデ
 ータで実際に与えられる範囲に対応する描画境界の両方を制限します。これは
 描画に対する現在の範囲制限とは無関係であることに注意してください。例え
 ばデータ "file.dat" のデータがすべて 2 < y < 4 の範囲にあるとすると、
 以下のコマンドは、左側の描画境界 (y 軸) は y の範囲全体 ([0:10]) のこ
 の部分 ([2:4]) のみが描画され、この範囲 ([2:4]) の軸の目盛りのみが作ら
 れる描画を生成します。つまり、描画は y の範囲全体 ([0:10]) に拡大され
 ますが、左の境界は 0 から 2 の間、4 から 10 の間は空白領域となります。
 このスタイルは、`範囲枠` グラフ (range-frame) とも呼ばれます。
       set border 3
       set yrange [0:10]
       set ytics nomirror rangelimited
       plot "file.dat"
3 xyplane
?commands set xyplane
?commands show xyplane
?set xyplane
?show xyplane
?xyplane
 `set xyplane` コマンドは 3D 描画で描かれる xy 平面の位置を調整するのに
 使われます。後方互換性のために、"set ticslevel" も同じ意味のコマンドと
 して使うことができます。

 書式:
       set xyplane at <zvalue>
       set xyplane relative <frac>
       set ticslevel <frac>    # set xyplane relative と同等
       show xyplane

 `set xyplane relative <frac>` は、xy 平面を Z 軸の範囲のどこに置くかを
 決定します。<frac> には、xy 平面と z の一番下の位置との差の、z 軸の範
 囲全体に対する割合を与えます。デフォルトの値は 0.5 です。負の値も許さ
 れていますが、そうすると 3 つの軸の目盛りの見出しが重なる可能性があり
 ます。非推奨ですが、古い形式 `set ticslevel` も後方互換性のために残さ
 れています。

 xy 平面を z 軸の 'pos' の位置に置くには、`ticslevel` の値を
 (pos - zmin) / (zmin - zmax) としてください。しかし、この位置は z の範
 囲 (`zrange`) を変更した場合は変わってしまいます。

 もう一つの形式である `set xyplane at <zvalue>` は、現在の z の範囲を気
 にすることなく、指定した z の値の位置に xy 平面を固定します。よって、
 x,y,z 軸を共通の原点を通るようにするには、`set xyplane at 0` とすれば
 いいことになります。

 以下も参照: `set view`, `set zeroaxis`。
3 xzeroaxis
?commands set xzeroaxis
?commands unset xzeroaxis
?commands show xzeroaxis
?set xzeroaxis
?unset xzeroaxis
?show xzeroaxis
?xzeroaxis
?noxzeroaxis
 コマンド `set xzeroaxis` は y = 0 の直線を描きます。詳細に関しては、以
 下参照: `set zeroaxis`。
3 y2data
?commands set y2data
?commands show y2data
?set y2data
?show y2data
?y2data
 コマンド `set y2data` は y2 (右) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 y2dtics
?commands set y2dtics
?commands unset y2dtics
?set y2dtics
?unset y2dtics
?show y2dtics
?y2dtics
?noy2dtics
 コマンド `set y2dtics` は y2 (右) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 y2label
?commands set y2label
?commands show y2label
?set y2label
?show y2label
?y2label
 コマンド `set y2label` は y2 (右) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 y2mtics
?commands set y2mtics
?commands unset y2mtics
?commands show y2mtics
?set y2mtics
?unset y2mtics
?show y2mtics
?y2mtics
?noy2mtics
 コマンド `set y2mtics` は y2 (右) 軸の目盛りを 1 年の各月に変更します。
 詳細は、以下参照: `set xmtics`。
3 y2range
?commands set y2range
?commands show y2range
?set y2range
?show y2range
?y2range
 コマンド `set y2range` は y2 (右) 軸の表示される垂直範囲を設定します。
 詳細は、以下参照: `set xrange`。
3 y2tics
?commands set y2tics
?commands unset y2tics
?commands show y2tics
?set y2tics
?unset y2tics
?show y2tics
?y2tics
?noy2tics
 コマンド `set y2tics` は y2 (右) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 y2zeroaxis
?commands set y2zeroaxis
?commands unset y2zeroaxis
?commands show y2zeroaxis
?set y2zeroaxis
?unset y2zeroaxis
?show y2zeroaxis
?y2zeroaxis
?noy2zeroaxis
 コマンド `set y2zeroaxis` は、原点を通る y2 (右) 軸 (x2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 ydata
?commands set ydata
?commands show ydata
?set ydata
?show ydata
?ydata
 コマンド `set ydata` は y 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 ydtics
?commands set ydtics
?commands unset ydtics
?commands show ydtics
?set ydtics
?unset ydtics
?show ydtics
?ydtics
?noydtics
 コマンド `set ydtics` は y 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 ylabel
?commands set ylabel
?commands show ylabel
?set ylabel
?show ylabel
?ylabel
 このコマンドは y 軸の見出しを設定します。以下参照: `set xlabel`。
3 ymtics
?commands set ymtics
?commands unset ymtics
?commands show ymtics
?set ymtics
?unset ymtics
?show ymtics
?ymtics
?noymtics
 コマンド `set ymtics` は、y 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
3 yrange
?commands set yrange
?commands show yrange
?set yrange
?show yrange
?yrange
 コマンド `set yrange` は、y 方向の垂直範囲を設定します。詳細は、以下参
 照: `set xrange`。
3 ytics
?commands set ytics
?commands unset ytics
?commands show ytics
?set ytics
?unset ytics
?show ytics
?ytics
?noytics
 コマンド `set ytics` は y 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 yzeroaxis
?commands set yzeroaxis
?commands unset yzeroaxis
?commands show yzeroaxis
?set yzeroaxis
?unset yzeroaxis
?show yzeroaxis
?yzeroaxis
?noyzeroaxis
 コマンド `set yzeroaxis` は x = 0 の直線 (y 軸) を書きます。詳細は、以
 下参照: `set zeroaxis`。
3 zdata
?commands set zdata
?commands show zdata
?set zdata
?show zdata
?zdata
 コマンド `set zdata` は z 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 zdtics
?commands set zdtics
?commands unset zdtics
?commands show zdtics
?set zdtics
?unset zdtics
?show zdtics
?zdtics
?nozdtics
 コマンド `set zdtics` は z 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 zzeroaxis
?commands set zzeroaxis
?commands unset zzeroaxis
?commands show zzeroaxis
?set zzeroaxis
?unset zzeroaxis
?show zzeroaxis
?zzeroaxis
?nozzeroaxis
 コマンド `set zzeroaxis` は (x=0,y=0) を通る直線を描きます。これは、2D
 描画、および `set view map` での splot では効力を持ちません。詳細は、
 以下参照: `set zeroaxis`, `set xyplane`。
3 cbdata
?commands set cbdata
?commands show cbdata
?set cbdata
?show cbdata
?cbdata
 このコマンドはカラーボックス軸のデータを時系列 (日時) 形式に式に設定し
 ます。以下参照: `set xdata`。
3 cbdtics
?commands set cbdtics
?commands unset cbdtics
?commands show cbdtics
?set cbdtics
?unset cbdtics
?show cbdtics
?cbdtics
?nocbdtics
 コマンド `cbdtics` はカラーボックス軸の目盛りの刻みを曜日に変換します。
 詳細は、以下参照: `set xdtics`。
3 zero
?commands set zero
?commands show zero
?set zero
?show zero
?zero
 `zero` の値は、0.0 に近いデフォルトの閾値を表します。

 書式:
       set zero <expression>
       show zero

 `gnuplot` は、(複素数値を持つ点の描画においては) その値の虚数部分の絶
 対値が `zero` 閾値より大きい場合 (つまり実数でない値を持つ点) は、その
 点を描画しません。この閾値は `gnuplot` の他の様々な部分においてその
 (大まかな) 数値誤差の閾値としても使われています。デフォルトの `zero` の
 値は 1e-8 です。1e-3 (= 典型的なビットマップディスプレイの解像度の逆数)
 より大きい `zero` の値は設定すべきではないでしょうが、`zero` を 0.0 と
 設定するのは意味のないことではありません。
3 zeroaxis
?commands set zeroaxis
?commands unset zeroaxis
?commands show zeroaxis
?set zeroaxis
?unset zeroaxis
?show zeroaxis
?zeroaxis
 x 軸は `set xzeroaxis` によって描かれ、`unset xzeroaxis` によって削除
 されます。同様の y, x2, y2, z 軸用のコマンドが同様の働きをします。

 書式:
       set {x|x2|y|y2|z}zeroaxis { {linestyle | ls <line_style>}
                                  | { linetype | lt <line_type>}
                                    { linewidth | lw <line_width>}}
       unset {x|x2|y|y2|z}zeroaxis
       show {x|y|z}zeroaxis


 デフォルトでは、これらのオプションはオフになっています。選択された 0
 の軸は <line_type> の線の型と<line_width> の線の幅 (現在使用している
 出力形式がサポートしていれば) で、あるいはあらかじめ定義された
 <line_style> のスタイルで描かれます。

 線の型を指定しなければ、軸は通常の軸の線の型 (型 0) で描かれます。

 `set zeroaxis` は `set xzeroaxis; set yzeroaxis` と同等です。z 軸は、
 `set zzeroaxis` を使って独立に設定する必要があることに注意してください。

 例:

 y=0 の軸を見えるように簡単に書く場合:

        set xzeroaxis

 太い線にして、違った色、または点線パターンにしたい場合:

        set xzeroaxis linetype 3 linewidth 2.5
3 zlabel
?commands set zlabel
?commands show zlabel
?set zlabel
?show zlabel
?zlabel
 このコマンドは z 軸の見出しを設定します。以下参照: `set xlabel`。
3 zmtics
?commands set zmtics
?commands unset zmtics
?commands show zmtics
?set zmtics
?unset zmtics
?show zmtics
?zmtics
?nozmtics
 コマンド `set zmtics` は z 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
3 zrange
?commands set zrange
?commands show zrange
?set zrange
?show zrange
?zrange
 コマンド `set zrange` は z 軸方向に表示される範囲を設定します。このコ
 マンドは `splot` にのみ有効で、`plot` では無視されます。詳細は、以下参
 照: `set xrange`。
3 ztics
?commands set ztics
?commands unset ztics
?commands show ztics
?set ztics
?unset ztics
?show ztics
?ztics
?noztics
 コマンド `set ztics` は z 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 cblabel
?commands set cblabel
?commands show cblabel
?set cblabel
?show cblabel
?cblabel
 このコマンドはカラーボックス軸の見出しを設定します。以下参照:
 `set xlabel`。
3 cbmtics
?commands set cbmtics
?commands unset cbmtics
?commands show cbmtics
?set cbmtics
?unset cbmtics
?show cbmtics
?cbmtics
?nocbmtics
 コマンド `set cbmtics` はカラーボックス軸の目盛りの見出しを月に変換し
 ます。詳細は、以下参照: `set xmtics`。
3 cbrange
?commands set cbrange
?commands show cbrange
?set cbrange
?show cbrange
?cbrange
 コマンド `set cbrange` は、スタイル `with pm3d`, `with image` や
 `with palette` などによって現在のパレット (`palette`) を使って色付けさ
 れる値の範囲を設定します。その範囲外の値に対しては、最も近い限界の値の
 色が使用されます。

 カラーボックス軸 (cb-軸) が `splot` で自動縮尺されている場合は、その
 カラーボックスの範囲は `zrange` が使われます。`splot ... pm3d|palette`
 で描画される点は、異なる `zrange` と `cbrange` を使うことでフィルタリ
 ングできます。

 `set cbrange` の書式に関する詳細は、以下参照: `set xrange`。以下も参照:
 `set palette`, `set colorbox`。
3 cbtics
?commands set cbtics
?commands unset cbtics
?commands show cbtics
?set cbtics
?unset cbtics
?show cbtics
?cbtics
?nocbtics
 コマンド `set cbtics` はカラーボックス軸の (見出し付けされる) 大目盛り
 を制御します。詳細は、以下参照: `set xtics`。
2 shell
?commands shell
?shell
 `shell` コマンドは対話的なシェルを起動します。`gnuplot` に戻るには、
 VMS では `logout` を、Unix ならば `exit` もしくは END-OF-FILE 文字を、
 AmigaOS では `endcli` を、MS-DOS か OS/2 ならば `exit` を入力して下
 さい。

 シェルコマンドを実行する方法は 2 つあります: コマンド `system` を使う
 か `!` (VMS では $) を使うか。前者は、コマンド文字列をパラメータとして
 取るので、他の gnuplot コマンドのどこでも使うことができますが、後者の
 書式は、その行にそのコマンドただ一つであることを要求します。これらの場
 合コマンドが終了するとすぐに制御は `gnuplot` に戻ってきます。例えば
 AmigaDOS, MS-DOS, OS/2 では、

      ! dir
 または
      system "dir"

 とするとディレクトリの一覧を表示して `gnuplot` に戻ってきます。

 `system` を使う他の例:
        system "date"; set time; plot "a.dat"
        print=1; if (print) replot; set out; system "lpr x.ps"
2 splot
?commands splot
?splot
 `splot` は 3 次元描画のためのコマンドです (もちろんご存知でしょうが、
 実際にはその 2 次元への射影)。それは関数、またはファイルから読み込んだ
 データから `plot` コマンドととても良く似た方法でその描画を作ります。
 `splot` は、それぞれ単一の x, y, z 軸を提供するだけで、`plot` で用意さ
 れている第 2 軸 x2, y2 のようなものはありません。

 `plot` コマンドと共通の仕様については、以下参照: `plot`。ここではそれ
 と異なるものだけ詳細に取り上げます。

 書式:
       splot {<ranges>}
             {<iteration>}
             <function> | "<datafile>" {datafile-modifiers}}
             {<title-spec>} {with <style>}
             {, {definitions,} <function> ...}

 ここで、関数 <function>、またはクォートでくくられたデータファイル名の
 どちらかが必要です。関数は、一本の数式、あるいは媒介変数モードでは
 3 つの数式の組です。

 デフォルトでは、`splot` は描画されるデータの下に完全な xy 面を描きます。
 z の一番下の目盛りと xy 平面の位置関係は `set ticslevel` で変更できます。
 `splot` の射影の向きは `set view` で制御できます。詳細は、以下参照:
 `set view`, `set ticslevel`。

 `splot` コマンドの範囲の指定の書式は `plot` の場合と同じです。媒介変数
 モードでなければ範囲は `xrange`, `yrange`, `zrange` の順であり、媒介変
 数モードでは `urange`, `vrange`, `xrange`, `yrange`, `zrange` の順です。

 `title` オプションも `plot` と同じです。`with` も `plot` とほぼ同じ
 ですが、`splot` では利用可能な描画スタイルは `lines`, `points`,
 `linespoints`, `dots`, `impulses` に限られています。`plot` で使える
 エラーバーの機能は `splot` にはありません。

 `datafile` オプションにはさらに違いがあります。

 以下も参照: `show plot`。
3 データファイル (datafile)
?commands splot datafile
?splot datafile
?splot data-file
 `plot` と同じように、ファイルに含まれる離散的なデータは、そのファイル
 名をクォートで囲んで指定することで描画できます。

 書式:
       splot '<file_name>' {binary <binary list>}
                           {matrix}
                           {index <index list>}
                           {every <every list>}
                           {using <using list>}

 `""` や `"-"` といった特別なファイル名も `plot` のときと同様に許されます。

 手短にいうと、`binary` や `matrix` はそのデータが特別な形であることを、
 `index` は多重データ集合ファイルからどのデータ集合を選んで描画するかを、
 `every` は各データ集合からどのデータ行 (部分集合) を選んで描画するかを、
 `using` は各データ行からどのように列を選ぶかを指定します。

 `index` と `every` オプションは `plot` の場合と同じように振舞います。
 `using` も、`using` のリストが 2 つでなく 3 つ必要であるということを
 除いては同様です。

 `thru` や `smooth` といった `plot` のオプションは `splot` では利用でき
 ません。しかし、`cntrparam` や `dgrid3d` が、制限されてはいますが平滑化
 のために用意されています。

 データファイルの形式は、各点が (x,y,z) の 3 つ組である以外は、本質的に
 `plot` と同じです。もし一つの値だけが与えられれば、それは z として使われ、
 データブロック番号が y として、そして x はそのデータブロック内での番号が
 使われます。もし 2 つ、あるいは 4 つの値が与えられれば、`gnuplot` はその
 最後の値を pm3d plot での色の計算に使います。3 つの値は (x,y,z) の組と見
 なされます。他に値があれば、それは一般に誤差と見なされます。それは `fit`
 で使うことが可能です。

 `splot` のデータファイルでは、1 行の空行はデータブロックの分離子です。
 `splot` は個々のデータブロックを、関数の y-孤立線と同じものとして扱い
 ます。1 行の空行で分離されている点同士は線分で結ばれることはありません。
 全てのデータブロックが全く同じ点の数を持つ場合、`gnuplot` はデータ
 ブロックを横断し、対応する点同士を結ぶ孤立線を描きます。これは "grid
 data" と呼ばれ、曲面の描画、等高線の描画 (`set contour`)、隠線処理
 (`set hidden3d`) では、この形のデータであることが必要となります。以下
 も参照: `splot grid_data`。

 3 列の `splot` データにおいては、媒介変数モード (`parametric`) を指定
 することはもはや不要です。
4 binary matrix
?commands plot datafile binary matrix
?commands splot datafile binary matrix
?plot datafile matrix binary
?splot datafile matrix binary
?plot binary matrix
?splot binary matrix
?plot matrix binary
?splot matrix binary
?matrix binary
?binary matrix
?gpbin
 Gnuplot は、`array`, `record`, `format`, `filetype` などの general バ
 イナリ形式を特定するようなキーワードをつけずにオプション `binary` を使
 うことで、matrix バイナリファイルを読み込むことができます。その他の変換
 用の general バイナリキーワードは、matrix バイナリファイルにも適用でき
 るでしょう。(詳細は、以下参照: `binary general`。)

 以前のバージョンでは、`gnuplot` は動的にバイナリデータかどうかを判断
 していましたが、現在は、ファイル名の後ろに `binary` キーワードを直接
 指定することが必要です。

 単精度浮動小数の数値が次のように保存されています:

       <N+1>  <y0>   <y1>   <y2>  ...  <yN>
        <x0> <z0,0> <z0,1> <z0,2> ... <z0,N>
        <x1> <z1,0> <z1,1> <z1,2> ... <z1,N>
         :      :      :      :   ...    :

 これらは以下のような 3 つの数字の組に変換されます:

       <x0> <y0> <z0,0>
       <x0> <y1> <z0,1>
       <x0> <y2> <z0,2>
        :    :     :
       <x0> <yN> <z0,N>

       <x1> <y0> <z1,0>
       <x1> <y1> <z1,1>
        :    :     :

 そして、これらの 3 つの数字の組は `gnuplot` の孤立線に変換され、その後
 `gnuplot` が通常の方法で描画の残りを行います。

 行列やベクトルの操作のサブルーチン (C による) が `binary.c` に用意され
 ています。バイナリデータを書くルーチンは

       int fwrite_matrix(file,m,nrl,nrl,ncl,nch,row_title,column_title)

 です。これらのサブルーチンを使う例が `bf_test.c` として用意されていて、
 これはデモファイル `demo/binary.dem` 用に複数のバイナリファイルを生成
 します。

 `index` キーワードは、ファイルフォーマットが 1 つのファイルにつき 1 つ
 の曲面しか許さないため、サポートされません。`every` や `using` フィルタ
 はサポートされます。`using` は、データがあたかも上の 3 つ組の形で読まれ
 たかのように働きます。

 以下参照: `binary general`。以下も参照。
^ <a href="http://www.gnuplot.info/demo/binary.html">
 バイナリファイルの splot のデモ。
^ </a>
4 データファイルの例
?commands splot datafile example
?splot datafile example
?splot example
 以下は3 次元データファイルの描画の単純な一つの例です。

       splot 'datafile.dat'

 ここで、"datafile.dat" は以下を含むとします:

       # The valley of the Gnu.
          0 0 10
          0 1 10
          0 2 10

          1 0 10
          1 1 5
          1 2 10

          2 0 10
          2 1 1
          2 2 10

          3 0 10
          3 1 0
          3 2 10

 この "datafile.dat" は 4*3 の格子 (それぞれ 3 点からなるブロックの
 4 つの行) を定義することに注意して下さい。行 (データブロック) は 1 行の
 空行で区切られます。

^ <img align=bottom src="http://www.gnuplot.info/doc/splot.gif" alt="[splot.gif]" width=640 height=480>
 x の値はそれぞれのデータブロックの中で定数になっていることに注意して下
 さい。もし y を定数の値とし、隠線処理が有効な状態で描画すると、その曲面は
 裏返しで書かれることになります。

 格子状データ (grid data) に対して、個々のデータブロック内で x の値を定
 数としておく必要はありませんし、同じ場所の y の値を同じ値に揃えておく
 必要もありません。`gnuplot` は個々のデータブロック内の点の数が等しいと
 いうことを必要としているだけです。しかし、等高線を導くのに用いられる曲
 面の網目は、対応する点を列的に選んで結ぶため、不揃いの格子データに対す
 る曲面の描画への影響は予想できません。それはケースバイケースの原理でテ
 ストすべきでしょう。
4 ascii 数字の matrix (matrix_ascii)
?commands plot datafile matrix ascii
?commands splot datafile matrix ascii
?plot datafile matrix ascii
?splot datafile matrix ascii
?plot matrix ascii
?splot matrix ascii
?data-file matrix ascii
?datafile matrix ascii
?matrix ascii
     {s}plot 'a.dat' matrix
 のキーワード `matrix` (キーワード `binary` がその後ろにつかない場合)
 は、データが ascii 数字の配列形式で保存されていることを意味します。

 各ブロックの z の値は一行で一度に読まれます。すなわち、
     z11 z12 z13 z14 ...
     z21 z22 z23 z24 ...
     z31 z32 z33 z34 ...
 など。

 3 次元では、配列の曲面描画の x、y 番号は、それぞれ配列の列番号と行番号
 (0 から始まる) に対応します。軸の変換や伸縮も、x=$1, y=$2, z=$3 による
 3 列のデータファイルに対する通常の方法と同様に行えます。例:
     splot 'a.dat' matrix using (1+$1/100):(1+$2*10):3

 空行、またはコメント行は配列データを終了させ、新たな曲面の網 (mesh) を
 開始します。いつものことですが、`splot` コマンド の `index` オプション
 を使ってファイル内の網を自由に選択できます。

 2 次元描画における配列データの縦、および横の行の描画の例については、
 以下参照: `matrix`。
4 matrix
?commands plot datafile matrix
?commands splot datafile matrix
?plot datafile matrix
?splot datafile matrix
?plot matrix
?splot matrix
?data-file matrix
?datafile matrix
?matrix
 データファイルは、ascii 形式かバイナリ形式の matrix (配列) フォーマッ
 トを使用することも可能で、`binary` または `matrix binary` がバイナリ形
 式を意味します。詳しくは、以下参照: `matrix ascii`, `matrix binary`。

 `splot` での基本的な使用法:
     splot 'a.dat' matrix
     splot 'a.gpbin' {matrix} binary
 `splot` での進んだ使用法:
     splot 'a.dat' matrix using 1:2:3
     splot 'a.gpbin' {matrix} binary using 1:2:3
 これにより軸の座標と z の値を独立に変換できるようになります。

 `plot` での使用法:
     plot `a.dat` matrix
     plot `a.dat` matrix using 1:3
     plot 'a.gpbin' {matrix} binary using 1:3
 これらは配列の行を描画し、using 2:3 とすれば配列の列を描画、using 1:2
 は、点の座標を描画します (多分無意味です)。オプション `every` を適用す
 ることで明示的に行や列を指定できます。

 例 -- ASCII データファイルの配列の軸の拡大:
     splot `a.dat` matrix using (1+$1):(1+$2*10):3

 例 -- ASCII データファイルの配列の第 3 行の描画:
     plot 'a.dat' matrix using 1:3 every 1:999:1:2
 (行は 0 から数えられるので、3 ではなくて 2 を指定します)。
3 格子状データ (grid data)
?commands splot grid_data
?splot grid_data
?grid_data
 3 次元描画のためのルーチンは、個々の網目の格子においては一つの標本点と
 一つのデータ点がある、という形の格子状データ用に設計されています。各デ
 ータ点は、関数の値を評価すること (以下参照: `set isosamples`)、または
 データファイルを読み込むこと (以下参照: `splot datafile`) によって生成
 されます。"孤立線" という言葉は関数に対しても、データに対してもその網
 目の線を表すものとして用いられます。網目は、必ずしも x, y に関する長方
 形でなくてもよく、u,v で媒介変数表示されても構わないことに注意して下さ
 い。以下参照: `set isosamples`。

 しかし、`gnuplot` はそのような形式を必ずしも必要とはしません。例えば
 関数の場合は、`samples` は `isosamples` と違っていても構いません。
 すなわち、x-孤立線のうち、1 本の y-孤立線と交わないものがいくつかある
 ことがあります。データファイルの場合は、個々のデータブロックのばらつい
 た点の個数が全て同じであれば、"孤立線は" はデータブロックの点を結び、
 "横断孤立線" は各データブロックの対応する点同士を結び、"曲面" を作ろう
 とします。どちらの場合でも、等高線、および隠線処理モードは点が意図した
 フォーマットであった場合とは違った描画を与えることになります。ばらつき
 のあるデータは `set dgrid3d` によって{異なる}格子状データに変換すること
 ができます。

 等高線に関するコードは、y-孤立線の点と、それに対応する隣の y-孤立線上
 の点の間の線分に沿っての z の張力を計測します。よって、x-孤立線に、
 y-孤立線との交点とはならないような標本点があるような曲面に対しては、
 `splot` の等高線はそのような標本点を無視することになります。以下を試して
 みて下さい:
        set xrange [-pi/2:pi/2]; set yrange [-pi/2:pi/2]
        set style function lp
        set contour
        set isosamples 10,10; set samples 10,10;
        splot cos(x)*cos(y)
        set samples 4,10; replot
        set samples 10,4; replot

3 splot の概要 (splot overview)
?commands splot overview
?splot overview
 `splot` は点の集まりとして、あるいは、それらの点を結ぶことによって曲面
 を表示することができます。`plot` と同様に、点はデータファイルから読む
 こともできますし、指定された区間で関数の値を評価して得ることもできます。
 以下参照: `set isosamples`。曲面は、各点を線分で結ぶことで近似的に作ら
 れます。以下参照: `set surface`。そしてその場合曲面は、`set hidden3d`
 で不透明にもできます。3 次元曲面を眺める向きは、`set view` で変更でき
 ます。

 さらに、格子状のデータ点に対しては、`splot` は同じ高さを持つ点を補間す
 ることができ (以下参照: `set contour`)、そしてそれらを結んで等高線を描
 くことができます。さらに、その結び方には真直な線分や滑らかな線を使うこ
 とができます (以下参照: `set cntrparam`)。関数は、常に `set isosamples`
 と `set samples` で決定される格子状データとして評価されます。一方、フ
 ァイルのデータは、`data-file` に書かれているような格子状データフォーマ
 ットにするか、あるいは格子データを生成する (以下参照: `set dgrid3d`)
 ということをしなければそうはなりません。

 等高線は曲面の上に表示することもできますし、底面に射影することもできま
 す。底面への射影は、ファイルに書き出すこともでき、そしてそれを `plot`
 で再び読み込んで `plot` のより強い整形能力を生かすこともできます。
2 system
?commands system
?system
 `system "command"` は、標準的なシェルを使って "command" を実行します。
 以下参照: `shell`。関数として呼ばれた場合、`system("command")` は結果
 として標準出力に流れる文字列を文字列値として返します。一つ追加される改
 行文字は無視されます。

 これは、gnuplot スクリプト内に外部関数を取り込むのに使えます:

       f(x) = real(system(sprintf("somecommand %f", x)))
2 test
?commands test
?test palette
?test
 このコマンドは、出力形式やパレットでどのような出力が行なえるかを画像で
 テストし表示します。

 書式:
       test {terminal | palette [rgb|rbg|grb|gbr|brg|bgr]}

 `test` または `test terminal` は、現在使用中の出力形式 (`terminal`) で
 使える線の種類、点の種類、または有用なそして利用可能なその他の描画を生
 成します。

 `test palette` は、現在のカラーパレット (`palette`) で計算した R(z),
 G(z),B(z) (0<=z<=1) の状態を画像で描画します。それは実際には、本来はあ
 なたが `show palette palette 256 float` の結果から作るべき綺麗な描画で
 す。追加のパラメータは、r,g,b の文字の組合せで、それにより描画する順番
 が決定されます。`set palette gray` で色々試してみてください。デフォル
 トの順番は rgb です。
2 undefine
?commands undefine
?undefine
 1 つ、または複数の定義済みのユーザ変数を削除します。これは、初期化テス
 トを含むようなスクリプトの状態をリセットするのに便利でしょう。

 例:

       undefine foo foo1 foo2
       if (!exists("foo")) load "initialize.gp"

2 unset
?commands unset
?unset
=iteration
 コマンド `set` で設定したオプションは、それに対応した `unset` コマンド
 によってそのデフォルトの値に戻すことが可能です。`unset` コマンドには繰
 り返し節も利用できます。以下参照: `iteration`。

 例:
       set xtics mirror rotate by -45 0,10,100
       ...
       unset xtics

       # 番号 100 から 200 までのラベルを unset
       unset for [i=100:200] label i

2 update
?commands update
?update
 このコマンドは当てはめ (fit) のパラメータの現在の値を、初期値のファイ
 ルの形式で (`fit` の項で説明されている)、与えられたファイルに書き出し
 ます。これは、現在の値を、後で使うために、あるいは終了/中断した当ては
 めを再実行するために保存しておくのに有用です。

 書式:
       update <filename> {<filename>}

 2 番目のファイル名を指定すると、元のパラメータファイルは変更せずに 2
 番目のファイルの方に更新された値を書き出します。

 そうでなければ、指定したファイルが存在すれば `gnuplot` はそのファイル
 名に `.old` をつけてファイル名を変更し、指定したファイル名のファイルを
 新たに開き直します。つまり、"`update 'fred'`" とすると、それは
 "`!rename fred fred.old; update 'fred.old' 'fred'`" としたことと同じこ
 とになります。["filename.ext" の 12 文字しか使えない DOS や他のシステ
 ムでは、"ext" が "`old`" になって "filename" は最初のファイルに関係す
 るもの (多分どれかがすぐに分かるでしょう) が使われます。VMS では、ファ
 イルのバージョン管理システムが使われるため、名前の変更は行なわれません。]

 より詳しい情報に関しては、以下参照: `fit`。
1 出力形式 (Terminal)
^ <h2> Terminal Types </h2>
2 terminal
?terminal
?term
 gnuplot はとても多くの出力形式をサポートしています。これらは、適切な
 出力形式を、必要なら機能を変更する追加オプションをつけて選択すること
 により設定されます。以下参照: `set terminal`。

 この文書は、あなたのシステム上で初期設定およびインストールがなされなか
 ったために利用できない出力形式についても記述されているかも知れません。
 インストールされた個々の gnuplot で、どの出力形式が有効なのかの一覧を
 見るには、オプションを何もつけずに 'set terminal' と打ってください。
<3 -- 全ての出力ドライバの項目は、.trm ファイルから引っ張って来られます。
1 グラフィカルユーザインターフェース (Graphical User Interfaces)
?graphical user interfaces
?gui's
 `gnuplot` のために色々なグラフィカルユーザインターフェースが書かれてき
 ました。その win32 用の物はこの配布版に含まれています。

 Bruce Ravel (ravel@phys.washington.edu) は、Gershon Elber による
 gnuplot.el を元に、GNU emacs, XEmacs 用の gnuplot-mode を書きました。
 gnuplot の CVS リポジトリにはそのコピーが含まれていますが、このパッケ
 ージの最新版は以下にもあります。
^ <a href="http://feff.phys.washington.edu/~ravel/software/gnuplot-mode/">
           http://feff.phys.washington.edu/~ravel/software/gnuplot-mode/
^ </a>
 Python, Tk/Tcl, および他のフロントエンドに関しては、以下のページのリン
 クをチェックしてみてください。
^ <a href="http://gnuplot.sourceforge.net/links.html">
          http://gnuplot.sourceforge.net/links.html
^ </a>

1 バグ (Bugs)
?bugs
 以前のものと現在のリリースに関して報告されたバグは SourceForge 上の公
 式配布サイトに置かれています。

 バグリポートは e-mail で gnuplot-bugs メーリングリストへ送って下さい。
 または、SourceForge の gnuplot ウェブサイトにその報告を投稿してくださ
 い。その際、あなたが使用している gnuplot のバージョンの完全な情報、そ
 して可能ならばそのバグを実証するテストスクリプトを送ってください。以下
 参照: `Seeking-assistance`。

 以下のセクションは、gnuplot 4.2 のリリース時現在に知られている問題の一
 覧を示しています。これらには外部のサポートライブラリのバグも含まれてい
 るので、gnuplot の修正とは関係なく改良されるかもしれません。

2 gnuplot の制限 (limitations)
?bugs gnuplot
=gamma
=bessel
=timefmt
=nohidden3d
=floating point exceptions
 浮動小数計算例外 (浮動小数値が大きすぎる (または小さすぎる) 場合、0 で
 割算した場合など) は、ユーザ定義関数において時折発生します。特に、いく
 つかのデモで、浮動小数の範囲を越える数値を生成することが起こるようです。
 システムがそのような例外を無視する (`gnuplot` はそのような点を定義でき
 ないもの、と見なします) か、または `gnuplot` の実行を中止するかは、コ
 ンパイル時 (あるいは実行時) の環境によります。

 ガンマ関数とベッセル関数、erf 関数は複素数引数に対しては動作しません。

 すべての x11 描画ウィンドウに対して、一度に 1 つのカラーパレットのみが
 有効です。これは、異なるパレットを使用する描画を含んだ multiplot では
 x11 上では正しく表示されない、ということを意味します。

 "時刻" として指定された座標は 24 時で折り返し、精度の最小単位は 1 秒で
 す。これは、特に地理上の座標に基づく時刻を使っている場合には制限になり
 ます。

 誤差指示線 (errorbars) は、極座標/球面座標描画モードでは使えません。

 `nohidden3d` は、全体的な設定である `set hidden3d` を、個々の描画に対
 して免除するためのオプションですが、これは媒介変数の曲線 (parametric)
 に対しては機能しません。

2 外部ライブラリ (External libraries)
?bugs external_libraries
=libgd
=svgalib
=locale
=internationalization
=pdf
 外部ライブラリ GD (PNG/JPEG/GIF ドライバで使用):
 バージョン 2.0.33 までの libgd には、Adobe の Symbol フォントの文字の
 マッピングに関するいくつかのバグがあります。また、アンチエイリアスされ
 た線分がキャンバスの上の角と交わる場合に、ライブラリがセグメンテーショ
 ンフォルトを引き起すこともあります。

 外部ライブラリ PDFlib (PDF ドライバで使用):
 gnuplot は libpdf のバージョン 4, 5, 6 のいずれかをリンクできます。し
 かし、これらはバージョンによってパイプされた入出力の処理が違っています
 ので、パイプを使って PDF を出力する gnuplot スクリプトは、PDFlib のあ
 るバージョンでだけしかちゃんと動かないかもしれません。

 外部ライブラリ svgalib (linux, vgadl ドライバで使用):
 これは gnuplot が root に setuid (嫌!) されることを要求しますし、ビデ
 オカードや X11 で使用されるグラフィックドライバに特有の多くのバグがあ
 ります。

 国際化 (ロケールの設定):
 gnuplot は、入出力の数、時刻、日付文字列のロケールに依存した書式の制御
 を、C ランタイムライブラリに含まれる setlocale() を用いて行うので、ロ
 ケールの有効性や、ロケール機能のサポートのレベル (例えば数字の 3 桁毎
 の区切り文字など) などは、あなたのコンピュータが提供する国際化のサポー
 トの度合いに依存します。
