/* GNUPLOT - post.trm */
/*
 * Copyright (C) 1990   
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted, 
 * provided that the above copyright notice appear in all copies and 
 * that both that copyright notice and this permission notice appear 
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the modified code.  Modifications are to be distributed 
 * as patches to released version.
 *  
 * This software  is provided "as is" without express or implied warranty.
 * 
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *     postscript
 *
 * AUTHORS
 *  Russell Lang
 * 
 * send your comments or suggestions to (pixar!info-gnuplot@sun.com).
 *
 * The 'postscript' driver produces landscape output 10" wide and 7" high.  
 * To get a smaller epsf output use 'set size 0.5,0.5', 
 * 'set term postscript portrait', make only one plot per file
 * and change the first line of the postscript file from
 * '%!PS-Adobe-2.0' to '%!PS-Adobe-2.0 EPSF-2.0'
 * To change font to Times-Roman and font size to 20pts use 
 * 'set term postscript "Times-Roman" 20'.
 */


/* PostScript driver by Russell Lang, rjl@monu1.cc.monash.edu.au */

char ps_font[MAX_ID_LEN+1] = "Courier" ; /* name of font */
int ps_fontsize = 14;					 /* size of font in pts */
BOOLEAN ps_portrait = FALSE;				 /* vertical page */
BOOLEAN ps_color = FALSE;
int ps_page=0;			/* page count */
int ps_path_count=0; 	/* count of lines in path */
int ps_ang=0;			/* text angle */
enum JUSTIFY ps_justify=LEFT;	/* text is flush left */

char *PS_header[] = {
"/vpt2 vpt 2 mul def\n",
"/hpt2 hpt 2 mul def\n",
/* flush left show */
"/Lshow { currentpoint stroke moveto\n",
"  0 vshift rmoveto show } def\n", 
/* flush right show */
"/Rshow { currentpoint stroke moveto\n",
"  dup stringwidth pop neg vshift rmoveto show } def\n", 
/* centred show */
"/Cshow { currentpoint stroke moveto\n",
"  dup stringwidth pop -2 div vshift rmoveto show } def\n", 
/* Dash or Color Line */
"/DL { Color {setrgbcolor [] 0 setdash pop}\n",
" {pop pop pop 0 setdash} ifelse } def\n",
/* Border Lines */
"/BL { stroke gnulinewidth 2 mul setlinewidth } def\n",
/* Axes Lines */
"/AL { stroke gnulinewidth 2 div setlinewidth } def\n",
/* Plot Lines */
"/PL { stroke gnulinewidth setlinewidth } def\n",
/* Line Types */
"/LTb { BL [] 0 0 0 DL } def\n", /* border */
"/LTa { AL [1 dl 2 dl] 0 setdash 0 0 0 setrgbcolor } def\n", /* axes */
"/LT0 { PL [] 0 1 0 DL } def\n",
"/LT1 { PL [4 dl 2 dl] 0 0 1 DL } def\n",
"/LT2 { PL [2 dl 3 dl] 1 0 0 DL } def\n",
"/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def\n",
"/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def\n",
"/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def\n",
"/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def\n",
"/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def\n",
"/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def\n",
"/M {moveto} def\n",
"/L {lineto} def\n",
"/P { stroke [] 0 setdash\n", /* Point */
"  currentlinewidth 2 div sub moveto\n",
"  0 currentlinewidth rlineto  stroke } def\n",
"/D { stroke [] 0 setdash  2 copy  vpt add moveto\n", /* Diamond */
"  hpt neg vpt neg rlineto  hpt vpt neg rlineto\n",
"  hpt vpt rlineto  hpt neg vpt rlineto  closepath  stroke\n",
"  P  } def\n",
"/A { stroke [] 0 setdash  vpt sub moveto  0 vpt2 rlineto\n", /* Plus (Add) */
"  currentpoint stroke moveto\n",
"  hpt neg vpt neg rmoveto  hpt2 0 rlineto stroke\n",
"  } def\n",
"/B { stroke [] 0 setdash  2 copy  exch hpt sub exch vpt add moveto\n", /* Box */
"  0 vpt2 neg rlineto  hpt2 0 rlineto  0 vpt2 rlineto\n",
"  hpt2 neg 0 rlineto  closepath  stroke\n",
"  P  } def\n",
"/C { stroke [] 0 setdash  exch hpt sub exch vpt add moveto\n", /* Cross */
"  hpt2 vpt2 neg rlineto  currentpoint  stroke  moveto\n",
"  hpt2 neg 0 rmoveto  hpt2 vpt2 rlineto stroke  } def\n",
"/T { stroke [] 0 setdash  2 copy  vpt 1.12 mul add moveto\n", /* Triangle */
"  hpt neg vpt -1.62 mul rlineto\n",
"  hpt 2 mul 0 rlineto\n",
"  hpt neg vpt 1.62 mul rlineto  closepath  stroke\n",
"  P  } def\n",
"/S { 2 copy A C} def\n", /* Star */
NULL
};

#define PS_XOFF	50	/* page offset in pts */
#define PS_YOFF	50

#define PS_XMAX 7200
#define PS_YMAX 5040

#define PS_XLAST (PS_XMAX - 1)
#define PS_YLAST (PS_YMAX - 1)

#define PS_VTIC (PS_YMAX/80)
#define PS_HTIC (PS_YMAX/80)

#define PS_SC (10)				/* scale is 1pt = 10 units */
#define	PS_LW (0.5*PS_SC)		/* linewidth = 0.5 pts */

#define PS_VCHAR (14*PS_SC)		/* default is 14 point characters */
#define PS_HCHAR (14*PS_SC*6/10)


PS_options()
{
	extern struct value *const_express();
	extern double real();

	if (!END_OF_COMMAND) {
		if (almost_equals(c_token,"p$ortrait")) {
			ps_portrait=TRUE;
			c_token++;
		}
		else if (almost_equals(c_token,"l$andscape")) {
			ps_portrait=FALSE;
			c_token++;
		}
		else if (almost_equals(c_token,"d$efault")) {
			ps_portrait=FALSE;
			ps_color=FALSE;
			strcpy(ps_font,"Courier");
			ps_fontsize = 14;
			c_token++;
		}
	}

	if (!END_OF_COMMAND) {
		if (almost_equals(c_token,"m$onochrome")) {
			ps_color=FALSE;
			c_token++;
		}
		else if (almost_equals(c_token,"c$olor")) {
			ps_color=TRUE;
			c_token++;
		}
	}

	if (!END_OF_COMMAND && isstring(c_token)) {
		quote_str(ps_font,c_token);
		c_token++;
	}

	if (!END_OF_COMMAND) {
		/* We have font size specified */
		struct value a;
		ps_fontsize = (int)real(const_express(&a));
		c_token++;
		term_tbl[term].v_char = (unsigned int)(ps_fontsize*PS_SC);
		term_tbl[term].h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	}

	sprintf(term_options,"%s %s \"%s\" %d",
		ps_portrait ? "portrait" : "landscape",
		ps_color ? "color" : "monochrome",ps_font,ps_fontsize);
}


PS_init()
{
struct termentry *t = &term_tbl[term];
int i;
	ps_page = 0;
	fprintf(outfile,"%%!PS-Adobe-2.0\n");
	fprintf(outfile,"%%%%Creator: gnuplot\n");
	fprintf(outfile,"%%%%DocumentFonts: %s\n", ps_font);
	fprintf(outfile,"%%%%BoundingBox: %d %d ", PS_XOFF,PS_YOFF);
	if (ps_portrait)
		fprintf(outfile,"%d %d\n", 
			(int)(xsize*(PS_XMAX)/PS_SC+0.5+PS_XOFF), 
			(int)(ysize*(PS_YMAX)/PS_SC+0.5+PS_YOFF) );
	else 
		fprintf(outfile,"%d %d\n", 
			(int)(ysize*(PS_YMAX)/PS_SC+0.5+PS_XOFF), 
			(int)(xsize*(PS_XMAX)/PS_SC+0.5+PS_YOFF) );
	fprintf(outfile,"%%%%Pages: (atend)\n");
	fprintf(outfile,"%%%%EndComments\n");
	fprintf(outfile,"/gnudict 40 dict def\ngnudict begin\n");
	fprintf(outfile,"/Color %s def\n",ps_color ? "true" : "false");
	fprintf(outfile,"/gnulinewidth %.3f def\n",PS_LW);
	fprintf(outfile,"/vshift %d def\n", (int)(t->v_char)/(-3));
	fprintf(outfile,"/dl {%d mul} def\n",PS_SC); /* dash length */
	fprintf(outfile,"/hpt %.1f def\n",PS_HTIC/2.0);
	fprintf(outfile,"/vpt %.1f def\n",PS_VTIC/2.0);
	for ( i=0; PS_header[i] != NULL; i++)
		fprintf(outfile,"%s",PS_header[i]);
	fprintf(outfile,"end\n");
	fprintf(outfile,"%%%%EndProlog\n");
}


PS_graphics()
{
struct termentry *t = &term_tbl[term];
	ps_page++;
	fprintf(outfile,"%%%%Page: %d %d\n",ps_page,ps_page);
	fprintf(outfile,"gnudict begin\n");
	fprintf(outfile,"gsave\n");
	fprintf(outfile,"%d %d translate\n",PS_XOFF,PS_YOFF);
	if (ps_portrait) {
	    fprintf(outfile,"%.3f %.3f scale\n", xsize/PS_SC, ysize/PS_SC);
	}
	else {
	    fprintf(outfile,"%.3f %.3f scale\n", ysize/PS_SC, xsize/PS_SC);
	    fprintf(outfile,"90 rotate\n0 %d translate\n", -PS_YMAX);
	}
	fprintf(outfile,"0 setgray\n");
	fprintf(outfile,"/%s findfont %d ", ps_font, (t->v_char) );
	fprintf(outfile,"scalefont setfont\n");
	fprintf(outfile,"newpath\n");
	ps_path_count = 0;
}


PS_text()
{
	ps_path_count = 0;
	fprintf(outfile,"stroke\ngrestore\nend\nshowpage\n");
}


PS_reset()
{
	fprintf(outfile,"%%%%Trailer\n");
	fprintf(outfile,"%%%%Pages: %d\n",ps_page);
}


PS_linetype(linetype)
int linetype;
{
char *line = "ba012345678"; 
	fprintf(outfile,"LT%c\n", line[(linetype%9)+2]);
	ps_path_count = 0;
}


PS_move(x,y)
unsigned int x,y;
{
	fprintf(outfile,"%d %d M\n", x, y);
	ps_path_count += 1;
}


PS_vector(x,y)
unsigned int x,y;
{
	fprintf(outfile,"%d %d L\n", x, y);
	ps_path_count += 1;
	if (ps_path_count >= 400) {
		fprintf(outfile,"currentpoint stroke moveto\n");
		ps_path_count = 0;
	}
}


PS_put_text(x,y,str)
unsigned int x, y;
char *str;
{
char ch;
	PS_move(x,y);
	if (ps_ang != 0)
		fprintf(outfile,"currentpoint gsave translate %d rotate 0 0 moveto\n"
			,ps_ang*90);
	putc('(',outfile);
	ch = *str++;
	while(ch!='\0') {
		if ( (ch=='(') || (ch==')') || (ch=='\\') )
			putc('\\',outfile);
		putc(ch,outfile);
		ch = *str++;
	}
	switch(ps_justify) {
		case LEFT : fprintf(outfile,") Lshow\n");
			break;
		case CENTRE : fprintf(outfile,") Cshow\n");
			break;
		case RIGHT : fprintf(outfile,") Rshow\n");
			break;
	}
	if (ps_ang != 0)
		fprintf(outfile,"grestore\n");
	ps_path_count = 0;
}

int PS_text_angle(ang)
int ang;
{
	ps_ang=ang;
	return TRUE;
}

int PS_justify_text(mode)
enum JUSTIFY mode;
{
	ps_justify=mode;
	return TRUE;
}

/* postscript point routines */
PS_point(x,y,number)
int x,y;
int number;
{
char *point = "PDABCTS";
	number %= POINT_TYPES;
 	if (number < -1)
		number = -1;		/* negative types are all 'dot' */
	fprintf(outfile,"%d %d %c\n", x, y, point[number+1]);
	ps_path_count = 0;
}

