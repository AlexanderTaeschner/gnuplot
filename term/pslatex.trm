/*
 * $Id: pslatex.trm,v 1.32 1997/05/18 21:22:24 drd Exp $
 */

/* GNUPLOT - pslatex.trm */
/*
 * Copyright (C) 1990 - 1993, 1997
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted, 
 * provided that the above copyright notice appear in all copies and 
 * that both that copyright notice and this permission notice appear 
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the modified code.  Modifications are to be distributed 
 * as patches to released version.
 *  
 * This software  is provided "as is" without express or implied warranty.
 * 
 * This file is included by ../term.c.
 *
 * This file supplies the terminal drivers:
 *     pslatex --latex with embedded postscript
 *     pstex   --plain TeX with embedded postscript
 *
 * AUTHORS
 *  George Phillips
 *  Russell Lang
 *  David Kotz
 * 
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 */

#ifndef GOT_DRIVER_H
#include "driver.h"
#endif

#ifdef TERM_REGISTER
register_term(pslatex)
register_term(pstex)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void PSLATEX_options __PROTO((void));
TERM_PUBLIC void PSLATEX_init __PROTO((void));
TERM_PUBLIC void PSLATEX_graphics __PROTO((void));
TERM_PUBLIC void PSLATEX_put_text __PROTO((unsigned int x, unsigned int y, char str[]));
TERM_PUBLIC int PSLATEX_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC int PSLATEX_text_angle __PROTO((int angle));
TERM_PUBLIC void PSLATEX_reset __PROTO((void));
TERM_PUBLIC void PSLATEX_text __PROTO((void));
TERM_PUBLIC void PSLATEX_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PSLATEX_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PSLATEX_linetype __PROTO((int lt));
TERM_PUBLIC void PSLATEX_point __PROTO((unsigned int x,unsigned int y, int number));
TERM_PUBLIC void PSLATEX_pointsize __PROTO((double size));
TERM_PUBLIC void PSLATEX_linewidth __PROTO((double width));

#define PSLATEX_XMAX (5*720)
#define PSLATEX_YMAX (3*720)

/* 10 pt char is about 10 pts high (say) */
#define PSLATEX_VCHAR (100)
/* 10 pt char is about 6 pts wide (say) */
/* I find about 5 points (output from test) - div */
#define PSLATEX_HCHAR (50)
#define GOT_PSLATEX_PROTO
#endif

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
static int PSLATEX_angle;
static int PSLATEX_justify;
static int PSLATEX_rotate = TRUE;
static char *PSLATEX_psfile = NULL;
static TBOOLEAN PSLATEX_useAuxFile = FALSE; /* do we write two files? */
static FILE *PSLATEX_auxFile;
static TBOOLEAN PSLATEX_output = TRUE; /* do we write LaTeX? */

struct text_command {
    int x, y, angle, justify;
    char* label;
    struct text_command* next;
};

static struct text_command* PSLATEX_labels;

TERM_PUBLIC void PSLATEX_options()
{
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "d$efault")) {
	    ps_color = FALSE;
	    ps_solid = FALSE;
	    PSLATEX_rotate = TRUE;
	    PSLATEX_useAuxFile = FALSE;
	    c_token++;
	}
    }

    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "c$olor")) {
	    ps_color = TRUE;
	    c_token++;
	}
    }

    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "m$onochrome")) {
	    ps_color = FALSE;
	    c_token++;
	}
    }

	if (!END_OF_COMMAND) {
		if (almost_equals(c_token,"so$lid")) {
			ps_solid=TRUE;
			c_token++;
		}
		else if (almost_equals(c_token,"da$shed")) {
			ps_solid=FALSE;
			c_token++;
		}
	}

    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "r$otate")) {
	    PSLATEX_rotate = TRUE;
	    c_token++;
	}
    }

    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "n$orotate")) {
	    PSLATEX_rotate = FALSE;
	    c_token++;
	}
    }

    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "a$uxfile")) {
	    PSLATEX_useAuxFile = TRUE;
	    c_token++;
	}
    }

	if (!END_OF_COMMAND) {
		/* We have font size specified */
		struct value a;
		int ps_fontsize = (int)real(const_express(&a));
		term->v_char = (unsigned int)(ps_fontsize*PS_SC);
		term->h_char = (unsigned int)(ps_fontsize*PS_SC/2);
	}

    /* be sure to generate an options string that PSLATEX_init understands */

    sprintf(term_options, "%s %s %s%s",
	    ps_color ? "color" : "monochrome",
	    ps_solid ? "solid" : "dashed",
	    PSLATEX_rotate ? "rotate" : "norotate",
	    PSLATEX_useAuxFile ? " auxfile" : "");
}

TERM_PUBLIC void PSLATEX_init()
{
    char *dotIndex;

    if (strcmp(term->name, "pstex") == 0)
        PSLATEX_output = FALSE;

    PSLATEX_auxFile = NULL;  /* until we know otherwise */
    /* dont tweak PSLATEX_useAuxFile if we decide we cannot comply
     * since this affects subsequent plots even after a set out
     * Instead, we will use PSLATEX_auxFile != NULL to indicate
     * use of an aux file
     */

    /* try to open the auxiliary file for the postscript parts. */
    if (outstr && PSLATEX_useAuxFile == TRUE &&
        (dotIndex=strrchr(outstr,'.')) ) {

	/* assume file name is ending in ".tex" */
	if (PSLATEX_psfile)
		free(PSLATEX_psfile);
	PSLATEX_psfile = gp_alloc(dotIndex - outstr + 3, "pslatex aux filename");
	if (PSLATEX_psfile) {
	    strncpy(PSLATEX_psfile, outstr, dotIndex-outstr+1); /* including . */
	    strcpy(PSLATEX_psfile + (dotIndex-outstr) + 1,"ps");
	    if ((PSLATEX_auxFile = fopen(PSLATEX_psfile,"w")) == (FILE *)NULL){
		fprintf(stderr,"Cannot open aux file %s for output\n",
			PSLATEX_psfile);
	    }
	} else {
	    fprintf(stderr,"Cannot make PostScript file name from %s\n",
		    outstr);
	    fprintf(stderr,"Turning off auxfile option\n");
	    PSLATEX_auxFile = NULL;
	}
    }

    if (PSLATEX_output) {
        fprintf(outfile, "%% GNUPLOT: LaTeX picture with Postscript\n");
	fprintf(outfile, "\\setlength{\\unitlength}{0.1bp}\n");
    } else {

        /* write plain TeX header */

        fprintf(outfile, "%% GNUPLOT: plain TeX with Postscript\n");
	fprintf(outfile, "\\expandafter\\ifx\\csname GNUPLOTpicture\\endcsname\\relax\n");
	fprintf(outfile, "  \\begingroup\n");

	fprintf(outfile, "    %% Inner version of \\newdimen from btxmac.tex\n");
	fprintf(outfile, "    \\edef\\innernewdimen{\\expandafter\\noexpand\\csname newdimen\\endcsname}%%\n");
	fprintf(outfile, "    \\innernewdimen\\GNUPLOTunit\n");
	fprintf(outfile, "  \\endgroup\n");
	fprintf(outfile, "  \\gdef\\GNUPLOTpicture(#1,#2){\\vbox to#2\\GNUPLOTunit\\bgroup\n");
	fprintf(outfile, "    \\def\\put(##1,##2)##3{\\unskip\\raise##2\\GNUPLOTunit\n");
	fprintf(outfile, "      \\hbox to0pt{\\kern##1\\GNUPLOTunit ##3\\hss}\\ignorespaces}%%\n");
	fprintf(outfile, "    \\def\\ljust##1{\\vbox to0pt{\\vss\\hbox to0pt{##1\\hss}\\vss}}%%\n");
	fprintf(outfile, "    \\def\\cjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1\\hss}\\vss}}%%\n");
	fprintf(outfile, "    \\def\\rjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1}\\vss}}%%\n");
	fprintf(outfile, "    \\def\\stack##1{\\let\\\\=\\cr\\tabskip=0pt\\halign{\\hfil ####\\hfil\\cr ##1\\crcr}}%%\n");
	fprintf(outfile, "    \\def\\lstack##1{\\hbox to0pt{\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n");
	fprintf(outfile, "    \\def\\cstack##1{\\hbox to0pt{\\hss\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n");
	fprintf(outfile, "    \\def\\rstack##1{\\hbox to0pt{\\vbox to0pt{\\stack{##1}\\vss}\\hss}}%%\n");
	fprintf(outfile, "    \\vss\\hbox to#1\\GNUPLOTunit\\bgroup\\ignorespaces}%%\n");
	fprintf(outfile, "  \\gdef\\endGNUPLOTpicture{\\hss\\egroup\\egroup}%%\n");
	fprintf(outfile, "\\fi\n");
	fprintf(outfile, "\\GNUPLOTunit=0.1bp\n");
    }

	{
		unsigned int xmin = xoffset * PSLATEX_XMAX / PS_SC;
		unsigned int xmax = (xoffset+xsize) * PSLATEX_XMAX / PS_SC;
		unsigned int ymin = yoffset * PSLATEX_YMAX / PS_SC;
		unsigned int ymax = (yoffset+ysize) * PSLATEX_YMAX / PS_SC;

		if (PSLATEX_auxFile) {
			FILE *tmp = outfile;
			outfile = PSLATEX_auxFile;
			PS_common_init(1,1,0, 0,0, xmin, ymin, xmax, ymax, NULL);
			outfile = tmp;
		} else {
			fprintf(outfile, "\\special{!\n");
			PS_common_init(1,1,0, 0,0, xmin, ymin, xmax, ymax, NULL);
			fprintf(outfile, "}\n");
		}
	}

    PSLATEX_angle = 0;
    PSLATEX_justify = 0;
    PSLATEX_labels = 0;
}

TERM_PUBLIC void PSLATEX_graphics()
{
    struct termentry *t = term;

    if (PSLATEX_output)
        fprintf(outfile, "\\begin{picture}(%d,%d)(0,0)\n", (int)(xsize*t->xmax), (int)(ysize*t->ymax));
    else
        fprintf(outfile, "\\GNUPLOTpicture(%d,%d)\n", (int)(xsize*t->xmax), (int)(ysize*t->ymax));

    if (PSLATEX_auxFile) {
	FILE *tmp;
	/*
	 * these are taken from the post.trm file computation
	 * of the bounding box, but without the X_OFF and Y_OFF
	 */
	int urx = (int)(xsize * (PS_XMAX) / PS_SC + 0.5),
	    ury = (int)(ysize * (PS_YMAX) / PS_SC + 0.5);

	/* generate special which xdvi and dvips can handle */
	fprintf(outfile,
		"\\special{psfile=%s llx=0 lly=0 urx=%d ury=%d rwi=%d}\n",
		PSLATEX_psfile, urx, ury, 10*urx);
	tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_graphics();
	outfile = tmp;
    } else {
	fprintf(outfile, "\\special{\"\n");
	PS_graphics();
    }

    PSLATEX_labels = (struct text_command *)NULL;
}

TERM_PUBLIC void PSLATEX_put_text(x, y, str)
unsigned int x, y;
char str[];
{
    struct text_command* tc;

    /* ignore empty strings */
    if (str[0] == '\0')
	return;
	
    tc = (struct text_command*)gp_alloc(sizeof(struct text_command), term->name);
    tc->x = x;
    tc->y = y;
    tc->label = (char *)gp_alloc(strlen(str) + 1, term->name);
    strcpy(tc->label, str);
    tc->justify = PSLATEX_justify;
    tc->angle = PSLATEX_angle;

    tc->next = PSLATEX_labels;
    PSLATEX_labels = tc;
}

TERM_PUBLIC int PSLATEX_justify_text(mode)
enum JUSTIFY mode;
{
    PSLATEX_justify = mode;
    return TRUE;
}

TERM_PUBLIC int PSLATEX_text_angle(angle)
int angle;
{
    /* rotated text is put in a short stack, and optionally uses 
     * postscript specials depending on PSLATEX_rotate */
    PSLATEX_angle = angle;
    return TRUE;
}


TERM_PUBLIC void PSLATEX_reset()
{
    if (PSLATEX_auxFile) {
	fclose(PSLATEX_auxFile);
	PSLATEX_auxFile=NULL;
    }
    if (PSLATEX_psfile) {
	free(PSLATEX_psfile);
	PSLATEX_psfile = NULL;
    }
}

TERM_PUBLIC void PSLATEX_text()
{
    struct text_command* tc;

    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_text();
	outfile = tmp;
    } else {
	PS_text();
	fprintf(outfile, "}\n");
    }

    for (tc = PSLATEX_labels; tc != (struct text_command*)NULL; tc = tc->next) {
	fprintf(outfile, "\\put(%d,%d){", tc->x, tc->y);
	switch (tc->angle) {
	case 0:
	    switch (tc->justify) {
	    case LEFT:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0)[l]{%s}"
				  : "\\ljust{%s}"), tc->label);
		break;
	    case CENTRE:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0){%s}"
				  : "\\cjust{%s}"), tc->label);
		break;
	    case RIGHT:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0)[r]{%s}"
				  : "\\rjust{%s}"), tc->label);
		break;
	    }
	    break;
	case 1: /* put text in a short stack */
	    if (PSLATEX_rotate) {
	        fprintf(outfile, "%%\n\\special{ps: gsave currentpoint currentpoint translate\n");
	        fprintf(outfile, "270 rotate neg exch neg exch translate}%%\n");
	    }
	    switch (tc->justify) {
	    case LEFT:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0)[lb]{\\shortstack{%s}}"
				  : "\\lstack{%s}"),
			tc->label);
		break;
	    case CENTRE:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0)[b]{\\shortstack{%s}}"
				  : "\\cstack{%s}"),
			tc->label);
		break;
	    case RIGHT:
		fprintf(outfile, (PSLATEX_output
				  ? "\\makebox(0,0)[lt]{\\shortstack{%s}}"
				  : "\\rstack{%s}"),
			tc->label);
		break;
	    }
	    if (PSLATEX_rotate) {
	        fprintf(outfile, "%%\n\\special{ps: currentpoint grestore moveto}%%\n");
	    }
	}
	fprintf(outfile, "}\n");
    }

    while (PSLATEX_labels) {
	tc = PSLATEX_labels->next;
	free(PSLATEX_labels->label);
	free(PSLATEX_labels);
	PSLATEX_labels = tc;
    }

    if (PSLATEX_output)
        fprintf(outfile, "\\end{picture}\n");
    else
	fprintf(outfile, "\\endGNUPLOTpicture\n");
}

TERM_PUBLIC void PSLATEX_move(x,y)
unsigned int x,y;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_move(x,y);
	outfile=tmp;
    } else {
	PS_move(x,y);
    }
}


TERM_PUBLIC void PSLATEX_vector(x,y)
unsigned int x,y;
{

    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_vector(x,y);
	outfile = tmp;
    } else {
	PS_vector(x,y);
    }
}


TERM_PUBLIC void PSLATEX_linetype(lt)
int lt;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_linetype(lt);
	outfile = tmp;
    } else {
	PS_linetype(lt);
    }
}

TERM_PUBLIC void PSLATEX_point(x,y,number)
unsigned int x,y;
int number;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_point(x,y,number);
	outfile = tmp;
    } else
	PS_point(x,y,number);
}


TERM_PUBLIC void PSLATEX_pointsize(ps)
double ps;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_pointsize(ps);
	outfile = tmp;
    } else
	PS_pointsize(ps);
}


TERM_PUBLIC void PSLATEX_linewidth(ps)
double ps;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = outfile;
	outfile = PSLATEX_auxFile;
	PS_linewidth(ps);
	outfile = tmp;
    } else
	PS_linewidth(ps);
}

#endif /* TERM_BODY */

#ifdef TERM_TABLE

#ifndef GOT_POST_PROTO
#define TERM_PROTO_ONLY
#include "post.trm"
#undef TERM_PROTO_ONLY
#endif

TERM_TABLE_START(pslatex_driver)
    "pslatex", "LaTeX picture environment with PostScript \\specials",
	PSLATEX_XMAX, PSLATEX_YMAX, PSLATEX_VCHAR, PSLATEX_HCHAR,
	PS_VTIC, PS_HTIC, PSLATEX_options, PSLATEX_init, PSLATEX_reset,
	PSLATEX_text, null_scale, PSLATEX_graphics, PSLATEX_move,
	PSLATEX_vector,	PSLATEX_linetype, PSLATEX_put_text, PSLATEX_text_angle,
	PSLATEX_justify_text, PSLATEX_point, do_arrow, set_font_null,
	PSLATEX_pointsize, 0 /*flags*/, 0/*suspend*/,0/*resume*/,0/*fillbox*/,
	PSLATEX_linewidth
TERM_TABLE_END(pslatex_driver)

#undef LAST_TERM
#define LAST_TERM pslatex_driver

TERM_TABLE_START(pstex_driver)
    "pstex", "plain TeX with PostScript \\specials",
	PSLATEX_XMAX, PSLATEX_YMAX, PSLATEX_VCHAR, PSLATEX_HCHAR,
	PS_VTIC, PS_HTIC, PSLATEX_options, PSLATEX_init, PSLATEX_reset,
	PSLATEX_text, null_scale, PSLATEX_graphics, PSLATEX_move,
	PSLATEX_vector,	PSLATEX_linetype, PSLATEX_put_text, PSLATEX_text_angle,
	PSLATEX_justify_text, PSLATEX_point, do_arrow, set_font_null,
	PSLATEX_pointsize, 0 /*flags*/, 0/*suspend*/,0/*resume*/,0/*fillbox*/,
	PSLATEX_linewidth
TERM_TABLE_END(pstex_driver)

#undef LAST_TERM
#define LAST_TERM pstex_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */


#ifdef TERM_HELP
START_HELP(pslatex)
"1 pslatex and pstex",
"?set terminal pslatex",
"?set term pslatex",
"?terminal pslatex",
"?term pslatex",
"?pslatex",
"?set terminal pstex",
"?set term pstex",
"?terminal pstex",
"?term pstex",
"?pstex",
" The `pslatex` and `pstex` drivers generate output for further processing by",
" LaTeX and TeX, respectively.  Figures generated by `pstex` can be included",
" in any plain-based format (including LaTeX).",
"",
" Syntax:",
"       set terminal pslatex | |pstex {<color>} {<dashed>} {<rotate>}",
"                                     {auxfile} {<font_size>}",
"",
" <color> is either `color` or `monochrome`.  <rotate> is either `rotate` or",
" `norotate` and determines if the y-axis label is rotated.  <font_size> is",
" used to scale the font from its usual size.",
"",
" If `auxfile` is specified, it directs the driver to put the PostScript",
" commands into an auxiliary file instead of directly into the LaTeX file.",
" This is useful if your pictures are large enough that dvips cannot handle",
" them.  The name of the auxiliary PostScript file is derived from the name of",
" the TeX file given on the `set output` command; it is determined by replacing",
" the trailing `.tex` (actually just the final extent in the file name---and",
" the option will be turned off if there is no extent) with `.ps` in the output",
" file name.  Remember to close the file before leaving `gnuplot`.",
"",
" Examples:",
"       set term pslatex monochrome dashed rotate       # set to defaults",
" To write the PostScript commands into the file \"foo.ps\":",
"       set term pslatex auxfile",
"       set output \"foo.tex\"; plot ...: set output"
END_HELP(pslatex)
#endif

