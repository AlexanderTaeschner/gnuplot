/*
 * $Id: pslatex.trm,v 1.35 1998/06/18 14:59:24 ddenholm Exp $
 */

/* GNUPLOT - pslatex.trm */

/*[
 * Copyright 1990 - 1993, 1998
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * This file is included by ../term.c.
 *
 * This file supplies the terminal drivers:
 *     pslatex --latex with embedded postscript
 *     pstex   --plain TeX with embedded postscript
 *
 * AUTHORS
 *  George Phillips
 *  Russell Lang
 *  David Kotz
 * 
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(pslatex)
register_term(pstex)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void PSLATEX_options __PROTO((void));
TERM_PUBLIC void PSLATEX_init __PROTO((void));
TERM_PUBLIC void PSLATEX_graphics __PROTO((void));
TERM_PUBLIC void PSLATEX_put_text __PROTO((unsigned int x, unsigned int y, char str[]));
TERM_PUBLIC int PSLATEX_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC int PSLATEX_text_angle __PROTO((int ang));
TERM_PUBLIC void PSLATEX_reset __PROTO((void));
TERM_PUBLIC void PSLATEX_text __PROTO((void));
TERM_PUBLIC void PSLATEX_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PSLATEX_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PSLATEX_linetype __PROTO((int lt));
TERM_PUBLIC void PSLATEX_point __PROTO((unsigned int x, unsigned int y, int number));
TERM_PUBLIC void PSLATEX_pointsize __PROTO((double size));
TERM_PUBLIC void PSLATEX_linewidth __PROTO((double width));

#define PSLATEX_XMAX (5*720)
#define PSLATEX_YMAX (3*720)

/* 10 pt char is about 10 pts high (say) */
#define PSLATEX_VCHAR (100)
/* 10 pt char is about 6 pts wide (say) */
/* I find about 5 points (output from test) - div */
#define PSLATEX_HCHAR (50)
#define GOT_PSLATEX_PROTO
#endif

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
static int PSLATEX_angle;
static int PSLATEX_justify;
static int PSLATEX_rotate = TRUE;
static char *PSLATEX_psfile = NULL;
static TBOOLEAN PSLATEX_useAuxFile = FALSE;	/* do we write two files? */
static FILE *PSLATEX_auxFile;
static TBOOLEAN PSLATEX_output = TRUE;	/* do we write LaTeX? */

struct text_command {
    int x, y, angle, justify;
    char *label;
    struct text_command *next;
};

static struct text_command *PSLATEX_labels;

TERM_PUBLIC void PSLATEX_options()
{
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "d$efault")) {
	    ps_color = FALSE;
	    ps_solid = FALSE;
	    PSLATEX_rotate = TRUE;
	    PSLATEX_useAuxFile = FALSE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "c$olor")
	    || almost_equals(c_token, "c$olour")) {
	    ps_color = TRUE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "m$onochrome")) {
	    ps_color = FALSE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "so$lid")) {
	    ps_solid = TRUE;
	    c_token++;
	} else if (almost_equals(c_token, "da$shed")) {
	    ps_solid = FALSE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "r$otate")) {
	    PSLATEX_rotate = TRUE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "n$orotate")) {
	    PSLATEX_rotate = FALSE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	if (almost_equals(c_token, "a$uxfile")) {
	    PSLATEX_useAuxFile = TRUE;
	    c_token++;
	}
    }
    if (!END_OF_COMMAND) {
	/* We have font size specified */
	struct value a;
	int ps_fontsize = (int) real(const_express(&a));
	term->v_char = (unsigned int) (ps_fontsize * PS_SC);
	term->h_char = (unsigned int) (ps_fontsize * PS_SC / 2);
    }
    /* be sure to generate an options string that PSLATEX_init understands */

    sprintf(term_options, "%s %s %s%s",
	    ps_color ? "color" : "monochrome",
	    ps_solid ? "solid" : "dashed",
	    PSLATEX_rotate ? "rotate" : "norotate",
	    PSLATEX_useAuxFile ? " auxfile" : "");
}

TERM_PUBLIC void PSLATEX_init()
{
    char *dotIndex;

    if (strcmp(term->name, "pstex") == 0)
	PSLATEX_output = FALSE;

    PSLATEX_auxFile = NULL;	/* until we know otherwise */
    /* dont tweak PSLATEX_useAuxFile if we decide we cannot comply
     * since this affects subsequent plots even after a set out
     * Instead, we will use PSLATEX_auxFile != NULL to indicate
     * use of an aux file
     */

    /* try to open the auxiliary file for the postscript parts. */
    if (outstr && PSLATEX_useAuxFile == TRUE &&
	(dotIndex = strrchr(outstr, '.'))) {

	/* assume file name is ending in ".tex" */
	if (PSLATEX_psfile)
	    free(PSLATEX_psfile);
	PSLATEX_psfile = gp_alloc(dotIndex - outstr + 3, "pslatex aux filename");
	if (PSLATEX_psfile) {
	/* including . */
	    safe_strncpy(PSLATEX_psfile, outstr, dotIndex - outstr + 1);
	    strcpy(PSLATEX_psfile + (dotIndex - outstr) + 1, "ps");
	    if ((PSLATEX_auxFile = fopen(PSLATEX_psfile, "w")) == (FILE *) NULL) {
		fprintf(stderr, "Cannot open aux file %s for output\n",
			PSLATEX_psfile);
	    }
	} else {
	    fprintf(stderr, "\
Cannot make PostScript file name from %s\n\
Turning off auxfile option\n", outstr);
	    PSLATEX_auxFile = NULL;
	}
    }
    if (PSLATEX_output) {
	fputs("\
% GNUPLOT: LaTeX picture with Postscript\n\
\\begingroup%\n\
  \\makeatletter%\n\
  \\newcommand{\\GNUPLOTspecial}{%\n\
    \\@sanitize\\catcode`\\%=14\\relax\\special}%\n\
  \\setlength{\\unitlength}{0.1bp}%\n", gpoutfile);
    } else {

	/* write plain TeX header */

	fputs("\
% GNUPLOT: plain TeX with Postscript\n\
\\begingroup\n\
  \\catcode`\\@=11\\relax\n\
  \\def\\GNUPLOTspecial{%\n\
    \\def\\do##1{\\catcode`##1=12\\relax}\\dospecials\n\
    \\catcode`\\{=1\\catcode`\\}=2\\catcode\\%=14\\relax\\special}%\n\
%\n\
\\expandafter\\ifx\\csname GNUPLOTpicture\\endcsname\\relax\n\
  \\csname newdimen\\endcsname\\GNUPLOTunit\n\
  \\gdef\\GNUPLOTpicture(#1,#2){\\vbox to#2\\GNUPLOTunit\\bgroup\n\
    \\def\\put(##1,##2)##3{\\unskip\\raise##2\\GNUPLOTunit\n\
      \\hbox to0pt{\\kern##1\\GNUPLOTunit ##3\\hss}\\ignorespaces}%\n\
    \\def\\ljust##1{\\vbox to0pt{\\vss\\hbox to0pt{##1\\hss}\\vss}}%\n\
    \\def\\cjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1\\hss}\\vss}}%\n\
    \\def\\rjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1}\\vss}}%\n\
    \\def\\stack##1{\\let\\\\=\\cr\\tabskip=0pt\\halign{\\hfil ####\\hfil\\cr ##1\\crcr}}%\n\
    \\def\\lstack##1{\\hbox to0pt{\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%\n\
    \\def\\cstack##1{\\hbox to0pt{\\hss\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%\n\
    \\def\\rstack##1{\\hbox to0pt{\\vbox to0pt{\\stack{##1}\\vss}\\hss}}%\n\
    \\vss\\hbox to#1\\GNUPLOTunit\\bgroup\\ignorespaces}%\n\
  \\gdef\\endGNUPLOTpicture{\\hss\\egroup\\egroup}%\n\
\\fi\n\
\\GNUPLOTunit=0.1bp\n", gpoutfile);
    }

    {
	unsigned int xmin_t = xoffset * PSLATEX_XMAX / PS_SC;
	unsigned int xmax_t = (xoffset + xsize) * PSLATEX_XMAX / PS_SC;
	unsigned int ymin_t = yoffset * PSLATEX_YMAX / PS_SC;
	unsigned int ymax_t = (yoffset + ysize) * PSLATEX_YMAX / PS_SC;

	if (PSLATEX_auxFile) {
	    FILE *tmp = gpoutfile;
	    gpoutfile = PSLATEX_auxFile;
	    PS_common_init(1, 1, 0, 0, 0, xmin_t, ymin_t, xmax_t, ymax_t, NULL);
	    gpoutfile = tmp;
	} else {
	    fputs("{\\GNUPLOTspecial{!\n", gpoutfile);
	    PS_common_init(1, 1, 0, 0, 0, xmin_t, ymin_t, xmax_t, ymax_t, NULL);
	    fputs("}}%\n", gpoutfile);
	}
    }

    PSLATEX_angle = 0;
    PSLATEX_justify = 0;
    PSLATEX_labels = 0;
}

TERM_PUBLIC void PSLATEX_graphics()
{
    struct termentry *t = term;

    if (PSLATEX_output)
	fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)%%\n", (int) (xsize * t->xmax), (int)
		(ysize * t->ymax));
    else
	fprintf(gpoutfile, "\\GNUPLOTpicture(%d,%d)\n", (int) (xsize * t->xmax), (int) (ysize * t->ymax));

    if (PSLATEX_auxFile) {
	FILE *tmp;
	/*
	 * these are taken from the post.trm file computation
	 * of the bounding box, but without the X_OFF and Y_OFF
	 */
	int urx = (int) (xsize * (PS_XMAX) / PS_SC + 0.5), ury = (int) (ysize * (PS_YMAX) / PS_SC
									+ 0.5);

	/* generate special which xdvi and dvips can handle */
	fprintf(gpoutfile,
		"\\special{psfile=%s llx=0 lly=0 urx=%d ury=%d rwi=%d}\n",
		PSLATEX_psfile, urx, ury, 10 * urx);
	tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_graphics();
	gpoutfile = tmp;
    } else {
	fputs("{\\GNUPLOTspecial{\"\n", gpoutfile);
	PS_graphics();
    }

    PSLATEX_labels = (struct text_command *) NULL;
}

TERM_PUBLIC void PSLATEX_put_text(x, y, str)
unsigned int x, y;
char str[];
{
    struct text_command *tc;

    /* ignore empty strings */
    if (str[0] == NUL)
	return;

    tc = (struct text_command *) gp_alloc(sizeof(struct text_command), term->name);
    tc->x = x;
    tc->y = y;
    tc->label = (char *) gp_alloc(strlen(str) + 1, term->name);
    strcpy(tc->label, str);
    tc->justify = PSLATEX_justify;
    tc->angle = PSLATEX_angle;

    tc->next = PSLATEX_labels;
    PSLATEX_labels = tc;
}

TERM_PUBLIC int PSLATEX_justify_text(mode)
enum JUSTIFY mode;
{
    PSLATEX_justify = mode;
    return TRUE;
}

TERM_PUBLIC int PSLATEX_text_angle(ang)
int ang;
{
    /* rotated text is put in a short stack, and optionally uses 
     * postscript specials depending on PSLATEX_rotate */
    PSLATEX_angle = ang;
    return TRUE;
}


TERM_PUBLIC void PSLATEX_reset()
{
    if (PSLATEX_auxFile) {
	fclose(PSLATEX_auxFile);
	PSLATEX_auxFile = NULL;
    }
    if (PSLATEX_psfile) {
	free(PSLATEX_psfile);
	PSLATEX_psfile = NULL;
    }
}

TERM_PUBLIC void PSLATEX_text()
{
    struct text_command *tc;

    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_text();
	gpoutfile = tmp;
    } else {
	PS_text();
	fputs("}}%\n", gpoutfile);
    }

    for (tc = PSLATEX_labels; tc != (struct text_command *) NULL; tc = tc->next) {
	fprintf(gpoutfile, "\\put(%d,%d){", tc->x, tc->y);
	if (PSLATEX_output &&
	    ((tc->label[0] == '{') || (tc->label[0] == '['))) {
	    fprintf(gpoutfile, "\\makebox(0,0)%s", tc->label);
	} else
	    switch (tc->angle) {
	    case 0:
		switch (tc->justify) {
		case LEFT:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0)[l]{%s}"
					: "\\ljust{%s}"), tc->label);
		    break;
		case CENTRE:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0){%s}"
					: "\\cjust{%s}"), tc->label);
		    break;
		case RIGHT:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0)[r]{%s}"
					: "\\rjust{%s}"), tc->label);
		    break;
		}
		break;
	    case 1:		/* put text in a short stack */
		if (PSLATEX_rotate) {
		    fputs("\
%\n\\special{ps: gsave currentpoint currentpoint translate\n\
270 rotate neg exch neg exch translate}%\n", gpoutfile);
		}
		switch (tc->justify) {
		case LEFT:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0)[lb]{\\shortstack{%s}}"
					: "\\lstack{%s}"),
			    tc->label);
		    break;
		case CENTRE:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0)[b]{\\shortstack{%s}}"
					: "\\cstack{%s}"),
			    tc->label);
		    break;
		case RIGHT:
		    fprintf(gpoutfile, (PSLATEX_output
					? "\\makebox(0,0)[lt]{\\shortstack{%s}}"
					: "\\rstack{%s}"),
			    tc->label);
		    break;
		}
		if (PSLATEX_rotate) {
		    fputs("%\n\\special{ps: currentpoint grestore moveto}%\n", gpoutfile);
		}
	    }
	fputs("}%\n", gpoutfile);
    }

    while (PSLATEX_labels) {
	tc = PSLATEX_labels->next;
	free(PSLATEX_labels->label);
	free(PSLATEX_labels);
	PSLATEX_labels = tc;
    }

    if (PSLATEX_output) {
	fputs("\
\\end{picture}%\n\
\\endgroup\n\
\\endinput\n", gpoutfile);
    } else {
	fputs("\
\\endGNUPLOTpicture\n\
\\endgroup\n\
\\endinput\n", gpoutfile);
    }
}

TERM_PUBLIC void PSLATEX_move(x, y)
unsigned int x, y;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_move(x, y);
	gpoutfile = tmp;
    } else {
	PS_move(x, y);
    }
}


TERM_PUBLIC void PSLATEX_vector(x, y)
unsigned int x, y;
{

    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_vector(x, y);
	gpoutfile = tmp;
    } else {
	PS_vector(x, y);
    }
}


TERM_PUBLIC void PSLATEX_linetype(lt)
int lt;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_linetype(lt);
	gpoutfile = tmp;
    } else {
	PS_linetype(lt);
    }
}

TERM_PUBLIC void PSLATEX_point(x, y, number)
unsigned int x, y;
int number;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_point(x, y, number);
	gpoutfile = tmp;
    } else
	PS_point(x, y, number);
}


TERM_PUBLIC void PSLATEX_pointsize(ps)
double ps;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_pointsize(ps);
	gpoutfile = tmp;
    } else
	PS_pointsize(ps);
}


TERM_PUBLIC void PSLATEX_linewidth(ps)
double ps;
{
    if (PSLATEX_auxFile) {
	FILE *tmp = gpoutfile;
	gpoutfile = PSLATEX_auxFile;
	PS_linewidth(ps);
	gpoutfile = tmp;
    } else
	PS_linewidth(ps);
}

#endif /* TERM_BODY */

#ifdef TERM_TABLE

#ifndef GOT_POST_PROTO
#define TERM_PROTO_ONLY
#include "post.trm"
#undef TERM_PROTO_ONLY
#endif

TERM_TABLE_START(pslatex_driver)
    "pslatex", "LaTeX picture environment with PostScript \\specials",
    PSLATEX_XMAX, PSLATEX_YMAX, PSLATEX_VCHAR, PSLATEX_HCHAR,
    PS_VTIC, PS_HTIC, PSLATEX_options, PSLATEX_init, PSLATEX_reset,
    PSLATEX_text, null_scale, PSLATEX_graphics, PSLATEX_move,
    PSLATEX_vector, PSLATEX_linetype, PSLATEX_put_text, PSLATEX_text_angle,
    PSLATEX_justify_text, PSLATEX_point, do_arrow, set_font_null,
    PSLATEX_pointsize, 0 /*flags */ , 0 /*suspend */
    , 0 /*resume */ , 0 /*fillbox */ ,
    PSLATEX_linewidth
TERM_TABLE_END(pslatex_driver)
#undef LAST_TERM
#define LAST_TERM pslatex_driver

TERM_TABLE_START(pstex_driver)
    "pstex", "plain TeX with PostScript \\specials",
    PSLATEX_XMAX, PSLATEX_YMAX, PSLATEX_VCHAR, PSLATEX_HCHAR,
    PS_VTIC, PS_HTIC, PSLATEX_options, PSLATEX_init, PSLATEX_reset,
    PSLATEX_text, null_scale, PSLATEX_graphics, PSLATEX_move,
    PSLATEX_vector, PSLATEX_linetype, PSLATEX_put_text, PSLATEX_text_angle,
    PSLATEX_justify_text, PSLATEX_point, do_arrow, set_font_null,
    PSLATEX_pointsize, 0 /*flags */ , 0 /*suspend */
    , 0 /*resume */ , 0 /*fillbox */ ,
    PSLATEX_linewidth
TERM_TABLE_END(pstex_driver)
#undef LAST_TERM
#define LAST_TERM pstex_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */


#ifdef TERM_HELP
START_HELP(pslatex)
"1 pslatex and pstex",
"?commands set terminal pslatex",
"?set terminal pslatex",
"?set term pslatex",
"?terminal pslatex",
"?term pslatex",
"?pslatex",
"?commands set terminal pstex",
"?set terminal pstex",
"?set term pstex",
"?terminal pstex",
"?term pstex",
"?pstex",
" The `pslatex` and `pstex` drivers generate output for further processing by",
" LaTeX and TeX, respectively.  Figures generated by `pstex` can be included",
" in any plain-based format (including LaTeX).",
"",
" Syntax:",
"       set terminal pslatex | |pstex {<color>} {<dashed>} {<rotate>}",
"                                     {auxfile} {<font_size>}",
"",
" <color> is either `color` or `monochrome`.  <rotate> is either `rotate` or",
" `norotate` and determines if the y-axis label is rotated.  <font_size> is",
" used to scale the font from its usual size.",
"",
" If `auxfile` is specified, it directs the driver to put the PostScript",
" commands into an auxiliary file instead of directly into the LaTeX file.",
" This is useful if your pictures are large enough that dvips cannot handle",
" them.  The name of the auxiliary PostScript file is derived from the name of",
" the TeX file given on the `set output` command; it is determined by replacing",
" the trailing `.tex` (actually just the final extent in the file name---and",
" the option will be turned off if there is no extent) with `.ps` in the output",
" file name.  Remember to close the file before leaving `gnuplot`.",
"",
" All drivers for LaTeX offer a special way of controlling text positioning:",
" If any text string begins with '{', you also need to include a '}' at the",
" end of the text, and the whole text will be centered both horizontally",
" and vertically by LaTeX. --- If the text string begins with '[', you need",
" to continue it with: a position specification (up to two out of t,b,l,r),",
" ']{', the text itself, and finally, '}'. The text itself may be anything",
" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
"",
" Examples:",
"       set term pslatex monochrome dashed rotate       # set to defaults",
" To write the PostScript commands into the file \"foo.ps\":",
"       set term pslatex auxfile",
"       set output \"foo.tex\"; plot ...: set output",
" About label positioning:",
" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
"        set title '\\LaTeX\\ -- $ \\gamma $'",
" Force centering both horizontally and vertically:",
"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
" Specify own positioning (top here):",
"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
" The other label -- account for long ticlabels:",
"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}'",
"",
" Linewidths and pointsizes may be changed with `set linestyle`."
END_HELP(pslatex)
#endif /* TERM_HELP */
