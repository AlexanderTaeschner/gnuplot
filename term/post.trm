/*
 * $Id: post.trm,v 1.39.2.5 2000/10/24 10:02:37 mikulik Exp $
 */

/* GNUPLOT - post.trm */

/*[
 * Copyright 1990 - 1993, 1998
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * This terminal driver supports:
 *     postscript
 *
 * AUTHORS
 *  Russell Lang
 *
 * modified 10/5/95 by drd - put in support for other postscript drivers
 * (enhpost, pslatex, ...) so they dont have to work quite so hard
 * 
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 *
 * The 'postscript' driver produces landscape output 10" wide and 7" high.  
 * To change font to Times-Roman and font size to 20pts use 
 * 'set term postscript "Times-Roman" 20'.
 * To get a smaller (5" x 3.5") eps output use 'set term post eps'
 * and make only one plot per file.  Font size for eps will be half
 * the specified size.
 *
 * Erik Luijten 30/5/97: added %%CreationDate, made %%DocumentFonts conform
 *                       to DSC, added version no. and patchl. to %%Creator
 * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(post)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void PS_options __PROTO((void));
TERM_PUBLIC void PS_common_init __PROTO((int encap, int portrait, int uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int bb_xmin, unsigned int bb_ymin, unsigned int bb_xmax, unsigned int bb_ymax, const char **dict));
TERM_PUBLIC void PS_init __PROTO((void));
TERM_PUBLIC void PS_graphics __PROTO((void));
TERM_PUBLIC void PS_text __PROTO((void));
TERM_PUBLIC void PS_reset __PROTO((void));
TERM_PUBLIC void PS_linetype __PROTO((int linetype));
TERM_PUBLIC void PS_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PS_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
TERM_PUBLIC void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
TERM_PUBLIC int PS_text_angle __PROTO((int ang));
TERM_PUBLIC int PS_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC void PS_point __PROTO((unsigned int x, unsigned int y, int number));
TERM_PUBLIC int PS_set_font __PROTO((const char * font));
TERM_PUBLIC int ENHPS_set_font __PROTO((const char * font));
TERM_PUBLIC void PS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
TERM_PUBLIC void PS_linewidth __PROTO((double linewidth)); /* JFi [linewidth] */
TERM_PUBLIC void PS_pointsize __PROTO((double ptsize)); /* JFi [pointsize] */
#ifdef PM3D
TERM_PUBLIC int PS_make_palette (t_sm_palette *);
TERM_PUBLIC void PS_previous_palette (void);
TERM_PUBLIC void PS_set_color (double);
TERM_PUBLIC void PS_filled_polygon (int, gpiPoint *);
#endif

#endif


#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
/* PostScript driver by Russell Lang, rjl@monu1.cc.monash.edu.au */

#include "post.h"

#define PS_FLUSH_PATH \
    if (ps_path_count) { fprintf(gpoutfile, "stroke "); ps_path_count = 0; }

static char *PS_RememberFont __PROTO((char *fname, int reencode));
static void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
static char *ENHPS_recurse __PROTO((char *p, TBOOLEAN brace, char *fontname, double fontsize, double base, TBOOLEAN widthflag, TBOOLEAN showflag));
static char ps_font[MAX_ID_LEN+1] = "Helvetica" ; /* name of font */
static int ps_fontsize = 14;					 /* size of font in pts */

/* for enhanced mode, we keep a separate font name and size, which
 * is restored to the default value on font of ""
 */
static char ps_enh_font[MAX_ID_LEN+1];
static int  ps_enh_fontsize;

static TBOOLEAN ps_portrait = FALSE;				 /* vertical page */
static TBOOLEAN ps_color = FALSE;
static TBOOLEAN ps_blacktext = FALSE;           /*  text always black  */
static TBOOLEAN ps_solid = FALSE;   		/*  use solid lines */
static float ps_dash_length = 1.0;   /*  scale factor for dash-dot patterns  */
static float ps_linewidth_factor = 1.0;   /*  scale factor for linewidth  */
static TBOOLEAN ps_eps = FALSE;	/* Is this for an eps file? */
			/* Added by Robert Davis <davis@ecn.purdue.edu> */
static int ps_page = 0;			/* page count */
static int ps_path_count = 0; 	/* count of lines in path */
static int ps_ang = 0;			/* text angle */
static enum JUSTIFY ps_justify = LEFT;	/* text is flush left */

/* added by Matt Heffron <heffron@falstaff.css.beckman.com> */
static TBOOLEAN ps_duplex_state = FALSE;
static TBOOLEAN ps_duplex_option = FALSE;

static const char GPFAR * GPFAR PS_header[] = {
"/M {moveto} bind def\n",
"/L {lineto} bind def\n",
"/R {rmoveto} bind def\n",
"/V {rlineto} bind def\n",
"/vpt2 vpt 2 mul def\n",
"/hpt2 hpt 2 mul def\n",
/* flush left show */
"/Lshow { currentpoint stroke M\n",
"  0 vshift R show } def\n", 
/* flush right show */
"/Rshow { currentpoint stroke M\n",
"  dup stringwidth pop neg vshift R show } def\n", 
/* centred show */
"/Cshow { currentpoint stroke M\n",
"  dup stringwidth pop -2 div vshift R show } def\n", 
/* set pointsize */
"/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def\n",
"  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def\n",
/* Dash or Color Line */
"/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }\n",
" {pop pop pop Solid {pop []} if 0 setdash} ifelse } def\n",
/* Border Lines */
"/BL { stroke gnulinewidth 2 mul setlinewidth } def\n",
/* Axes Lines */
"/AL { stroke gnulinewidth 2 div setlinewidth } def\n",
/* set user defined linewidth */
"/UL { gnulinewidth mul /userlinewidth exch def } def\n",
/* Plot Lines */
"/PL { stroke userlinewidth setlinewidth } def\n",
/* Line Types */
"/LTb { BL [] 0 0 0 DL } def\n", /* border */
"/LTa { AL [1 dl 2 dl] 0 setdash 0 0 0 setrgbcolor } def\n", /* axes */
"/LT0 { PL [] 1 0 0 DL } def\n",
"/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def\n",
"/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def\n",
"/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def\n",
"/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def\n",
"/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def\n",
"/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def\n",
"/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def\n",
"/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def\n",
/* Point (Round) */	/* Matt Heffron make it round */
"/Pnt { stroke [] 0 setdash\n",
"   gsave 1 setlinecap M 0 0 V stroke grestore } def\n",

/* Diamond */
"/Dia { stroke [] 0 setdash 2 copy vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath stroke\n",
"  Pnt } def\n",

/* Plus */
"/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V\n",
"  currentpoint stroke M\n",
"  hpt neg vpt neg R hpt2 0 V stroke\n",
"  } def\n",

/* Box */
"/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V closepath stroke\n",
"  Pnt } def\n",

/* Cross (X) */
"/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  hpt2 vpt2 neg V currentpoint stroke M\n",
"  hpt2 neg 0 R hpt2 vpt2 V stroke } def\n",

/* Triangle Up*/
"/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath stroke\n",
"  Pnt  } def\n",

/* Star */
"/Star { 2 copy Pls Crs } def\n",

/* div added filed box */
/* Filled Box */
"/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V  hpt2 0 V  0 vpt2 V\n",
"  hpt2 neg 0 V  closepath fill } def\n",

/* div added filled triangle */
/* Triangle Up, Filled */
"/TriUF { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath fill } def\n",

/* Matt Heffron: added a few more types */
/* Triangle Down */
"/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath stroke\n",
"  Pnt  } def\n",

/* Triangle Down, Filled*/
"/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M\n",
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath fill} def\n",

/* Diamond, Filled */
"/DiaF { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath fill } def\n",

/* Pentagon */
"/Pent { stroke [] 0 setdash 2 copy gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath stroke grestore Pnt } def\n",

/* Pentagon, Filled */
"/PentF { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath fill grestore } def\n",

/* Circle */
"/Circle { stroke [] 0 setdash 2 copy\n",
"  hpt 0 360 arc stroke Pnt } def\n",

/* Circle,Filled */
"/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def\n",
/* 16 differently filled circles */
"/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def\n",
"/C1 { BL [] 0 setdash 2 copy        moveto\n",
"       2 copy  vpt 0 90 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C2 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 90 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C3 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C4 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 180 270 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C5 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 90 arc\n",
"       2 copy moveto\n",
"       2 copy  vpt 180 270 arc closepath fill\n",
"               vpt 0 360 arc } bind def\n",
"/C6 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 90 270 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C7 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 0 270 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C8 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy vpt 270 360 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C9 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 270 450 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy vpt 90 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C11 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 180 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy  vpt 270 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C12 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 180 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C13 { BL [] 0 setdash  2 copy moveto\n",
"       2 copy  vpt 0 90 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy  vpt 180 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C14 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 90 360 arc closepath fill\n",
"               vpt 0 360 arc } bind def\n",
"/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",

/* Auxiliary definitions for rectangles */

"/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto\n",
"       neg 0 rlineto closepath } bind def\n",
"/Square { dup Rec } bind def\n",
"/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def\n",

/* 16 differently filled squares */

"/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def\n",
"/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def\n",
"/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
"/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def\n",
"/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
"/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill\n",
"       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
"/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
"/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill\n",
"       2 copy vpt Square fill\n",
"       Bsquare } bind def\n",
"/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def\n",
"/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
"/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill\n",
"       Bsquare } bind def\n",
"/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill\n",
"       Bsquare } bind def\n",
"/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def\n",
"/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
"       2 copy vpt Square fill Bsquare } bind def\n",
"/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
"       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
"/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def\n",

/* 16 different diamonds (actually just rotated squares) */

"/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def\n",
"/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def\n",
"/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def\n",
"/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def\n",
"/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def\n",
"/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def\n",
"/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def\n",
"/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def\n",
"/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def\n",
"/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def\n",
"/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def\n",
"/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def\n",
"/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def\n",
"/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def\n",
"/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def\n",
"/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def\n",

/* closed figures w/o the point in the middle (added by Dick Crawford) */

/* Diamond */
"/DiaE { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath stroke } def\n",

/* Box */
"/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V closepath stroke } def\n",

/* Triangle Up*/
"/TriUE { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath stroke } def\n",

/* Triangle Down */
"/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath stroke } def\n",

/* Pentagon */
"/PentE { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath stroke grestore } def\n",

/* Circle */
"/CircE { stroke [] 0 setdash \n",
"  hpt 0 360 arc stroke } def\n",

/* opaque closed figures w/o the point in the middle (added by Dick Crawford) */

"/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def\n",

/* Diamond */
"/DiaW { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V Opaque stroke } def\n",

/* Box */
"/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V Opaque stroke } def\n",

/* Triangle Up*/
"/TriUW { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V Opaque stroke } def\n",

/* Triangle Down */
"/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V Opaque stroke } def\n",

/* Pentagon */
"/PentW { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  Opaque stroke grestore } def\n",

/* Circle */
"/CircW { stroke [] 0 setdash \n",
"  hpt 0 360 arc Opaque stroke } def\n",

/* filled box : usage   x1 y1 x2 y2 BoxFill */
"/BoxFill { gsave Rec 1 setgray fill grestore } def\n",

/* oblique symbol font, e.g. set xlabel 'b' "Symbol-Oblique"
   gives an oblique (slanted) beta character */
"/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont\n",
"dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n",
"currentdict end definefont\n",

NULL
};

static const char GPFAR * GPFAR ENHPS_header[] = {
/* For MFshow and MFwidth the tos is an array with the string and font info:  */
/*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <printed?> <text string>]  */

"/MFshow {{dup dup 0 get findfont exch 1 get scalefont setfont\n",
"     [ currentpoint ] exch dup 2 get 0 exch rmoveto dup dup 5 get exch 4 get\n",
"     {show} {stringwidth pop 0 rmoveto}ifelse dup 3 get\n",
"     {2 get neg 0 exch rmoveto pop} {pop aload pop moveto}ifelse} forall} bind def\n",
"/MFwidth {0 exch {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont\n",
"      5 get stringwidth pop add}\n",
"    {pop} ifelse} forall} bind def\n",

/* flush left show */
"/MLshow { currentpoint stroke M\n",
"  0 exch R MFshow } bind def\n", 

/* flush right show */
"/MRshow { currentpoint stroke M\n",
"  exch dup MFwidth neg 3 -1 roll R MFshow } def\n", 

/* centred show */
"/MCshow { currentpoint stroke M\n",
"  exch dup MFwidth -2 div 3 -1 roll R MFshow } def\n", 
NULL
};

/* added to enhpost by Matt Heffron <heffron@falstaff.css.beckman.com> */
/* moved to post.trm by drd */

static struct PS_FontName {
	char *name;
	struct PS_FontName *next;
} *PS_DocFonts = NULL;

/* given a font, look in store to see if it is there already
 * if so, return NULL. If not, reencode it if allowed to, otherwise
 * return an appropriate re-encode string
 */
 
TERM_PUBLIC char *
PS_RememberFont(fname, can_reencode)
char *fname;
int can_reencode;
{
    struct PS_FontName *fnp;
    char *recode = NULL;
    char *myfname = "Symbol";

    if (strcmp(fname, "Symbol-Oblique") != 0)
	myfname = fname;

    for (fnp = PS_DocFonts; fnp ; fnp = fnp->next)
	if (strcmp(fnp->name, myfname) == 0)
	    return NULL;

    /* we did not find the name */
   
    fnp = (struct PS_FontName *)gp_alloc(sizeof(struct PS_FontName),
					 "PostScript Font record");
    fnp->name = gp_strdup(myfname);
    fnp->next = PS_DocFonts;
    PS_DocFonts = fnp;

    switch(encoding) {
    case S_ENC_ISO8859_1:
	recode = "reencodeISO def\n";
	break;
    case S_ENC_CP437:
	recode = "reencodeCP437 def\n";
	break;
    case S_ENC_CP850 : 
	recode = "reencodeCP850 def\n";
	break;
    }

    if (can_reencode && recode) {
	fprintf(gpoutfile,"/%s %s", myfname, recode);
	return NULL;
    } else
	return recode;
}

static int PS_pen_x, PS_pen_y;
static int PS_taken;
static int PS_linetype_last;
static TBOOLEAN PS_relative_ok;

/* HBB 990914: PS_SOLID is already used by the WIN32 API headers.
 * Renamed to PS_SOLIDE, therefore... */
enum PS_id {
    PS_PORTRAIT, PS_LANDSCAPE,
    PS_EPSF, PS_DEFAULT, PS_ENHANCED, PS_NOENHANCED,
    PS_MONOCHROME, PS_COLOR, PS_BLACKTEXT, PS_COLORTEXT,
    PS_SOLIDE, PS_DASHED, PS_DASHLENGTH, PS_LINEWIDTH,
    PS_SIMPLEX, PS_DUPLEX, PS_DEFAULTPLEX,
    PS_OTHER
};

static struct gen_table PS_opts[] =
{
    { "p$ortrait", PS_PORTRAIT },
    { "l$andscape", PS_LANDSCAPE },
    { "ep$sf", PS_EPSF },
    { "enh$anced", PS_ENHANCED },
    { "noenh$anced", PS_NOENHANCED },
    { "m$onochrome", PS_MONOCHROME },
    { "c$olor", PS_COLOR },
    { "c$olour", PS_COLOR },
    { "b$lacktext", PS_BLACKTEXT },
    { "color$text", PS_COLORTEXT },
    { "colour$text", PS_COLORTEXT },
    { "so$lid", PS_SOLIDE },
    { "da$shed", PS_DASHED },
    { "dashl$ength", PS_DASHLENGTH },
    { "dl", PS_DASHLENGTH },
    { "linew$idth", PS_LINEWIDTH },
    { "lw", PS_LINEWIDTH },
    { "si$mplex", PS_SIMPLEX },
    { "du$plex", PS_DUPLEX },
    { "defaultp$lex", PS_DEFAULTPLEX },
    { NULL, PS_OTHER }
};

TERM_PUBLIC void
PS_options()
{
    struct value a;

    while (!END_OF_COMMAND) {
	switch(lookup_table(&PS_opts[0],c_token)) {
	case PS_PORTRAIT:
	    ps_portrait = TRUE;
	    ps_eps = FALSE;
	    c_token++;
	    break;
	case PS_LANDSCAPE:
	    ps_portrait = FALSE;
	    ps_eps = FALSE;
	    c_token++;
	    break;
	case PS_EPSF:
	    ps_portrait = TRUE;
	    ps_eps = TRUE;
	    c_token++;
	    break;
	case PS_DEFAULT:
	    ps_portrait = FALSE;
	    ps_eps = FALSE;
	    ps_color = FALSE;
	    ps_blacktext = FALSE;
	    ps_solid = FALSE;
	    ps_dash_length = 1.0;
	    ps_linewidth_factor = 1.0;
	    ps_duplex_option = FALSE;
	    strcpy(ps_font,"Helvetica");
	    ps_fontsize = 14;
	    term->v_char = (unsigned int)(ps_fontsize*PS_SC);
	    term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	    term->put_text = PS_put_text;
	    c_token++;
	    break;
	case PS_ENHANCED:
	    term->put_text = ENHPS_put_text;
	    term->set_font = ENHPS_set_font;
	    ++c_token;
	    break;
	case PS_NOENHANCED:
	    term->put_text = PS_put_text;
	    term->set_font = PS_set_font;
	    ++c_token;
	    break;
	case PS_MONOCHROME:
	    ps_color = FALSE;
	    c_token++;
	    break;
	case PS_COLOR:
	    ps_color = TRUE;
	    c_token++;
	    break;
	case PS_BLACKTEXT:
	    ps_blacktext = TRUE;
	    c_token++;
	    break;
	case PS_COLORTEXT:
	    ps_blacktext = FALSE;
	    c_token++;
	    break;
        case PS_SOLIDE:
	    ps_solid = TRUE;
	    c_token++;
	    break;
	case PS_DASHED:
	    ps_solid = FALSE;
	    c_token++;
	    break;
	case PS_DASHLENGTH:
	    c_token++;
	    ps_dash_length = real(const_express(&a));
	    if (ps_dash_length <= 0.0)
		ps_dash_length = 1.0;
	    break;
	case PS_LINEWIDTH:
	    c_token++;
	    ps_linewidth_factor = real(const_express(&a));
	    if (ps_linewidth_factor <= 0.0)
		ps_linewidth_factor = 1.0;
	    break;
	case PS_SIMPLEX:
	    ps_duplex_state  = FALSE;
	    ps_duplex_option = TRUE;
	    c_token++;
	    break;
	case PS_DUPLEX:
	    ps_duplex_state  = TRUE;
	    ps_duplex_option = TRUE;
	    c_token++;
	    break;
	case PS_DEFAULTPLEX:
	    ps_duplex_option = FALSE;
	    c_token++;
	    break;
	case PS_OTHER:
	default:
	    if (isstring(c_token)) {
		quote_str(ps_font,c_token, MAX_ID_LEN);
		c_token++;
	    } else {
		/* We have font size specified */
		ps_fontsize = (int)real(const_express(&a));
		term->v_char = (unsigned int)(ps_fontsize*PS_SC);
		term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	    }
	    break;
	}
    }

    if (!ps_color)
	ps_blacktext = TRUE;

    sprintf(default_font,"%s,%d",ps_font,ps_fontsize);
    /* default_font holds the font and size set at 'set term' */
    /* Entry font added by DJL */
    /* HBB 19990823: fixed the options string. It violated the 'save
     * loadable output' rule */
    sprintf(term_options,"%s %senhanced %s %s \\\n"
	                 "   %s dashlength %.1f linewidth %.1f %s \\\n"
	                 "   \"%s\" %d",
	    ps_eps ? "eps" : (ps_portrait ? "portrait" : "landscape"),
	    term->put_text == ENHPS_put_text ? "" : "no",
	    ps_color ? "color" : "monochrome",
	    ps_blacktext ? "blacktext" : "colortext",
	    ps_solid ? "solid" : "dashed",
	    ps_dash_length,
	    ps_linewidth_factor,
	    ps_duplex_option ? (ps_duplex_state ? "duplex" : "simplex")
	    : "defaultplex",
	    ps_font,ps_fontsize);
}

/* store settings passed to common_init() for use in PS_graphics()
 * ps_eps, ps_portrait, etc are reserved for storing the term options
 */
static int ps_common_encap;
static int ps_common_portrait;
static int ps_common_uses_fonts;
static unsigned int ps_common_xoff, ps_common_yoff;


TERM_PUBLIC void
PS_common_init(encap, portrait, uses_fonts, xoff, yoff, bb_xmin, bb_ymin, bb_xmax, bb_ymax, dict)
int encap; /* encapsulated or not - 1 for pslatex */
int portrait; /* 1 for pslatex */
int uses_fonts; /* 0 for ps(la)tex */
unsigned int xoff, yoff; /* how much to translate by */
unsigned int bb_xmin, bb_ymin, bb_xmax, bb_ymax; /* bounding box */
const char **dict; /* extra entries for the dictionary */
{
    static const char GPFAR psi1[] = "\
%%%%Creator: gnuplot %s patchlevel %s\n\
%%%%CreationDate: %s\
%%%%DocumentFonts: %s\n";

    static const char GPFAR psi2[] = "\
%%%%EndComments\n\
/gnudict 256 dict def\ngnudict begin\n\
/Color %s def\n\
/Solid %s def\n\
/gnulinewidth %.3f def\n\
/userlinewidth gnulinewidth def\n\
/vshift %d def\n\
/dl {%.1f mul} def\n\
/hpt_ %.1f def\n\
/vpt_ %.1f def\n\
/hpt hpt_ def\n\
/vpt vpt_ def\n";

    static const char GPFAR * GPFAR PS_iso_8859_1_encoding[] = {
"/reencodeISO {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding ISOLatin1Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/ISOLatin1Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
"/yacute/thorn/ydieresis\n",
"] def\n",
NULL };

/*   encoding for code page 437                                            */
/*                                                                         */
/*   version 1.0:  - Mainly letters are mapped. The following positions    */
/*   (JFi)           are left blank (undefined):                           */
/*                   -- first 32 positions,                                */
/*                   -- frame characters,                                  */
/*                   -- greek characters,                                  */
/*                   -- some more special characters.                      */
/*                                                                         */
/*   version 1.1:  - added some more special characters                    */
/*                                                                         */
    static const char GPFAR * GPFAR PS_cp_437_encoding[] = {
"/reencodeCP437 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding CP437Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/CP437Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
"/ydieresis/Odieresis/Udieresis/cent/sterling/yen/.notdef/florin\n",
"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
"/questiondown/.notdef/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
"/space/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/germandbls/.notdef/.notdef/.notdef/.notdef/mu/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/infinity/.notdef/.notdef/.notdef\n",
"/.notdef/plusminus/greaterequal/lessequal/.notdef/.notdef/divide/.notdef\n",
"/degree/bullet/periodcentered/.notdef/nsuperior/twosuperior/.notdef\n",
"] def\n",
NULL };

/*   encoding for code page 850                                            */
/*                                                                         */
/*   version 1.0:  - Mainly letters are mapped. The following positions    */
/*   (JFi)           are left blank (undefined):                           */
/*                   -- first 32 positions,                                */
/*                   -- frame characters,                                  */
/*                   -- a few special characters.                          */
/*                                                                         */
    static const char GPFAR * GPFAR PS_cp_850_encoding[] = {
"/reencodeCP850 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding CP850Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/CP850Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
"/ydieresis/Odieresis/Udieresis/oslash/sterling/Oslash/multiply/florin\n",
"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
"/questiondown/registered/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
"/space/space/.notdef/.notdef/.notdef/Aacute/Acircumflex/Agrave\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/cent/yen/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/atilde/Atilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency\n",
"/eth/Eth/Ecircumflex/Edieresis/Egrave/dotlessi/Iacute/Icircumflex\n",
"/Idieresis/.notdef/.notdef/.notdef/.notdef/brokenbar/Igrave/.notdef\n",
"/Oacute/germandbls/Ocircumflex/Ograve/otilde/Otilde/mu/thorn\n",
"/Thorn/Uacute/Ucircumflex/Ugrave/yacute/Yacute/macron/acute\n",
"/hyphen/plusminus/equal/threequarters/paragraph/section/divide/.notdef\n",
"/degree/.notdef/periodcentered/onesuperior/threesuperior/twosuperior/.notdef\n",
"] def\n",
NULL };

    struct termentry *t = term;
    int i;
    time_t now;

    ps_common_encap = encap; /* store for later */
    ps_common_portrait = portrait; /* store for later */
    ps_common_uses_fonts = uses_fonts;
    ps_common_xoff = xoff;
    ps_common_yoff = yoff;

    ps_page = 0;

    if (!encap)
	fputs("%!PS-Adobe-2.0\n", gpoutfile);
    else
	fputs("%!PS-Adobe-2.0 EPSF-2.0\n", gpoutfile);

    if (outstr) fprintf(gpoutfile, "%%%%Title: %s\n", outstr );   /*  JFi  */
    time(&now);
    fprintf(gpoutfile, psi1, gnuplot_version, gnuplot_patchlevel,
	    asctime(localtime(&now)), uses_fonts ? "(atend)" : "");

    fprintf(gpoutfile,"%%%%BoundingBox: %d %d %d %d\n",
	    xoff + bb_xmin, yoff + bb_ymin, xoff + bb_xmax, yoff + bb_ymax);

    fprintf(gpoutfile,"%%%%Orientation: %s\n",
	    ps_portrait ? "Portrait" : "Landscape");

    if (!encap)
	fputs("%%Pages: (atend)\n", gpoutfile);
    fprintf(gpoutfile, psi2,
	    ps_color ? "true" : "false",
	    ps_solid ? "true" : "false",
	    PS_LW*ps_linewidth_factor,	/* line width */
	    (int)(t->v_char)/(-3),	/* shift for vertical centring */
	    PS_SC*ps_dash_length,	/* dash length */
	    PS_HTIC/2.0,		/* half point width */
	    PS_VTIC/2.0);		/* half point height */

    if (uses_fonts && (encoding == S_ENC_ISO8859_1)) {
	for (i = 0; PS_iso_8859_1_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_iso_8859_1_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_CP437)) {       /* JFi */
	for (i = 0; PS_cp_437_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_cp_437_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_CP850)) {       /* JFi */
	for (i = 0; PS_cp_850_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_cp_850_encoding[i]);
	}
    }
    /* Duplicate code! 
     * As long as only two code pages are implemented, that's not a big 
     * problem. Otherwise a small procedure might be beneficial.
     */

    for ( i = 0; PS_header[i] != NULL; i++)
	fprintf(gpoutfile,"%s",PS_header[i]);
    if (ps_duplex_option)
	fprintf(gpoutfile, "statusdict begin %s setduplexmode end\n",
		ps_duplex_state ? "true" : "false");
    if (uses_fonts)
	PS_RememberFont(ps_font, 1);

    if (dict)
	while (*dict)
	    fputs(*(dict++), gpoutfile);	

    fputs("end\n%%EndProlog\n", gpoutfile);
}

/* the init fn for the postscript driver */
TERM_PUBLIC void
PS_init()
{
    unsigned int xmin_t, ymin_t, xmax_t, ymax_t;

    if (ps_eps) {
	term->xmax = PS_XMAX;
	term->ymax = PS_YMAX;
	xmin_t = PS_XMAX * xoffset / (2*PS_SC);
	xmax_t = PS_XMAX * (xsize + xoffset) / (2*PS_SC);
	ymin_t = PS_YMAX * yoffset / (2*PS_SC);
	ymax_t = PS_YMAX * (yoffset + ysize) / (2*PS_SC);
    } else if (ps_portrait) {
	term->xmax = PS_YMAX;
	term->ymax = PS_XMAX;
	xmin_t = PS_YMAX * xoffset / PS_SC;
	xmax_t = PS_YMAX * (xsize + xoffset) / PS_SC;
	ymin_t = PS_XMAX * yoffset / PS_SC;
	ymax_t = PS_XMAX * (ysize + yoffset) / PS_SC;
    } else {
	term->xmax = PS_XMAX;
	term->ymax = PS_YMAX;
	ymin_t = PS_XMAX * xoffset / PS_SC;
	ymax_t = PS_XMAX * (xsize+xoffset) / PS_SC;
	xmin_t = PS_YMAX * (1-ysize-yoffset) / PS_SC;
	xmax_t = PS_YMAX * (1-yoffset) / PS_SC;
    }

    /* for enhanced postscript, copy ps_font to ps_enh_font
     * does no harm for non-enhanced
     */
    strcpy(ps_enh_font, ps_font);
    ps_enh_fontsize = ps_fontsize;

    PS_common_init(ps_eps, ps_portrait, 1, PS_XOFF, PS_YOFF,
		   xmin_t, ymin_t, xmax_t, ymax_t,
		   (term->put_text == ENHPS_put_text) ? ENHPS_header : NULL);
}


TERM_PUBLIC void
PS_graphics()
{
    static char GPFAR psg1[] = "0 setgray\nnewpath\n";
    struct termentry *t = term;
    ps_page++;
    if (!ps_common_encap)
	fprintf(gpoutfile,"%%%%Page: %d %d\n",ps_page,ps_page);
    fprintf(gpoutfile,"\
gnudict begin\ngsave\n\
%d %d translate\n\
%.3f %.3f scale\n",
	    ps_common_xoff, ps_common_yoff,
	    (ps_eps ? 0.5 : 1.0)/PS_SC,
	    (ps_eps ? 0.5 : 1.0)/PS_SC);
    if (!ps_common_portrait) {
	fprintf(gpoutfile,"90 rotate\n0 %d translate\n", (int)(-PS_YMAX));
    }
    fprintf(gpoutfile, psg1);
    if (ps_common_uses_fonts)
	fprintf(gpoutfile, "(%s) findfont %d scalefont setfont\n",
		ps_font, (t->v_char) );
    ps_path_count = 0;
    PS_relative_ok = FALSE;
    PS_pen_x = PS_pen_y = -4000;
    PS_taken = 0;
    PS_linetype_last = -1;
}


TERM_PUBLIC void
PS_text()
{
    ps_path_count = 0;
    fprintf(gpoutfile,"stroke\ngrestore\nend\nshowpage\n");
    /* fprintf(stderr,"taken %d times\n",PS_taken); */
    /* informational:  tells how many times it was "cheaper"
     * to do a relative moveto or lineto rather than an
     * absolute one */
}


TERM_PUBLIC void
PS_reset()
{
    fputs("%%Trailer\n", gpoutfile);

    /* I think the following commands should be executed 
       `if (ps_common_uses_fonts)`. So I changed the next line. 
       Please see "PS_RememberFont", too.                       */  /* JFi */

    /*	if (!ps_common_uses_fonts) {  */                             /* JFi */
    if (ps_common_uses_fonts) {
	fputs("%%DocumentFonts: ", gpoutfile);
	while (PS_DocFonts) {
	    struct PS_FontName *fnp;
	    fnp = PS_DocFonts->next;
	    fprintf(gpoutfile, "%s%s", PS_DocFonts->name, fnp ? " " : "\n");
	    free(PS_DocFonts->name);
	    free(PS_DocFonts);
	    PS_DocFonts = fnp;
	}
    }
    if (!ps_common_encap)
	fprintf(gpoutfile,"%%%%Pages: %d\n",ps_page);
}


TERM_PUBLIC void
PS_linetype(linetype)
int linetype;
{
    linetype = (linetype % 9) + 2;
    if (linetype < 0) linetype = 0;
    PS_relative_ok = FALSE;
#if 0
    /*  In order to make 'PS_linewidth' work properly, I need to comment
     *  this line out.  Especially in combination with the line width
     *  extension of the `set arrow` command this is necessary.
     *  Can we live with that drawback?  (JFi)
     */
    if (PS_linetype_last == linetype) return;
#endif
    PS_linetype_last = linetype;
    fprintf(gpoutfile,"LT%c\n", "ba012345678"[linetype]);
    ps_path_count = 0;
}


TERM_PUBLIC void
PS_linewidth (linewidth)
double linewidth;
{
        fprintf(gpoutfile,"%.3f UL\n",linewidth);

/*  
  Documentation of the 'change linewidth' strategy of the postscript terminal:

  1. define a new postscript variable with a default value:
     /userlinewidth gnulinewidth def

  2. define a new postscript command to change the contents of that variable:
     /UL { gnulinewidth mul /userlinewidth exch def } def
     usage:  multiplication_factor UL

  3. modify the already known postscript command /PL for the plot lines:
     /PL { stroke userlinewidth setlinewidth } def

  4. issue the new command before every change of the plot linestyle:
     example:
         4.0 UL
         LT0
     result:
         Linetype 0 is drawn four times as thick as defined by the contents
         of the postscript variable 'gnulinewidth'.
*/
}


TERM_PUBLIC void
PS_pointsize (ptsize)
double ptsize;
{
    fprintf(gpoutfile,"%.3f UP\n",ptsize);

/*  
 *  Documentation of the 'change pointsize' strategy of the postscript
 * terminal:
 *
 * 1. define two new postscript variables to hold the overall pointsize:
 *    /hpt_  and  /vpt_
 *
 * 2. define a new postscript command to use the contents of these variables: 
 *    /UP { cf. definition above } def
 *    usage:  multiplication_factor UP
 *
 * [3.] [doesn't exist, skip to next number]
 *
 * 4. issue the new command whereever you change the symbols (and linetype):
 *    example:
 *        2.5 UP
 *        4.0 UL  % optionally change linewidth, too
 *        LT0
 *    result:
 *        Next symbols will be drawn 2.5 times as big as defined by the 
 *        GNUPLOT `set pointsize` command (= overall pointsize).
 */
}


TERM_PUBLIC void
PS_move(x,y)
unsigned int x,y;
{
    int dx, dy;
    /* Make this semi-dynamic and independent of architecture */
    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
    dx = x - PS_pen_x;
    dy = y - PS_pen_y;
    /* can't cancel all null moves--need a move after stroke'ing */
    if (dx==0 && dy==0 && PS_relative_ok)
	return;
    sprintf(abso, "%d %d M\n", x, y);
    sprintf(rel, "%d %d R\n", dx, dy);
    if (strlen(rel) < strlen(abso) && PS_relative_ok) {
	fputs(rel, gpoutfile);
	PS_taken++;
    }else
	fputs(abso, gpoutfile);
    PS_relative_ok = TRUE;
    ps_path_count += 1;

    PS_pen_x = x;
    PS_pen_y = y;
}

TERM_PUBLIC void
PS_vector(x,y)
unsigned int x,y;
{
    int dx, dy;
    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];

    dx = x - PS_pen_x;
    dy = y - PS_pen_y;
    if (dx==0 && dy==0) return;
    sprintf(abso, "%d %d L\n", x, y);
    sprintf(rel, "%d %d V\n", dx, dy);
    if (strlen(rel) < strlen(abso) && PS_relative_ok) {
	fputs(rel, gpoutfile);
	PS_taken++;
    }else
	fputs(abso, gpoutfile);
    PS_relative_ok = TRUE;
    ps_path_count += 1;
    PS_pen_x = x;
    PS_pen_y = y;
    if (ps_path_count >= 400) {
	fputs("currentpoint stroke M\n", gpoutfile);
	ps_path_count = 0;
    }
}


TERM_PUBLIC void
PS_put_text(x,y,str)
unsigned int x, y;
const char *str;
{
    char ch;

    if (!str && !strlen(str)) return;
    PS_move(x,y);
    if (ps_blacktext)
	fputs("gsave 0 setgray\n", gpoutfile);
    if (ps_ang != 0)
	fprintf(gpoutfile,"currentpoint gsave translate %d rotate 0 0 M\n",
		ps_ang*90);
    putc('(',gpoutfile);
    ch = *str++;
    while(ch!='\0') {
	if ( (ch=='(') || (ch==')') || (ch=='\\') )
	    putc('\\',gpoutfile);
	putc(ch,gpoutfile);
	ch = *str++;
    }
    switch(ps_justify) {
    case LEFT : fputs(") Lshow\n", gpoutfile);
	break;
    case CENTRE : fputs(") Cshow\n", gpoutfile);
	break;
    case RIGHT : fputs(") Rshow\n", gpoutfile);
	break;
    }
    if (ps_ang != 0 || ps_blacktext)
	fputs("grestore\n", gpoutfile);
    if (ps_ang != 0 && ps_blacktext)
	fputs("grestore\n", gpoutfile);
    ps_path_count = 0;
    PS_relative_ok = FALSE;
}


TERM_PUBLIC int
PS_text_angle(ang)
int ang;
{
    ps_ang = ang;
    return TRUE;
}


TERM_PUBLIC int
PS_justify_text(mode)
enum JUSTIFY mode;
{
    ps_justify = mode;
    return TRUE;
}


TERM_PUBLIC int
PS_set_font(font)  /* Entry font added by DJL */
const char *font;
{
    char name[32];
    int  size;
    size_t sep;

    sep = strcspn(font,",");
    strncpy(name,font,sep);
    name[sep] = NUL;
    size = ps_fontsize;
    sscanf (&(font[sep+1]),"%d",&size);
    fprintf(gpoutfile,"/%s findfont %d scalefont setfont\n",name,size*PS_SC);
    PS_RememberFont(name,1 );
    return TRUE;
}


/* postscript point routines */


TERM_PUBLIC void
PS_point(x,y,number)
unsigned int x,y;
int number;
{
    static const char GPFAR * GPFAR pointFNS[] = {
	"Pnt",  "Pls",   "Crs",    "Star",
	"Box",  "BoxF",  "Circle", "CircleF",
	"TriU", "TriUF", "TriD",   "TriDF",
	"Dia",  "DiaF",  "Pent",   "PentF",
	"C0",   "C1",    "C2",     "C3",
	"C4",   "C5",    "C6",     "C7",
	"C8",   "C9",    "C10",    "C11",
	"C12",  "C13",   "C14",    "C15",
	"S0",   "S1",    "S2",     "S3",
	"S4",   "S5",    "S6",     "S7",
	"S8",   "S9",    "S10",    "S11",
	"S12",  "S13",   "S14",    "S15",
	"D0",   "D1",    "D2",     "D3",
	"D4",   "D5",    "D6",     "D7",
	"D8",   "D9",    "D10",    "D11",
	"D12",  "D13",   "D14",    "D15",
	"BoxE", "CircE", "TriUE",  "TriDE",
	"DiaE", "PentE", "BoxW",   "CircW",
	"TriUW", "TriDW", "DiaW",  "PentW"
};
    if (number < 0)
	number = -1;		/* negative types are all 'dot' */
    else
	number %= sizeof(pointFNS)/sizeof(pointFNS[0]) -1;
    fprintf(gpoutfile,"%d %d %s\n", x, y, pointFNS[number+1]);

    PS_relative_ok = 0;
    ps_path_count = 0;
    PS_linetype_last = -1; /* force next linetype change */
}

TERM_PUBLIC void
PS_fillbox(style, x1,y1,x2,y2)
int style;
unsigned int x1,y1,x2,y2;
{
    PS_FLUSH_PATH;

    fprintf(gpoutfile, "%d %d %d %d BoxFill\n", x1,y1, x2,y2);

    PS_relative_ok = 0;
    PS_linetype_last = -1;
}


/* ENHPOST */


#ifdef DEBUG_ENHPS
#define ENHPS_DEBUG(x) printf x;
#else
#define ENHPS_DEBUG(x)
#endif


static TBOOLEAN ENHps_opened_string;  /* try to cut out empty ()'s */

/* used in determining height of processed text */

static float ENHps_max_height, ENHps_min_height;


/* process a bit of string, and return the last character used.
 * p is start of string
 * brace is TRUE to keep processing to }, FALSE for do one character
 * fontname & fontsize are obvious
 * base is the current baseline
 * widthflag is TRUE if the width of this should count,
 *              FALSE for zero width boxes
 * showflag is TRUE if this should be shown,
 *             FALSE if it should not be shown (like TeX \phantom)
 */

static char *
ENHPS_recurse(p, brace, fontname, fontsize, base, widthflag, showflag)
char *p, *fontname;
TBOOLEAN brace, widthflag, showflag;
double fontsize, base;
{

/* close a postscript string if it has been opened */
#define ENHPS_FLUSH      \
{	if (ENHps_opened_string)  \
	{	fputs(")]\n", gpoutfile);   \
		ENHps_opened_string = FALSE; \
	}                         \
}

#define ENHPS_OPEN	\
{	if (!ENHps_opened_string) \
	{ fprintf(gpoutfile, "[(%s) %.1f %.1f %s %s (",  \
		  fontname, fontsize, base, \
 		  widthflag ? "true" : "false",  \
 		  showflag ? "true" : "false");  \
 	  ENHps_opened_string = TRUE; \
 	}	\
}

    ENHPS_DEBUG(("RECURSE WITH [%p] \"%s\", %d %s %.1f %.1f %d %d\n", p, p, brace, fontname, fontsize, base, widthflag, showflag));

/* Start each recursion with a clean string */
    ENHPS_FLUSH;

    if (base + fontsize > ENHps_max_height) {
	ENHps_max_height = base + fontsize;
	ENHPS_DEBUG(("Setting max height to %.1f\n", ENHps_max_height));
    }

    if (base < ENHps_min_height) {
	ENHps_min_height = base;
	ENHPS_DEBUG(("Setting min height to %.1f\n", ENHps_min_height));
    }

    while (*p) {
	float shift;

	switch (*p)
	{
	case '}'  :
				/*{{{  deal with it*/
	    if (brace)
		return (p);

	    fputs("enhpost printer driver - spurious }\n", stderr);
	    break;
				/*}}}*/

	case '_'  :
	case '^'  :
	    /*{{{  deal with super/sub script*/

	    shift = (*p == '^') ? 0.5 : -0.3;

	    ENHPS_FLUSH;

	    p = ENHPS_recurse(p+1, FALSE, fontname, fontsize*0.8, base+shift*fontsize, widthflag, showflag);

	    break;
	    /*}}}*/
	case '{'  :
	{
	    char *savepos = NULL, save = 0;
	    char *localfontname = fontname, ch;
	    int recode = 1;
	    float f = fontsize;

	    /*{{{  recurse (possibly with a new font) */

	    ENHPS_DEBUG(("Dealing with {\n"));

	    if (*++p == '/') {
		/* then parse a fontname, optional fontsize */
		while (*++p == ' ');
		if (*p=='-') {
		    recode = 0;
		    while (*++p == ' ');
		}
		localfontname = p;
		while ((ch = *p) > ' ' && ch != '=' && ch != '*')
		    ++p;
		save = *(savepos=p);
		if (ch == '=') {
		    *p++ = '\0';				
		    /*{{{  get optional font size*/
		    ENHPS_DEBUG(("Calling strtod(\"%s\") ...", p));
		    f = (float)strtod(p, &p);
		    ENHPS_DEBUG(("Returned %.1f and \"%s\"\n", f, p));

		    if (f)
			f *= PS_SC;  /* remember the scaling */
		    else
			f = fontsize;

		    ENHPS_DEBUG(("Font size %.1f\n", f));
		    /*}}}*/
		}
		else if (ch == '*') {
		    *p++ = '\0';				
		    /*{{{  get optional font size scale factor*/
		    ENHPS_DEBUG(("Calling strtod(\"%s\") ...", p));
		    f = (float)strtod(p, &p);
		    ENHPS_DEBUG(("Returned %.1f and \"%s\"\n", f, p));

		    if (f)
			f *= fontsize;  /* apply the scale factor */
		    else
			f = fontsize;

		    ENHPS_DEBUG(("Font size %.1f\n", f));
		    /*}}}*/
		} else {
		    *p++ = '\0';
		    f = fontsize;
		}				

		while (*p == ' ')
		    ++p;
		if (*localfontname) {
		    /* only allow RememberFont to re-encode it if no string
		     * active */
		    char *recodestring = PS_RememberFont(localfontname,
							 recode && !ENHps_opened_string);
		    if (recode && recodestring) {
			ENHPS_FLUSH;
			fprintf(gpoutfile, "/%s %s",
				localfontname, recodestring);
		    }
		} else
		    localfontname = fontname;
	    }
	    /*}}}*/

	    ENHPS_DEBUG(("Before recursing, we are at [%p] \"%s\"\n", p, p));

	    p = ENHPS_recurse(p, TRUE, localfontname, f, base,
			      widthflag, showflag);

	    ENHPS_DEBUG(("BACK WITH \"%s\"\n", p));

	    ENHPS_FLUSH;

	    if (savepos)
		/* restore overwritten character */
		*savepos = save;
	    break;
	}
	case '@' :
	    /*{{{  phantom box - prints next 'char', then restores currentpoint */

	    ENHPS_FLUSH;
	    p = ENHPS_recurse(++p, FALSE, fontname, fontsize, base,
			      FALSE, showflag);

	    break;
	    /*}}}*/

	case '&' :
	    /*{{{  character skip - skips space equal to length of character(s) */
	    ENHPS_FLUSH;

	    p = ENHPS_recurse(++p, FALSE, fontname, fontsize, base,
			      widthflag, FALSE);

	    break;
	    /*}}}*/

	case '('  :
	case ')'  :
	    /*{{{  an escape and print it */
	    /* special cases */
	    ENHPS_OPEN;
	    fputc('\\', gpoutfile);
	    fputc(*p, gpoutfile);
	    break;
	    /*}}}*/

	case '\\'  :
	    /*{{{  is it an escape */
	    /* special cases */

	    if (p[1]=='\\' || p[1]=='(' || p[1]==')') {
		ENHPS_OPEN;
		fputc('\\', gpoutfile);
	    } else if (p[1] >= '0' && p[1] <= '7') {
		/* up to 3 octal digits */
		ENHPS_OPEN
		    fputc('\\', gpoutfile);
		fputc(p[1], gpoutfile);
		++p;
		if (p[1] >= '0' && p[1] <= '7') {
		    fputc(p[1], gpoutfile);
		    ++p;
		    if (p[1] >= '0' && p[1] <= '7') {
			fputc(p[1], gpoutfile);
			++p;
		    }
		}
		break;
	    }
	    ++p;
	    /* just go and print it (fall into the 'default' case) */

	    /*}}}*/
	default:
	    /*{{{  print it */
	    ENHPS_OPEN;

	    fputc(*p, gpoutfile);

	    /*}}}*/

	}

	/* like TeX, we only do one character in a recursion, unless it's
	 * in braces
	 */

	if (!brace) {
	    ENHPS_FLUSH;
	    return(p);  /* the ++p in the outer copy will increment us */
	}

	if (*p) /* only not true if { not terminated, I think */
	    ++p;	
    }

    ENHPS_FLUSH;
    return p;
}


/* a set-font routine for enhanced post : simply copies
 * the font into a global, or restores the globals
 * to the ps_font default
 */

TERM_PUBLIC int
ENHPS_set_font(font)  /* Entry font added by DJL */
const char *font;
{
    ENHPS_DEBUG(("ENHPS_set_font(\"%s\")\n", font));

    if (ignore_enhanced_text)
	return PS_set_font(font);

    if (*font) {
	size_t sep = strcspn(font,",");
	strncpy(ps_enh_font,font,sep);
	ps_enh_font[sep] = NUL;
	ps_enh_fontsize = ps_fontsize;
	sscanf (font+sep+1,"%d",&ps_enh_fontsize);
	PS_RememberFont(ps_enh_font, 1);
    } else {
	/* return to defaults */
	strcpy(ps_enh_font, ps_font);
	ps_enh_fontsize = ps_fontsize;
    }

    return TRUE;
}

TERM_PUBLIC void
ENHPS_put_text(x, y, str)
unsigned int x, y;
const char *str;
{
    if (ignore_enhanced_text) {
	PS_put_text(x,y,str);
	return;
    }

    /* flush any pending graphics (all the XShow routines do this...) */

    if (!strlen(str))
	return;

    if (ps_path_count) {
	fputs(" stroke\n",gpoutfile);
	ps_path_count = 0;
	PS_relative_ok = FALSE;
    }

    /* if there are no magic characters, we should just be able
     * punt the string to PS_put_text(), which will give shorter
     * ps output [eg tics and stuff rarely need extra processing],
     * but we need to make sure that the current font is the
     * default one before we can do that. {ie I tried it and it
     * used the wrong font !}
     * if (!strpbrk(str, "{}^_@&"))
     * {
     *   - do something to ensure default font is selected
     *   PS_put_text(x,y,str);
     *   return;
     * }
     */

    PS_move(x,y);

    if (ps_blacktext)
	fputs("gsave 0 setgray\n", gpoutfile);
    if (ps_ang != 0)
	fprintf(gpoutfile,"currentpoint gsave translate %d rotate 0 0 moveto\n",
		ps_ang*90);

    fputs("[ ",gpoutfile);

    /* set up the globals */

    ENHps_opened_string = FALSE;
    ENHps_max_height = -1000;
    ENHps_min_height = 1000;

    /* Set the recursion going. We say to keep going until a
     * closing brace, but we don't really expect to find one.
     * If the return value is not the nul-terminator of the
     * string, that can only mean that we did find an unmatched
     * closing brace in the string. We increment past it (else
     * we get stuck in an infinite loop) and try again.
     *
     * ps_enh_font and ps_enh_fontsize are either set to the
     * the defaults set on option line, or have been set to
     * "font,size". That is to say, ps_font is used only
     * at startup and by ENHPS_set_font
     */
    while (*(str = ENHPS_recurse((char *)str, TRUE, ps_enh_font,
				 (double)(ps_enh_fontsize*PS_SC),
				 0.0, TRUE, TRUE))) {
	ENHPS_FLUSH;

	/* I think we can only get here if *str == '}' */
	if (*str == '}')
	    fputs("enhpost printer driver - ignoring spurious }\n", gpoutfile);
	else
	    fprintf(stderr, "internal error in enhpost driver - *str=0x%x\n", *str);

	if (!*++str)
	    break; /* end of string */

	/* else carry on and process the rest of the string */
    }

    ENHps_max_height += ENHps_min_height;

    fprintf(gpoutfile, "] %.1f ", -ENHps_max_height/3);

    switch(ps_justify) {
    case LEFT : fputs("MLshow\n", gpoutfile);
	break;
    case CENTRE : fputs("MCshow\n", gpoutfile);
	break;
    case RIGHT : fputs("MRshow\n", gpoutfile);
	break;
    }

    if (ps_ang != 0 || ps_blacktext)
	fputs("grestore\n", gpoutfile);
    if (ps_ang != 0 && ps_blacktext)
	fputs("grestore\n", gpoutfile);
    ps_path_count = 0;
    PS_relative_ok = FALSE;
}

#ifdef PM3D

/* implementation of pm3dGetColorValue() in the postscript way.
   Notice that the description, i.e. the part after %, is important 
   since it is used in `show pm3d' for displaying the analytical formulae.
*/
char *( PostScriptColorFormulae[] ) = {
  "/cF0 {pop 0} bind def\t% 0",
  "/cF1 {pop 0.5} bind def\t% 0.5",
  "/cF2 {pop 1} bind def\t% 1",
  "/cF3 {} bind def\t% x",
  "/cF4 {dup mul} bind def\t% x^2",
  "/cF5 {dup dup mul mul} bind def\t% x^3",
  "/cF6 {dup mul dup mul} bind def\t% x^4",
  "/cF7 {sqrt} bind def\t% sqrt(x)",
  "/cF8 {sqrt sqrt} bind def\t% sqrt(sqrt(x))",
  "/cF9 {90 mul sin} bind def\t% sin(90x)",
  "/cF10 {90 mul cos} bind def\t% cos(90x)",
  "/cF11 {0.5 sub abs} bind def\t% |x-0.5|",
  "/cF12 {2 mul 1 sub dup mul} bind def\t% (2x-1)^2",
  "/cF13 {180 mul sin} bind def\t% sin(180x)",
  "/cF14 {180 mul cos abs} bind def\t% |cos(180x)|",
  "/cF15 {360 mul sin} bind def\t% sin(360x)",
  "/cF16 {360 mul cos} bind def\t% cos(360x)",
  "/cF17 {360 mul sin abs} bind def\t% |sin(360x)|",
  "/cF18 {360 mul cos abs} bind def\t% |cos(360x)|",
  "/cF19 {720 mul sin abs} bind def\t% |sin(720x)|",
  "/cF20 {720 mul cos abs} bind def\t% |cos(720x)|",
  "/cF21 {3 mul} bind def\t% 3x",
  "/cF22 {3 mul 1 sub} bind def\t% 3x-1",
  "/cF23 {3 mul 2 sub} bind def\t% 3x-2",
  "/cF24 {3 mul 1 sub abs} bind def\t% |3x-1|",
  "/cF25 {3 mul 2 sub abs} bind def\t% |3x-2|",
  "/cF26 {1.5 mul .5 sub} bind def\t% (3x-1)/2",
  "/cF27 {1.5 mul 1 sub} bind def\t% (3x-2)/2",
  "/cF28 {1.5 mul .5 sub abs} bind def\t% |(3x-1)/2|",
  "/cF29 {1.5 mul 1 sub abs} bind def\t% |(3x-2)/2|",
  "/cF30 {0.32 div 0.78125 sub} def\t% x/0.32-0.78125",
  "/cF31 {2 mul 0.84 sub} def\t% 2*x-0.84",
  "/cF32 {dup 0.42 le {4 mul} {dup 0.92 le {-2 mul 1.84 add} {0.08 div 11.5 sub} ifelse} ifelse } def\t% 4x;1;-2x+1.84;x/0.08-11.5",
  "/cF33 {2 mul 0.5 sub abs} def\t% |2*x - 0.5|",
  "/cF34 {2 mul} def\t% 2*x",
  "/cF35 {2 mul 0.5 sub} def\t% 2*x - 0.5",
  "/cF36 {2 mul 1 sub} def\t% 2*x - 1",
  "" };

TERM_PUBLIC int PS_make_palette (t_sm_palette *palette)
{
#define R sm_palette.formulaR
#define G sm_palette.formulaG
#define B sm_palette.formulaB
if (palette == NULL)
  /* postscript can do continous number of colours */
  return 0;
/* write header for smooth colours */

fprintf(gpoutfile, "gsave %% colour palette begin\n");
/* print the definition of R,G,B formulae */

if (sm_palette.ps_allcF == 0) { /* print only those 3 used formulae */
    fprintf(gpoutfile, "%s\n",PostScriptColorFormulae[ abs(R) ]);
    if (abs(G) != abs(R))
      fprintf(gpoutfile, "%s\n",PostScriptColorFormulae[ abs(G) ]);
    if ((abs(B) != abs(R)) && (abs(B) != abs(G)))
      fprintf(gpoutfile, "%s\n",PostScriptColorFormulae[ abs(B) ]);
    }
  else { /* all color formulae are written into the output PostScript file */
    int i = 0;
    while ( *(PostScriptColorFormulae[i]) )
      fprintf(gpoutfile, "%s\n",PostScriptColorFormulae[ i++ ]);
    }

/* now print something like
/g {dup cF7 exch dup cF5 exch cF15 setrgbcolor} bind def
*/
fprintf(gpoutfile,"Color %s and { %% COLOUR vs. GRAY map\n",
  (sm_palette.colorMode == SMPAL_COLOR_MODE_RGB) ? "true" : "false"
  );
fprintf(gpoutfile,"  /g {stroke dup ");
if (R < 0) fprintf(gpoutfile, "1 exch sub "); /* negate */
fprintf(gpoutfile,"cF%i exch dup ", abs(R));
if (G < 0) fprintf(gpoutfile, "1 exch sub "); /* negate */
fprintf(gpoutfile,"cF%i exch ", abs(G));
if (R<0 || G<0 || B<0) fprintf(gpoutfile,"\n\t");
if (B < 0) fprintf(gpoutfile, "1 exch sub "); /* negate */
fprintf(gpoutfile,"cF%i ", abs(B));
fprintf(gpoutfile,"setrgbcolor} bind def\n");
fprintf(gpoutfile, "  /h {rlineto rlineto rlineto fill} bind def\n");
/*
fprintf(gpoutfile, "%%  /G {currentrgbcolor 3 index stroke g} bind def\n");
fprintf(gpoutfile, "%%  /H {h setrgbcolor pop} bind def\n");
*/
fprintf(gpoutfile, "  /F {rlineto fill setrgbcolor pop} bind def\n");
fprintf(gpoutfile, "}{\n");
fprintf(gpoutfile, "  /g {stroke setgray} bind def\n");
fprintf(gpoutfile, "  /h {rlineto rlineto rlineto fill setgray} bind def\n");
/*
fprintf(gpoutfile, "%%  /g {currentgray exch stroke setgray} bind def\n");
fprintf(gpoutfile, "%%  /G {currentgray exch stroke g} bind def\n");
fprintf(gpoutfile, "%%  /H {h setgray} bind def\n");
*/
fprintf(gpoutfile, "  /F {rlineto fill setgray} bind def\n");
fprintf(gpoutfile, "} ifelse\n");
fprintf(gpoutfile, "/N {newpath moveto} def\n");
fprintf(gpoutfile, "/f {rlineto fill} bind def\n");
return 0;
#undef R
#undef G
#undef B
}


#if 0 /* caching of color value removed; won't be so efficient for z=const 
	 surfaces/map, but will save a lot of headache (linetype changes 
	 color, for instance) */
double pm3d_last_color;
  /* last choosen colour */

double pm3d_ps_color;
  /* keep here the last set color */
#endif

TERM_PUBLIC void PS_set_color (double gray)
{
/* map [0;1] to interval [16;255] */
/* Note: command G puts on stack current colour/gray values to be restored 
   afterwards!
*/
#if 0
pm3d_ps_color = gray;
pm3d_last_color = gray;
#endif
/* printing the gray with 4 digits and without the leading 0 ... saving space */
if (gray <= 0) fprintf(gpoutfile, "0 g "); else
if (gray >= 1) fprintf(gpoutfile, "1 g "); else {
   char s[15];
   gray = 0.0001*(int)(gray*10000+0.5); /* round it to 4 digits */
   sprintf(s,"%.4g g ",gray);
   if (s[0] == '0' && s[1] == '.') fprintf(gpoutfile, "%s", &(s[1]));
     else fprintf(gpoutfile, "%s", s);
  }
PS_relative_ok = FALSE; /* "M" required because "g" forces stroke */
}

TERM_PUBLIC void PS_filled_polygon ( int points, gpiPoint *corners )
{
    int i;
    /* produce lines like:
       .9335 g 9055 29350 N 695 0 V 0 564 V -695 0 f
       .9335 g 9055 29350 N 695 0 V 0 564 V -695 0 f
     */
    fprintf(gpoutfile, "%i %i N", corners[0].x, corners[0].y);
    if (points == 4) /* shorter version */
	fprintf(gpoutfile, " %i %i %i %i %i %i h\n",
	    corners[3].x-corners[2].x, corners[3].y-corners[2].y,
	    corners[2].x-corners[1].x, corners[2].y-corners[1].y,
	    corners[1].x-corners[0].x, corners[1].y-corners[0].y
	       );
    else {  
	for (i = 1; i < points-1; i++)
	    fprintf(gpoutfile, " %i %i V",
		corners[i].x-corners[i-1].x, corners[i].y-corners[i-1].y);
	fprintf(gpoutfile, " %i %i F\n",
	    corners[i].x-corners[i-1].x, corners[i].y-corners[i-1].y);
    }
    PS_relative_ok = FALSE;
}

TERM_PUBLIC void PS_previous_palette(void)
{
fprintf(gpoutfile, "grestore %% colour palette end\n");
}

#endif /* PM3D */

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(post_driver)
"postscript",
"PostScript graphics language [mode \042fontname\042 font_size]",
   PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, 
   PS_VTIC, PS_HTIC, PS_options, PS_init, PS_reset, 
   PS_text, null_scale, PS_graphics, PS_move, PS_vector, 
   PS_linetype, PS_put_text, PS_text_angle, 
   PS_justify_text, PS_point, do_arrow, PS_set_font, PS_pointsize,
   TERM_BINARY /*flags*/, 0 /*suspend*/, 0 /*resume*/, PS_fillbox, PS_linewidth
#ifdef PM3D
#ifdef USE_MOUSE
   , 0, 0, 0, 0, 0 /* no mouse support for postscript */
#endif
   , PS_make_palette,
   PS_previous_palette, /* write grestore */
   PS_set_color,
   PS_filled_polygon
#endif
TERM_TABLE_END(post_driver)

#undef LAST_TERM
#define LAST_TERM post_driver

#endif /* TERM_TABLE */

#endif /* TERM_PROTO_ONLY */

#ifdef TERM_HELP
START_HELP(post)
"1 postscript",
"?commands set terminal postscript",
"?set terminal postscript",
"?set term postscript",
"?terminal postscript",
"?term postscript",
"?postscript",
" Several options may be set in the `postscript` driver.",
"",
" Syntax:",
"       set terminal postscript {<mode>} {enhanced | noenhanced}",
"                               {color | colour | monochrome}",
"                               {blacktext | colortext | colourtext}",
"                               {solid | dashed} {dashlength | dl <DL>}",
"                               {linewidth | lw <LW>}",
"                               {<duplexing>}",
"                               {\"<fontname>\"} {<fontsize>}",
"",
" where <mode> is `landscape`, `portrait`, `eps` or `default`;",
" `enhanced` activates the \"enhanced PostScript\" features (subscripts,",
" superscripts and mixed fonts);",
" `color` enables color;",
" `blacktext` forces all text to be written in black even in color mode;",
" `solid` draws all plots with solid lines, overriding any dashed patterns;",
" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>",
" (which is a floating-point number greater than zero);",
" `linewidth` or `lw` scales all linewidths by <LW>;",
" <duplexing> is `defaultplex`, `simplex` or `duplex` (\"duplexing\" in",
" PostScript is the ability of the printer to print on both sides of the same",
" page---don't set this if your printer can't do it);",
" `\"<fontname>\"` is the name of a valid PostScript font; and `<fontsize>` is",
" the size of the font in PostScript points.",
"",
" `default` mode sets all options to their defaults: `landscape`, `monochrome`,",
" `dashed`, `dl 1.0`, `lw 1.0`, `defaultplex`, `noenhanced`, \"Helvetica\" and",
" 14pt.  Default size of a PostScript plot is 10 inches wide and 7 inches high.",
"",
" `eps` mode generates EPS (Encapsulated PostScript) output, which is just",
" regular PostScript with some additional lines that allow the file to be",
" imported into a variety of other applications.  (The added lines are",
" PostScript comment lines, so the file may still be printed by itself.)  To",
" get EPS output, use the `eps` mode and make only one plot per file.  In `eps`",
" mode the whole plot, including the fonts, is reduced to half of the default",
" size.",
"",
" Examples:",
"       set terminal postscript default       # old postscript",
"       set terminal postscript enhanced      # old enhpost",
"       set terminal postscript landscape 22  # old psbig",
"       set terminal postscript eps 14        # old epsf1",
"       set terminal postscript eps 22        # old epsf2",
"       set size 0.7,1.4; set term post portrait color \"Times-Roman\" 14",
"",
" Linewidths and pointsizes may be changed with `set linestyle`.",
"",
" The `postscript` driver supports about 70 distinct pointtypes, selectable",
" through the `pointtype` option on `plot` and `set linestyle`.",
"",
" Several possibly useful files about `gnuplot`'s PostScript are included",
" in the /docs/ps subdirectory of the `gnuplot` distribution and at the",
" distribution sites.  These are \"ps_symbols.gpi\" (a `gnuplot` command file",
" that, when executed, creates the file \"ps_symbols.ps\" which shows all the",
" symbols available through the `postscript` terminal), \"ps_guide.ps\" (a",
" PostScript file that contains a summary of the enhanced syntax and a page",
" showing what the octal codes produce with text and symbol fonts) and",
" \"ps_file.doc\" (a text file that contains a discussion of the organization",
" of a PostScript file written by `gnuplot`).",
"", 
" A PostScript file is editable, so once `gnuplot` has created one, you are",
" free to modify it to your heart's desire.  See the \"editing postscript\"",
" section for some hints.",
"2 enhanced postscript",
"?commands set terminal postscript enhanced",
"?set terminal postscript enhanced",
"?set term postscript enhanced",
"?terminal postscript enhanced",
"?term postscript enhanced",
"?enhanced_postscript",
"@start table - first is interactive cleartext form",
"  Control      Examples        Explanation",
"   ^           a^x             superscript",
"   _           a_x             subscript",
"   @           @x or a@^b_c    phantom box (occupies no width)",
"   &           &{space}        inserts space of specified length",
"#\\begin{tabular}{|ccl|} \\hline",
"#\\multicolumn{3}{|c|}{Enhanced Text Control Codes} \\\\ \\hline",
"#Control & Examples & Explanation \\\\ \\hline",
"#\\verb~^~ & \\verb~a^x~ & superscript\\\\",
"#\\verb~_~ & \\verb~a_x~ & subscript\\\\",
"#\\verb~@~ & \\verb~@x or a@^b_c~ & phantom box (occupies no width)\\\\",
"#\\verb~&~ & \\verb~&{space}~ & inserts space of specified length\\\\",
"%c c l .",
"%.TE", /* ugly - doc2ms uses @ for column separator, but here we */
"%.TS", /* need @ in table, so end and restart the table ! */
"%center box tab ($) ;",
"%c c l .",
"%Control$Examples$Explanation",
"%_",
"%^$a^x$superscript",
"%\\&_$a\\&_x$subscript",
"% @ $ @x or a\\&@^b\\&_c$phantom box (occupies no width)",
"% & $ &{space}$inserts space of specified length",
"@end table",
"",
" Braces can be used to place multiple-character text where a single character",
" is expected (e.g., 2^{10}).  To change the font and/or size, use the full",
" form:  {/[fontname][=fontsize | *fontscale] text}.  Thus {/Symbol=20 G} is a",
" 20-point GAMMA) and {/*0.75 K} is a K at three-quarters of whatever fontsize",
" is currently in effect.  (The '/' character MUST be the first character after",
" the '{'.)",
"",
" If the encoding vector has been changed by `set encoding`, the default",
" encoding vector can be used instead by following the slash with a dash.  This",
" is unnecessary if you use the Symbol font, however---since /Symbol uses its",
" own encoding vector, `gnuplot` will not apply any other encoding vector to",
" it.",
"",
" The phantom box is useful for a@^b_c to align superscripts and subscripts",
" but does not work well for overwriting an accent on a letter.  (To do the",
" latter, it is much better to use `set encoding iso_8859_1` to change to the",
" ISO Latin-1 encoding vector, which contains a large variety of letters with",
" accents or other diacritical marks.)  Since the box is non-spacing, it is",
" sensible to put the shorter of the subscript or superscript in the box (that",
" is, after the @).",
"",
" Space equal in length to a string can be inserted using the '&' character.",
" Thus",
"         'abc&{def}ghi'",
" would produce",
"         'abc   ghi'.",
"",
" You can access special symbols numerically by specifying \\character-code (in",
" octal), e.g., {/Symbol \\245} is the symbol for infinity.",
"",
" You can escape control characters using \\, e.g.,  \\\\, \\{, and so on.",
"",
" But be aware that strings in double-quotes are parsed differently than those",
" enclosed in single-quotes.  The major difference is that backslashes may need",
" to be doubled when in double-quoted strings.",
"",
" Examples (these are hard to describe in words---try them!):",
"       set xlabel 'Time (10^6 {/Symbol m}s)'",
"       set title '{/Symbol=18 \\362@_{/=9.6 0}^{/=12 x}} \\",
"                  {/Helvetica e^{-{/Symbol m}^2/2} d}{/Symbol m}'",
"",
" The file \"ps_guide.ps\" in the /docs/ps subdirectory of the `gnuplot` source",
" distribution contains more examples of the enhanced syntax.",
"2 editing postscript",
"?commands set terminal postscript editing",
"?set terminal postscript editing",
"?set term postscript editing",
"?terminal postscript editing",
"?term postscript editing",
"?editing_postscript",
" The PostScript language is a very complex language---far too complex to",
" describe in any detail in this document.  Nevertheless there are some things",
" in a PostScript file written by `gnuplot` that can be changed without risk of",
" introducing fatal errors into the file.",
"",
" For example, the PostScript statement \"/Color true def\" (written into the",
" file in response to the command `set terminal postscript color`), may be",
" altered in an obvious way to generate a black-and-white version of a plot.",
" Similarly line colors, text colors, line weights and symbol sizes can also be",
" altered in straight-forward ways.  Text (titles and labels) can be edited to",
" correct misspellings or to change fonts.  Anything can be repositioned, and",
" of course anything can be added or deleted, but modifications such as these",
" may require deeper knowledge of the PostScript language.",
"",
" The organization of a PostScript file written by `gnuplot` is discussed in",
" the text file \"ps_file.doc\" in the docs/ps subdirectory of the gnuplot",
" source distribution."
END_HELP(post)
#endif

